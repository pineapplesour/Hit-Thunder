<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hit Thunder Guide Maker</title>

    <!-- Favicon -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“š</text></svg>">

    <!-- Icons -->
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

    <!-- Dependencies from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.worker.min.js";</script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Tokenizer scripts are loaded on-demand based on user selection -->

	    <style>
	        /* --- START OF EMBEDDED CSS (modern UI) --- */
	        :root {
	            --bg: #0b1020;
	            --secondary-bg: rgba(255, 255, 255, 0.06);
	            --accent: #7c3aed;
	            --secondary-accent: #38bdf8;
	            --text: #e5e7eb;
	            --secondary-text: #cbd5e1;
	            --text-2: #cbd5e1;
	            --text-3: #94a3b8;
	            --border: var(--border-light);
	            --border-light: rgba(148, 163, 184, 0.22);
	            --border-dark: rgba(2, 6, 23, 0.75);
	            --outline: rgba(167, 139, 250, 0.55);
	            --error-color: #ef4444;
	            --success-color: #22c55e;
	            --warn-color: #f59e0b;
	            --shadow: 0 18px 60px rgba(0, 0, 0, 0.35);
	            --shadow-sm: 0 10px 28px rgba(0, 0, 0, 0.25);
	            --radius: 14px;
	            --radius-sm: 10px;
	        }

	        *,
	        *::before,
	        *::after {
	            box-sizing: border-box;
	        }

	        * {
	            margin: 0;
	            padding: 0;
	        }

	        input,
	        button,
	        textarea,
	        select {
	            font: inherit;
	        }

	        p,
	        h1,
	        h2,
	        h3,
	        h4,
	        h5,
	        h6 {
	            overflow-wrap: break-word;
	        }

	        html,
	        body {
	            height: 100%;
	            overflow: hidden;
	        }

	        body {
	            font-weight: 450;
	            line-height: 1.5;
	            color: var(--text);
	            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
	            background:
	                radial-gradient(1200px circle at 12% 12%, rgba(124, 58, 237, 0.22), transparent 55%),
	                radial-gradient(900px circle at 90% 18%, rgba(56, 189, 248, 0.18), transparent 52%),
	                radial-gradient(900px circle at 50% 110%, rgba(34, 197, 94, 0.12), transparent 55%),
	                var(--bg);
	            display: flex;
	            flex-direction: column;
	        }

	        * {
	            scrollbar-width: thin;
	            scrollbar-color: rgba(148, 163, 184, 0.35) transparent;
	        }

	        ::-webkit-scrollbar {
	            width: 12px;
	            height: 12px;
	        }

	        ::-webkit-scrollbar-track {
	            background: transparent;
	        }

	        ::-webkit-scrollbar-thumb {
	            background: rgba(148, 163, 184, 0.28);
	            border-radius: 999px;
	            border: 3px solid transparent;
	            background-clip: content-box;
	        }

	        ::-webkit-scrollbar-thumb:hover {
	            background: rgba(148, 163, 184, 0.4);
	            border: 3px solid transparent;
	            background-clip: content-box;
	        }

	        #app-container {
	            display: flex;
	            height: 100vh;
	            padding: 16px;
	            gap: 16px;
	        }
	        @supports (height: 100dvh) {
	            #app-container {
	                height: 100dvh;
	            }
	        }

	        #controls-sidebar {
	            width: 460px;
	            min-width: 460px;
	            flex-shrink: 0;
	            display: flex;
	            flex-direction: column;
	            gap: 12px;
	        }

	        #main-content {
	            flex-grow: 1;
	            min-width: 0;
	            display: flex;
	            flex-direction: column;
	            gap: 12px;
	        }

	        @media (max-width: 950px) {
	            html,
	            body {
	                height: auto;
	                overflow: auto;
	            }

	            #app-container {
	                flex-direction: column;
	                padding: 12px;
	                gap: 12px;
	                height: auto;
	                min-height: 100vh;
	            }

	            #controls-sidebar {
	                width: 100%;
	                min-width: 0;
	                flex-shrink: 1;
	                min-height: 0;
	                max-height: 46vh;
	            }

	            #main-content {
	                min-height: 0;
	            }
	        }

	        .sidebar-header {
	            background: rgba(255, 255, 255, 0.06);
	            border: 1px solid var(--border-light);
	            border-radius: var(--radius);
	            padding: 14px 16px;
	            box-shadow: var(--shadow-sm);
	            backdrop-filter: blur(10px);
	        }

	        .sidebar-logo {
	            display: flex;
	            align-items: baseline;
	            justify-content: space-between;
	            gap: 10px;
	            font-size: 18px;
	            font-weight: 800;
	            letter-spacing: -0.01em;
	        }

	        .sidebar-logo span {
	            font-size: 12px;
	            font-weight: 650;
	            color: var(--text-3);
	            vertical-align: middle;
	        }

	        .sidebar-content {
	            flex-grow: 1;
	            overflow-y: auto;
	            padding-right: 6px;
	        }

	        #main-content-wrapper {
	            border: 1px solid var(--border-light);
	            border-radius: var(--radius);
	            padding: 14px 16px;
	            background: rgba(255, 255, 255, 0.05);
	            box-shadow: var(--shadow-sm);
	            backdrop-filter: blur(10px);
	            display: flex;
	            flex-direction: column;
	            flex-grow: 1;
	            min-height: 0;
	        }

	        .ui-panel {
	            background: rgba(255, 255, 255, 0.06);
	            border: 1px solid var(--border-light);
	            border-radius: var(--radius);
	            padding: 14px 14px;
	            box-shadow: var(--shadow-sm);
	            word-wrap: break-word;
	        }

	        details.ui-panel {
	            padding: 12px 14px;
	        }

	        .material-symbols-outlined {
	            font-size: 1.1em;
	            line-height: 1;
	            vertical-align: middle;
	        }

	        .ui-label {
	            color: var(--text-3);
	            font-weight: 700;
	            font-size: 12px;
	        }

	        .ui-input {
	            outline: 0;
	            border: 1px solid var(--border-light);
	            padding: 10px 12px;
	            font-size: 14px;
	            border-radius: 12px;
	            background: rgba(15, 23, 42, 0.55);
	            color: var(--text);
	            width: 100%;
	        }

	        .ui-input:focus {
	            border-color: rgba(167, 139, 250, 0.55);
	            box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.28);
	        }

	        textarea.ui-input {
	            min-height: 96px;
	            resize: vertical;
	        }

	        .ui-btn {
	            background: rgba(15, 23, 42, 0.6);
	            color: var(--text);
	            padding: 10px 12px;
	            font-size: 14px;
	            line-height: 1.1;
	            border: 1px solid var(--border-light);
	            border-radius: 12px;
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            gap: 8px;
	            cursor: pointer;
	            user-select: none;
	            transition: transform 0.04s ease, background 0.15s ease, border-color 0.15s ease, filter 0.15s ease;
	        }

	        .ui-btn:hover {
	            background: rgba(30, 41, 59, 0.55);
	            border-color: rgba(148, 163, 184, 0.32);
	        }

	        .ui-btn:active {
	            transform: translateY(1px);
	        }

	        .ui-btn:disabled {
	            opacity: 0.45;
	            cursor: not-allowed;
	        }

	        #start-button {
	            background: linear-gradient(135deg, rgba(124, 58, 237, 0.95), rgba(56, 189, 248, 0.75));
	            border-color: rgba(167, 139, 250, 0.45);
	        }

	        #start-button:hover:not(:disabled) {
	            filter: brightness(1.05);
	        }

	        #main-buttons-container {
	            display: flex;
	            gap: 10px;
	        }

	        #main-buttons-container .ui-btn {
	            flex-grow: 1;
	        }

	        #save-button,
	        #load-button,
	        #clear-button {
	            width: 44px;
	            flex: 0 0 auto;
	            padding: 10px;
	        }

	        .input-group,
	        .input-group-tight {
	            margin-bottom: 14px;
	            display: flex;
	            flex-direction: column;
	            gap: 8px;
	        }

	        details {
	            margin-bottom: 14px;
	        }

	        details > summary {
	            cursor: pointer;
	            font-weight: 800;
	            color: var(--text);
	            padding: 2px 2px 10px;
	            list-style: none;
	            display: flex;
	            align-items: center;
	            justify-content: space-between;
	            user-select: none;
	        }

	        details > summary::-webkit-details-marker {
	            display: none;
	        }

	        details > summary::after {
	            content: "â–¾";
	            color: var(--text-3);
	            transition: transform 0.15s ease;
	        }

	        details[open] > summary::after {
	            transform: rotate(180deg);
	        }

	        details[open] > summary {
	            border-bottom: 1px solid rgba(148, 163, 184, 0.14);
	            margin-bottom: 10px;
	        }

	        #status-display {
	            padding: 14px 16px;
	            text-align: center;
	            border: 1px solid var(--border-light);
	            border-radius: var(--radius);
	            background: rgba(15, 23, 42, 0.3);
	            margin-bottom: 14px;
	        }

	        #logs-container {
	            height: 100%;
	            background: rgba(15, 23, 42, 0.55);
	            border: 1px solid var(--border-light);
	            border-radius: var(--radius);
	            padding: 10px 12px;
	            overflow-y: auto;
	            font-size: 12px;
	            flex-grow: 1;
	            min-height: 200px;
	        }

        .log-line {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.2rem;
            align-items: flex-start;
        }

        .log-timestamp {
            color: var(--text-3);
            white-space: nowrap;
        }

        .log-level {
            font-weight: bold;
            white-space: nowrap;
        }

        .log-level.INFO {
            color: #509ac4;
        }

        .log-level.WARN {
            color: var(--warn-color);
        }

        .log-level.ERROR {
            color: var(--error-color);
        }

        .log-level.SUCCESS {
            color: var(--success-color);
        }

        .log-context {
            color: #9c71c5;
            white-space: nowrap;
        }

        .log-content {
            flex-grow: 1;
            word-break: break-all;
            white-space: pre-wrap;
        }

	        /* --- API Monitor (ported from general-test.html) --- */
	        .log-mini {
	            flex-grow: 1;
	            overflow: auto;
	            background: rgba(15, 23, 42, 0.55);
	            border: 1px solid var(--border-light);
	            border-radius: var(--radius);
	            font-family: monospace;
	            font-size: 11px;
	            white-space: pre-wrap;
	            padding: 0.5rem;
	            word-break: break-all;
            max-height: 360px;
            min-height: 0;
        }

        .key-monitor-row {
            display: flex;
            gap: 6px;
            align-items: center;
            padding: 1px 0;
            margin: 0;
            line-height: 1.15;
            border-bottom: 1px dashed rgba(140, 146, 132, 0.35);
        }

        .key-monitor-row:last-child {
            border-bottom: none;
        }

        .key-monitor-dot {
            font-weight: bold;
            width: 10px;
            flex: 0 0 10px;
        }

        .key-monitor-col {
            font-family: monospace;
            font-size: 12px;
            line-height: 1.15;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .key-monitor-col.idx {
            width: 28px;
            text-align: right;
            color: var(--text-3);
        }

        .key-monitor-col.key {
            width: 90px;
        }

        .key-monitor-col.arch {
            width: 140px;
        }

        .key-monitor-col.tok {
            width: 85px;
            text-align: right;
        }

        .key-monitor-col.age {
            width: 80px;
            text-align: right;
        }

        .key-monitor-col.retry {
            width: 80px;
            text-align: right;
        }

        .key-monitor-col.status {
            flex: 1;
            min-width: 140px;
        }

        #key-monitor-output {
            white-space: normal;
            padding: 5px;
        }

	        #api-monitor-recent-calls {
	            white-space: pre;
	            word-break: normal;
	        }

	        .api-monitor-grid {
	            display: flex;
	            gap: 10px;
	            flex-wrap: wrap;
	        }

	        .api-monitor-col {
	            flex: 1 1 360px;
	            min-width: 0;
	            min-height: 0;
	            display: flex;
	            flex-direction: column;
	        }

	        /* Mobile: keep API monitor panes stacked (avoid horizontal overflow). */
	        @media (max-width: 950px) {
	            .api-monitor-grid {
	                flex-direction: column;
	            }
	            .api-monitor-col {
	                flex: 1 1 auto;
	            }
	        }

	        .api-monitor-header {
	            display: flex;
	            gap: 10px;
	            font-size: 11px;
	            color: var(--text-3);
	            font-family: monospace;
	            padding: 4px 0;
	            overflow-x: auto;
	        }

	        .api-monitor-header > div {
	            flex: 0 0 auto;
	        }

	        @media (max-width: 520px) {
	            .api-monitor-col {
	                flex-basis: 100%;
	            }

	            .api-monitor-header .api-monitor-h-context,
	            .api-monitor-header .api-monitor-h-estTok,
	            .api-monitor-header .api-monitor-h-age,
	            .api-monitor-header .api-monitor-h-retry {
	                display: none;
	            }

	            .key-monitor-col.arch,
	            .key-monitor-col.tok,
	            .key-monitor-col.age,
	            .key-monitor-col.retry {
	                display: none;
	            }

	            .key-monitor-col.key {
	                width: 84px;
	            }

	            .key-monitor-col.status {
	                min-width: 0;
	            }
	        }

		        .file-upload-area {
	            border: 1px dashed rgba(148, 163, 184, 0.45);
	            padding: 14px;
	            text-align: center;
	            cursor: pointer;
	            border-radius: var(--radius);
	            background: rgba(15, 23, 42, 0.3);
	            transition: border-color 0.15s ease, background 0.15s ease;
	        }

	        .file-upload-area.dragover {
	            border-color: rgba(56, 189, 248, 0.85);
	            background: rgba(56, 189, 248, 0.10);
	        }

	        .file-list-item {
	            background: rgba(15, 23, 42, 0.35);
	            padding: 10px 12px;
	            border: 1px solid var(--border-light);
	            border-radius: var(--radius);
	            margin-top: 0.5rem;
	            display: flex;
	            flex-direction: column;
	            gap: 0.5rem;
	        }

        .file-list-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-list-item-name {
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-list-item-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

	        .file-list-item-controls .ui-input {
	            width: 60px;
	            padding: 2px;
	            font-size: 0.9rem;
	        }

	        .file-list-item-controls .ui-btn {
	            padding: 2px;
	        }

        .file-list-item-controls label {
            font-size: 0.8rem;
        }

	        #main-buttons-container {
	            display: flex;
	            gap: 10px;
	        }

	        #main-buttons-container .ui-btn {
	            flex-grow: 1;
	        }

	        #tabs-nav-container {
	            display: flex;
	            border-bottom: 1px solid rgba(148, 163, 184, 0.16);
	            margin-bottom: 14px;
	            flex-wrap: wrap;
	            gap: 8px;
	            padding-bottom: 10px;
	        }

	        .tab-button {
	            background: rgba(15, 23, 42, 0.45);
	            border: 1px solid rgba(148, 163, 184, 0.18);
	            padding: 8px 12px;
	            border-radius: 999px;
	            color: var(--text-2);
	            cursor: pointer;
	            white-space: nowrap;
	            font-weight: 750;
	            transition: background 0.15s ease, border-color 0.15s ease, filter 0.15s ease;
	        }

	        .tab-button.active {
	            background: rgba(124, 58, 237, 0.18);
	            border-color: rgba(167, 139, 250, 0.35);
	            color: var(--text);
	        }

        .status-badge {
            padding: 2px 6px;
            font-size: 0.75rem;
            color: var(--bg);
        }

        .status-completed {
            background-color: var(--success-color);
        }

        .status-error {
            background-color: var(--error-color);
        }

        .status-processing {
            background-color: var(--warn-color);
        }

        .status-pending {
            background-color: var(--text-3);
        }

        .status-paused {
            background-color: var(--text-3);
        }

        .status-stopped {
            background-color: var(--text-3);
        }

        .status-aborted {
            background-color: var(--text-3);
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1rem;
        }

        .markdown-content {
            font-family: sans-serif;
            line-height: 1.6;
        }

	        .markdown-content pre {
	            background: rgba(15, 23, 42, 0.55);
	            padding: 0.5rem;
	            border: 1px solid var(--border-light);
	            border-radius: var(--radius);
	            overflow-x: auto;
	        }

	        .markdown-content code {
	            background: rgba(15, 23, 42, 0.55);
	            border: 1px solid rgba(148, 163, 184, 0.14);
	            border-radius: 8px;
	            padding: 0.1rem 0.3rem;
	        }

	        .refinement-card-body {
	            background: rgba(15, 23, 42, 0.35);
	            border: 1px solid var(--border-light);
	            border-radius: var(--radius);
	            padding: 0.5rem;
	            max-height: 150px;
	            overflow-y: auto;
	            white-space: pre-wrap;
	            word-break: break-all;
	        }

	        /* --- END OF EMBEDDED CSS --- */
	    </style>
</head>

<body>
    <div id="app-container">
        <!-- CONTROLS SIDEBAR -->
        <aside id="controls-sidebar">
            <header class="sidebar-header">
                <h1 class="sidebar-logo">
	                    <span id="app-title" data-i18n="appTitle">Hit Thunder Guide Maker</span>
                    <span id="api-call-counter">(API í˜¸ì¶œ: 0)</span>
                </h1>
                <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
		                    <label for="gui-lang-select" class="ui-label" id="gui-lang-label" data-i18n="guiLangLabel" style="margin:0;">GUI ì–¸ì–´</label>
	                    <select id="gui-lang-select" class="ui-input" style="height: 26px; padding: 0 8px;">
                        <option value="en" data-i18n="guiLangOptionEnglish">English</option>
                        <option value="ko" data-i18n="guiLangOptionKorean">í•œêµ­ì–´</option>
                    </select>
                </div>
            </header>

            <div class="sidebar-content">
	                <div class="ui-panel">
                    <div class="input-group">
			                        <label for="file-upload-input" class="ui-label" id="file-upload-label" data-i18n="fileUploadLabel">1. ì‹œí—˜ì§€ ì—…ë¡œë“œ (.pdf, .txt)</label>
		                        <div id="file-upload-area" class="file-upload-area">
		                            <span id="file-upload-hint" data-i18n="fileUploadHint">ì—¬ê¸°ë¥¼ í´ë¦­í•˜ê±°ë‚˜ PDF/TXT íŒŒì¼ì„ ë“œë¡­í•˜ì„¸ìš”</span>
		                        </div>
                        <ul id="file-list"></ul>
                        <div class="input-group-tight" style="margin-top: 0.75rem;">
                            <label for="answer-upload-input" class="ui-label" id="answer-upload-label" data-i18n="answerFileUploadLabel">ì •ë‹µ/í•´ì„¤ íŒŒì¼ ì—…ë¡œë“œ (ì˜µì…˜)</label>
                            <div id="answer-upload-area" class="file-upload-area">
                                <span id="answer-upload-hint" data-i18n="answerFileUploadHint">ì—¬ê¸°ë¥¼ í´ë¦­í•˜ê±°ë‚˜ PDF/TXT íŒŒì¼ì„ ë“œë¡­í•˜ì„¸ìš” (ì •ë‹µ/í•´ì„¤)</span>
                            </div>
                            <ul id="answer-file-list"></ul>
                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" id="answer-upload-help" data-i18n="answerFileUploadHelp">
                                íŒŒì¼ëª…ì´ ì•ˆ ë§ì•„ë„ ë©ë‹ˆë‹¤. 0ë‹¨ê³„(ì¶”ì¶œ) ì´í›„ ë¬¸ì„œ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ ìë™ ë§¤ì¹­ í›„ ì •ë‹µë§Œ ì±„ì›ë‹ˆë‹¤.
                            </div>
                            <input type="file" id="answer-upload-input" style="display: none;" accept=".pdf,.txt" multiple>
                        </div>
	                        <div class="input-group-tight" style="margin-top: 0.75rem;">
			                            <label for="global-split-pages-input" class="ui-label" id="global-split-pages-label" data-i18n="globalSplitPagesLabel">ì „ì—­ PDF ë¶„í•  í˜ì´ì§€ (ì˜µì…˜)</label>
			                            <input type="number" id="global-split-pages-input" class="ui-input" min="0"
		                                placeholder="(leave blank = per-file)" data-i18n-placeholder="globalSplitPagesPlaceholder">
		                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" id="global-split-pages-help" data-i18n="globalSplitPagesHelp">
		                                ê°’ì„ ë„£ìœ¼ë©´, ê°œë³„ PDF ë¶„í• ì´ 0(ê¸°ë³¸)ì¸ íŒŒì¼ì— ì „ì—­ ê°’ì´ ì ìš©ë©ë‹ˆë‹¤.
		                            </div>
		                        </div>
		                        <div class="input-group-tight" style="margin-top: 0.75rem;">
			                            <label for="global-key-split-count-input" class="ui-label" id="global-key-split-count-label" data-i18n="globalKeySplitCountLabel">í‚¤ ë¶„í•  ê°œìˆ˜(ì›Œì»¤ ìˆ˜) (ì˜µì…˜)</label>
			                            <input type="number" id="global-key-split-count-input" class="ui-input" min="1" max="999"
		                                placeholder="(leave blank = auto: use all keys)" data-i18n-placeholder="globalKeySplitCountPlaceholder">
		                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" id="global-key-split-count-help" data-i18n="globalKeySplitCountHelp">
		                                0~2ë‹¨ê³„ ì›Œì»¤ ë™ì‹œì„±ì„ ì œì–´í•©ë‹ˆë‹¤. (ìë™: ëª¨ë“  í‚¤ ì‚¬ìš©)
		                            </div>
		                        </div>
                        <input type="file" id="file-upload-input" style="display: none;" accept=".pdf,.txt" multiple>
                    </div>

                    <div id="main-buttons-container">
	                        <button id="start-button" class="ui-btn" disabled>
                            <span class="material-symbols-outlined">play_arrow</span>
                            <span class="button-text">ë§¤ë‰´ì–¼ ìƒì„±</span>
                        </button>

	                        <button id="save-button" class="ui-btn" disabled data-i18n-title="saveButtonTitle" data-i18n-aria-label="saveButtonTitle">
	                            <span class="material-symbols-outlined">save</span>
	                        </button>

	                        <button id="load-button" class="ui-btn" data-i18n-title="loadButtonTitle" data-i18n-aria-label="loadButtonTitle">
	                            <span class="material-symbols-outlined">folder_open</span>
	                        </button>
	                        <input type="file" id="load-progress-input" accept=".json" style="display: none;">
	                        <input type="file" id="subgroupify-save-input" accept=".json" style="display: none;">
	                        <input type="file" id="postprocess-save-input" accept=".json" style="display: none;">

	                        <button id="clear-button" class="ui-btn" title="ì‹¤í—˜ ì´ˆê¸°í™” (ì „ì²´ ì‚­ì œ)" data-i18n-title="clearButtonTitle" data-i18n-aria-label="clearButtonTitle">
	                            <span class="material-symbols-outlined">delete_forever</span>
	                        </button>
	                    </div>

                    <div style="margin-top: 0.5rem;">
                        <label
                            style="display:flex; align-items:center; gap:8px; font-size:12px; color:var(--text-2); cursor:pointer;">
                            <input type="checkbox" id="load-ocr-only-input">
	                            <span id="load-ocr-only-text" data-i18n="loadOcrOnlyText">OCR ìºì‹œë§Œ ë¶ˆëŸ¬ì˜¤ê¸° (ê¸°ì¡´ íŒŒì´í”„ë¼ì¸ ë¬´ì‹œ, 0ë‹¨ê³„ë¶€í„° ì¬ì‹œì‘)</span>
                        </label>
                    </div>
                </div>

	                <details class="ui-panel" open>
		                    <summary id="summary-api-settings" data-i18n="summaryApiSettings">API ì„¤ì •</summary>
                    <div style="padding-top: 1rem;">
                        <div class="input-group-tight">
		                            <label for="api-key-list-input" class="ui-label" data-i18n="apiKeysLabel">API í‚¤ (ì¤„ë‹¹ 1ê°œ)</label>
		                            <textarea id="api-key-list-input" class="ui-input" rows="4"
	                                placeholder="í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”&#10;(ì¤„ë‹¹ 1ê°œ)" data-i18n-placeholder="apiKeysPlaceholder"></textarea>
                        </div>
                        <div class="input-group-tight">
		                            <label for="api-url-input" class="ui-label" data-i18n="apiUrlLabel">API URL</label>
		                            <input type="text" id="api-url-input" class="ui-input">
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n-html="apiUrlHelpHtml">
	                                <code>{model}</code>ì„ ì“°ë©´ ëª¨ë¸ëª… ì…ë ¥ê°’ìœ¼ë¡œ ìë™ ì¹˜í™˜ë©ë‹ˆë‹¤. (OpenAI í˜¸í™˜: <code>.../v1beta/openai/chat/completions</code>, Cloudflare Responses: <code>.../ai/v1/responses</code>)
	                            </div>
                        </div>
                        <div class="input-group-tight">
		                            <label for="api-proxy-url-input" class="ui-label" data-i18n="apiProxyUrlLabel">í”„ë¡ì‹œ URL (ì˜µì…˜)</label>
		                            <input type="text" id="api-proxy-url-input" class="ui-input"
	                                placeholder="https://your-proxy.example/forward or https://your-proxy.example/?url={url}" data-i18n-placeholder="apiProxyUrlPlaceholder">
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n-html="apiProxyUrlHelpHtml">
	                                CORSë¡œ ë§‰íŒ ì—”ë“œí¬ì¸íŠ¸(ì˜ˆ: Cloudflare AI)ì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤. URLì— <code>{url}</code>ì´ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ í¬ì›Œë”©í•˜ê³ , ì—†ìœ¼ë©´ JSON ë˜í¼ë¡œ ì „ì†¡í•©ë‹ˆë‹¤.
	                            </div>
                        </div>
                        <div class="input-group-tight">
		                            <label for="api-model-name-input" class="ui-label" data-i18n="apiModelLabel">ëª¨ë¸ëª…</label>
		                            <input type="text" id="api-model-name-input" class="ui-input">
                        </div>
                        <div class="input-group-tight">
		                            <label class="ui-label" style="cursor:pointer; display:flex; align-items:center;">
		                                <input type="checkbox" id="bypass-system-role-input" style="margin-right:5px;">
	                                <span data-i18n="bypassSystemRoleLabel">System Role Bypass (Userë¡œ ë³‘í•©)</span>
		                            </label>
                        </div>
                        <div class="input-group-tight">
		                            <label class="ui-label" style="cursor:pointer; display:flex; align-items:center;">
		                                <input type="checkbox" id="enable-rate-limit-input" style="margin-right:5px;">
	                                <span data-i18n="enableRateLimitLabel">í‚¤ë³„ ì†ë„ ì œí•œ ì‚¬ìš©</span>
		                            </label>
                            <div style="display:flex; gap:10px; margin-top:8px;">
                                <div style="flex:1;">
		                                    <label for="rpm-limit-input" class="ui-label" data-i18n="rpmLabel">RPM (í˜¸ì¶œ/ë¶„)</label>
		                                    <input type="number" id="rpm-limit-input" value="30" min="1" class="ui-input">
                                </div>
                                <div style="flex:1;">
		                                    <label for="tpm-limit-input" class="ui-label" data-i18n="tpmLabel">TPM (í† í°/ë¶„)</label>
		                                    <input type="number" id="tpm-limit-input" value="15000" min="1" class="ui-input">
                                </div>
                            </div>
                            <div style="display:flex; gap:10px; margin-top:8px;">
                                <div style="flex:1;">
		                                    <label for="inflight-limit-input" class="ui-label" data-i18n="inflightLabel">í‚¤ë³„ ë™ì‹œ ìš”ì²­ ì œí•œ</label>
		                                    <input type="number" id="inflight-limit-input" value="0" min="0" class="ui-input"
	                                        placeholder="0 = unlimited" data-i18n-placeholder="inflightPlaceholder">
	                                    <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="inflightHelp">
	                                        API í‚¤ë³„ ë™ì‹œ ì§„í–‰ ìš”ì²­ì˜ ìµœëŒ€ ê°œìˆ˜(0 = ë¬´ì œí•œ).
	                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </details>

		                <details class="ui-panel">
		                    <summary id="summary-generation-options" data-i18n="summaryGenerationOptions">ìƒì„± ì˜µì…˜</summary>
		                    <div style="padding-top: 1rem;">
		                        <div class="input-group-tight">
			                            <label for="std-problem-lang-input" class="ui-label" id="std-problem-lang-label" data-i18n="stdProblemLangLabel">Guide language</label>
			                            <input type="text" id="std-problem-lang-input" class="ui-input"
			                                placeholder="e.g. Korean / English" value="English" data-i18n-placeholder="stdProblemLangPlaceholder">
		                        </div>
		                        <div class="input-group-tight" style="margin-top: 0.75rem;">
		                            <label class="ui-label" data-i18n="phase0PdfInputModeLabel">0ë‹¨ê³„: ì¶”ì¶œ(OCR) ëª¨ë“œ</label>
		                            <select id="phase0-pdf-input-mode-select" class="ui-input">
		                                <option value="multimodal" data-i18n="phase0PdfInputModeMultimodal">LLM ë©€í‹°ëª¨ë‹¬ (ì´ë¯¸ì§€ + PDF í…ìŠ¤íŠ¸)</option>
		                                <option value="raw_text_only" data-i18n="phase0PdfInputModeRawTextOnly">í…ìŠ¤íŠ¸ë§Œ (PDF í…ìŠ¤íŠ¸ë§Œ / ì´ë¯¸ì§€ ì—†ìŒ)</option>
		                                <option value="tesseract_text" data-i18n="phase0PdfInputModeTesseractText">Tesseract OCR â†’ í…ìŠ¤íŠ¸ë§Œ (ì´ë¯¸ì§€ ì—†ìŒ)</option>
		                            </select>
		                            <label for="tesseract-lang-input" class="ui-label" style="margin-top:6px;" data-i18n="tesseractLangLabel">Tesseract ì–¸ì–´</label>
		                            <input type="text" id="tesseract-lang-input" class="ui-input" value="kor+eng"
		                                placeholder="ì˜ˆ) kor+eng" data-i18n-placeholder="tesseractLangPlaceholder">
		                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="tesseractHelp">
		                                TesseractëŠ” ë¸Œë¼ìš°ì €ì—ì„œ traineddataë¥¼ ë‚´ë ¤ë°›ìŠµë‹ˆë‹¤. ì²« ì‹¤í–‰ì€ ëŠë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
		                            </div>
		                        </div>

		                        <div class="input-group-tight" style="margin-top: 0.75rem;">
		                            <label class="ui-label" data-i18n="phase0MultimodalTransportLabel">0ë‹¨ê³„: ë©€í‹°ëª¨ë‹¬ ì…ë ¥ ì „ì†¡</label>
		                            <select id="phase0-multimodal-transport-select" class="ui-input">
		                                <option value="images_raw_text" data-i18n="phase0MultimodalTransportImages">ì´ë¯¸ì§€ + PDF í…ìŠ¤íŠ¸ (ê¸°ì¡´)</option>
		                                <option value="pdf_raw_text" data-i18n="phase0MultimodalTransportPdf">PDF + PDF í…ìŠ¤íŠ¸ (ì‹¤í—˜)</option>
		                            </select>
		                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="phase0MultimodalTransportHelp">
		                                ê¸°ë³¸ê°’ì€ ê¸°ì¡´ ë°©ì‹ì…ë‹ˆë‹¤. â€œPDF + í…ìŠ¤íŠ¸â€ëŠ” ë¡œì»¬ ë Œë”ë§ ì—†ì´ PDFë¥¼ ëª¨ë¸ì— ì²¨ë¶€í•©ë‹ˆë‹¤.
		                            </div>
		                        </div>

		                        <div class="input-group-tight" style="margin-top: 0.75rem;">
		                            <label class="ui-label" data-i18n="phase0SmartRouterLabel">0ë‹¨ê³„: Smart QID Router (ì‹¤í—˜)</label>
		                            <label style="display:flex; gap:8px; align-items:center; font-size:12px; color:var(--text-2);">
		                                <input type="checkbox" id="phase0-smart-router-input">
		                                <span data-i18n-html="phase0SmartRouterTextHtml">PDFë¥¼ ëª¨ë¸ì— ì²¨ë¶€í•´ <code>Pageâ†’QID</code>ë¥¼ ë¼ìš°íŒ…í•œ ë’¤, QID ë¬¶ìŒ ë‹¨ìœ„ë¡œ ì¶”ì¶œ(atomic blockì€ ì ˆëŒ€ ìë¥´ì§€ ì•ŠìŒ)</span>
		                            </label>
		                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="phase0SmartRouterHelp">
		                                ë¶„í•  í˜ì´ì§€ ê°’ì€ â€œìš”ì²­ë‹¹ ìµœëŒ€ í˜ì´ì§€â€ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤. 0ì´ë©´ í•œ íŒŒì¼ì„ 1íšŒ ìš”ì²­ìœ¼ë¡œ ë¬¶ìŠµë‹ˆë‹¤(ì»¤ì§ˆ ìˆ˜ ìˆìŒ).
		                            </div>
		                        </div>
		                        <div class="input-group-tight" style="margin-top: 0.75rem;">
			                            <label class="ui-label" id="phase0-image-crops-label" data-i18n="phase0ImageCropsLabel">ê·¸ë¦¼/ë„í‘œ í¬ë¡­ (ì˜µì…˜)</label>
		                            <label style="display:flex; gap:8px; align-items:center; font-size:12px; color:var(--text-2);">
		                                <input type="checkbox" id="phase0-image-crops-input">
			                                <span id="phase0-image-crops-text" data-i18n-html="phase0ImageCropsTextHtml">ê·¸ë¦¼/ë„í‘œê°€ ìˆëŠ” ë¬¸ì œ: ì´ë¯¸ì§€ í¬ë¡­ì„ <code>question_text</code> ì•ì— <code>![img](data:...)</code>ë¡œ ì‚½ì…</span>
		                            </label>
			                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" id="phase0-image-crops-help" data-i18n="phase0ImageCropsHelp">
			                                ê¸°ë³¸ê°’: ì‚¬ìš© ì•ˆ í•¨. í™œì„±í™” ì‹œ ë¹„ìš©/ìš©ëŸ‰ì´ ì¦ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
			                            </div>
		                        </div>
		                        <div class="input-group-tight" style="margin-top: 0.75rem;">
		                            <label class="ui-label" id="phase1-subgrouping-label" data-i18n="phase1SubgroupingLabel">ìœ í˜• ë‚´ ì†Œê·¸ë£¹ (ì‹¤í—˜)</label>
		                            <label style="display:flex; gap:8px; align-items:center; font-size:12px; color:var(--text-2);">
		                                <input type="checkbox" id="phase1-subgrouping-input">
		                                <span id="phase1-subgrouping-text" data-i18n-html="phase1SubgroupingTextHtml">ìœ í˜• ë‚´ì—ì„œ â€œí•œ ë¬¸ì¥ìœ¼ë¡œ ê°™ì€ í’€ì´ê°€ ê°€ëŠ¥í•œâ€ ë¬¸ì œë§Œ <code>subgroup_tag</code>ë¡œ ë¬¶ê¸° (ë Œë”ëŸ¬ ìœ ì‚¬ë„ ê·¸ë£¹ì— ë°˜ì˜)</span>
		                            </label>
		                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" id="phase1-subgrouping-help" data-i18n="phase1SubgroupingHelp">
		                                ê¸°ë³¸ê°’: ì‚¬ìš© ì•ˆ í•¨. í™œì„±í™” ì‹œ 1ë‹¨ê³„ ì´í›„ ì¶”ê°€ í˜¸ì¶œì´ ë°œìƒí•©ë‹ˆë‹¤.
		                            </div>
		                        </div>
		                        <div class="input-group-tight" style="margin-top: 0.75rem;">
		                            <label class="ui-label" id="phase0-answer-fill-label" data-i18n="phase0AnswerFillLabel">ë¯¸ì •ë‹µ ë¬¸ì œ LLM ì±„ìš°ê¸° (ì˜µì…˜)</label>
		                            <label style="display:flex; gap:8px; align-items:center; font-size:12px; color:var(--text-2);">
		                                <input type="checkbox" id="phase0-answer-fill-input">
		                                <span id="phase0-answer-fill-text" data-i18n-html="phase0AnswerFillTextHtml">ì •ë‹µì´ ì—†ëŠ” ë¬¸ì œë§Œ LLMìœ¼ë¡œ <code>official_answer</code> + <code>official_explanation</code> ì±„ìš°ê¸° (ì£¼ì˜: ê³µì‹ ì•„ë‹˜)</span>
		                            </label>
		                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" id="phase0-answer-fill-help" data-i18n="phase0AnswerFillHelp">
		                                ê¸°ë³¸ê°’: ì‚¬ìš© ì•ˆ í•¨. í™œì„±í™” ì‹œ 0ë‹¨ê³„ ì´í›„ ì¶”ê°€ í˜¸ì¶œì´ ë°œìƒí•©ë‹ˆë‹¤.
		                            </div>
		                        </div>
		                        <div class="input-group-tight" style="margin-top: 0.25rem; padding-left: 14px;">
		                            <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
		                                <label class="muted" style="font-size:12px;">
		                                    <input type="checkbox" id="phase0-answer-fill-fill-answers-input" checked>
		                                    <span data-i18n="ppFillAnswersLabel">Fill answers</span>
		                                </label>
		                                <label class="muted" style="font-size:12px;">
		                                    <input type="checkbox" id="phase0-answer-fill-fill-explanations-input" checked>
		                                    <span data-i18n="ppFillExplanationsLabel">Fill explanations</span>
		                                </label>
		                                <label class="muted" style="font-size:12px;">
		                                    <input type="checkbox" id="phase0-answer-fill-overwrite-answers-input">
		                                    <span data-i18n="ppOverwriteAnswersLabel">Overwrite existing answers</span>
		                                </label>
		                                <label class="muted" style="font-size:12px;">
		                                    <input type="checkbox" id="phase0-answer-fill-overwrite-explanations-input">
		                                    <span data-i18n="ppOverwriteExplanationsLabel">Overwrite existing explanations</span>
		                                </label>
		                            </div>
		                            <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:6px;">
		                                <label class="muted" style="font-size:12px;">
		                                    <input type="checkbox" id="phase0-answer-fill-include-type-guide-input" checked>
		                                    <span data-i18n="ppIncludeTypeGuideLabel">Include type guide (fmm_source)</span>
		                                </label>
		                                <label class="muted" style="font-size:12px;" data-i18n="ppTypeGuideMaxCharsLabel">Type guide max chars</label>
		                                <input type="number" id="phase0-answer-fill-type-guide-max-chars-input" class="ui-input" min="200" max="200000" value="12000" style="max-width:140px;">
		                            </div>
		                        </div>
		                        <div class="input-group-tight">
		                            <label for="answer-fill-chunk-tokens-input" class="ui-label" data-i18n="answerFillChunkTokensLabel">0ë‹¨ê³„: ë¯¸ì •ë‹µ í’€ì´ ë°°ì¹˜ í† í°(ëŒ€ëµ)</label>
		                            <input type="number" id="answer-fill-chunk-tokens-input" class="ui-input" min="1000" max="400000"
		                                value="50000">
		                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="answerFillChunkTokensHelp">
		                                ë¯¸ì •ë‹µ ë¬¸ì œ ì •ë‹µ/í•´ì„¤ ìƒì„± ë°°ì¹˜ ë¬¶ìŒì—ë§Œ ì ìš©ë©ë‹ˆë‹¤.
		                            </div>
		                        </div>
		                        <div class="input-group-tight">
		                            <label class="ui-label" data-i18n="answerFillRefLabel">ì°¸ê³  ì†ŒìŠ¤ (ì˜µì…˜)</label>
		                            <label style="display:flex; gap:8px; align-items:center; font-size:12px; color:var(--text-2);">
		                                <input type="checkbox" id="answer-fill-duckduckgo-input">
		                                <span data-i18n="answerFillDuckDuckGoLabel">DuckDuckGo Instant Answer ì°¸ê³  (ë¬´ë£Œ, ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ì¶”ê°€)</span>
		                            </label>
		                        </div>
		                    </div>
		                </details>

		                <details class="ui-panel">
		                    <summary id="summary-experiment-cost" data-i18n="summaryExperimentCost">ì‹¤í—˜ / ë¹„ìš© ì œì–´</summary>
                    <div style="padding-top: 1rem;">
                        <div class="input-group-tight">
		                            <label class="ui-label" data-i18n="runPlanLabel">ì‹¤í–‰ ê³„íš</label>
                            <div style="display:flex; gap:10px; flex-wrap:wrap;">
                                <div style="flex:1; min-width:210px;">
		                                    <label for="run-start-from-select" class="ui-label" data-i18n="runStartFromLabel">ì¬ì‹œì‘ ì§€ì  (í•œ ë²ˆë§Œ ì ìš©)</label>
		                                    <select id="run-start-from-select" class="ui-input">
	                                        <option value="continue" data-i18n="runStartFromContinue">ê³„ì† (ëŒ€ê¸°ì¤‘ ë‹¨ê³„ë§Œ ì´ì–´ì„œ)</option>
	                                        <option value="phase0" data-i18n="runStartFromPhase0">0ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ (ì¶”ì¶œë¶€í„°)</option>
	                                        <option value="phase1" data-i18n="runStartFromPhase1">1ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ (ìœ í˜•ë¶„ë¥˜ë¶€í„°)</option>
	                                        <option value="phase2" data-i18n="runStartFromPhase2">2ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ (ê°€ì´ë“œë¶€í„°)</option>
	                                        <option value="phase3" data-i18n="runStartFromPhase3">3ë‹¨ê³„ë§Œ ë‹¤ì‹œ (ìµœì¢… í•©ë³¸ë§Œ)</option>
	                                    </select>
                                </div>
                                <div style="flex:1; min-width:210px;">
		                                    <label for="run-stop-after-select" class="ui-label" data-i18n="runStopAfterLabel">ì‹¤í–‰ ì¢…ë£Œ ë‹¨ê³„</label>
		                                    <select id="run-stop-after-select" class="ui-input">
	                                        <option value="phase3" data-i18n="runStopAfterPhase3">3ë‹¨ê³„ê¹Œì§€ (ì „ì²´)</option>
	                                        <option value="phase2" data-i18n="runStopAfterPhase2">2ë‹¨ê³„ê¹Œì§€ (ê°€ì´ë“œ/ì»¤ë²„ë¦¬ì§€ê¹Œì§€ë§Œ)</option>
	                                        <option value="phase1" data-i18n="runStopAfterPhase1">1ë‹¨ê³„ê¹Œì§€ (ìœ í˜•ë¶„ë¥˜ê¹Œì§€ë§Œ)</option>
	                                        <option value="phase0" data-i18n="runStopAfterPhase0">0ë‹¨ê³„ê¹Œì§€ (ì¶”ì¶œê¹Œì§€ë§Œ)</option>
	                                    </select>
                                </div>
                            </div>
                            <label
                                style="display:flex; align-items:center; gap:8px; font-size:12px; color:var(--text-2); cursor:pointer; margin-top:6px;">
                                <input type="checkbox" id="reset-call-counters-on-start-input">
	                                <span data-i18n="resetCallCountersLabel">ì‹œì‘/ì¬ê°œ ì‹œ í˜¸ì¶œ ì¹´ìš´í„° ì´ˆê¸°í™”</span>
                            </label>
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="runPlanHelp">
	                                ì €ì¥íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¨ ë’¤ â€œì¬ì‹œì‘ ì§€ì â€ì„ ì„ íƒí•˜ê³  â€œë§¤ë‰´ì–¼ ì¬ê°œâ€ë¥¼ ëˆ„ë¥´ë©´ í•´ë‹¹ ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ ì‹¤í–‰í•©ë‹ˆë‹¤. (ì¬ì‹œì‘ì€ 1íšŒ ì ìš©)
	                            </div>
                        </div>

	                        <div class="input-group-tight">
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="runPlanExamples">
	                                ì˜ˆ: (1) OCRë§Œ ìˆëŠ” ì €ì¥íŒŒì¼ â†’ 0ë‹¨ê³„ë¶€í„°, (2) ìœ í˜•ë¶„ë¥˜(í´ëŸ¬ìŠ¤í„°)ê¹Œì§€ ìˆëŠ” ì €ì¥íŒŒì¼ â†’ 2ë‹¨ê³„ë¶€í„°, (3) í•©ë³¸ë§Œ ë‹¤ì‹œ ë§Œë“¤ê¸° â†’ 3ë‹¨ê³„ë§Œ
	                            </div>
	                        </div>

		                        <div class="input-group-tight">
		                            <label for="chunk-tokens-input" class="ui-label" data-i18n="chunkTokensLabel">1ë‹¨ê³„: ì²­í¬ í† í°(ëŒ€ëµ)</label>
		                            <input type="number" id="chunk-tokens-input" class="ui-input" min="1000" max="400000"
		                                value="50000">
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="chunkTokensHelp">
	                                ì²­í¬ í† í°ì„ í‚¤ìš°ë©´ í˜¸ì¶œ ìˆ˜ëŠ” ì¤„ì§€ë§Œ, í”„ë¡¬í”„íŠ¸ê°€ ì»¤ì§‘ë‹ˆë‹¤.
	                            </div>
	                        </div>

		                        <div class="input-group-tight">
		                            <label for="chunk-tokens-1b-input" class="ui-label" data-i18n="chunkTokens1bLabel">1ë‹¨ê³„B: ë¶„ë¥˜ ë°°ì¹˜ í† í°(ëŒ€ëµ)</label>
		                            <input type="number" id="chunk-tokens-1b-input" class="ui-input" min="1000" max="400000"
		                                value="50000">
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="chunkTokens1bHelp">
	                                1ë‹¨ê³„B(ìœ í˜•ë¶„ë¥˜) ë°°ì¹˜ ë¬¶ìŒì—ë§Œ ì ìš©ë©ë‹ˆë‹¤. (1ë‹¨ê³„A ìœ í˜•í‘œì¤€ ìƒì„±/ê²€ì¦ê³¼ ë¶„ë¦¬)
	                            </div>
		                        </div>

		                        <div class="input-group-tight">
		                            <label for="subgrouping-chunk-tokens-input" class="ui-label" data-i18n="subgroupChunkTokensLabel">1ë‹¨ê³„: ì†Œê·¸ë£¹ ë°°ì¹˜ í† í°(ëŒ€ëµ)</label>
		                            <input type="number" id="subgrouping-chunk-tokens-input" class="ui-input" min="1000" max="400000"
		                                value="50000">
		                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="subgroupChunkTokensHelp">
		                                ì†Œê·¸ë£¹ ìƒì„±(ìœ í˜• ë‚´ ë¬¸ì œ ë¬¶ê¸°) ë°°ì¹˜ ë¬¶ìŒì—ë§Œ ì ìš©ë©ë‹ˆë‹¤.
		                            </div>
		                        </div>

		                        <div class="input-group-tight">
		                            <label for="tokenizer-mode-select" class="ui-label" data-i18n="tokenizerModeLabel">í† í¬ë‚˜ì´ì € ë°©ì‹</label>
		                            <select id="tokenizer-mode-select" class="ui-input">
		                                <option value="char_estimate" data-i18n="tokenizerModeCharEstimate">ë¬¸ì ê¸°ë°˜ ì¶”ì • (lenÃ·4, ê°€ì¥ ë¹ ë¦„)</option>
		                                <option value="char_estimate_3" data-i18n="tokenizerModeCharEstimate3">ë¬¸ì ê¸°ë°˜ ì¶”ì • (lenÃ·3, ë³´ìˆ˜ì )</option>
		                                <option value="char_estimate_2.5" data-i18n="tokenizerModeCharEstimate25">ë¬¸ì ê¸°ë°˜ ì¶”ì • (lenÃ·2.5, ë§¤ìš° ë³´ìˆ˜ì )</option>
		                                <option value="simple_split" data-i18n="tokenizerModeSimpleSplit">ë‹¨ì–´/ê³µë°± ë¶„í•  (ê°€ë²¼ìš´ ê·¼ì‚¬)</option>
		                                <option value="gpt_tokenizer_lazy" selected data-i18n="tokenizerModeGptTokenizer">gpt-tokenizer (ì •í™•, ì²« ë¡œë”© ëŠë¦¼)</option>
		                            </select>
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="tokenizerModeHelp">
	                                ë¬¸ì ê¸°ë°˜ ì¶”ì •ì´ ê°€ì¥ ë¹ ë¦„. gpt-tokenizerëŠ” ì •í™•í•˜ì§€ë§Œ ~2MB ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë”© í•„ìš”.
	                            </div>
	                        </div>

		                        <div class="input-group-tight">
		                            <label for="chunk-mode-select" class="ui-label" data-i18n="chunkModeLabel">1ë‹¨ê³„: ì²­í¬ ìƒì„± ë°©ì‹</label>
		                            <select id="chunk-mode-select" class="ui-input">
		                                <option value="file_first" data-i18n="chunkModeFileFirst">íŒŒì¼ë³„ ìš°ì„  ë¬¶ê¸° (ê¶Œì¥)</option>
		                                <option value="sequential" data-i18n="chunkModeSequential">ìˆœì°¨ì  (ê¸°ì¡´)</option>
		                            </select>
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="chunkModeHelp">
	                                íŒŒì¼ë³„ ìš°ì„  ë¬¶ê¸°: í•œ íŒŒì¼ì˜ ë‹¤ì–‘í•œ ìœ í˜•ì´ ê°™ì€ ì²­í¬ì— í¬í•¨ë˜ì–´ ì§€ì—½ì  ë¶„ë¥˜ ë°©ì§€.
	                            </div>
	                        </div>

		                        <div class="input-group-tight">
		                            <label for="max-types-input" class="ui-label" data-i18n="maxTypesLabel">1ë‹¨ê³„: ìµœëŒ€ ìœ í˜• ê°œìˆ˜</label>
		                            <input type="number" id="max-types-input" class="ui-input" min="5" max="100" value="25">
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="maxTypesHelp">
	                                ì²­í¬ë³„ ìœ í˜• ë³‘í•© ì‹œ ìµœì¢… ìœ í˜• ê°œìˆ˜ ì œí•œ (ê¸°ë³¸ 25).
	                            </div>
	                        </div>

		                        <div class="input-group-tight">
		                            <label class="ui-label" data-i18n="phase1ArchTitle">1ë‹¨ê³„: ìœ í˜•ë¶„ë¥˜ ì•„í‚¤í…ì²˜</label>
		                            <label for="phase1-arch-select" class="ui-label" data-i18n="phase1ArchModeLabel" style="margin-top:6px;">ëª¨ë“œ</label>
		                            <select id="phase1-arch-select" class="ui-input">
		                                <option value="p1_default" data-i18n="phase1ArchP1Default">ê¸°ë³¸: ì²­í¬ë³„ pass ëª©í‘œ (ìµœëŒ€ 2íšŒ)</option>
		                                <option value="p1_no_eval" data-i18n="phase1ArchP1NoEval">pass@1: ì›ìƒ·(ê²€ì¦/ì¬ì‹œë„ ì—†ìŒ)</option>
		                                <option value="p1_until_pass" data-i18n="phase1ArchP1UntilPass">passê¹Œì§€ ë°˜ë³µ(ë¬´ì œí•œ; ë¹„ìš©â†‘)</option>
		                                <option value="p1_coverage_style" selected data-i18n="phase1ArchP1CoverageStyle">ì»¤ë²„ë¦¬ì§€: ìœ í˜• ìƒì„± â†’ ë³‘í•© â†’ ë¶„ë¥˜ â†’ ë¯¸ë¶„ë¥˜ ì¬ì‹œë„</option>
		                            </select>
	                        </div>

		                        <div class="input-group-tight">
		                            <label class="ui-label" data-i18n="phase2ArchTitle">2ë‹¨ê³„: ê°€ì´ë“œ/ì»¤ë²„ë¦¬ì§€ ì•„í‚¤í…ì²˜</label>
		                            <label for="phase2-arch-select" class="ui-label" data-i18n="phase2ArchModeLabel" style="margin-top:6px;">ëª¨ë“œ</label>
		                            <select id="phase2-arch-select" class="ui-input">
		                                <option value="p2_default" data-i18n="phase2ArchP2Default">ê¸°ë³¸: ê°ì‚¬(í”¼ë“œë°± 1íšŒ) + ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜</option>
		                                <option value="p2_pass_to_coverage" data-i18n="phase2ArchP2PassToCoverage">pass@1: ê°ì‚¬ ìƒëµ â†’ ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜</option>
		                                <option value="p2_auditor_only" data-i18n="phase2ArchP2AuditorOnly">ê°ì‚¬ë§Œ: ì»¤ë²„ë¦¬ì§€ ìƒëµ</option>
		                                <option value="p2_auditor_until_pass_then_coverage" data-i18n="phase2ArchP2AuditorUntilPassThenCoverage">ê°ì‚¬ passê¹Œì§€ ë°˜ë³µ â†’ ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜</option>
		                                <option value="p2_integrated" data-i18n="phase2ArchP2Integrated">í†µí•©: ê°ì‚¬ ìƒëµ â†’ ì»¤ë²„ë¦¬ì§€ íŒ¨ì²˜ê°€ êµìœ¡ì„±ê¹Œì§€ ê°œì„ </option>
		                                <option value="p2_integrated_creator_patch" selected data-i18n="phase2ArchP2IntegratedCreatorPatch">í†µí•©(í•´ì„¤ Patch): ê°ì‚¬ ìƒëµ â†’ í•´ì„¤ìƒì„± ê¸°ë°˜ ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜</option>
		                                <option value="p2_draft_only" data-i18n="phase2ArchP2DraftOnly">ì´ˆì €ë¹„ìš©: ê°ì‚¬/ì»¤ë²„ë¦¬ì§€ ëª¨ë‘ ìƒëµ (ì´ˆì•ˆë§Œ)</option>
		                            </select>
                            <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:6px;">
                                <div style="flex:1; min-width:210px;">
		                                    <label for="phase2-target-select" class="ui-label" data-i18n="phase2TargetLabel">ëŒ€ìƒ ìœ í˜•</label>
		                                    <select id="phase2-target-select" class="ui-input">
	                                        <option value="all" data-i18n="phase2TargetAll">ì „ì²´ ìœ í˜•</option>
	                                        <option value="single" data-i18n="phase2TargetSingle">í•œ ìœ í˜•ë§Œ (ì´ë¦„ í¬í•¨ / ì •ê·œì‹)</option>
	                                    </select>
                                </div>
                                <div id="phase2-target-query-wrap" style="flex:2; min-width:240px; display:none;">
		                                    <label for="phase2-target-query-input" class="ui-label" data-i18n="phase2TargetQueryLabel">ìœ í˜• í•„í„°</label>
		                                    <input type="text" id="phase2-target-query-input" class="ui-input"
		                                        placeholder="ì˜ˆ) 1ì°¨í•¨ìˆ˜ / /quadratic/i" data-i18n-placeholder="phase2TargetQueryPlaceholder">
	                                </div>
                            </div>
		                            <label for="phase2-max-modules-input" class="ui-label" data-i18n="phase2MaxModulesLabel" style="margin-top:6px;">ìµœëŒ€ ëª¨ë“ˆ
		                                ìˆ˜ (0 = ë¬´ì œí•œ)</label>
	                            <input type="number" id="phase2-max-modules-input" class="ui-input" min="0" max="9999"
	                                value="0">
                        </div>

		                        <div class="input-group-tight">
		                            <label class="ui-label" data-i18n="coverageSettingsLabel">ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜ ì„¤ì • (2ë‹¨ê³„)</label>
		                            <div style="display:flex; gap:10px;">
		                                <div style="flex:1;">
		                                    <label for="coverage-max-tokens-input" class="ui-label" data-i18n="coverageMaxTokensLabel">ìµœëŒ€ í† í° (ìš”ì²­ë‹¹)</label>
		                                    <input type="number" id="coverage-max-tokens-input" class="ui-input" min="100"
		                                        max="1000000" step="1000" value="100000">
		                                </div>
		                                <div style="flex:1;">
		                                    <label for="coverage-max-rounds-input" class="ui-label" data-i18n="coverageMaxRoundsLabel">ìµœëŒ€ ë¼ìš´ë“œ</label>
		                                    <input type="number" id="coverage-max-rounds-input" class="ui-input" min="0"
		                                        max="99" value="4">
		                                </div>
		                            </div>
		                            <div style="display:flex; gap:10px; margin-top:8px;">
		                                <div style="flex:1;">
		                                    <label for="coverage-auto-accept-missing-leq-input" class="ui-label" data-i18n="coverageAutoAcceptLabel">ë‚¨ì€ ë¬¸ì œ â‰¤ Nì´ë©´ 1íšŒ íŒ¨ì¹˜ í›„ í™•ì •(ì¬ê²€ì¦ ìƒëµ)</label>
		                                    <input type="number" id="coverage-auto-accept-missing-leq-input" class="ui-input"
		                                        min="0" max="999" value="5">
		                                </div>
		                            </div>
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n-html="coverageMaxTokensHelpHtml">
	                                <code>ìµœëŒ€ í† í°</code>ì€ ìš”ì²­ ì „ì²´(system+guide+problems) ê¸°ì¤€ì´ë©°, ì´ˆê³¼ ì‹œ ìë™ ë¶„í• ë©ë‹ˆë‹¤. (ì¶œë ¥ <code>max_tokens</code>ì™€ ë³„ê°œ)
	                            </div>
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="coverageAutoAcceptHelp">
	                                <code>N=0</code>ì´ë©´ ë¹„í™œì„±. ê²€ì¦ ê²°ê³¼ê°€ Nê°œ ì´í•˜ì¼ ë•Œ 1íšŒ íŒ¨ì¹˜ í›„ ë°”ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤. (ì •í™•í•œ ìµœì¢… ì»¤ë²„ë¦¬ì§€ëŠ” ì¬ê²€ì¦í•˜ì§€ ì•ŠìŒ)
	                            </div>
		                            <div style="display:flex; gap:10px; margin-top:8px;">
		                                <div style="flex:1;">
		                                    <label for="coverage-verifier-output-select" class="ui-label" data-i18n="coverageVerifierOutputLabel">ê²€ì¦ ì¶œë ¥</label>
		                                    <select id="coverage-verifier-output-select" class="ui-input">
		                                        <option value="full" data-i18n="coverageVerifierOutputFull">ì „ì²´(ì¶©ì¡±+ë¯¸ì¶©ì¡±, ê·¼ê±° í¬í•¨)</option>
		                                        <option value="missing_only" selected data-i18n="coverageVerifierOutputMissingOnly">ë¯¸ì¶©ì¡±ë§Œ(ì €ë¹„ìš©)</option>
		                                    </select>
		                                </div>
		                                <div style="flex:1;">
		                                    <label for="coverage-verifier-max-tries-input" class="ui-label" data-i18n="coverageVerifierMaxTriesLabel">ê²€ì¦ ì¬ì‹œë„ (0 = ë¬´ì œí•œ)</label>
		                                    <input type="number" id="coverage-verifier-max-tries-input" class="ui-input" min="0"
		                                        max="99" value="0">
		                                </div>
		                            </div>
		                            <div style="display:flex; gap:10px; margin-top:8px;">
		                                <div style="flex:1;">
		                                    <label for="coverage-final-verify-select" class="ui-label" data-i18n="coverageFinalVerifyLabel">ìµœì¢… ê²€ì¦</label>
		                                    <select id="coverage-final-verify-select" class="ui-input">
		                                        <option value="global" data-i18n="coverageFinalVerifyGlobal">ì „ì—­(ì „ì²´ ë¬¸ì œ ì¬ê²€ì¦)</option>
		                                        <option value="per_chunk" selected data-i18n="coverageFinalVerifyPerChunk">ì²­í¬ ì™„ë£Œ ì‹œ ì¬ê²€ì¦(ì „ì—­ ì¬ì§ˆë¬¸ ì—†ìŒ)</option>
		                                        <option value="none" data-i18n="coverageFinalVerifyNone">ìƒëµ(ìµœì†Œ ë¹„ìš©)</option>
		                                    </select>
		                                </div>
		                                <div style="flex:1;">
		                                    <label for="coverage-overflow-mode-select" class="ui-label" data-i18n="coverageOverflowModeLabel">ê°€ì´ë“œ ì´ˆê³¼ ì‹œ</label>
		                                    <select id="coverage-overflow-mode-select" class="ui-input">
	                                        <option value="guide_merge" data-i18n="coverageOverflowGuideMerge">ê°€ì´ë“œ ë¶„í•  ë³‘í•© (ê¶Œì¥)</option>
	                                        <option value="type_split" data-i18n="coverageOverflowTypeSplit">ìœ í˜• ë¶„í• </option>
	                                        <option value="error" data-i18n="coverageOverflowError">ì˜¤ë¥˜ë¡œ ì¤‘ë‹¨</option>
	                                    </select>
	                                </div>
	                            </div>
		                            <div style="display:flex; gap:10px; margin-top:8px;">
		                                <div style="flex:1;">
		                                    <label for="coverage-overflow-threshold-input" class="ui-label" data-i18n="coverageOverflowThresholdLabel">ë¶„í•  ì„ê³„ê°’ (ì˜¤ë¥˜ íšŸìˆ˜)</label>
		                                    <input type="number" id="coverage-overflow-threshold-input" class="ui-input" min="1"
		                                        max="10" value="2">
		                                </div>
		                            </div>
	                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n-html="coverageOverflowHelpHtml">
	                                â€œì „ì²´â€ ëª¨ë“œëŠ” ë¬¸ì œë³„ë¡œ <code>covered</code>/<code>reason</code>ë¥¼ ëª¨ë‘ ë°›ìœ¼ë©°, í•­ëª© ìˆ˜ê°€ ë§ì§€ ì•Šìœ¼ë©´ ìë™ ì¬ìš”ì²­í•©ë‹ˆë‹¤.<br>"ê°€ì´ë“œ ë¶„í•  ë³‘í•©"ì€ ë¬¸ì œë¥¼ ë‚˜ëˆ  ê°ê° ê°€ì´ë“œë¥¼ ìƒì„± í›„ ë³‘í•©í•©ë‹ˆë‹¤.
	                            </div>
	                        </div>

	                        <div class="input-group-tight">
	                            <label for="max-data-envelope-tries-input" class="ui-label" data-i18n="maxDataEnvelopeTriesLabel">ì—„ê²© &lt;data&gt; í¬ë§· ì¬ì‹œë„ íšŸìˆ˜ (0 = ë¬´ì œí•œ)</label>
	                            <input type="number" id="max-data-envelope-tries-input" class="ui-input" min="0" max="99"
	                                value="0">
                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="maxDataEnvelopeTriesHelp">
                                ëª¨ë¸ì´ XML í¬ë§·ì„ ê³„ì† ê¹¨ëŠ” ê²½ìš° ë¬´í•œ ì¬ì‹œë„ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
                            </div>
                        </div>

	                        <div class="input-group-tight">
	                            <label for="structured-output-style-select" class="ui-label" data-i18n="structuredOutputStyleLabel">êµ¬ì¡°í™” ì¶œë ¥ ìŠ¤íƒ€ì¼</label>
	                            <select id="structured-output-style-select" class="ui-input">
	                                <option value="structured_only" data-i18n="structuredOutputStyleStructuredOnly">êµ¬ì¡°ë§Œ(ê¸°ë³¸)</option>
	                                <option value="rationale_then_structured" selected data-i18n="structuredOutputStyleRationaleThenStructured">ì´ìœ  ë¨¼ì € â†’ êµ¬ì¡°í™” ì¶œë ¥(ë§ˆì§€ë§‰)</option>
	                            </select>
                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="structuredOutputStyleHelp">
                                &lt;data&gt;/&lt;patches&gt; ë“± êµ¬ì¡°í™” ì¶œë ¥ ë‹¨ê³„ì—ì„œ â€œì´ìœ â€ë¥¼ ë¨¼ì € ì¶œë ¥í•˜ê³ , êµ¬ì¡°í™” ë¸”ë¡ì„ ë§ˆì§€ë§‰ì— ë‘ë„ë¡ ìœ ë„í•©ë‹ˆë‹¤. (ì‹¤í—˜ ëª¨ë“œ
                                í¬í•¨)
                            </div>
                        </div>

	                        <div class="input-group-tight">
	                            <label class="ui-label" data-i18n="structuredOutputOverridesLabel">ì´ìœ  ë¨¼ì €(í˜ì´ì¦ˆë³„ ì˜¤ë²„ë¼ì´ë“œ)</label>
                            <div style="display:flex; gap:10px; flex-wrap:wrap;">
                                <div style="flex:1; min-width:210px;">
	                                    <label for="structured-output-phase0-select" class="ui-label" data-i18n="structuredOutputPhase0Label">0ë‹¨ê³„(ì¶”ì¶œ)</label>
	                                    <select id="structured-output-phase0-select" class="ui-input">
	                                        <option value="inherit" data-i18n="structuredOutputOptionInherit">ì „ì—­ ë”°ë¦„</option>
	                                        <option value="structured_only" selected data-i18n="structuredOutputOptionStructuredOnly">êµ¬ì¡°ë§Œ</option>
	                                        <option value="rationale_then_structured" data-i18n="structuredOutputOptionRationaleThenStructured">ì´ìœ  ë¨¼ì €</option>
	                                    </select>
	                                </div>
                                <div style="flex:1; min-width:210px;">
	                                    <label for="structured-output-phase1a-select"
	                                        class="ui-label" data-i18n="structuredOutputPhase1aLabel">1A(ìœ í˜•í‘œì¤€)</label>
	                                    <select id="structured-output-phase1a-select" class="ui-input">
                                        <option value="inherit" data-i18n="structuredOutputOptionInherit">ì „ì—­ ë”°ë¦„</option>
                                        <option value="structured_only" data-i18n="structuredOutputOptionStructuredOnly">êµ¬ì¡°ë§Œ</option>
                                        <option value="rationale_then_structured" data-i18n="structuredOutputOptionRationaleThenStructured">ì´ìœ  ë¨¼ì €</option>
                                    </select>
                                </div>
                                <div style="flex:1; min-width:210px;">
	                                    <label for="structured-output-phase1b-select"
	                                        class="ui-label" data-i18n="structuredOutputPhase1bLabel">1B(ìœ í˜•ë¶„ë¥˜)</label>
	                                    <select id="structured-output-phase1b-select" class="ui-input">
	                                        <option value="inherit" data-i18n="structuredOutputOptionInherit">ì „ì—­ ë”°ë¦„</option>
	                                        <option value="structured_only" selected data-i18n="structuredOutputOptionStructuredOnly">êµ¬ì¡°ë§Œ</option>
	                                        <option value="rationale_then_structured" data-i18n="structuredOutputOptionRationaleThenStructured">ì´ìœ  ë¨¼ì €</option>
	                                    </select>
	                                </div>
                                <div style="flex:1; min-width:210px;">
	                                    <label for="structured-output-phase2-select"
	                                        class="ui-label" data-i18n="structuredOutputPhase2Label">2ë‹¨ê³„(ëª¨ë“ˆ/ì»¤ë²„ë¦¬ì§€)</label>
	                                    <select id="structured-output-phase2-select" class="ui-input">
                                        <option value="inherit" data-i18n="structuredOutputOptionInherit">ì „ì—­ ë”°ë¦„</option>
                                        <option value="structured_only" data-i18n="structuredOutputOptionStructuredOnly">êµ¬ì¡°ë§Œ</option>
                                        <option value="rationale_then_structured" data-i18n="structuredOutputOptionRationaleThenStructured">ì´ìœ  ë¨¼ì €</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-top:4px; font-size:11px; color:var(--text-3);" data-i18n="structuredOutputOverridesHelp">
                                1Bì—ì„œ â€œì´ìœ  ë¨¼ì €â€ë¥¼ ì¼œë©´, ì»¨í…ìŠ¤íŠ¸ í­ë°œì„ ë§‰ê¸° ìœ„í•´ ìë™ìœ¼ë¡œ â€œë°©ë²•ë¡  ìš”ì•½(ì§§ê²Œ)â€ë§Œ ìš”êµ¬í•©ë‹ˆë‹¤.
                            </div>
                        </div>
                    </div>
                </details>

	                <details class="ui-panel">
	                    <summary id="summary-type-guide-regeneration" data-i18n="summaryTypeGuideRegeneration">ìœ í˜• ê°€ì´ë“œ ì¬ìƒì„±</summary>
	                    <div style="padding-top: 1rem;">
                        <div class="input-group-tight">
	                            <label class="ui-label" data-i18n="typeGuideImportLabel">ìœ í˜• TXT/MD ë¶ˆëŸ¬ì˜¤ê¸° (.txt/.md)</label>
                            <div style="display:flex; gap:0.5rem;">
	                                <button id="type-guide-import-btn" class="ui-btn" data-i18n="typeGuideImportButton">ë¶ˆëŸ¬ì˜¤ê¸°</button>
                                <input type="file" id="type-guide-import-input" accept=".txt,.md,.markdown,text/plain"
                                    style="display: none;">
                            </div>
                            <div id="type-guide-import-status"
                                style="margin-top:6px; font-size:12px; color:var(--text-2);" data-i18n="typeGuideImportStatusEmpty">ê°€ì´ë“œ ë¯¸ë¡œë”©</div>
                        </div>
	                        <div class="input-group-tight" style="display:flex; gap:0.5rem;">
	                            <button id="type-rerun-btn" class="ui-btn" disabled data-i18n="typeGuideRerunButton">ê°€ì´ë“œ ì¬ìƒì„±</button>
	                            <button id="type-export-btn" class="ui-btn" disabled data-i18n="typeGuideExportButton">íŒ¨ì¹˜ ë‹¤ìš´ë¡œë“œ (.json)</button>
	                        </div>
                    </div>
                </details>

	                <details class="ui-panel">
	                    <summary id="summary-incremental" data-i18n="summaryIncremental">ì‹ ê·œ ë¬¸ì œ ì¶”ê°€ (ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜ ì „ìš©)</summary>
                    <div style="padding-top: 1rem;">
                        <div class="input-group-tight">
	                            <label class="ui-label" data-i18n="incBaseImportLabel">ê¸°ì¡´ ê°€ì´ë“œ/ë¬¸ì œ ë² ì´ìŠ¤ ë¶ˆëŸ¬ì˜¤ê¸° (.json)</label>
                            <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
	                                <button id="inc-base-import-btn" class="ui-btn" data-i18n="incBaseImportButton">ë¶ˆëŸ¬ì˜¤ê¸°</button>
                                <input type="file" id="inc-base-import-input" accept=".json,application/json" style="display:none;">
                            </div>
                        <div style="margin-top:6px; font-size:12px; color:var(--text-2);" data-i18n-html="incBaseImportHelpHtml">
                                ê¶Œì¥: builderê°€ ë§Œë“  íŒ¨ì¹˜ íŒŒì¼(`type_patch_*.json`).<br>
                                â€œìƒˆ ìœ í˜•(ë¯¸ë¶„ë¥˜)ë¡œ ì¶”ê°€â€ë§Œ í•  ê²½ìš° ë² ì´ìŠ¤ ì—†ì´ë„ ë™ì‘í•©ë‹ˆë‹¤.
                            </div>
                        </div>

                        <div class="input-group-tight">
	                            <label class="ui-label" data-i18n="incNewFilesLabel">ì¶”ê°€í•  ìƒˆ ì‹œí—˜ì§€ ì—…ë¡œë“œ (.pdf, .txt)</label>
                            <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
	                                <button id="inc-new-files-btn" class="ui-btn" data-i18n="incNewFilesButton">íŒŒì¼ ì„ íƒ</button>
                                <input type="file" id="inc-new-files-input" multiple accept=".pdf,.txt,application/pdf,text/plain" style="display:none;">
                            </div>
                            <div id="inc-new-files-status" style="margin-top:6px; font-size:12px; color:var(--text-2);" data-i18n="incNewFilesStatusNone">íŒŒì¼ ë¯¸ì„ íƒ</div>
                            <div class="input-group-tight" style="margin-top:10px;">
	                                <label class="ui-label" data-i18n="incOcrSplitLabel">OCR ë¶„í•  (PDF í˜ì´ì§€ ë¬¶ìŒ)</label>
                                <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
	                                    <input id="inc-split-pages-input" class="ui-input" type="number" min="0" step="1" value="0" style="max-width:140px;">
                                    <div style="font-size:11px; color:var(--text-3);" data-i18n="incOcrSplitHelp">
                                        0ì´ë©´ ê¸°ë³¸ê°’(ìƒë‹¨ ì „ì—­ ì„¤ì •)ì„ ì‚¬ìš©. ì˜ˆ: 5 â†’ 5í˜ì´ì§€ì”© OCR/ì¶”ì¶œ ìœ ë‹› ìƒì„±.
                                    </div>
                                </div>
                                <label style="display:flex; gap:8px; align-items:center; margin-top:6px; font-size:12px; color:var(--text-2);">
                                    <input type="checkbox" id="inc-reuse-extraction-cache-input" checked>
                                    <span data-i18n="incReuseExtractionCacheLabel">ê°™ì€ íŒŒì¼ë¡œ ë‹¤ì‹œ ì‹¤í–‰ ì‹œ, ì™„ë£Œëœ OCR/ì¶”ì¶œ ê²°ê³¼ë¥¼ ì¬ì‚¬ìš©(ì´ì–´í•˜ê¸°)</span>
                                </label>
                            </div>
                        </div>

                        <div class="input-group-tight">
	                            <label class="ui-label" data-i18n="incTypeModeLabel">ìœ í˜• ë°°ì¹˜ ëª¨ë“œ</label>
	                            <select id="inc-type-mode-select" class="ui-input">
                                <option value="distribute" data-i18n="incTypeModeDistribute">ê¸°ì¡´ ìœ í˜•ì— ë¶„ë°° (ë¶„ë¥˜í‘œì¤€ í•„ìš”)</option>
                                <option value="new_type" data-i18n="incTypeModeNewType">ìƒˆ ìœ í˜•(ë¯¸ë¶„ë¥˜)ë¡œ ì¶”ê°€</option>
                            </select>
                            <div style="margin-top:6px; font-size:11px; color:var(--text-3);" data-i18n="incTypeModeHelp">
                                â€œê¸°ì¡´ ìœ í˜•ì— ë¶„ë°°â€ëŠ” ë² ì´ìŠ¤ íŒŒì¼ì— `classificationStandard`ê°€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ì—†ìœ¼ë©´ â€œìƒˆ ìœ í˜•â€ì„ ì‚¬ìš©í•˜ì„¸ìš”.
                            </div>
                        </div>

	                        <div class="input-group-tight" id="inc-new-type-title-wrap" style="display:none;">
	                            <label class="ui-label" data-i18n="incNewTypeTitleLabel">ìƒˆ ìœ í˜• ì œëª©</label>
	                            <input id="inc-new-type-title-input" class="ui-input" value="ğŸ†• ì‹ ê·œ ë¬¸ì œ (ë¯¸ë¶„ë¥˜)">
	                        </div>

	                        <div class="input-group-tight">
	                            <label class="ui-label" data-i18n="incExperimentalOptionsLabel">ì‹¤í—˜ ì˜µì…˜</label>
                            <label style="display:flex; gap:8px; align-items:center; font-size:12px; color:var(--text-2);">
                                <input type="checkbox" id="inc-experimental-image-crops-input">
                                <span data-i18n="incExperimentalImageCropsLabel">ê·¸ë¦¼/ë„í‘œê°€ ìˆëŠ” ë¬¸ì œ: ì´ë¯¸ì§€ í¬ë¡­ì„ `question_text` ì•ì— `![img](data:...)`ë¡œ ì‚½ì… (ì‹¤í—˜)</span>
                            </label>
                        </div>

	                        <div class="input-group-tight" style="display:flex; gap:0.5rem; flex-wrap:wrap;">
	                            <button id="inc-run-btn" class="ui-btn" disabled data-i18n="incRunButton">ì‹ ê·œë¬¸ì œ íŒ¨ì¹˜ ìƒì„±</button>
	                            <button id="inc-download-btn" class="ui-btn" disabled data-i18n="incDownloadButton">íŒ¨ì¹˜ ë‹¤ìš´ë¡œë“œ (.json)</button>
	                        </div>

                        <div id="inc-status" style="margin-top:8px; font-size:12px; color:var(--text-2);" data-i18n="incStatusIdle">ëŒ€ê¸°</div>
                    </div>
                </details>

		                <details class="ui-panel">
		                    <summary id="summary-prompts-advanced" data-i18n="summaryPromptsAdvanced">í”„ë¡¬í”„íŠ¸(ê³ ê¸‰)</summary>
                    <div style="padding-top: 1rem;">
                        <div id="prompt-controls" style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
	                            <button id="import-prompts-btn" class="ui-btn" style="flex-grow: 1;" data-i18n="promptsImportButton">ë¶ˆëŸ¬ì˜¤ê¸°</button>
                            <input type="file" id="import-prompts-input" accept=".json" style="display: none;">
	                            <button id="export-prompts-btn" class="ui-btn" style="flex-grow: 1;" data-i18n="promptsExportButton">ë‚´ë³´ë‚´ê¸°</button>
	                            <button id="reset-prompts-btn" class="ui-btn" style="flex-grow: 1;" data-i18n="promptsResetButton">ì´ˆê¸°í™”</button>
                        </div>

	                        <div class="input-group-tight">
	                            <label for="prompt-extractor" class="ui-label" data-i18n="promptExtractorLabel">1. ì¶”ì¶œ(Extractor) í”„ë¡¬í”„íŠ¸</label>
	                            <textarea id="prompt-extractor" class="ui-input" rows="5"></textarea>
	                        </div>
	                        <div class="input-group-tight">
	                            <label for="prompt-classifier-standard" class="ui-label" data-i18n="promptClassifierStandardLabel">2a. ìœ í˜•í‘œì¤€ ìƒì„± í”„ë¡¬í”„íŠ¸</label>
	                            <textarea id="prompt-classifier-standard" class="ui-input" rows="5"></textarea>
	                        </div>
	                        <div class="input-group-tight">
	                            <label for="prompt-classifier-standard-verifier" class="ui-label" data-i18n="promptClassifierStandardVerifierLabel">2a-ê²€ì¦. ìœ í˜•í‘œì¤€ í‰ê°€ í”„ë¡¬í”„íŠ¸</label>
	                            <textarea id="prompt-classifier-standard-verifier" class="ui-input" rows="5"></textarea>
	                        </div>
	                        <div class="input-group-tight">
	                            <label for="prompt-classifier-apply" class="ui-label" data-i18n="promptClassifierApplyLabel">2b. ìœ í˜•ë¶„ë¥˜ ì ìš© í”„ë¡¬í”„íŠ¸</label>
	                            <textarea id="prompt-classifier-apply" class="ui-input" rows="5"></textarea>
	                        </div>
	                        <div class="input-group-tight">
	                            <label for="prompt-subgroup-creator" class="ui-label" data-i18n="promptSubgroupCreatorLabel">2c. ì†Œê·¸ë£¹ ìƒì„± í”„ë¡¬í”„íŠ¸ (ì‹¤í—˜)</label>
	                            <textarea id="prompt-subgroup-creator" class="ui-input" rows="5"></textarea>
	                        </div>
	                        <div class="input-group-tight">
	                            <label for="prompt-standard-problem-creator" class="ui-label" data-i18n="promptStandardProblemCreatorLabel">3. í‘œì¤€ë¬¸ì œ ìƒì„± í”„ë¡¬í”„íŠ¸</label>
	                            <textarea id="prompt-standard-problem-creator" class="ui-input" rows="5"></textarea>
	                        </div>
	                        <div class="input-group-tight">
	                            <label for="prompt-explanation-creator" class="ui-label" data-i18n="promptExplanationCreatorLabel">4. í•´ì„¤ ìƒì„± í”„ë¡¬í”„íŠ¸</label>
	                            <textarea id="prompt-explanation-creator" class="ui-input" rows="5"></textarea>
	                        </div>
	                        <div class="input-group-tight">
	                            <label for="prompt-explanation-feedback" class="ui-label" data-i18n="promptExplanationFeedbackLabel">5. ê°ì‚¬/í”¼ë“œë°± í”„ë¡¬í”„íŠ¸</label>
	                            <textarea id="prompt-explanation-feedback" class="ui-input" rows="5"></textarea>
	                        </div>
	                        <div class="input-group-tight">
	                            <label for="prompt-coverage-verifier" class="ui-label" data-i18n="promptCoverageVerifierLabel">6. ì»¤ë²„ë¦¬ì§€ ê²€ì¦ í”„ë¡¬í”„íŠ¸</label>
	                            <textarea id="prompt-coverage-verifier" class="ui-input" rows="5"></textarea>
	                        </div>
	                        <div class="input-group-tight">
	                            <label for="prompt-coverage-patcher" class="ui-label" data-i18n="promptCoveragePatcherLabel">7. ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜ í”„ë¡¬í”„íŠ¸</label>
	                            <textarea id="prompt-coverage-patcher" class="ui-input" rows="5"></textarea>
	                        </div>
                    </div>
                </details>
            </div>
        </aside>

        <!-- MAIN CONTENT AREA -->
        <main id="main-content">
            <div id="main-content-wrapper">
                <div id="status-display">
                    <h2 id="status-text" data-i18n="statusReadyTitle">ì¤€ë¹„</h2>
                    <p id="status-subtext" data-i18n="statusReadySubtext">ì‹œì‘í•˜ë ¤ë©´ PDF ë˜ëŠ” TXT ì‹œí—˜ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”.</p>
                </div>

                <div id="results-and-logs-container"
                    style="display: flex; flex-direction: column; flex-grow: 1; min-height: 0;">
                    <div id="tabs-nav-container"></div>

                    <div id="pipelines-content-container" style="overflow-y: auto; flex-grow:1; padding-top: 1rem;">
                    </div>

		                    <details id="api-monitor-details" class="ui-panel" open style="margin-top: 1rem;">
		                        <summary id="summary-api-monitor" data-i18n="summaryApiMonitor">API ëª¨ë‹ˆí„°</summary>
	                        <div class="api-monitor-grid">
	                            <div class="api-monitor-col">
	                                <div class="api-monitor-header">
	                                    <div style="width:10px;"></div>
	                                    <div class="api-monitor-h-idx" style="width:28px; text-align:right;" data-i18n="apiMonitorColIndex">#</div>
	                                    <div class="api-monitor-h-key" style="width:90px;" data-i18n="apiMonitorColKey">í‚¤</div>
	                                    <div class="api-monitor-h-context" style="width:140px;" data-i18n="apiMonitorColContext">ì»¨í…ìŠ¤íŠ¸</div>
	                                    <div class="api-monitor-h-estTok" style="width:85px; text-align:right;">estTok</div>
	                                    <div class="api-monitor-h-age" style="width:80px; text-align:right;">age</div>
	                                    <div class="api-monitor-h-retry" style="width:80px; text-align:right;">retry</div>
	                                    <div class="api-monitor-h-status" style="flex:1;" data-i18n="apiMonitorColStatus">ìƒíƒœ</div>
	                                </div>
	                                <div class="log-mini" id="key-monitor-output" style="max-height:360px; font-size:12px;"></div>
	                            </div>
	                            <div class="api-monitor-col">
	                                <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
	                                    <div style="font-size:11px; font-weight:bold; margin:2px 0;" data-i18n="apiMonitorRecentCallsTitle">ìµœê·¼ í˜¸ì¶œ (50)</div>
	                                    <div id="api-monitor-totals"
	                                        style="font-size:10px; font-family:monospace; color:var(--text-3);"
	                                        data-i18n="apiMonitorTotalsInit">Calls 0 â€¢ waiting 0 â€¢ inflight 0 â€¢ ok 0 â€¢ fail 0</div>
	                                </div>
	                                <div class="log-mini" id="api-monitor-recent-calls"
	                                    style="max-height:360px; font-size:12px;"></div>
	                            </div>
	                            <div class="api-monitor-col">
	                                <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
	                                    <div style="font-size:11px; font-weight:bold; margin:2px 0;" data-i18n="apiMonitorBreakdownTitle">í˜¸ì¶œ ë¸Œë ˆì´í¬ë‹¤ìš´ (ì„±ê³µ)</div>
		                                    <button id="reset-call-breakdown-btn" class="ui-btn"
		                                        style="padding:2px 6px; font-size:12px;" data-i18n="apiMonitorBreakdownResetButton">ì´ˆê¸°í™”</button>
	                                </div>
	                                <div class="log-mini" id="api-monitor-breakdown"
	                                    style="max-height:360px; font-size:12px;"></div>
	                            </div>
	                        </div>
                    </details>

                    <h3 style="margin-top: 1rem; margin-bottom: 0.5rem;" data-i18n="processLogTitle">í”„ë¡œì„¸ìŠ¤ ë¡œê·¸</h3>
                    <div id="log-tools"
                        style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom: 0.5rem;">
                        <div style="display:flex; gap:6px; align-items:center;">
                            <label for="log-ui-max-lines-input" style="font-size:12px; color:var(--text-2);" data-i18n="logUiMaxLinesLabel">í‘œì‹œ ì¤„ìˆ˜</label>
	                            <input type="number" id="log-ui-max-lines-input" class="ui-input" min="50" max="5000"
	                                value="300" style="width:90px;">
                        </div>
                        <div style="display:flex; gap:6px; align-items:center;">
                            <label for="log-ui-max-chars-input" style="font-size:12px; color:var(--text-2);" data-i18n="logUiMaxCharsLabel">ì¤„ë‹¹ ê¸€ììˆ˜</label>
	                            <input type="number" id="log-ui-max-chars-input" class="ui-input" min="80" max="50000"
	                                value="800" style="width:110px;">
                        </div>
                        <div style="display:flex; gap:6px; align-items:center;">
                            <label for="log-filter-type-select" style="font-size:12px; color:var(--text-2);" data-i18n="logFilterTypeLabel">íƒ€ì…</label>
	                            <select id="log-filter-type-select" class="ui-input" style="width:180px;">
                                <option value="all" data-i18n="logFilterTypeAll">ì „ì²´</option>
                                <option value="api_input" data-i18n="logFilterTypeApiInput">API ì…ë ¥</option>
                                <option value="api_output" data-i18n="logFilterTypeApiOutput">API ì¶œë ¥</option>
                                <option value="errors" data-i18n="logFilterTypeErrors">ê²½ê³ +ì—ëŸ¬</option>
                                <option value="errors_no_api_http" data-i18n="logFilterTypeErrorsNoHttp">ê²½ê³ +ì—ëŸ¬(HTTP 429/5xx ì œì™¸)</option>
                            </select>
                        </div>
                        <div style="display:flex; gap:6px; align-items:center;">
                            <label for="log-filter-session-select"
                                style="font-size:12px; color:var(--text-2);" data-i18n="logFilterSessionLabel">ì„¸ì…˜</label>
	                            <select id="log-filter-session-select" class="ui-input" style="width:220px;">
                                <option value="current" data-i18n="logFilterSessionCurrent">í˜„ì¬ ì„¸ì…˜</option>
                                <option value="all" data-i18n="logFilterSessionAll">ì „ì²´ ì„¸ì…˜</option>
                            </select>
                        </div>
                        <div style="display:flex; gap:6px; align-items:center;">
                            <label for="log-filter-phase-select"
                                style="font-size:12px; color:var(--text-2);" data-i18n="logFilterPhaseLabel">í˜ì´ì¦ˆ</label>
	                            <select id="log-filter-phase-select" class="ui-input" style="width:210px;">
                                <option value="all" data-i18n="logFilterPhaseAll">ì „ì²´</option>
                                <option value="phase0" data-i18n="logFilterPhase0">0ë‹¨ê³„ (ì¶”ì¶œ)</option>
                                <option value="phase1" data-i18n="logFilterPhase1">1ë‹¨ê³„ (ìœ í˜•ë¶„ë¥˜)</option>
                                <option value="phase2" data-i18n="logFilterPhase2">2ë‹¨ê³„ (ê°€ì´ë“œ/ì»¤ë²„ë¦¬ì§€)</option>
                                <option value="phase3" data-i18n="logFilterPhase3">3ë‹¨ê³„ (ìµœì¢…)</option>
                                <option value="other" data-i18n="logFilterPhaseOther">ê¸°íƒ€</option>
                            </select>
                        </div>
	                        <input type="text" id="log-filter-query-input" class="ui-input"
	                            placeholder="Search (context/message)" style="width:240px;" data-i18n-placeholder="logFilterQueryPlaceholder">
	                        <button id="download-logs-btn" class="ui-btn" data-i18n="logDownloadButton">ë‹¤ìš´ë¡œë“œ(í•„í„°ë¨)</button>
	                        <button id="clear-logs-btn" class="ui-btn" data-i18n="logClearButton">í™”ë©´ ì§€ìš°ê¸°</button>
                    </div>
                    <div id="full-capture-tools"
                        style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom: 0.5rem;">
                        <label style="font-size:12px; color:var(--text-2);">
                            <input type="checkbox" id="full-capture-enabled-input">
                            <span data-i18n="fullCaptureEnabledLabel">Full API capture (IndexedDB)</span>
                        </label>
                        <button id="full-capture-export-btn" class="ui-btn" data-i18n="fullCaptureExportButton">Export full log (JSONL)</button>
                        <button id="full-capture-clear-btn" class="ui-btn" data-i18n="fullCaptureClearButton">Clear full log</button>
                        <span id="full-capture-status"
                            style="font-size:12px; color:var(--text-3); font-family:monospace;"></span>
                    </div>
		                    <details id="format-errors-details" class="ui-panel" style="margin: 0.5rem 0;">
		                        <summary id="summary-format-errors" data-i18n="summaryFormatErrors">í˜•ì‹ ì˜¤ë¥˜(êµ¬ì¡°í™” ì¶œë ¥) â€” raw I/O ëª¨ìŒ</summary>
                        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin: 6px 0;">
                            <div id="format-errors-summary"
                                style="font-size:12px; color:var(--text-3); font-family:monospace;">0 entries</div>
	                            <button id="format-errors-clear-btn" class="ui-btn"
	                                style="padding:2px 6px; font-size:12px;" data-i18n="formatErrorsClearButton">ì´ˆê¸°í™”</button>
	                            <button id="format-errors-download-btn" class="ui-btn"
	                                style="padding:2px 6px; font-size:12px;" data-i18n="formatErrorsDownloadButton">ë‹¤ìš´ë¡œë“œ(JSON)</button>
                        </div>
                        <div class="log-mini" id="format-errors-output" style="max-height:260px; white-space:pre-wrap;">
                        </div>
                    </details>
                    <div id="logs-container"></div>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        /* --- START OF EMBEDDED JAVASCRIPT --- */

        //======================================================================
        // 1. CORE UTILITIES & RESILIENCE
        //======================================================================
        let successfulApiCallCount = 0;
        // New: default chunk size for token-based chunking (1 token â‰ˆ ~4 chars)
        const DEFAULT_CHUNK_TOKENS = 50000;

        // --- Experiment / cost-control config ---
        const EXP_CONFIG_STORAGE_KEY = 'mastery_manual_experiment_config_v1';
        const __PHASE_INDEX = { phase0: 0, phase1: 1, phase2: 2, phase3: 3 };

        function __normalizeStartFrom(v) {
            const s = String(v || '').toLowerCase().trim();
            if (s === 'continue') return 'continue';
            return Object.prototype.hasOwnProperty.call(__PHASE_INDEX, s) ? s : 'continue';
        }

        function __normalizeStopAfter(v) {
            const s = String(v || '').toLowerCase().trim();
            return Object.prototype.hasOwnProperty.call(__PHASE_INDEX, s) ? s : 'phase3';
        }

        function __computeRunPhases(runPlan) {
            const startFrom = __normalizeStartFrom(runPlan?.startFrom);
            const stopAfter = __normalizeStopAfter(runPlan?.stopAfter);
            const stopIdx = __PHASE_INDEX[stopAfter];
            let startIdx = (startFrom === 'continue') ? 0 : __PHASE_INDEX[startFrom];
            if (startIdx > stopIdx) startIdx = stopIdx;
            return {
                phase0: startIdx <= 0 && stopIdx >= 0,
                phase1: startIdx <= 1 && stopIdx >= 1,
                phase2: startIdx <= 2 && stopIdx >= 2,
                phase3: startIdx <= 3 && stopIdx >= 3,
            };
        }

        const PHASE1_ARCH_DEFINITIONS = [
            {
                id: 'p1_default',
                name: 'ê¸°ë³¸: ì²­í¬ë³„ pass ëª©í‘œ (ìµœëŒ€ 2íšŒ)',
                apply: (cfg) => {
                    cfg.phase1.enableEvaluator = true;
                    cfg.phase1.maxAttempts = 2;
                }
            },
            {
                id: 'p1_no_eval',
                name: 'pass@1: ì›ìƒ·(ê²€ì¦/ì¬ì‹œë„ ì—†ìŒ)',
                apply: (cfg) => {
                    cfg.phase1.enableEvaluator = false;
                    cfg.phase1.maxAttempts = 1;
                }
            },
            {
                id: 'p1_until_pass',
                name: 'passê¹Œì§€ ë°˜ë³µ(ë¬´ì œí•œ; ë¹„ìš©â†‘)',
                apply: (cfg) => {
                    cfg.phase1.enableEvaluator = true;
                    cfg.phase1.maxAttempts = 0; // 0 = unlimited
                }
            },
            {
                id: 'p1_coverage_style',
                name: 'ì»¤ë²„ë¦¬ì§€: ìœ í˜• ìƒì„± â†’ ë³‘í•© â†’ ë¶„ë¥˜ â†’ ë¯¸ë¶„ë¥˜ ì¬ì‹œë„',
                apply: (cfg) => {
                    cfg.phase1.enableEvaluator = false;
                    cfg.phase1.maxAttempts = 1;
                    cfg.phase1.classificationMode = 'coverage';
                    cfg.phase1.maxUnclassifiedRetries = __clampInt(cfg?.phase1?.maxUnclassifiedRetries ?? 2, { min: 0, max: 5, fallback: 2 });
                }
            }
        ];

        const PHASE2_ARCH_DEFINITIONS = [
            {
                id: 'p2_default',
                name: 'ê¸°ë³¸: ê°ì‚¬(í”¼ë“œë°± 1íšŒ) + ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜',
                apply: (cfg) => {
                    cfg.phase2.generatorMode = 'basic';
                    cfg.phase2.enableAuditor = true;
                    cfg.phase2.auditorLoopMode = 'single_pass';
                    cfg.phase2.auditorMaxCycles = 1;
                    cfg.phase2.enableCoverage = true;
                    cfg.phase2.coverage.patcherMode = 'coverage_only';
                }
            },
            {
                id: 'p2_pass_to_coverage',
                name: 'pass@1: ê°ì‚¬ ìƒëµ â†’ ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜',
                apply: (cfg) => {
                    cfg.phase2.generatorMode = 'basic';
                    cfg.phase2.enableAuditor = false;
                    cfg.phase2.auditorLoopMode = 'single_pass';
                    cfg.phase2.auditorMaxCycles = 1;
                    cfg.phase2.enableCoverage = true;
                    cfg.phase2.coverage.patcherMode = 'coverage_only';
                }
            },
            {
                id: 'p2_auditor_only',
                name: 'ê°ì‚¬ë§Œ: ì»¤ë²„ë¦¬ì§€ ìƒëµ',
                apply: (cfg) => {
                    cfg.phase2.generatorMode = 'basic';
                    cfg.phase2.enableAuditor = true;
                    cfg.phase2.auditorLoopMode = 'single_pass';
                    cfg.phase2.auditorMaxCycles = 1;
                    cfg.phase2.enableCoverage = false;
                    cfg.phase2.coverage.patcherMode = 'coverage_only';
                }
            },
            {
                id: 'p2_auditor_until_pass_then_coverage',
                name: 'ê°ì‚¬ passê¹Œì§€ ë°˜ë³µ â†’ ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜',
                apply: (cfg) => {
                    cfg.phase2.generatorMode = 'basic';
                    cfg.phase2.enableAuditor = true;
                    cfg.phase2.auditorLoopMode = 'until_pass';
                    cfg.phase2.auditorMaxCycles = 0; // 0 = unlimited
                    cfg.phase2.enableCoverage = true;
                    cfg.phase2.coverage.patcherMode = 'coverage_only';
                }
            },
            {
                id: 'p2_integrated',
                name: 'í†µí•©: ê°ì‚¬ ìƒëµ â†’ ì»¤ë²„ë¦¬ì§€ íŒ¨ì²˜ê°€ êµìœ¡ì„±ê¹Œì§€ ê°œì„ ',
                apply: (cfg) => {
                    cfg.phase2.generatorMode = 'basic';
                    cfg.phase2.enableAuditor = false;
                    cfg.phase2.auditorLoopMode = 'single_pass';
                    cfg.phase2.auditorMaxCycles = 1;
                    cfg.phase2.enableCoverage = true;
                    cfg.phase2.coverage.patcherMode = 'integrated';
                }
            },
            {
                id: 'p2_integrated_creator_patch',
                name: 'í†µí•©(í•´ì„¤ Patch): ê°ì‚¬ ìƒëµ â†’ í•´ì„¤ìƒì„± ê¸°ë°˜ ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜',
                apply: (cfg) => {
                    cfg.phase2.generatorMode = 'basic';
                    cfg.phase2.enableAuditor = false;
                    cfg.phase2.auditorLoopMode = 'single_pass';
                    cfg.phase2.auditorMaxCycles = 1;
                    cfg.phase2.enableCoverage = true;
                    cfg.phase2.coverage.patcherMode = 'creator_patch';
                }
            },
            {
                id: 'p2_draft_only',
                name: 'ì´ˆì €ë¹„ìš©: ê°ì‚¬/ì»¤ë²„ë¦¬ì§€ ëª¨ë‘ ìƒëµ (ì´ˆì•ˆë§Œ)',
                apply: (cfg) => {
                    cfg.phase2.generatorMode = 'basic';
                    cfg.phase2.enableAuditor = false;
                    cfg.phase2.auditorLoopMode = 'single_pass';
                    cfg.phase2.auditorMaxCycles = 1;
                    cfg.phase2.enableCoverage = false;
                    cfg.phase2.coverage.patcherMode = 'coverage_only';
                }
            }
        ];

        function __findArch(defs, id, fallbackId) {
            const wanted = String(id || '').trim();
            const found = (defs || []).find(d => d?.id === wanted);
            if (found) return found;
            return (defs || []).find(d => d?.id === fallbackId) || null;
        }

        function __applyPhase1Arch(cfg) {
            const def = __findArch(PHASE1_ARCH_DEFINITIONS, cfg?.phase1?.archId, 'p1_default');
            if (!def) return;
            try { def.apply(cfg); } catch { }
        }

        function __applyPhase2Arch(cfg) {
            const def = __findArch(PHASE2_ARCH_DEFINITIONS, cfg?.phase2?.archId, 'p2_default');
            if (!def) return;
            try { def.apply(cfg); } catch { }
        }

	        const DEFAULT_PIPELINE_CONFIG = {
	            runPlan: { startFrom: 'continue', stopAfter: 'phase3', resetCallCountersOnStart: false },
	            runPhases: { phase0: true, phase1: true, phase2: true, phase3: true }, // derived from runPlan
		            phase0: {
		                pdfInputMode: 'multimodal',
		                multimodalTransport: 'images_raw_text', // images_raw_text | pdf_raw_text
		                smartRouter: { enabled: false },
		                tesseractLang: 'kor+eng',
		                experimentalImageCrops: false,
		                // NOTE: This is an "export postprocess"-equivalent fill (same engine as Save Postprocessing)
		                // and runs after Phase 3 (when fmm_source exists) so the type guide can be attached.
		                answerFill: {
		                    enabled: false,
		                    fillChunkTokens: DEFAULT_CHUNK_TOKENS,
		                    typeGuideMaxChars: 12000,
		                    includeTypeGuide: true,
		                    fillAnswers: true,
		                    fillExplanations: true,
		                    overwriteAnswers: false,
		                    overwriteExplanations: false,
		                    useDuckDuckGo: false,
		                }
		            },
	            phase1: { archId: 'p1_coverage_style', chunkTokens: DEFAULT_CHUNK_TOKENS, chunkTokens1b: DEFAULT_CHUNK_TOKENS, chunkMode: 'file_first', maxTypes: 25, enableEvaluator: false, maxAttempts: 1, classificationMode: 'coverage', maxUnclassifiedRetries: 2, subgrouping: { enabled: false, chunkTokens: DEFAULT_CHUNK_TOKENS } },
	            phase2: {
	                archId: 'p2_integrated_creator_patch',
                enableAuditor: false,
                auditorLoopMode: 'single_pass', // single_pass | until_pass
                auditorMaxCycles: 1,            // 0 = unlimited (used when until_pass)
                enableCoverage: true,
                singleType: { enabled: false, query: '' },
                maxModules: 0,
                coverage: { maxTokens: 100000, maxRounds: 4, patcherMode: 'creator_patch', verifierOutput: 'missing_only', verifierMaxTries: 0, finalVerifyMode: 'per_chunk', autoAcceptAfterPatchMissingLeq: 5, overflowMode: 'guide_merge', overflowThreshold: 2 },
            },
            format: {
                maxDataEnvelopeTries: 0,
                structuredOutputStyle: 'rationale_then_structured',
                structuredOutputStyleByPhase: { phase0: 'structured_only', phase1a: 'inherit', phase1b: 'structured_only', phase2: 'inherit' },
            }, // 0 = unlimited
        };

        function __safeJsonParse(raw) {
            try { return JSON.parse(String(raw || '')); } catch { return null; }
        }

        function __clampInt(v, { min = 0, max = 999999, fallback = 0 } = {}) {
            const n = parseInt(v, 10);
            if (!Number.isFinite(n)) return fallback;
            return Math.max(min, Math.min(max, n));
        }

        function __getBoolFromUi(id, fallback) {
            const el = document.getElementById(id);
            if (!el) return !!fallback;
            return !!el.checked;
        }

        function __getStrFromUi(id, fallback = '') {
            const el = document.getElementById(id);
            if (!el) return String(fallback || '');
            return String(el.value ?? fallback ?? '');
        }

        function __deepClone(obj) {
            try { return JSON.parse(JSON.stringify(obj)); } catch { return obj; }
        }

        function __deepMerge(base, override) {
            const b = (base && typeof base === 'object') ? base : {};
            const o = (override && typeof override === 'object') ? override : {};
            if (Array.isArray(b) || Array.isArray(o)) return __deepClone(o);
            const out = { ...b };
            Object.keys(o).forEach(k => {
                const bv = b[k];
                const ov = o[k];
                if (bv && typeof bv === 'object' && !Array.isArray(bv) && ov && typeof ov === 'object' && !Array.isArray(ov)) {
                    out[k] = __deepMerge(bv, ov);
                } else {
                    out[k] = __deepClone(ov);
                }
            });
            return out;
        }

        function __migratePipelineConfig(rawCfg) {
            const base = __deepClone(DEFAULT_PIPELINE_CONFIG);
            const cfg = (rawCfg && typeof rawCfg === 'object') ? rawCfg : {};

            // --- runPlan ---
            const legacyRerun = String(cfg?.resume?.rerunFromPhase || '').toLowerCase();
            const startFrom = __normalizeStartFrom(cfg?.runPlan?.startFrom || (legacyRerun && legacyRerun !== 'none' ? legacyRerun : 'continue'));
            const stopAfter = (() => {
                const v = cfg?.runPlan?.stopAfter;
                if (v) return __normalizeStopAfter(v);
                const rp = cfg?.runPhases;
                if (rp && typeof rp === 'object') {
                    if (rp.phase3) return 'phase3';
                    if (rp.phase2) return 'phase2';
                    if (rp.phase1) return 'phase1';
                    if (rp.phase0) return 'phase0';
                }
                return 'phase3';
            })();
            base.runPlan.startFrom = startFrom;
            base.runPlan.stopAfter = stopAfter;
            base.runPlan.resetCallCountersOnStart = !!(cfg?.runPlan?.resetCallCountersOnStart ?? cfg?.resume?.resetCallCountersOnStart ?? false);
            base.runPhases = __computeRunPhases(base.runPlan);

		            // --- phase0 ---
		            if (cfg?.phase0?.pdfInputMode) base.phase0.pdfInputMode = cfg.phase0.pdfInputMode;
		            if (cfg?.phase0?.multimodalTransport) base.phase0.multimodalTransport = cfg.phase0.multimodalTransport;
		            if (cfg?.phase0?.tesseractLang) base.phase0.tesseractLang = cfg.phase0.tesseractLang;
		            if (typeof cfg?.phase0?.experimentalImageCrops !== 'undefined') base.phase0.experimentalImageCrops = !!cfg.phase0.experimentalImageCrops;
		            {
		                const sr = cfg?.phase0?.smartRouter;
		                const enabled = (typeof sr === 'boolean')
		                    ? sr
		                    : !!(sr?.enabled ?? cfg?.phase0?.smartRouterEnabled ?? false);
		                base.phase0.smartRouter = { enabled: !!enabled };
		            }
		            {
		                const af0 = (cfg?.phase0?.answerFill && typeof cfg.phase0.answerFill === 'object') ? cfg.phase0.answerFill : {};
		                const inferredTokens = (base?.phase1?.chunkTokens1b ?? base?.phase1?.chunkTokens ?? DEFAULT_CHUNK_TOKENS);
		                base.phase0.answerFill = {
		                    enabled: !!(af0?.enabled ?? false),
		                    // migrate legacy chunkTokens -> fillChunkTokens
		                    fillChunkTokens: Number.isFinite(af0?.fillChunkTokens)
		                        ? af0.fillChunkTokens
		                        : (Number.isFinite(af0?.chunkTokens) ? af0.chunkTokens : inferredTokens),
		                    typeGuideMaxChars: __clampInt(af0?.typeGuideMaxChars ?? base?.phase0?.answerFill?.typeGuideMaxChars ?? 12000, { min: 200, max: 200000, fallback: 12000 }),
		                    includeTypeGuide: (typeof af0?.includeTypeGuide === 'boolean') ? af0.includeTypeGuide : true,
		                    fillAnswers: (typeof af0?.fillAnswers === 'boolean') ? af0.fillAnswers : true,
		                    fillExplanations: (typeof af0?.fillExplanations === 'boolean') ? af0.fillExplanations : true,
		                    overwriteAnswers: !!(af0?.overwriteAnswers ?? false),
		                    overwriteExplanations: !!(af0?.overwriteExplanations ?? false),
		                    useDuckDuckGo: !!(af0?.useDuckDuckGo ?? false),
		                };
		            }

            // --- phase1 ---
            if (Number.isFinite(cfg?.phase1?.chunkTokens)) base.phase1.chunkTokens = cfg.phase1.chunkTokens;
            if (Number.isFinite(cfg?.phase1?.chunkTokens1b)) base.phase1.chunkTokens1b = cfg.phase1.chunkTokens1b;
            // Backward-compat: if chunkTokens1b is missing, default to the Phase 1A chunk tokens.
            if (!Number.isFinite(base.phase1.chunkTokens1b)) base.phase1.chunkTokens1b = base.phase1.chunkTokens;
            // Phase1 subgrouping (experimental)
            base.phase1.subgrouping = {
                enabled: !!(cfg?.phase1?.subgrouping?.enabled ?? false),
                chunkTokens: Number.isFinite(cfg?.phase1?.subgrouping?.chunkTokens)
                    ? cfg.phase1.subgrouping.chunkTokens
                    : base.phase1.chunkTokens1b,
            };
            const p1Arch = String(cfg?.phase1?.archId || '').trim();
            if (PHASE1_ARCH_DEFINITIONS.some(d => d?.id === p1Arch)) base.phase1.archId = p1Arch;
            else base.phase1.archId = (cfg?.phase1?.enableEvaluator === false) ? 'p1_no_eval' : 'p1_default';
            __applyPhase1Arch(base);

            // --- phase2 ---
            if (typeof cfg?.phase2?.maxModules !== 'undefined') base.phase2.maxModules = cfg.phase2.maxModules;
            if (cfg?.phase2?.singleType && typeof cfg.phase2.singleType === 'object') {
                base.phase2.singleType.enabled = !!cfg.phase2.singleType.enabled;
                base.phase2.singleType.query = String(cfg.phase2.singleType.query || '');
            }
            if (typeof cfg?.phase2?.auditorLoopMode !== 'undefined') base.phase2.auditorLoopMode = cfg.phase2.auditorLoopMode;
            if (typeof cfg?.phase2?.auditorMaxCycles !== 'undefined') base.phase2.auditorMaxCycles = cfg.phase2.auditorMaxCycles;
                if (cfg?.phase2?.coverage && typeof cfg.phase2.coverage === 'object') {
                    if (typeof cfg.phase2.coverage.maxTokens !== 'undefined') {
                        base.phase2.coverage.maxTokens = __clampInt(cfg.phase2.coverage.maxTokens, { min: 100, max: 1000000, fallback: base.phase2.coverage.maxTokens });
                    }
                    if (typeof cfg.phase2.coverage.maxRounds !== 'undefined') {
                    base.phase2.coverage.maxRounds = __clampInt(cfg.phase2.coverage.maxRounds, { min: 0, max: 99, fallback: base.phase2.coverage.maxRounds });
                }
                if (typeof cfg.phase2.coverage.patcherMode !== 'undefined') base.phase2.coverage.patcherMode = cfg.phase2.coverage.patcherMode;
                if (typeof cfg.phase2.coverage.verifierOutput !== 'undefined') base.phase2.coverage.verifierOutput = cfg.phase2.coverage.verifierOutput;
                if (typeof cfg.phase2.coverage.verifierMaxTries !== 'undefined') {
                    base.phase2.coverage.verifierMaxTries = __clampInt(cfg.phase2.coverage.verifierMaxTries, { min: 0, max: 99, fallback: base.phase2.coverage.verifierMaxTries });
                }
                if (typeof cfg.phase2.coverage.finalVerifyMode !== 'undefined') base.phase2.coverage.finalVerifyMode = cfg.phase2.coverage.finalVerifyMode;
                    if (typeof cfg.phase2.coverage.autoAcceptAfterPatchMissingLeq !== 'undefined') {
                        base.phase2.coverage.autoAcceptAfterPatchMissingLeq = __clampInt(cfg.phase2.coverage.autoAcceptAfterPatchMissingLeq, { min: 0, max: 999, fallback: base.phase2.coverage.autoAcceptAfterPatchMissingLeq ?? 0 });
                    }
                    if (typeof cfg.phase2.coverage.overflowMode !== 'undefined') {
                        const m = String(cfg.phase2.coverage.overflowMode || '').trim();
                        base.phase2.coverage.overflowMode = m || base.phase2.coverage.overflowMode || 'guide_merge';
                    }
                    if (typeof cfg.phase2.coverage.overflowThreshold !== 'undefined') {
                        base.phase2.coverage.overflowThreshold = __clampInt(cfg.phase2.coverage.overflowThreshold, { min: 1, max: 10, fallback: base.phase2.coverage.overflowThreshold ?? 2 });
                    }
                }

            const p2Arch = String(cfg?.phase2?.archId || '').trim();
            if (PHASE2_ARCH_DEFINITIONS.some(d => d?.id === p2Arch)) {
                base.phase2.archId = p2Arch;
            } else {
                const ea = cfg?.phase2?.enableAuditor;
                const ec = cfg?.phase2?.enableCoverage;
                const mode = String(cfg?.phase2?.coverage?.patcherMode || '').toLowerCase();
                if (ea === false && ec === false) base.phase2.archId = 'p2_draft_only';
                else if (ea !== false && ec === false) base.phase2.archId = 'p2_auditor_only';
                else if (ea === false && ec !== false) base.phase2.archId = (mode === 'integrated') ? 'p2_integrated' : 'p2_pass_to_coverage';
                else base.phase2.archId = 'p2_default';
            }
            __applyPhase2Arch(base);

            // --- format ---
            if (typeof cfg?.format?.maxDataEnvelopeTries !== 'undefined') base.format.maxDataEnvelopeTries = cfg.format.maxDataEnvelopeTries;
            if (typeof cfg?.format?.structuredOutputStyle !== 'undefined') base.format.structuredOutputStyle = cfg.format.structuredOutputStyle;
            if (cfg?.format?.structuredOutputStyleByPhase && typeof cfg.format.structuredOutputStyleByPhase === 'object') {
                const src = cfg.format.structuredOutputStyleByPhase || {};
                const norm = (v) => {
                    const s = String(v || '').trim().toLowerCase();
                    if (s === 'rationale_then_structured' || s === 'structured_only' || s === 'inherit') return s;
                    return 'inherit';
                };
                base.format.structuredOutputStyleByPhase = {
                    phase0: norm(src.phase0),
                    phase1a: norm(src.phase1a),
                    phase1b: norm(src.phase1b),
                    phase2: norm(src.phase2),
                };
            }

            return base;
        }

        function getPipelineConfigFromUi() {
            const runPlan = {
                startFrom: __normalizeStartFrom(__getStrFromUi('run-start-from-select', 'continue')),
                stopAfter: __normalizeStopAfter(__getStrFromUi('run-stop-after-select', 'phase3')),
                resetCallCountersOnStart: __getBoolFromUi('reset-call-counters-on-start-input', false),
            };
            const runPhases = __computeRunPhases(runPlan);

            const chunkTokens = __clampInt(__getStrFromUi('chunk-tokens-input', DEFAULT_CHUNK_TOKENS), {
                min: 1000,
                max: 400000,
                fallback: DEFAULT_CHUNK_TOKENS,
            });
            const chunkTokens1b = __clampInt(__getStrFromUi('chunk-tokens-1b-input', chunkTokens), {
                min: 1000,
                max: 400000,
                fallback: chunkTokens,
            });
            const cfg = __deepClone(DEFAULT_PIPELINE_CONFIG);
            cfg.runPlan = runPlan;
            cfg.runPhases = runPhases;

	            cfg.phase0 = {
	                pdfInputMode: __getStrFromUi('phase0-pdf-input-mode-select', 'multimodal') || 'multimodal',
	                multimodalTransport: __getStrFromUi('phase0-multimodal-transport-select', 'images_raw_text') || 'images_raw_text',
	                smartRouter: { enabled: __getBoolFromUi('phase0-smart-router-input', false) },
	                tesseractLang: (__getStrFromUi('tesseract-lang-input', 'kor+eng') || 'kor+eng').trim() || 'kor+eng',
	                experimentalImageCrops: __getBoolFromUi('phase0-image-crops-input', false),
	                answerFill: {
	                    enabled: __getBoolFromUi('phase0-answer-fill-input', false),
	                    fillChunkTokens: __clampInt(__getStrFromUi('answer-fill-chunk-tokens-input', chunkTokens1b), {
	                        min: 1000,
	                        max: 400000,
	                        fallback: chunkTokens1b,
	                    }),
	                    typeGuideMaxChars: __clampInt(__getStrFromUi('phase0-answer-fill-type-guide-max-chars-input', 12000), { min: 200, max: 200000, fallback: 12000 }),
	                    includeTypeGuide: __getBoolFromUi('phase0-answer-fill-include-type-guide-input', true),
	                    fillAnswers: __getBoolFromUi('phase0-answer-fill-fill-answers-input', true),
	                    fillExplanations: __getBoolFromUi('phase0-answer-fill-fill-explanations-input', true),
	                    overwriteAnswers: __getBoolFromUi('phase0-answer-fill-overwrite-answers-input', false),
	                    overwriteExplanations: __getBoolFromUi('phase0-answer-fill-overwrite-explanations-input', false),
	                    useDuckDuckGo: __getBoolFromUi('answer-fill-duckduckgo-input', false),
	                },
	            };

            cfg.phase1.chunkTokens = chunkTokens;
            cfg.phase1.chunkTokens1b = chunkTokens1b;
            cfg.phase1.subgrouping = {
                enabled: __getBoolFromUi('phase1-subgrouping-input', false),
                chunkTokens: __clampInt(__getStrFromUi('subgrouping-chunk-tokens-input', chunkTokens1b), {
                    min: 1000,
                    max: 400000,
                    fallback: chunkTokens1b,
                }),
            };
            cfg.phase1.chunkMode = (__getStrFromUi('chunk-mode-select', 'file_first') || 'file_first').trim() || 'file_first';
            cfg.phase1.maxTypes = __clampInt(__getStrFromUi('max-types-input', 25), { min: 5, max: 100, fallback: 25 });
            cfg.phase1.archId = (__getStrFromUi('phase1-arch-select', 'p1_coverage_style') || 'p1_coverage_style').trim() || 'p1_coverage_style';

            cfg.phase2.archId = (__getStrFromUi('phase2-arch-select', 'p2_integrated_creator_patch') || 'p2_integrated_creator_patch').trim() || 'p2_integrated_creator_patch';
            const targetMode = (__getStrFromUi('phase2-target-select', 'all') || 'all').toLowerCase();
            const targetQuery = __getStrFromUi('phase2-target-query-input', '');
            cfg.phase2.singleType = {
                enabled: targetMode === 'single',
                query: targetQuery,
            };
            cfg.phase2.maxModules = __clampInt(__getStrFromUi('phase2-max-modules-input', 0), { min: 0, max: 9999, fallback: 0 });
            cfg.phase2.coverage = {
                maxTokens: __clampInt(__getStrFromUi('coverage-max-tokens-input', 100000), { min: 100, max: 1000000, fallback: 100000 }),
                maxRounds: __clampInt(__getStrFromUi('coverage-max-rounds-input', 4), { min: 0, max: 99, fallback: 4 }),
                autoAcceptAfterPatchMissingLeq: __clampInt(__getStrFromUi('coverage-auto-accept-missing-leq-input', 5), { min: 0, max: 999, fallback: 5 }),
                patcherMode: String(cfg?.phase2?.coverage?.patcherMode || 'coverage_only'),
                verifierOutput: (__getStrFromUi('coverage-verifier-output-select', 'missing_only') || 'missing_only').trim() || 'missing_only',
                verifierMaxTries: __clampInt(__getStrFromUi('coverage-verifier-max-tries-input', 0), { min: 0, max: 99, fallback: 0 }),
                finalVerifyMode: (__getStrFromUi('coverage-final-verify-select', 'per_chunk') || 'per_chunk').trim() || 'per_chunk',
                overflowMode: (__getStrFromUi('coverage-overflow-mode-select', 'guide_merge') || 'guide_merge').trim() || 'guide_merge',
                overflowThreshold: __clampInt(__getStrFromUi('coverage-overflow-threshold-input', 2), { min: 1, max: 10, fallback: 2 }),
            };

            const format = {
                maxDataEnvelopeTries: __clampInt(__getStrFromUi('max-data-envelope-tries-input', 0), { min: 0, max: 99, fallback: 0 }),
                structuredOutputStyle: (() => {
                    const v = String(__getStrFromUi('structured-output-style-select', 'rationale_then_structured') || 'rationale_then_structured').trim().toLowerCase();
                    if (v === 'rationale_then_structured' || v === 'structured_only') return v;
                    return 'rationale_then_structured';
                })(),
                structuredOutputStyleByPhase: (() => {
                    const norm = (v) => {
                        const s = String(v || '').trim().toLowerCase();
                        if (s === 'structured_only' || s === 'rationale_then_structured' || s === 'inherit') return s;
                        return 'inherit';
                    };
                    return {
                        phase0: norm(__getStrFromUi('structured-output-phase0-select', 'inherit')),
                        phase1a: norm(__getStrFromUi('structured-output-phase1a-select', 'inherit')),
                        phase1b: norm(__getStrFromUi('structured-output-phase1b-select', 'inherit')),
                        phase2: norm(__getStrFromUi('structured-output-phase2-select', 'inherit')),
                    };
                })(),
            };
            cfg.format = format;

            __applyPhase1Arch(cfg);
            __applyPhase2Arch(cfg);

            return cfg;
        }

        function applyPipelineConfigToUi(cfg) {
            const c = __migratePipelineConfig(cfg);
            try {
                const setVal = (id, v) => { const el = document.getElementById(id); if (el) el.value = String(v ?? ''); };
                const setChk = (id, v) => { const el = document.getElementById(id); if (el) el.checked = !!v; };

                setVal('run-start-from-select', c.runPlan?.startFrom ?? 'continue');
                setVal('run-stop-after-select', c.runPlan?.stopAfter ?? 'phase3');
                setChk('reset-call-counters-on-start-input', c.runPlan?.resetCallCountersOnStart ?? false);

                setVal('chunk-tokens-input', c.phase1?.chunkTokens ?? DEFAULT_CHUNK_TOKENS);
                setVal('chunk-tokens-1b-input', c.phase1?.chunkTokens1b ?? c.phase1?.chunkTokens ?? DEFAULT_CHUNK_TOKENS);
                setChk('phase1-subgrouping-input', c.phase1?.subgrouping?.enabled ?? false);
                setVal('subgrouping-chunk-tokens-input', c.phase1?.subgrouping?.chunkTokens ?? c.phase1?.chunkTokens1b ?? c.phase1?.chunkTokens ?? DEFAULT_CHUNK_TOKENS);
                setVal('chunk-mode-select', c.phase1?.chunkMode ?? 'file_first');
                setVal('max-types-input', c.phase1?.maxTypes ?? 25);
                setVal('phase1-arch-select', c.phase1?.archId ?? 'p1_coverage_style');

                setVal('phase2-arch-select', c.phase2?.archId ?? 'p2_integrated_creator_patch');
                setVal('phase2-target-select', c.phase2?.singleType?.enabled ? 'single' : 'all');
                setVal('phase2-target-query-input', c.phase2?.singleType?.query ?? '');
                setVal('phase2-max-modules-input', c.phase2?.maxModules ?? 0);
                setVal('coverage-max-tokens-input', c.phase2?.coverage?.maxTokens ?? 100000);
                setVal('coverage-max-rounds-input', c.phase2?.coverage?.maxRounds ?? 4);
                setVal('coverage-auto-accept-missing-leq-input', c.phase2?.coverage?.autoAcceptAfterPatchMissingLeq ?? 5);
                setVal('coverage-verifier-output-select', c.phase2?.coverage?.verifierOutput ?? 'missing_only');
                setVal('coverage-verifier-max-tries-input', c.phase2?.coverage?.verifierMaxTries ?? 0);
                setVal('coverage-final-verify-select', c.phase2?.coverage?.finalVerifyMode ?? 'per_chunk');
                setVal('coverage-overflow-mode-select', c.phase2?.coverage?.overflowMode ?? 'guide_merge');
                setVal('coverage-overflow-threshold-input', c.phase2?.coverage?.overflowThreshold ?? 2);

	                setVal('phase0-pdf-input-mode-select', c.phase0?.pdfInputMode ?? 'multimodal');
	                setVal('phase0-multimodal-transport-select', c.phase0?.multimodalTransport ?? 'images_raw_text');
	                setChk('phase0-smart-router-input', c.phase0?.smartRouter?.enabled ?? false);
	                setVal('tesseract-lang-input', c.phase0?.tesseractLang ?? 'kor+eng');
	                setChk('phase0-image-crops-input', c.phase0?.experimentalImageCrops ?? false);
	                setChk('phase0-answer-fill-input', c.phase0?.answerFill?.enabled ?? false);
	                setChk('phase0-answer-fill-fill-answers-input', c.phase0?.answerFill?.fillAnswers ?? true);
	                setChk('phase0-answer-fill-fill-explanations-input', c.phase0?.answerFill?.fillExplanations ?? true);
	                setChk('phase0-answer-fill-overwrite-answers-input', c.phase0?.answerFill?.overwriteAnswers ?? false);
	                setChk('phase0-answer-fill-overwrite-explanations-input', c.phase0?.answerFill?.overwriteExplanations ?? false);
	                setChk('phase0-answer-fill-include-type-guide-input', c.phase0?.answerFill?.includeTypeGuide ?? true);
	                setVal('phase0-answer-fill-type-guide-max-chars-input', c.phase0?.answerFill?.typeGuideMaxChars ?? 12000);
	                setVal('answer-fill-chunk-tokens-input', c.phase0?.answerFill?.fillChunkTokens ?? c.phase0?.answerFill?.chunkTokens ?? c.phase1?.chunkTokens1b ?? c.phase1?.chunkTokens ?? DEFAULT_CHUNK_TOKENS);
	                setChk('answer-fill-duckduckgo-input', c.phase0?.answerFill?.useDuckDuckGo ?? false);

                setVal('max-data-envelope-tries-input', c.format?.maxDataEnvelopeTries ?? 0);
                setVal('structured-output-style-select', c.format?.structuredOutputStyle ?? 'rationale_then_structured');
                const sop = c.format?.structuredOutputStyleByPhase || {};
                setVal('structured-output-phase0-select', sop?.phase0 ?? 'inherit');
                setVal('structured-output-phase1a-select', sop?.phase1a ?? 'inherit');
                setVal('structured-output-phase1b-select', sop?.phase1b ?? 'inherit');
                setVal('structured-output-phase2-select', sop?.phase2 ?? 'inherit');

                const wrap = document.getElementById('phase2-target-query-wrap');
                if (wrap) wrap.style.display = (c.phase2?.singleType?.enabled ? 'block' : 'none');
            } catch { }
        }

        function loadPipelineConfigFromStorage() {
            const raw = (() => { try { return localStorage.getItem(EXP_CONFIG_STORAGE_KEY); } catch { return null; } })();
            const parsed = __safeJsonParse(raw);
            if (parsed && typeof parsed === 'object') applyPipelineConfigToUi(parsed);
        }

        function savePipelineConfigToStorage() {
            try {
                const cfg = getPipelineConfigFromUi();
                localStorage.setItem(EXP_CONFIG_STORAGE_KEY, JSON.stringify(cfg));
            } catch { }
        }

        function getPipelineConfig(ap = activeProcess) {
            const cfg = ap?.pipelineConfig;
            if (cfg && typeof cfg === 'object') return cfg;
            return getPipelineConfigFromUi();
        }

        function applyPipelineConfigToActiveProcess(cfg, ap = activeProcess) {
            if (!ap || typeof ap !== 'object') return;
            const prevCfg = ap.pipelineConfig && typeof ap.pipelineConfig === 'object' ? ap.pipelineConfig : null;
            const prevCoverageMaxTokens = Number.isFinite(prevCfg?.phase2?.coverage?.maxTokens) ? prevCfg.phase2.coverage.maxTokens : null;
            ap.pipelineConfig = cfg && typeof cfg === 'object' ? cfg : getPipelineConfigFromUi();
            const nextCoverageMaxTokens = Number.isFinite(ap.pipelineConfig?.phase2?.coverage?.maxTokens) ? ap.pipelineConfig.phase2.coverage.maxTokens : null;
            if (Number.isFinite(prevCoverageMaxTokens) && Number.isFinite(nextCoverageMaxTokens) && prevCoverageMaxTokens !== nextCoverageMaxTokens) {
                try {
                    logger.warn("ì„¤ì •", `ì»¤ë²„ë¦¬ì§€ maxTokensê°€ ${prevCoverageMaxTokens} â†’ ${nextCoverageMaxTokens}ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤. ì´í›„ ì»¤ë²„ë¦¬ì§€ ê²€ì¦/íŒ¨ì¹˜ëŠ” ìƒˆ ê°’ ê¸°ì¤€ìœ¼ë¡œ ìë™ ë¶„í• ë©ë‹ˆë‹¤.`);
                } catch { }
            }

            // Sync chunk sizes into canonical fields (Phase 1A vs Phase 1B can differ).
            const nextChunkTokens1a = Number.isFinite(ap.pipelineConfig?.phase1?.chunkTokens)
                ? ap.pipelineConfig.phase1.chunkTokens
                : (DEFAULT_CHUNK_TOKENS || 10000);
            const nextChunkTokens1b = Number.isFinite(ap.pipelineConfig?.phase1?.chunkTokens1b)
                ? ap.pipelineConfig.phase1.chunkTokens1b
                : nextChunkTokens1a;

            const prevChunkTokens1a = Number.isFinite(ap.chunkTokens) ? ap.chunkTokens : DEFAULT_CHUNK_TOKENS;
            const prevChunkTokens1b = Number.isFinite(ap.chunkTokensPhase1b) ? ap.chunkTokensPhase1b : prevChunkTokens1a;

            if (prevChunkTokens1a !== nextChunkTokens1a || prevChunkTokens1b !== nextChunkTokens1b) {
                ap.chunkTokens = nextChunkTokens1a;
                ap.chunkTokensPhase1b = nextChunkTokens1b;
                // IMPORTANT: Do NOT auto-wipe classification/modules on resume just because chunk size changed.
                // Chunk size affects batching cost, not the semantic validity of already-produced clusters/modules.
                // If the user wants re-classification under a different chunking, they should use "ì¬ì‹œì‘ ì§€ì : 1ë‹¨ê³„".
                try {
                    const p1 = ap.phase1_patterns || {};
                    const hasFinalStandard = Array.isArray(p1?.standardCreation?.finalStandard) && p1.standardCreation.finalStandard.length > 0;
                    const hasPerQuestion = Array.isArray(p1?.perQuestion) && p1.perQuestion.length > 0;
                    const hasClusters = Array.isArray(p1?.clusters) && p1.clusters.length > 0;
                    const hasAnyModules = Array.isArray(ap.phase2_modules) && ap.phase2_modules.length > 0;
                    if (hasFinalStandard || hasPerQuestion || hasClusters || hasAnyModules) {
                        try {
                            logger.warn(
                                "ì„¤ì •",
                                `ì²­í¬ í† í° ë³€ê²½: 1A ${prevChunkTokens1a} â†’ ${nextChunkTokens1a}, 1B ${prevChunkTokens1b} â†’ ${nextChunkTokens1b}. ê¸°ì¡´ ê²°ê³¼(ìœ í˜•ë¶„ë¥˜/ëª¨ë“ˆ)ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤. ë‹¤ì‹œ ê³„ì‚°í•˜ë ¤ë©´ â€˜ì¬ì‹œì‘ ì§€ì â€™ì„ 1ë‹¨ê³„ë¡œ ì„¤ì •í•˜ì„¸ìš”.`
                            );
                        } catch { }
                    } else {
                        // No meaningful downstream results yet â†’ safe to clear partial Phase 1 scaffolding
                        try {
                            if (ap.phase1_patterns?.standardCreation) {
                                ap.phase1_patterns.standardCreation.status = 'pending';
                                ap.phase1_patterns.standardCreation.perChunk = [];
                                ap.phase1_patterns.standardCreation.finalStandard = null;
                            }
                            if (Array.isArray(ap.phase1_patterns?.perQuestion)) ap.phase1_patterns.perQuestion = [];
                            if (Array.isArray(ap.phase1_patterns?.clusters)) ap.phase1_patterns.clusters = [];
                            if (ap.phase1_patterns) ap.phase1_patterns.status = 'pending';
                        } catch { }
                        try { ap.phase2_modules = []; } catch { }
                        try { ap.phase3_finalManual = { status: 'pending', content: null, error: null }; } catch { }
                    }
                } catch { }
            }
            // Sync current coverage options to any PENDING/ERROR modules so they pick up new UI settings
            try {
                if (Array.isArray(ap.phase2_modules)) {
                    const newCov = ap.pipelineConfig?.phase2?.coverage || {};
                    // We only update if the module is not yet completed
                    ap.phase2_modules.forEach(m => {
                        if (m && (m.status === 'pending' || m.status === 'error' || m.status === 'processing')) {
                            // Ensure coverageOpts object exists
                            if (!m.coverageOpts) m.coverageOpts = {};

                            // 1. Update maxRounds if valid
                            if (typeof newCov.maxRounds === 'number') m.coverageOpts.maxRounds = newCov.maxRounds;

                            // 2. Update maxTokens if valid
                            if (typeof newCov.maxTokens === 'number') m.coverageOpts.maxTokens = newCov.maxTokens;

                            // 3. Update related flags
                            if (newCov.verifierOutput) m.coverageOpts.verifierOutput = newCov.verifierOutput;
                            if (typeof newCov.verifierMaxTries === 'number') m.coverageOpts.verifierMaxTries = newCov.verifierMaxTries;
                            if (newCov.finalVerifyMode) m.coverageOpts.finalVerifyMode = newCov.finalVerifyMode;
                            if (typeof newCov.autoAcceptAfterPatchMissingLeq === 'number') m.coverageOpts.autoAcceptAfterPatchMissingLeq = newCov.autoAcceptAfterPatchMissingLeq;
                            if (newCov.overflowMode) m.coverageOpts.overflowMode = newCov.overflowMode;
                            if (typeof newCov.overflowThreshold === 'number') m.coverageOpts.overflowThreshold = newCov.overflowThreshold;
                        }
                    });
                }
            } catch (_) { }

        }

        function __makeTypeMatcher(query) {
            const q = String(query || '').trim();
            if (!q) return null;
            if (q.startsWith('/') && q.lastIndexOf('/') > 0) {
                const last = q.lastIndexOf('/');
                const body = q.slice(1, last);
                const flags = q.slice(last + 1) || 'i';
                try {
                    const re = new RegExp(body, flags);
                    return (name) => re.test(String(name || ''));
                } catch {
                    // fallthrough to substring match
                }
            }
            const needle = q.toLowerCase();
            return (name) => String(name || '').toLowerCase().includes(needle);
        }

        function resetProcessFromPhase(ap, fromPhase, cfg) {
            if (!ap || typeof ap !== 'object') return;
            const from = String(fromPhase || 'none').toLowerCase();
            const pCfg = (cfg && typeof cfg === 'object') ? cfg : getPipelineConfig(ap);

            try { ap.error = null; } catch { }

            const resetPhase1 = () => {
                ap.phase1_patterns = {
                    status: 'pending',
                    standardCreation: { status: 'pending', perChunk: [], finalStandard: null },
                    perQuestion: [],
                    clusters: [],
                    error: null
                };
                ap.phase2_modules = [];
                ap.typeOrdering = { status: 'pending', order: null, error: null };
                ap.phase3_finalManual = { status: 'pending', content: null, error: null };
            };

            const resetPhase2 = () => {
                // Ensure module list exists (build from clusters if needed)
                if (!Array.isArray(ap.phase2_modules) || ap.phase2_modules.length === 0) {
                    const clusters = ap.phase1_patterns?.clusters || [];
                    if (clusters.length) {
                        ap.phase2_modules = clusters.map(cl => ({
                            pattern_name: cl.pattern_name,
                            parent_pattern_name: cl.parent_pattern_name || null,
                            status: 'pending',
                            qidsCovered: (cl.qids || []).slice(),
                        }));
                    } else {
                        ap.phase2_modules = [];
                    }
                }

                // Reset all modules (experiments can still limit execution via single-type / maxModules)
                (ap.phase2_modules || []).forEach(m => {
                    if (!m || typeof m !== 'object') return;
                    m.status = 'pending';
                    m.error = null;
                    m.standardProblem = null;
                    m.explanation = null;
                    m.refinementCycles = [];
                    m.events = [];
                    m.coverage = null;
                });
                ap.typeOrdering = { status: 'pending', order: null, error: null };
                ap.phase3_finalManual = { status: 'pending', content: null, error: null };
            };

            const resetPhase3 = () => {
                ap.phase3_finalManual = { status: 'pending', content: null, error: null };
            };

            const resetPhase0 = () => {
                // Reset extraction while keeping examPapers cache.
                if (Array.isArray(ap.phase0_extract)) {
                    ap.phase0_extract.forEach(s => {
                        if (!s || typeof s !== 'object') return;
                        s.status = 'pending';
                        s.error = null;
                        s.qasByQid = null;
                        if (Array.isArray(s.parts)) {
                            s.parts.forEach(p => {
                                if (!p || typeof p !== 'object') return;
                                p.status = 'pending';
                                p.error = null;
                                p.qasByQid = null;
                            });
                        }
                    });
                }
                resetPhase1();
            };

            if (from === 'phase0') resetPhase0();
            else if (from === 'phase1') resetPhase1();
            else if (from === 'phase2') resetPhase2();
            else if (from === 'phase3') resetPhase3();

            // Keep config synced (chunk tokens etc.)
            try { applyPipelineConfigToActiveProcess(pCfg, ap); } catch { }
        }

        class Logger {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.entries = []; // { tsIso, tsUi, level, context, message, messageFull, sessionId }
                this.uiMaxLines = 300;
                this.uiMaxChars = 800;
                this.storeMaxEntries = 5000;
                // Keep full text for downloads/debugging; only truncate at extremely large sizes.
                this.storeMaxChars = 20000000;
                this.uiStartIndex = 0; // "Clear UI" hides older entries without deleting history
                this.sessions = []; // [{ id, startedAt, label }]
                this.activeSessionId = null;
                this.filters = { type: 'all', phase: 'all', query: '', session: 'current' };
                this.startNewSession({ reason: 'init' });
            }
            getSessions() { return Array.isArray(this.sessions) ? this.sessions.slice() : []; }
            getActiveSessionId() { return this.activeSessionId; }
            startNewSession({ reason = '', label = '' } = {}) {
                const ts = Date.now();
                const idx = (Array.isArray(this.sessions) ? this.sessions.length : 0) + 1;
                const id = `S${idx}_${ts.toString(36)}`;
                const time = (() => { try { return new Date(ts).toLocaleTimeString('en-US', { hour12: false }); } catch { return ''; } })();
                const autoLabel = `${time}${reason ? ` Â· ${reason}` : ''}`.trim();
                const sess = { id, startedAt: ts, label: String(label || autoLabel || id) };
                this.sessions.push(sess);
                this.activeSessionId = id;
                try { window.__refreshLogSessionSelect?.(); } catch { }
                return id;
            }
            setActiveSession(id) {
                const sid = String(id || '').trim();
                if (!sid) return;
                this.activeSessionId = sid;
                try { window.__refreshLogSessionSelect?.(); } catch { }
                this.renderUi();
            }
            setUiLimits({ maxLines, maxChars } = {}) {
                const ml = parseInt(maxLines, 10);
                const mc = parseInt(maxChars, 10);
                if (Number.isFinite(ml) && ml >= 50) this.uiMaxLines = Math.min(5000, ml);
                if (Number.isFinite(mc) && mc >= 80) this.uiMaxChars = Math.min(50000, mc);
                this.renderUi();
            }
            getEntries() { return Array.isArray(this.entries) ? this.entries.slice() : []; }
            getUiStartIndex() { return Number.isFinite(this.uiStartIndex) ? this.uiStartIndex : 0; }
            setFilters({ type, phase, query, session } = {}) {
                if (type != null) this.filters.type = String(type || 'all');
                if (phase != null) this.filters.phase = String(phase || 'all');
                if (query != null) this.filters.query = String(query || '');
                if (session != null) this.filters.session = String(session || 'current');
                this.renderUi();
            }
            exportState() {
                return {
                    version: 2,
                    sessions: Array.isArray(this.sessions) ? this.sessions : [],
                    activeSessionId: this.activeSessionId || null,
                    entries: Array.isArray(this.entries) ? this.entries : [],
                    uiStartIndex: Number.isFinite(this.uiStartIndex) ? this.uiStartIndex : 0,
                };
            }
            importState(obj) {
                if (!obj || typeof obj !== 'object') return;
                const ver = Number.isFinite(obj.version) ? obj.version : 1;
                const sessions = Array.isArray(obj.sessions) ? obj.sessions : [];
                const entries = Array.isArray(obj.entries) ? obj.entries : [];
                this.sessions = sessions
                    .filter(s => s && typeof s === 'object')
                    .map(s => ({
                        id: String(s.id || ''),
                        startedAt: Number.isFinite(s.startedAt) ? s.startedAt : Date.now(),
                        label: String(s.label || s.id || ''),
                    }))
                    .filter(s => s.id);
                if (!this.sessions.length) {
                    // Backward-compat: synthesize one session.
                    const sid = `S1_${Date.now().toString(36)}`;
                    this.sessions = [{ id: sid, startedAt: Date.now(), label: 'legacy' }];
                    this.activeSessionId = sid;
                } else {
                    this.activeSessionId = String(obj.activeSessionId || this.sessions[this.sessions.length - 1].id || '');
                    if (!this.activeSessionId) this.activeSessionId = this.sessions[this.sessions.length - 1].id;
                }
                this.entries = entries
                    .filter(e => e && typeof e === 'object')
                    .map(e => {
                        const msgFull = String(e.messageFull ?? e.message ?? '');
                        return {
                            tsIso: String(e.tsIso || new Date().toISOString()),
                            tsUi: String(e.tsUi || ''),
                            level: String(e.level || 'INFO'),
                            context: String(e.context || ''),
                            messageFull: msgFull,
                            message: String(e.message ?? msgFull),
                            sessionId: String(e.sessionId || ''),
                        };
                    });
                // Backward compat: if old entries lack sessionId, pin them to the first session.
                const fallbackSid = this.sessions[0]?.id || this.activeSessionId;
                this.entries.forEach(e => { if (!e.sessionId) e.sessionId = fallbackSid; });
                const idx = Number.isFinite(obj.uiStartIndex) ? obj.uiStartIndex : 0;
                this.uiStartIndex = Math.max(0, Math.min(this.entries.length, idx));
                this._trimStored();
                try { window.__refreshLogSessionSelect?.(); } catch { }
                this.renderUi();
            }
            deleteEntriesFromPhase(fromPhase) {
                const from = String(fromPhase || '').toLowerCase();
                const fromIdx = Object.prototype.hasOwnProperty.call(__PHASE_INDEX, from) ? __PHASE_INDEX[from] : null;
                if (fromIdx == null) return;
                const keep = [];
                for (const e of (this.entries || [])) {
                    const p = __inferLogPhase(e?.context || '');
                    const idx = Object.prototype.hasOwnProperty.call(__PHASE_INDEX, p) ? __PHASE_INDEX[p] : 999;
                    if (idx < fromIdx) keep.push(e);
                }
                this.entries = keep;
                this.uiStartIndex = Math.max(0, Math.min(this.entries.length, this.uiStartIndex || 0));
                this.renderUi();
            }
            clearUi() {
                this.uiStartIndex = Array.isArray(this.entries) ? this.entries.length : 0;
                if (this.container) this.container.innerHTML = '';
            }
            clear() {
                this.entries = [];
                this.uiStartIndex = 0;
                this.sessions = [];
                this.activeSessionId = null;
                try { this.startNewSession({ reason: 'init' }); } catch { }
                if (this.container) this.container.innerHTML = '';
            }
            _truncateForStore(message) {
                const raw = String(message ?? '');
                const limit = Math.max(200, Number.isFinite(this.storeMaxChars) ? this.storeMaxChars : 50000);
                if (raw.length <= limit) return raw;
                return `${raw.slice(0, limit)} â€¦ [truncated in storage; total ${raw.length} chars]`;
            }
            _trimStored() {
                const max = Math.max(200, Number.isFinite(this.storeMaxEntries) ? this.storeMaxEntries : 5000);
                if (this.entries.length <= max) return;
                const removeN = this.entries.length - max;
                this.entries.splice(0, removeN);
                const uiStart = Number.isFinite(this.uiStartIndex) ? this.uiStartIndex : 0;
                this.uiStartIndex = Math.max(0, uiStart - removeN);
            }
            _truncateForUi(message) {
                const raw = String(message ?? '');
                const limit = Math.max(80, Number.isFinite(this.uiMaxChars) ? this.uiMaxChars : 800);
                if (raw.length <= limit) return raw;
                return `${raw.slice(0, limit)} â€¦ [truncated in UI]`;
            }
            _entryMatchesFilters(entry) {
                const type = String(this.filters?.type || 'all');
                const session = String(this.filters?.session || 'current');
                const phase = String(this.filters?.phase || 'all');
                const query = String(this.filters?.query || '').trim().toLowerCase();

                const level = String(entry?.level || '').toUpperCase();
                const context = String(entry?.context || '');
                const msg = String(entry?.messageFull ?? entry?.message ?? '');
                const sessionId = String(entry?.sessionId || '');

                if (session === 'current') {
                    if (this.activeSessionId && sessionId !== this.activeSessionId) return false;
                } else if (session !== 'all') {
                    if (sessionId !== session) return false;
                }

                if (type === 'api_input' && !msg.startsWith('API Input (payload):')) return false;
                if (type === 'api_output' && !msg.startsWith('API Raw Output:')) return false;
                if (type === 'errors' && !(level === 'WARN' || level === 'ERROR')) return false;
                if (type === 'errors_no_api_http') {
                    if (!(level === 'WARN' || level === 'ERROR')) return false;
                    const m = msg.match(/(?:HTTP\s*|httpStatus=)(\d{3})/i);
                    const st = m ? parseInt(m[1], 10) : null;
                    const isNoisyApiHttp = Number.isFinite(st) && (st === 429 || (st >= 500 && st < 600));
                    if (isNoisyApiHttp) return false;
                }

                if (phase && phase !== 'all') {
                    const p = (() => {
                        try { return __inferLogPhase(context); } catch { return 'other'; }
                    })();
                    if (p !== phase) return false;
                }

                if (query) {
                    const ctxL = context.toLowerCase();
                    const msgL = msg.toLowerCase();
                    if (!ctxL.includes(query) && !msgL.includes(query)) return false;
                }

                return true;
            }
            _appendLine(entry) {
                if (!this.container) return;
                const uiMessage = this._truncateForUi(entry?.messageFull ?? entry?.message ?? '');
                const line = document.createElement('div');
                line.className = 'log-line';
                line.innerHTML =
                    `<span class="log-timestamp">${this.escapeHtml(entry.tsUi)}</span>` +
                    `<span class="log-level ${this.escapeHtml(entry.level)}">${this.escapeHtml(entry.level)}</span>` +
                    `<span class="log-context">[${this.escapeHtml(entry.context)}]</span>` +
                    `<span class="log-content">${this.escapeHtml(uiMessage)}</span>`;
                this.container.appendChild(line);

                const limit = Math.max(50, Number.isFinite(this.uiMaxLines) ? this.uiMaxLines : 300);
                while (this.container.children.length > limit) {
                    this.container.removeChild(this.container.firstChild);
                }
                this.container.scrollTop = this.container.scrollHeight;
            }
            renderUi() {
                if (!this.container) return;
                const start = Math.max(0, Number.isFinite(this.uiStartIndex) ? this.uiStartIndex : 0);
                const limit = Math.max(50, Number.isFinite(this.uiMaxLines) ? this.uiMaxLines : 300);

                const picked = [];
                for (let i = this.entries.length - 1; i >= start && picked.length < limit; i--) {
                    const e = this.entries[i];
                    if (this._entryMatchesFilters(e)) picked.push(e);
                }
                picked.reverse();

                this.container.innerHTML = '';
                picked.forEach(e => this._appendLine(e));
            }
            importEntries(entries, { uiStartIndex } = {}) {
                const arr = Array.isArray(entries) ? entries : [];
                this.entries = arr
                    .filter(e => e && typeof e === 'object')
                    .map(e => {
                        const msgFull = String(e.messageFull ?? e.message ?? '');
                        return ({
                            tsIso: String(e.tsIso || new Date().toISOString()),
                            tsUi: String(e.tsUi || ''),
                            level: String(e.level || 'INFO'),
                            context: String(e.context || ''),
                            messageFull: msgFull,
                            message: String(e.message ?? msgFull),
                            sessionId: String(e.sessionId || ''),
                        });
                    });
                if (!this.sessions.length) {
                    const sid = `S1_${Date.now().toString(36)}`;
                    this.sessions = [{ id: sid, startedAt: Date.now(), label: 'legacy' }];
                    this.activeSessionId = sid;
                }
                const fallbackSid = this.sessions[0]?.id || this.activeSessionId;
                this.entries.forEach(e => { if (!e.sessionId) e.sessionId = fallbackSid; });
                const idx = Number.isFinite(uiStartIndex) ? uiStartIndex : 0;
                this.uiStartIndex = Math.max(0, Math.min(this.entries.length, idx));
                this.renderUi();
            }
            _log(level, context, message) {
                const ts = new Date();
                const tsUi = ts.toLocaleTimeString('en-US', { hour12: false });
                const fullMessage = String(message ?? '');
                const storedMessage = this._truncateForStore(fullMessage);
                const entry = {
                    tsIso: ts.toISOString(),
                    tsUi,
                    level,
                    context: String(context ?? ''),
                    message: storedMessage,
                    messageFull: fullMessage,
                    sessionId: this.activeSessionId || '',
                };
                this.entries.push(entry);
                this._trimStored();
                const idx = this.entries.length - 1;
                if (idx < (Number.isFinite(this.uiStartIndex) ? this.uiStartIndex : 0)) return;
                if (!this._entryMatchesFilters(entry)) return;
                this._appendLine(entry);
            }
            escapeHtml(unsafe) {
                return String(unsafe)
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }
            info(context, message) { this._log('INFO', context, message); }
            warn(context, message) { this._log('WARN', context, message); }
            error(context, message) { this._log('ERROR', context, message); }
            success(context, message) { this._log('SUCCESS', context, message); }
        }
        const logger = new Logger('logs-container');

        // --- Structured-output (format) error collector: raw request/response for debugging ---
        const __formatErrors = (() => {
            const DEFAULT_MAX_ENTRIES = 120;
            const state = {
                version: 2,
                maxEntries: DEFAULT_MAX_ENTRIES,
                nextId: 1,
                entries: [],
            };

            const __now = () => Date.now();
            const __fmtTime = (ts) => { try { return new Date(ts).toLocaleTimeString('en-US', { hour12: false }); } catch { return ''; } };
            const __clipUi = (s, maxChars) => {
                const str = String(s ?? '');
                const n = Math.max(200, Number(maxChars) || 0);
                if (str.length <= n) return str;
                return str.slice(0, n) + `\nâ€¦ [truncated in UI; total ${str.length} chars]`;
            };

            const __textContent = (content) => {
                if (typeof content === 'string') return content;
                if (Array.isArray(content)) {
                    try {
                        return content
                            .map(p => (p && typeof p === 'object' && p.type === 'text') ? (p.text || '') : '')
                            .join('');
                    } catch { return ''; }
                }
                return content == null ? '' : String(content);
            };

            const __escapeRegex = (s) => String(s || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            const __lineColAt = (text, idx) => {
                const s = String(text || '');
                const i = Math.max(0, Math.min(s.length, Number(idx) || 0));
                const before = s.slice(0, i);
                const line = before.split('\n').length;
                const lastNl = before.lastIndexOf('\n');
                const col = i - (lastNl >= 0 ? lastNl + 1 : 0) + 1;
                return { line, col };
            };

            const __findFocusIndex = (text, errorMsg) => {
                const raw = String(text || '');
                const err = String(errorMsg || '');
                if (!raw) return 0;

                // Unbalanced tag: try to focus near the last likely offending tag.
                {
                    const m = err.match(/Unbalanced tags for <([^>]+)>/i);
                    const name = m ? String(m[1] || '').trim() : '';
                    if (name) {
                        const tag = __escapeRegex(name);
                        const openRe = new RegExp(`<\\s*${tag}\\b[^>]*>`, 'ig');
                        const closeRe = new RegExp(`<\\s*\\/\\s*${tag}\\s*>`, 'ig');
                        const opens = [...raw.matchAll(openRe)];
                        const closes = [...raw.matchAll(closeRe)];
                        if (opens.length !== closes.length) {
                            if (opens.length > closes.length && opens.length) return opens[opens.length - 1].index ?? 0;
                            if (closes.length > opens.length && closes.length) return closes[closes.length - 1].index ?? 0;
                        }
                    }
                }

                // Tags outside <data>
                if (err.toLowerCase().includes('outside <data>')) {
                    const m = raw.match(/<\s*data\s*>/i);
                    const n = raw.match(/<\s*\/\s*data\s*>/i);
                    if (m && n && Number.isFinite(m.index) && Number.isFinite(n.index)) {
                        const start = m.index;
                        const end = n.index + n[0].length;
                        const outsideBefore = raw.slice(0, start);
                        const outsideAfter = raw.slice(end);
                        const tagOutsideRe = /<\s*\/?\s*[a-zA-Z][^>]*>/g;
                        const bm = tagOutsideRe.exec(outsideBefore);
                        if (bm && Number.isFinite(bm.index)) return bm.index;
                        const am = tagOutsideRe.exec(outsideAfter);
                        if (am && Number.isFinite(am.index)) return end + am.index;
                    }
                }

                // Prefer focusing on <data> if present.
                const dataIdx = raw.search(/<\s*data\s*>/i);
                if (dataIdx >= 0) return dataIdx;
                return 0;
            };

            const __makeResponseSnippet = (text, errorMsg, { radius = 900 } = {}) => {
                const raw = String(text || '');
                const err = String(errorMsg || '');
                if (!raw) return '';

                const focus = __findFocusIndex(raw, err);
                const start = Math.max(0, focus - Math.max(200, radius));
                const end = Math.min(raw.length, focus + Math.max(200, radius));
                const head = (start > 0) ? `â€¦ [snip; start=${start}] â€¦\n` : '';
                const tail = (end < raw.length) ? `\nâ€¦ [snip; end=${end}; total=${raw.length}] â€¦` : '';
                const slice = raw.slice(start, end);
                const caret = Math.max(0, Math.min(slice.length, focus - start));
                const marked = slice.slice(0, caret) + '<<<FOCUS>>>' + slice.slice(caret);
                const lc = __lineColAt(raw, focus);
                const metaLine = `FOCUS: index=${focus}/${raw.length} (line ${lc.line}, col ${lc.col})`;
                return `${metaLine}\n${head}${marked}${tail}`;
            };

            const __summarizePayload = (payload) => {
                const p = (payload && typeof payload === 'object') ? payload : {};
                const msgs = Array.isArray(p.messages) ? p.messages : [];
                const outMsgs = msgs.map((m, idx) => {
                    const role = String(m?.role || '');
                    const raw = __textContent(m?.content);
                    return {
                        idx,
                        role,
                        content: raw, // full text (download needs full)
                        contentChars: raw.length,
                    };
                });
                return {
                    model: p.model ?? null,
                    temperature: Number.isFinite(p.temperature) ? p.temperature : null,
                    top_p: Number.isFinite(p.top_p) ? p.top_p : null,
                    top_k: Number.isFinite(p.top_k) ? p.top_k : null,
                    max_tokens: Number.isFinite(p.max_tokens) ? p.max_tokens : null,
                    messages: outMsgs,
                };
            };

            const __trim = () => {
                const max = Number.isFinite(state.maxEntries) ? state.maxEntries : DEFAULT_MAX_ENTRIES;
                if (state.entries.length <= max) return;
                state.entries.splice(0, state.entries.length - max);
            };

            function add(entry) {
                try { __callStats.recordFormatError({ context: entry?.context }); } catch { }
                try {
                    const base = (entry && typeof entry === 'object') ? entry : {};
                    const ts = Number.isFinite(base.ts) ? base.ts : __now();
                    const e = {
                        id: state.nextId++,
                        ts,
                        tsIso: new Date(ts).toISOString(),
                        context: String(base.context || ''),
                        kind: String(base.kind || 'unknown'),
                        stage: String(base.stage || ''),
                        attempt: Number.isFinite(base.attempt) ? base.attempt : null,
                        error: String(base.error || ''),
                        request: base.request ? __summarizePayload(base.request) : null,
                        responseRaw: String(base.responseRaw ?? base.response ?? ''), // full text (download needs full)
                        responseChars: String(base.responseRaw ?? base.response ?? '').length,
                        responseSnippet: __makeResponseSnippet(String(base.responseRaw ?? base.response ?? ''), String(base.error || '')),
                        meta: (base.meta && typeof base.meta === 'object') ? base.meta : null,
                    };
                    state.entries.push(e);
                    __trim();
                    render();
                } catch { }
            }

            function clear() {
                state.entries = [];
                state.nextId = 1;
                render();
            }

            function deleteEntriesFromPhase(fromPhase) {
                const from = String(fromPhase || '').toLowerCase();
                const fromIdx = Object.prototype.hasOwnProperty.call(__PHASE_INDEX, from) ? __PHASE_INDEX[from] : null;
                if (fromIdx == null) return;
                state.entries = (state.entries || []).filter(e => {
                    const p = __inferLogPhase(e?.context || '');
                    const idx = Object.prototype.hasOwnProperty.call(__PHASE_INDEX, p) ? __PHASE_INDEX[p] : 999;
                    return idx < fromIdx;
                });
                render();
            }

            function exportState() {
                return {
                    version: state.version,
                    maxEntries: state.maxEntries,
                    nextId: state.nextId,
                    entries: Array.isArray(state.entries) ? state.entries : [],
                };
            }

            function importState(obj) {
                if (!obj || typeof obj !== 'object') return;
                state.maxEntries = Number.isFinite(obj.maxEntries) ? obj.maxEntries : state.maxEntries;
                state.nextId = Number.isFinite(obj.nextId) ? obj.nextId : state.nextId;
                const ver = Number.isFinite(obj.version) ? obj.version : 1;
                state.entries = Array.isArray(obj.entries)
                    ? obj.entries.map(e => {
                        if (!e || typeof e !== 'object') return e;
                        const resp = String(e.responseRaw ?? e.response ?? '');
                        const err = String(e.error || '');
                        const next = { ...e };
                        next.responseRaw = resp;
                        next.responseChars = Number.isFinite(e.responseChars) ? e.responseChars : resp.length;
                        if (!next.responseSnippet || ver < 2) {
                            next.responseSnippet = __makeResponseSnippet(resp, err);
                        }
                        return next;
                    })
                    : [];
                __trim();
                render();
            }

            function render() {
                const outEl = document.getElementById('format-errors-output');
                const sumEl = document.getElementById('format-errors-summary');
                if (sumEl) sumEl.textContent = `${state.entries.length} entries`;
                if (!outEl) return;
                const recent = state.entries.slice(-30);
                const lines = recent.map(e => {
                    const t = __fmtTime(e.ts);
                    const head = `${t}  #${e.id}  ${e.kind}${e.stage ? `/${e.stage}` : ''}${Number.isFinite(e.attempt) ? `  try=${e.attempt}` : ''}  ${e.context}`;
                    const err = e.error ? `ERROR: ${e.error}` : '';
                    const resp = (() => {
                        const raw = String(e.responseRaw || '');
                        if (!raw) return '';
                        const snip = String(e.responseSnippet || __makeResponseSnippet(raw, e.error || ''));
                        const n = Number.isFinite(e.responseChars) ? e.responseChars : raw.length;
                        return `RESPONSE (len=${n}):\n${__clipUi(snip, 12000)}`;
                    })();
                    const req = (() => {
                        const r = e.request;
                        if (!r || !Array.isArray(r.messages)) return '';
                        const m = r.messages.map(mm => {
                            const role = mm?.role || '';
                            const txt = __clipUi(mm?.content || '', 4000);
                            return `- ${role} (${mm?.contentChars ?? 0} chars)\n${txt}`;
                        }).join('\n\n');
                        return `REQUEST:\nmodel=${r.model || ''}\n${m}`;
                    })();
                    return [head, err, req, resp].filter(Boolean).join('\n') + '\n' + '-'.repeat(80);
                });
                outEl.textContent = lines.join('\n');
            }

            function downloadJson() {
                try {
                    const jsonString = JSON.stringify(exportState(), null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    const date = new Date().toISOString().slice(0, 10);
                    a.download = `format_errors_${date}.json`;
                    a.href = url;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch { }
            }

            function initUi() {
                const clearBtn = document.getElementById('format-errors-clear-btn');
                if (clearBtn && clearBtn.dataset.bound !== '1') {
                    clearBtn.dataset.bound = '1';
                    clearBtn.addEventListener('click', () => clear());
                }
                const dlBtn = document.getElementById('format-errors-download-btn');
                if (dlBtn && dlBtn.dataset.bound !== '1') {
                    dlBtn.dataset.bound = '1';
                    dlBtn.addEventListener('click', () => downloadJson());
                }
                render();
            }

            return { add, clear, deleteEntriesFromPhase, exportState, importState, render, initUi, getState: () => state };
        })();

        // helper usable in rendering cards
        function escapeHtmlForInnerHTML(unsafe) {
            if (unsafe === null || unsafe === undefined) return '';
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // --- Call stats (successful API calls only; errors excluded)
        const __callStats = (() => {
            const __dict = () => Object.create(null);
            const __stageOrder = [
                'p0_extract',
                'p1_create_types',
                'p1_eval_types',
                'p1_merge',
                'p1_classify_batch',
                'p1_subgroup',
                'p2_std_problem',
                'p2_explanation',
                'p2_auditor',
                'p2_revise_std_problem',
                'p2_revise_explanation_patch',
                'p2_coverage_verify',
                'p2_coverage_patch',
                'other',
            ];

            const __stageLabelKey = {
                p0_extract: 'callStatsStageP0Extract',
                p1_create_types: 'callStatsStageP1CreateTypes',
                p1_eval_types: 'callStatsStageP1EvalTypes',
                p1_merge: 'callStatsStageP1Merge',
                p1_classify_batch: 'callStatsStageP1ClassifyBatch',
                p1_subgroup: 'callStatsStageP1Subgroup',
                p2_std_problem: 'callStatsStageP2StdProblem',
                p2_explanation: 'callStatsStageP2Explanation',
                p2_auditor: 'callStatsStageP2Auditor',
                p2_revise_std_problem: 'callStatsStageP2ReviseStdProblem',
                p2_revise_explanation_patch: 'callStatsStageP2ReviseExplanationPatch',
                p2_coverage_verify: 'callStatsStageP2CoverageVerify',
                p2_coverage_patch: 'callStatsStageP2CoveragePatch',
                other: 'callStatsStageOther',
            };

            const state = {
                okTotal: 0,
                failTotal: 0,
                formatErrorTotal: 0,
                estTokensTotal: 0,
                actualTokensTotal: 0,
                latencyMsTotal: 0,

                // Session-based stats: sessionId -> count
                okBySession: __dict(),
                failBySession: __dict(),
                formatErrorBySession: __dict(),

                okByPhase: { phase0: 0, phase1: 0, phase2: 0, phase3: 0, other: 0 },
                okByStage: __dict(),
                latencyMsByStage: __dict(),
                okByType: __dict(),
                latencyMsByType: __dict(),
                okByTypeStage: __dict(),
                latencyMsByTypeStage: __dict(),
                okByTypeCycleStage: __dict(),
                lastOkCallAt: null,
            };

            const __inc = (obj, key, n = 1) => {
                if (!key) return;
                const k = String(key);
                const cur = Number.isFinite(obj[k]) ? obj[k] : 0;
                obj[k] = cur + (Number.isFinite(n) ? n : 1);
            };

            const __get = (obj, key) => (key && Number.isFinite(obj[String(key)]) ? obj[String(key)] : 0);

            function __stripXmlSuffix(context) {
                return String(context || '').replace(/-XML(?:Try|Repair)\d+$/i, '');
            }

            function inferStage(context) {
                const base = __stripXmlSuffix(context);
                const c = base.toLowerCase();

                if (c.startsWith('extract-')) return 'p0_extract';
                if (c.startsWith('createtypes')) return 'p1_create_types';
                if (c.startsWith('evaltypes')) return 'p1_eval_types';
                if (c.startsWith('merge-')) return 'p1_merge';
                if (c.startsWith('classifybatch')) return 'p1_classify_batch';
                if (c.startsWith('subgroupbatch')) return 'p1_subgroup';
                if (c.startsWith('subgroupifysavebatch')) return 'p1_subgroup';

                if (/-coverage\d+-w\d+$/i.test(base)) return 'p2_coverage_verify';
                if (/-patch$/i.test(base)) return 'p2_coverage_patch';

                if (/revisestdproblem\d+/i.test(base)) return 'p2_revise_std_problem';
                if (/reviseexplanationpatch\d+/i.test(base)) return 'p2_revise_explanation_patch';
                if (/-feedback\d+/i.test(base)) return 'p2_auditor';
                if (/-stdproblem/i.test(base)) return 'p2_std_problem';
                if (/-explanation/i.test(base)) return 'p2_explanation';

                if (c.startsWith('module-') || c.startsWith('rerun-')) return 'other';
                return 'other';
            }

            function inferPhase(_context, stage) {
                const s = String(stage || '');
                if (s.startsWith('p0_')) return 'phase0';
                if (s.startsWith('p1_')) return 'phase1';
                if (s.startsWith('p2_')) return 'phase2';
                if (s.startsWith('p3_')) return 'phase3';
                return 'other';
            }

            function inferType(context) {
                const base = __stripXmlSuffix(context);
                let m = base.match(/^Module-(.+?)-W\d+/);
                if (m) return m[1];
                if (base.startsWith('Rerun-')) {
                    m = base.match(/^Rerun-(.+?)-(?:StdProblem|Explanation|Feedback\d+|ReviseStdProblem\d+|ReviseExplanationPatch\d+|C\d+-R\d+|Final)/);
                    if (m) return m[1];
                }
                return null;
            }

            function inferCycle(context) {
                const base = __stripXmlSuffix(context);
                const m =
                    base.match(/-Feedback(\d+)/i) ||
                    base.match(/-ReviseStdProblem(\d+)/i) ||
                    base.match(/-ReviseExplanationPatch(\d+)/i);
                if (!m) return null;
                const n = parseInt(m[1], 10);
                return Number.isFinite(n) ? n : null;
            }

            let __renderQueued = false;
            const __fmtSec = (ms, digits = 1) => {
                if (!Number.isFinite(ms) || ms <= 0) return '-';
                return `${(ms / 1000).toFixed(digits)}s`;
            };

            function _getCurrentSessionId() {
                try { return logger.getActiveSessionId() || 'legacy'; } catch { return 'legacy'; }
            }

            function render() {
                if (__renderQueued) return;
                __renderQueued = true;
                requestAnimationFrame(() => {
                    __renderQueued = false;
                    const el = document.getElementById('api-monitor-breakdown');
                    if (!el) return;

                    const activeId = _getCurrentSessionId();
                    const viewMode = (document.getElementById('log-filter-session-select') || {}).value || 'current';

                    // compute stats to show based on viewMode
                    let showOk = state.okTotal;
                    let showFail = state.failTotal;
                    let showFmt = state.formatErrorTotal;
                    let showLat = state.latencyMsTotal;

                    if (viewMode === 'current') {
                        showOk = state.okBySession[activeId] || 0;
                        showFail = state.failBySession[activeId] || 0;
                        showFmt = state.formatErrorBySession[activeId] || 0;
                        // Latency is global in this structure (simplified), but we could track per session if needed.
                        // For now we show global latency avg or just total ok counts
                    } else if (viewMode !== 'all' && state.okBySession[viewMode] !== undefined) {
                        showOk = state.okBySession[viewMode] || 0;
                        showFail = state.failBySession[viewMode] || 0;
                        showFmt = state.formatErrorBySession[viewMode] || 0;
                    }

                    const p = state.okByPhase || {};
                    const phaseLine = __tGuiFmt('callStatsPhaseLineFmt', {
                        p0: p.phase0 || 0,
                        p1: p.phase1 || 0,
                        p2: p.phase2 || 0,
                        p3: p.phase3 || 0,
                    });

                    const avgLat = (state.okTotal > 0) ? __fmtSec(state.latencyMsTotal / state.okTotal, 2) : '-';

                    const sessionLabel = (() => {
                        if (viewMode === 'all') return __tGui('callStatsSessionAll');
                        if (viewMode === 'current') return __tGuiFmt('callStatsSessionCurrentFmt', { id: activeId || '-' });
                        return __tGuiFmt('callStatsSessionOtherFmt', { id: viewMode });
                    })();

                    const statLine = __tGuiFmt('callStatsStatLineFmt', { session: sessionLabel, ok: showOk, fail: showFail, fmt: showFmt });
                    const globalLine = __tGuiFmt('callStatsGlobalLineFmt', { okTotal: state.okTotal, avgLat });

                    const stageLines = __stageOrder
                        .map(k => {
                            const n = __get(state.okByStage, k);
                            if (!n) return null;
                            const latSum = __get(state.latencyMsByStage, k);
                            const avg = n > 0 ? __fmtSec(latSum / n, 2) : '-';
                            const label = (() => {
                                const lk = __stageLabelKey[k];
                                if (!lk) return k;
                                const t = __tGui(lk);
                                return (t && t !== lk) ? t : k;
                            })();
                            return __tGuiFmt('callStatsStageLineFmt', { stage: label, n, avg });
                        })
                        .filter(Boolean);

                    const last = state.lastOkCallAt ? new Date(state.lastOkCallAt).toLocaleTimeString('en-US', { hour12: false }) : '';
                    const lastLine = last ? __tGuiFmt('callStatsLastOkFmt', { time: last }) : '';

                    el.innerHTML =
                        `<div style="font-family:monospace; font-size:12px; font-weight:bold; color:var(--accent);">${escapeHtmlForInnerHTML(statLine)}</div>` +
                        `<div style="font-family:monospace; font-size:11px; color:var(--text-3); margin-bottom:4px;">${escapeHtmlForInnerHTML(globalLine)}</div>` +
                        `<div style="font-family:monospace; font-size:11px; color:var(--text-3);">${escapeHtmlForInnerHTML(phaseLine)}</div>` +
                        (lastLine ? `<div style="font-family:monospace; font-size:11px; color:var(--text-3);">${escapeHtmlForInnerHTML(lastLine)}</div>` : '') +
                        `<div style="margin-top:8px; font-family:monospace; font-size:12px;">${stageLines.map(l => `<div>${escapeHtmlForInnerHTML(l)}</div>`).join('') || `<div style="color:var(--text-3);">${escapeHtmlForInnerHTML(__tGui('callStatsNoOkYet'))}</div>`}</div>`;
                    try { saveToStorage(); } catch { }
                });
            }

            function recordFailCall({ context, reason } = {}) {
                state.failTotal += 1;
                const sess = _getCurrentSessionId();
                __inc(state.failBySession, sess, 1);
                render();
            }

            function recordFormatError({ context } = {}) {
                state.formatErrorTotal += 1;
                const sess = _getCurrentSessionId();
                __inc(state.formatErrorBySession, sess, 1);
                render();
            }

            function recordOkCall({ context, estTokens, actualTokens, latencyMs } = {}) {
                const stage = inferStage(context);
                const phase = inferPhase(context, stage);
                const type = inferType(context);
                const cycle = inferCycle(context);
                const sess = _getCurrentSessionId();

                state.okTotal += 1;
                __inc(state.okBySession, sess, 1);

                state.estTokensTotal += Number.isFinite(estTokens) ? estTokens : 0;
                state.actualTokensTotal += Number.isFinite(actualTokens) ? actualTokens : 0;
                state.latencyMsTotal += Number.isFinite(latencyMs) ? Math.max(0, latencyMs) : 0;
                state.lastOkCallAt = Date.now();

                if (state.okByPhase && typeof state.okByPhase === 'object') {
                    const cur = Number.isFinite(state.okByPhase[phase]) ? state.okByPhase[phase] : 0;
                    state.okByPhase[phase] = cur + 1;
                }

                __inc(state.okByStage, stage, 1);
                __inc(state.latencyMsByStage, stage, Number.isFinite(latencyMs) ? Math.max(0, latencyMs) : 0);

                if (type) {
                    __inc(state.okByType, type, 1);
                    __inc(state.latencyMsByType, type, Number.isFinite(latencyMs) ? Math.max(0, latencyMs) : 0);
                    if (!state.okByTypeStage[type]) state.okByTypeStage[type] = __dict();
                    if (!state.latencyMsByTypeStage[type]) state.latencyMsByTypeStage[type] = __dict();
                    __inc(state.okByTypeStage[type], stage, 1);
                    __inc(state.latencyMsByTypeStage[type], stage, Number.isFinite(latencyMs) ? Math.max(0, latencyMs) : 0);

                    if (Number.isFinite(cycle)) {
                        if (!state.okByTypeCycleStage[type]) state.okByTypeCycleStage[type] = __dict();
                        const cyKey = String(cycle);
                        if (!state.okByTypeCycleStage[type][cyKey]) state.okByTypeCycleStage[type][cyKey] = __dict();
                        __inc(state.okByTypeCycleStage[type][cyKey], stage, 1);
                    }
                }

                render();
            }

            function reset() {
                state.okTotal = 0;
                state.failTotal = 0;
                state.formatErrorTotal = 0;
                state.estTokensTotal = 0;
                state.actualTokensTotal = 0;
                state.latencyMsTotal = 0;
                state.okBySession = __dict();
                state.failBySession = __dict();
                state.formatErrorBySession = __dict();

                state.okByPhase = { phase0: 0, phase1: 0, phase2: 0, phase3: 0, other: 0 };
                state.okByStage = __dict();
                state.latencyMsByStage = __dict();
                state.okByType = __dict();
                state.latencyMsByType = __dict();
                state.okByTypeStage = __dict();
                state.latencyMsByTypeStage = __dict();
                state.okByTypeCycleStage = __dict();
                state.lastOkCallAt = null;
                render();
            }

            function exportState() {
                try { return JSON.parse(JSON.stringify(state)); } catch { return null; }
            }

            function importState(saved) {
                if (!saved || typeof saved !== 'object') return;
                try {
                    reset();
                    state.okTotal = Number.isFinite(saved.okTotal) ? saved.okTotal : 0;
                    state.failTotal = Number.isFinite(saved.failTotal) ? saved.failTotal : 0;
                    state.formatErrorTotal = Number.isFinite(saved.formatErrorTotal) ? saved.formatErrorTotal : 0;
                    state.estTokensTotal = Number.isFinite(saved.estTokensTotal) ? saved.estTokensTotal : 0;
                    state.actualTokensTotal = Number.isFinite(saved.actualTokensTotal) ? saved.actualTokensTotal : 0;
                    state.latencyMsTotal = Number.isFinite(saved.latencyMsTotal) ? saved.latencyMsTotal : 0;
                    state.lastOkCallAt = Number.isFinite(saved.lastOkCallAt) ? saved.lastOkCallAt : null;

                    const copyDict = (src) => {
                        const dst = __dict();
                        if (!src || typeof src !== 'object') return dst;
                        Object.keys(src).forEach(k => { if (Number.isFinite(src[k])) dst[k] = src[k]; });
                        return dst;
                    };

                    state.okBySession = copyDict(saved.okBySession);
                    state.failBySession = copyDict(saved.failBySession);
                    state.formatErrorBySession = copyDict(saved.formatErrorBySession);

                    state.okByPhase = saved.okByPhase && typeof saved.okByPhase === 'object'
                        ? { phase0: saved.okByPhase.phase0 || 0, phase1: saved.okByPhase.phase1 || 0, phase2: saved.okByPhase.phase2 || 0, phase3: saved.okByPhase.phase3 || 0, other: saved.okByPhase.other || 0 }
                        : { phase0: 0, phase1: 0, phase2: 0, phase3: 0, other: 0 };

                    state.okByStage = copyDict(saved.okByStage);
                    state.latencyMsByStage = copyDict(saved.latencyMsByStage);
                    state.okByType = copyDict(saved.okByType);
                    state.latencyMsByType = copyDict(saved.latencyMsByType);

                    state.okByTypeStage = __dict();
                    if (saved.okByTypeStage && typeof saved.okByTypeStage === 'object') {
                        Object.keys(saved.okByTypeStage).forEach(type => {
                            state.okByTypeStage[type] = copyDict(saved.okByTypeStage[type]);
                        });
                    }
                    state.latencyMsByTypeStage = __dict();
                    if (saved.latencyMsByTypeStage && typeof saved.latencyMsByTypeStage === 'object') {
                        Object.keys(saved.latencyMsByTypeStage).forEach(type => {
                            state.latencyMsByTypeStage[type] = copyDict(saved.latencyMsByTypeStage[type]);
                        });
                    }

                    state.okByTypeCycleStage = __dict();
                    if (saved.okByTypeCycleStage && typeof saved.okByTypeCycleStage === 'object') {
                        Object.keys(saved.okByTypeCycleStage).forEach(type => {
                            state.okByTypeCycleStage[type] = __dict();
                            const cycles = saved.okByTypeCycleStage[type];
                            if (!cycles || typeof cycles !== 'object') return;
                            Object.keys(cycles).forEach(cy => {
                                state.okByTypeCycleStage[type][cy] = copyDict(cycles[cy]);
                            });
                        });
                    }
                } catch { /* ignore */ }
                render();
            }

            function getTypeCounts(type) {
                const t = String(type || '');
                return {
                    total: __get(state.okByType, t),
                    stages: state.okByTypeStage[t] || __dict(),
                    latencyMsTotal: __get(state.latencyMsByType, t),
                    latencyMsByStage: state.latencyMsByTypeStage[t] || __dict(),
                    cycles: state.okByTypeCycleStage[t] || __dict(),
                };
            }

            const STORAGE_KEY = 'MASTERY_MANUAL_CALL_STATS_V2';
            function saveToStorage() {
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(exportState())); } catch { }
            }
            function loadFromStorage() {
                try {
                    const s = localStorage.getItem(STORAGE_KEY);
                    if (s) importState(JSON.parse(s));
                } catch { }
            }

            // Init load
            try { setTimeout(loadFromStorage, 100); } catch { }

            return {
                recordOkCall,
                recordFailCall,
                recordFormatError,
                reset,
                render,
                exportState,
                importState,
                getTypeCounts,
                inferStage,
                inferType,
                inferCycle,
                _getCurrentSessionId // for debug
            };
        })();

        // === API key rolling + per-key rate limiting (ported from general.html) ===
        const apiKeyManager = {
            keys: [],
            idx: 0,
            consecutiveErrors: {}, // track consecutive errors per key
            setKeys(list) {
                this.keys = Array.isArray(list) ? list : [];
                this.idx = 0;
                // Preserve error counts or reset? Let's preserve to smooth config updates.
                if (!this.consecutiveErrors) this.consecutiveErrors = {};
            },
            hasKeys() { return this.keys.length > 0; },
            nextKey() {
                if (!this.keys.length) throw new Error("No API keys configured");
                const key = this.keys[this.idx];
                this.idx = (this.idx + 1) % this.keys.length;
                return key;
            }
        };


        function getApiKeyListFromInput() {
            const raw = getEl('api-key-list-input')?.value || '';
            return raw.split('\n').map(k => k.trim()).filter(Boolean);
        }

        function getPhase0Concurrency() {
            const override = getGlobalKeySplitCountOverride();
            const keyCount = getApiKeyListFromInput().length;
            const auto = keyCount > 0 ? keyCount : 1;
            const desired = Number.isFinite(override) ? Math.max(1, override) : auto;
            if (keyCount > 0) return Math.min(desired, keyCount);
            return desired;
        }

        function __sleepInterruptible(ms) {
            const total = Math.max(0, Number(ms) || 0);
            const end = Date.now() + total;
            return new Promise(async resolve => {
                while (Date.now() < end) {
                    if (processController.stop) return resolve();
                    const slice = Math.min(200, end - Date.now());
                    await new Promise(r => setTimeout(r, slice));
                }
                resolve();
            });
        }

        function maskKey(key) {
            if (!key) return '';
            return key.length <= 8 ? key : `${key.slice(0, 4)}...${key.slice(-4)}`;
        }

        // ===== Per-key rate limiter (copied from general.html) =====
        const __rateState = new Map(); // apiKey -> { windowStart, rpm, tpm, lastSentAt, chain, rpmLimit, tpmLimit, cooldownUntil, cooldownRetryCount, chainLockedAt, chainOwner, chainCreatedAt }

        // ===== Per-key inflight limiter (UI-controlled) =====
        const __inflightState = new Map(); // apiKey -> { count: number }

        function __normalizeInflightLimit(v) {
            const n = parseInt(v, 10);
            if (!Number.isFinite(n) || n <= 0) return 0; // 0 = unlimited
            return Math.min(999, n);
        }

        function __getInflightLimitPerKey() {
            return __normalizeInflightLimit(getEl('inflight-limit-input')?.value);
        }

        function __ensureInflightStateForKey(rawKey) {
            const key = rawKey || '__NO_KEY__';
            if (!__inflightState.has(key)) __inflightState.set(key, { count: 0 });
            return __inflightState.get(key);
        }

        function __getInflightCount(rawKey) {
            const key = rawKey || '__NO_KEY__';
            return Number.isFinite(__inflightState.get(key)?.count) ? __inflightState.get(key).count : 0;
        }

        async function __acquireInflightSlot(rawKey, { heartbeat } = {}) {
            const key = rawKey || '__NO_KEY__';
            const st = __ensureInflightStateForKey(key);
            while (true) {
                if (processController.stop) throw new Error("Operation cancelled.");
                const limit = __getInflightLimitPerKey();
                if (limit <= 0 || st.count < limit) {
                    st.count = Math.max(0, (Number.isFinite(st.count) ? st.count : 0) + 1);
                    return;
                }
                try { if (typeof heartbeat === 'function') heartbeat(); } catch { }
                await __sleepInterruptible(120);
            }
        }

        function __releaseInflightSlot(rawKey) {
            const key = rawKey || '__NO_KEY__';
            const st = __ensureInflightStateForKey(key);
            st.count = Math.max(0, (Number.isFinite(st.count) ? st.count : 0) - 1);
        }

        function __minuteStart(ts) { return ts - (ts % 60000); }

        function __normalizeRateLimit(v) {
            const n = parseInt(v, 10);
            if (!Number.isFinite(n) || n <= 0) return 0;
            return n;
        }

        function __mergeRateLimit(existing, incoming) {
            const e = __normalizeRateLimit(existing);
            const n = __normalizeRateLimit(incoming);
            if (e <= 0) return n;
            if (n <= 0) return e;
            return Math.min(e, n);
        }

        function __ensureRateStateForKey(rawKey) {
            const key = rawKey || '__NO_KEY__';
            if (!__rateState.has(key)) {
                __rateState.set(key, {
                    windowStart: __minuteStart(Date.now()),
                    rpm: 0,
                    tpm: 0,
                    lastSentAt: 0,
                    chain: Promise.resolve(),
                    chainLockedAt: 0,
                    chainOwner: null,
                    chainCreatedAt: 0,
                    rpmLimit: 0,
                    tpmLimit: 0,
                    cooldownUntil: null,
                    cooldownRetryCount: 0,
                });
            }
            return __rateState.get(key);
        }

        function __resetRateChainIfStale(state, now, maxStaleMs = 120000) {
            if (!state) return false;
            const lockedAt = Number.isFinite(state.chainLockedAt) ? state.chainLockedAt : 0;
            const createdAt = Number.isFinite(state.chainCreatedAt) ? state.chainCreatedAt : 0;
            const refAt = lockedAt || createdAt;
            if (!refAt) return false;
            if (now - refAt <= maxStaleMs) return false;
            state.chain = Promise.resolve();
            state.chainLockedAt = 0;
            state.chainOwner = null;
            state.chainCreatedAt = 0;
            return true;
        }

        function __recoverRateStateIfStale(state, now, maxStaleMs = 120000) {
            if (!state) return false;
            const win = __minuteStart(now);
            let changed = false;
            const ws = Number.isFinite(state.windowStart) ? state.windowStart : win;
            const staleWin = Math.abs(ws - win) >= 60000 && Math.abs(now - ws) > maxStaleMs;
            const futureWin = ws > now + 60000;
            if (staleWin || futureWin) {
                state.windowStart = win;
                state.rpm = 0;
                state.tpm = 0;
                changed = true;
            }
            const lastSentAt = Number.isFinite(state.lastSentAt) ? state.lastSentAt : 0;
            // Clock skew guard: if lastSentAt is in the future, rate limiter can wedge indefinitely.
            // Reset it so cooldown/pacing can resume normally.
            if (lastSentAt > now + 5000) {
                state.lastSentAt = now;
                changed = true;
            }
            if (!changed && lastSentAt && (now - lastSentAt > maxStaleMs) && (state.rpm > 0 || state.tpm > 0)) {
                state.rpm = 0;
                state.tpm = 0;
                changed = true;
            }
            return changed;
        }

        function __applySharedRateLimitsForKey(rawKey, { rpmLimitUi, tpmLimitUi } = {}) {
            const state = __ensureRateStateForKey(rawKey);
            // UI is the source of truth; apply changes immediately (including increases).
            state.rpmLimit = __normalizeRateLimit(rpmLimitUi);
            state.tpmLimit = __normalizeRateLimit(tpmLimitUi);
            return state;
        }

        // ===== Tokenizer Support (multiple modes) =====
        let __gptTokenizerLoaded = false;
        let __gptTokenizerLoadPromise = null;

        function __getTokenizerMode() {
            try {
                const el = document.getElementById('tokenizer-mode-select');
                return el ? el.value : 'char_estimate';
            } catch { return 'char_estimate'; }
        }

        async function __loadGptTokenizerLazy() {
            if (__gptTokenizerLoaded) return true;
            if (__gptTokenizerLoadPromise) return __gptTokenizerLoadPromise;

            __gptTokenizerLoadPromise = new Promise((resolve) => {
                try {
                    // Check if already available
                    const tok = window.o200k_base || window.GPTTokenizer_o200k_base;
                    if (tok && typeof tok.encode === 'function') {
                        __gptTokenizerLoaded = true;
                        return resolve(true);
                    }

                    // Dynamically load the script
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/gpt-tokenizer@3.4.0/dist/o200k_base.min.js';
                    script.async = true;
                    script.onload = () => {
                        __gptTokenizerLoaded = true;
                        logger.success('Tokenizer', 'gpt-tokenizer (o200k_base) loaded successfully.');
                        resolve(true);
                    };
                    script.onerror = () => {
                        logger.warn('Tokenizer', 'Failed to load gpt-tokenizer, falling back to char estimate.');
                        resolve(false);
                    };
                    document.head.appendChild(script);
                } catch (e) {
                    logger.warn('Tokenizer', `Error loading gpt-tokenizer: ${e.message}`);
                    resolve(false);
                }
            });

            return __gptTokenizerLoadPromise;
        }

        function __countTokens(text) {
            if (text == null) return 0;
            const s = (typeof text === 'string') ? text : String(text);
            if (!s) return 0;

            const mode = __getTokenizerMode();

            // Helper: count CJK/Korean characters
            // Korean/CJK text is MORE token-efficient than English (approx 1 token per 15-20 chars)
            const countCjkChars = (str) => {
                let count = 0;
                for (const char of str) {
                    const code = char.charCodeAt(0);
                    // Korean Hangul (AC00-D7AF), CJK (3000-9FFF), Japanese Hiragana/Katakana (3040-30FF)
                    if ((code >= 0xAC00 && code <= 0xD7AF) ||
                        (code >= 0x3000 && code <= 0x9FFF) ||
                        (code >= 0x3040 && code <= 0x30FF)) {
                        count++;
                    }
                }
                return count;
            };

            // Character-based estimation modes with CJK correction
            // Korean/CJK: ~16 chars per token (measured), English: ~4 chars per token
            if (mode === 'char_estimate') {
                const cjk = countCjkChars(s);
                const nonCjk = s.length - cjk;
                return Math.ceil(nonCjk / 4 + cjk / 16); // CJK: 0.0625 tokens/char, others: 0.25
            }
            if (mode === 'char_estimate_3') {
                const cjk = countCjkChars(s);
                const nonCjk = s.length - cjk;
                return Math.ceil(nonCjk / 3 + cjk / 12); // CJK: ~0.083 tokens/char
            }
            if (mode === 'char_estimate_2.5') {
                const cjk = countCjkChars(s);
                const nonCjk = s.length - cjk;
                return Math.ceil(nonCjk / 2.5 + cjk / 10); // CJK: 0.1 tokens/char
            }

            // Simple word/whitespace split (lightweight approximation)
            if (mode === 'simple_split') {
                // Split on whitespace and punctuation, count "tokens"
                const tokens = s.split(/[\s\u3000]+/).filter(Boolean);
                // Add extra tokens for Korean/CJK characters (typically 1 char = 1-2 tokens)
                let cjkCount = 0;
                for (const char of s) {
                    const code = char.charCodeAt(0);
                    if ((code >= 0x3000 && code <= 0x9FFF) || (code >= 0xAC00 && code <= 0xD7AF)) {
                        cjkCount++;
                    }
                }
                return Math.ceil(tokens.length + cjkCount * 0.5);
            }

            // gpt-tokenizer mode (accurate but requires loaded library)
            if (mode === 'gpt_tokenizer_lazy') {
                try {
                    const tok = window.o200k_base || window.GPTTokenizer_o200k_base;
                    if (tok && typeof tok.encode === 'function') {
                        return tok.encode(s).length;
                    }
                } catch { }
                // Fallback if not loaded yet
                return Math.ceil(s.length / 3);
            }

            // Default fallback
            return Math.ceil(s.length / 4);
        }

        function __estimateTokens(messages) {
            if (messages == null) return 0;
            if (typeof messages === 'string') return __countTokens(messages);
            if (!Array.isArray(messages)) return __countTokens(String(messages));

            // Serialize like what the model "sees" (role + text) for closer estimation.
            const parts = [];
            for (const m of messages) {
                const role = (m?.role || 'user').toString();
                const contentText = __extractTextContent(m?.content);
                if (!role && !contentText) continue;
                parts.push(`[${role}]\n${contentText}`);
            }
            return __countTokens(parts.join('\n\n'));
        }

        // ===== Live API-key state (cooldown/backoff + inflight counters) =====
        const __apiKeyLive = (() => {
            const state = { byKey: new Map(), order: [] };
            const __now = () => Date.now();
            const ensure = (rawKey) => {
                if (!rawKey) return null;
                if (!state.byKey.has(rawKey)) {
                    state.byKey.set(rawKey, {
                        rawKey,
                        masked: maskKey(rawKey),
                        phase: 'idle', // idle | waiting_rate | inflight
                        lastUniqueId: '',
                        estTokens: null,
                        sentAt: null,
                        lastSentAt: null,
                        pendingCount: 0,
                        inflightCount: 0,
                        lastHttpStatus: null,
                        lastMsg: '',
                        retryUntil: null,
                        retryHttpStatus: null,
                        retryCount: 0,
                        updatedAt: __now(),
                    });
                }
                const s = state.byKey.get(rawKey);
                if (s) s.masked = maskKey(rawKey);
                return s;
            };

            const syncFromInput = () => {
                const keys = getApiKeyListFromInput();
                const seen = new Set(keys);
                for (const k of state.byKey.keys()) {
                    if (!seen.has(k)) state.byKey.delete(k);
                }
                state.order = keys;
                for (const k of keys) ensure(k);
                return keys;
            };

            const onPrepare = (rawKey, meta = {}) => {
                const s = ensure(rawKey);
                if (!s) return;
                s.phase = 'waiting_rate';
                s.pendingCount = Math.max(0, (Number.isFinite(s.pendingCount) ? s.pendingCount : 0) + 1);
                s.lastUniqueId = meta?.uniqueId ? meta.uniqueId : s.lastUniqueId;
                s.estTokens = Number.isFinite(meta.estTokens) ? meta.estTokens : s.estTokens;
                s.sentAt = null;
                s.updatedAt = __now();
                if (Number.isFinite(s.retryUntil) && __now() >= s.retryUntil) {
                    s.retryUntil = null;
                    s.retryHttpStatus = null;
                }
            };

            const onSent = (rawKey, meta = {}) => {
                const s = ensure(rawKey);
                if (!s) return;
                if (Number.isFinite(s.pendingCount) && s.pendingCount > 0) s.pendingCount -= 1;
                s.inflightCount = Math.max(0, (Number.isFinite(s.inflightCount) ? s.inflightCount : 0) + 1);
                s.phase = 'inflight';
                s.lastUniqueId = meta?.uniqueId ? meta.uniqueId : s.lastUniqueId;
                s.estTokens = Number.isFinite(meta.estTokens) ? meta.estTokens : s.estTokens;
                s.sentAt = __now();
                s.lastSentAt = s.sentAt;
                s.updatedAt = __now();
            };

            const onDone = (rawKey, meta = {}) => {
                const s = ensure(rawKey);
                if (!s) return;
                const doneAt = __now();
                s.inflightCount = Math.max(0, (Number.isFinite(s.inflightCount) ? s.inflightCount : 0) - 1);
                if (Number.isFinite(s.pendingCount) && s.pendingCount > 0) s.phase = 'waiting_rate';
                else s.phase = 'idle';
                s.sentAt = null;
                s.lastUniqueId = meta?.uniqueId ? meta.uniqueId : s.lastUniqueId;
                if (Number.isFinite(meta.httpStatus)) s.lastHttpStatus = meta.httpStatus;
                if (meta.message != null) s.lastMsg = (meta.message || '').toString().slice(0, 220);
                const doneMsg = (meta?.message ?? '').toString();
                const okMsg = /^ok$/i.test((doneMsg || '').trim());
                const isHttpOk = Number.isFinite(meta.httpStatus) && meta.httpStatus >= 200 && meta.httpStatus < 400;
                if (isHttpOk || okMsg || meta?.ok === true) {
                    s.retryCount = 0;
                    s.retryUntil = null;
                    s.retryHttpStatus = null;
                    try {
                        const rs = __rateState?.get?.(rawKey || '__NO_KEY__');
                        if (rs) {
                            rs.cooldownUntil = null;
                            rs.cooldownRetryCount = 0;
                        }
                    } catch { }
                }
                s.updatedAt = doneAt;
            };

            const onRetry = (rawKey, meta = {}) => {
                const s = ensure(rawKey);
                if (!s) return { delayMs: 0, retryCount: 0, retryUntil: null };
                const status = Number.isFinite(meta.httpStatus) ? meta.httpStatus : null;
                s.retryCount = (Number.isFinite(s.retryCount) ? s.retryCount : 0) + 1;
                const streak = s.retryCount;

                const __computeBackoffMs = (n, httpStatus) => {
                    const status = Number.isFinite(httpStatus) ? httpStatus : null;
                    const is429 = status === 429;
                    const is5xx = status != null && status >= 500 && status < 600;

                    // HTTP-aware key backoff (aligned with general-test intent):
                    // - 429: longer waits sooner
                    // - 5xx: moderate exponential-ish
                    // - other: quick ramp-up
                    const seq = is429
                        ? [10000, 30000, 60000, 60000]
                        : (is5xx
                            ? [5000, 15000, 30000, 60000]
                            : [3000, 10000, 30000, 60000]);
                    const idx = Math.max(0, Math.min(seq.length - 1, (Number.isFinite(n) ? n : 1) - 1));
                    return Math.min(Math.max(0, seq[idx]), 60000);
                };

                const delayMs = Number.isFinite(meta.delayMs)
                    ? Math.max(0, meta.delayMs)
                    : __computeBackoffMs(streak, status);

                if (delayMs > 0) {
                    const now = __now();
                    s.retryHttpStatus = status;
                    const until = now + delayMs;
                    s.retryUntil = Number.isFinite(s.retryUntil) ? Math.max(s.retryUntil, until) : until;
                }
                try {
                    const rs = __ensureRateStateForKey(rawKey);
                    if (Number.isFinite(s.retryUntil)) {
                        rs.cooldownUntil = Number.isFinite(rs.cooldownUntil) ? Math.max(rs.cooldownUntil, s.retryUntil) : s.retryUntil;
                    }
                    rs.cooldownRetryCount = Number.isFinite(rs.cooldownRetryCount) ? Math.max(rs.cooldownRetryCount, streak) : streak;
                } catch { }
                s.updatedAt = __now();
                return { delayMs, retryCount: streak, retryUntil: s.retryUntil, httpStatus: status };
            };

            const getCooldownUntil = (rawKey) => {
                const s = ensure(rawKey);
                if (!s) return null;
                let until = Number.isFinite(s.retryUntil) ? s.retryUntil : 0;
                try {
                    const rs = __rateState?.get?.(rawKey || '__NO_KEY__');
                    if (rs) {
                        if (Number.isFinite(rs.cooldownUntil)) until = Math.max(until, rs.cooldownUntil);
                        // Include lastSentAt to respect the reservation/pacing duration
                        if (Number.isFinite(rs.lastSentAt)) until = Math.max(until, rs.lastSentAt);
                    }
                } catch { }
                return Number.isFinite(until) && until > 0 ? until : null;
            };

            const formatWaitTime = (ms) => {
                if (ms < 1000) return `${ms}ms`;
                return `${(ms / 1000).toFixed(1)}s`;
            };

            const reserveUsage = (rawKey, estTokens, paceMs) => {
                // Update __rateState directly to prevent race conditions across parallel workers
                const rs = __ensureRateStateForKey(rawKey);
                const now = __now();
                if (__minuteStart(now) !== rs.windowStart) {
                    rs.windowStart = __minuteStart(now);
                    rs.rpm = 0;
                    rs.tpm = 0;
                }
                const effectiveLast = Math.max(rs.lastSentAt || 0, now);
                rs.lastSentAt = effectiveLast + (paceMs || 100);
                rs.rpm += 1;
                rs.tpm += estTokens;

                // Sync UI state
                const s = ensure(rawKey);
                if (s) {
                    s.lastSentAt = rs.lastSentAt;
                }
            };

            return { syncFromInput, onPrepare, onSent, onDone, onRetry, formatWaitTime, reserveUsage, getCooldownUntil, _get: (k) => state.byKey.get(k), _all: () => state.byKey };
        })();

        try { window.__apiKeyLive = __apiKeyLive; } catch { }

        // ===== Full API I/O capture (IndexedDB) =====
        const __fullApiCapture = (() => {
            const STORAGE_KEY = 'hit_thunder_full_api_capture_enabled_v1';
            const DB_NAME = 'hit_thunder_guide_maker';
            const DB_VERSION = 1;
            const STORE_NAME = 'full_api_capture_v1';

            const state = {
                enabled: false,
                approxCount: 0,
                buffer: [],
                flushTimerId: null,
                flushing: false,
                lastError: '',
                db: null,
                openPromise: null,
                uiPingTimerId: null,
            };

            const __loadEnabled = () => {
                try { state.enabled = localStorage.getItem(STORAGE_KEY) === '1'; } catch { state.enabled = false; }
            };
            const __saveEnabled = () => {
                try { localStorage.setItem(STORAGE_KEY, state.enabled ? '1' : '0'); } catch { }
            };

            const __openDb = async () => {
                if (state.db) return state.db;
                if (state.openPromise) return state.openPromise;
                state.openPromise = new Promise((resolve, reject) => {
                    try {
                        const req = indexedDB.open(DB_NAME, DB_VERSION);
                        req.onupgradeneeded = () => {
                            const db = req.result;
                            if (!db.objectStoreNames.contains(STORE_NAME)) {
                                db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                            }
                        };
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => reject(req.error || new Error('IndexedDB open failed.'));
                    } catch (e) {
                        reject(e);
                    }
                }).then(db => {
                    state.db = db;
                    state.openPromise = null;
                    state.lastError = '';
                    return db;
                }).catch(e => {
                    state.openPromise = null;
                    state.lastError = e?.message || String(e || '');
                    throw e;
                });
                return state.openPromise;
            };

            const __sanitizeText = (text) => {
                let s = String(text ?? '');
                s = s.replace(/!\[[^\]]*]\(data:[^)]+\)/gi, '[image]');
                s = s.replace(/<\s*img\b[^>]*\bsrc\s*=\s*["']data:[^"']+["'][^>]*>/gi, '[image]');
                s = s.replace(/data:image\/[^;\s]+;base64,[a-z0-9+/=]+/gi, '[image]');
                return s;
            };

            const sanitizeMessages = (messages) => {
                const arr = Array.isArray(messages) ? messages : [];
                return arr.map(m => {
                    const role = String(m?.role || '').trim();
                    const name = m?.name != null ? String(m.name) : undefined;
                    const content = m?.content;
                    if (typeof content === 'string') {
                        return { role, ...(name ? { name } : {}), content: __sanitizeText(content) };
                    }
                    if (Array.isArray(content)) {
                        const parts = content.map(p => {
                            if (!p || typeof p !== 'object') return p;
                            const t = String(p.type || '').trim();
                            if (t === 'text') return { ...p, text: __sanitizeText(p.text || '') };
                            // Drop binary/image payloads to keep capture size sane.
                            return { type: t || 'unknown', omitted: true };
                        });
                        return { role, ...(name ? { name } : {}), content: parts };
                    }
                    // Unknown shape: keep minimal
                    return { role, ...(name ? { name } : {}), content: '[unsupported content]' };
                });
            };

            const __pingUi = () => {
                if (state.uiPingTimerId) return;
                state.uiPingTimerId = setTimeout(() => {
                    state.uiPingTimerId = null;
                    try { __refreshFullCaptureUi(); } catch { }
                }, 400);
            };

            const __scheduleFlush = () => {
                if (state.flushTimerId) return;
                state.flushTimerId = setTimeout(() => {
                    state.flushTimerId = null;
                    flush().catch(() => { });
                }, 800);
            };

            const append = (record) => {
                if (!state.enabled) return;
                try {
                    state.buffer.push(record);
                    if (state.buffer.length >= 6) flush().catch(() => { });
                    else __scheduleFlush();
                    __pingUi();
                } catch (e) {
                    state.lastError = e?.message || String(e || '');
                }
            };

            const flush = async () => {
                if (!state.enabled) return;
                if (state.flushing) return;
                if (!state.buffer.length) return;
                state.flushing = true;
                const batch = state.buffer.splice(0, state.buffer.length);
                try {
                    const db = await __openDb();
                    await new Promise((resolve, reject) => {
                        const tx = db.transaction(STORE_NAME, 'readwrite');
                        const store = tx.objectStore(STORE_NAME);
                        batch.forEach(rec => { try { store.add(rec); } catch { } });
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed.'));
                        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted.'));
                    });
                    state.approxCount += batch.length;
                    state.lastError = '';
                } catch (e) {
                    // Put it back so user can export later if DB becomes available.
                    state.buffer.unshift(...batch);
                    state.lastError = e?.message || String(e || '');
                } finally {
                    state.flushing = false;
                    __pingUi();
                }
            };

            const refreshCount = async () => {
                try {
                    const db = await __openDb();
                    const n = await new Promise((resolve, reject) => {
                        const tx = db.transaction(STORE_NAME, 'readonly');
                        const store = tx.objectStore(STORE_NAME);
                        const req = store.count();
                        req.onsuccess = () => resolve(req.result || 0);
                        req.onerror = () => reject(req.error || new Error('IndexedDB count failed.'));
                    });
                    state.approxCount = Number(n) || 0;
                    __pingUi();
                    return state.approxCount;
                } catch (e) {
                    state.lastError = e?.message || String(e || '');
                    __pingUi();
                    return state.approxCount;
                }
            };

            const clear = async () => {
                await flush().catch(() => { });
                const db = await __openDb();
                await new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_NAME, 'readwrite');
                    const store = tx.objectStore(STORE_NAME);
                    const req = store.clear();
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error || new Error('IndexedDB clear failed.'));
                });
                state.approxCount = 0;
                state.buffer.length = 0;
                state.lastError = '';
                __pingUi();
            };

            const __downloadBlob = (filename, blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const exportJsonl = async ({ filename } = {}) => {
                await flush().catch(() => { });
                const db = await __openDb();
                const parts = [];
                await new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const store = tx.objectStore(STORE_NAME);
                    const req = store.openCursor();
                    req.onsuccess = () => {
                        const cursor = req.result;
                        if (!cursor) return resolve();
                        try {
                            parts.push(JSON.stringify(cursor.value) + '\n');
                        } catch { }
                        cursor.continue();
                    };
                    req.onerror = () => reject(req.error || new Error('IndexedDB cursor failed.'));
                });
                const name = filename || `full_api_capture_${new Date().toISOString().replace(/[:.]/g, '-')}.jsonl`;
                __downloadBlob(name, new Blob(parts, { type: 'application/jsonl;charset=utf-8' }));
            };

            const isEnabled = () => !!state.enabled;
            const setEnabled = async (v) => {
                const next = !!v;
                if (state.enabled && !next) {
                    await flush().catch(() => { });
                }
                state.enabled = next;
                __saveEnabled();
                if (state.enabled) {
                    await __openDb().catch(() => { });
                    await refreshCount().catch(() => { });
                }
                __pingUi();
                return state.enabled;
            };

            const getStatus = () => ({
                enabled: !!state.enabled,
                approxCount: Number(state.approxCount) || 0,
                pending: state.buffer.length,
                lastError: state.lastError || '',
            });

            __loadEnabled();
            if (state.enabled) {
                __openDb().then(() => refreshCount()).catch(() => { });
            }

            return { isEnabled, setEnabled, append, flush, clear, exportJsonl, refreshCount, getStatus, sanitizeMessages };
        })();

        try { window.__fullApiCapture = __fullApiCapture; } catch { }

        // ===== API Monitor (UI) =====
        const __apiMonitor = (() => {
            const state = {
                recentCalls: [], // newest last
                maxEntries: 400,
                nextId: 1,
                pending: new Map(), // id -> entry (waiting | inflight)
                running: false,
                timerId: null,
            };

            const esc = (v) => {
                const s = (v ?? '').toString();
                return s.replace(/[&<>"']/g, (ch) => {
                    if (ch === '&') return '&amp;';
                    if (ch === '<') return '&lt;';
                    if (ch === '>') return '&gt;';
                    if (ch === '"') return '&quot;';
                    return '&#39;';
                });
            };

            const __now = () => Date.now();
            const __fmtTime = (ts) => {
                try { return new Date(ts).toLocaleTimeString('en-US', { hour12: false }); } catch { return ''; }
            };

            const __isPending = (e) => {
                const st = (e?.state || '').toString();
                return st === 'waiting' || st === 'inflight';
            };

            function __trim() {
                if (state.recentCalls.length <= state.maxEntries) return;
                // Prefer trimming completed entries first; never drop pending unless absolutely necessary.
                while (state.recentCalls.length > state.maxEntries) {
                    const idx = state.recentCalls.findIndex(e => e && !__isPending(e));
                    if (idx < 0) break;
                    const removed = state.recentCalls.splice(idx, 1)[0];
                    if (removed?.id) state.pending.delete(removed.id);
                }
                // Still too many (all pending?) -> trim oldest
                if (state.recentCalls.length > state.maxEntries) {
                    state.recentCalls.splice(0, state.recentCalls.length - state.maxEntries);
                    // Rebuild pending map from remaining
                    const next = new Map();
                    for (const e of state.recentCalls) {
                        if (__isPending(e) && Number.isFinite(e?.id)) next.set(e.id, e);
                    }
                    state.pending = next;
                }
            }

            function startCall(entry) {
                try {
                    const id = state.nextId++;
                    const e = {
                        id,
                        ts: Number.isFinite(entry?.ts) ? entry.ts : __now(),
                        state: 'waiting', // waiting | inflight | done
                        ok: null,
                        httpStatus: null,
                        key: (entry?.key || '').toString(),
                        context: (entry?.context || '').toString(),
                        estTokens: Number.isFinite(entry?.estTokens) ? entry.estTokens : null,
                        actualTokens: null,
                        latencyMs: null,
                        requestId: null,
                        message: (entry?.message || 'WAITING').toString(),
                    };
                    state.recentCalls.push(e);
                    state.pending.set(id, e);
                    __trim();
                    render();
                    return id;
                } catch {
                    return null;
                }
            }

            function updateCall(id, patch = {}) {
                try {
                    const e = (Number.isFinite(id) && state.pending.has(id)) ? state.pending.get(id) : null;
                    if (!e) return false;
                    if (patch?.state != null) e.state = String(patch.state || '').toLowerCase();
                    if (patch?.message != null) e.message = String(patch.message || '');
                    if (Number.isFinite(patch?.ts)) e.ts = patch.ts;
                    if (patch?.context != null) e.context = String(patch.context || '');
                    if (patch?.key != null) e.key = String(patch.key || '');
                    if (Number.isFinite(patch?.estTokens)) e.estTokens = patch.estTokens;
                    if (Number.isFinite(patch?.actualTokens)) e.actualTokens = patch.actualTokens;
                    if (Number.isFinite(patch?.latencyMs)) e.latencyMs = patch.latencyMs;
                    if (patch?.requestId != null) e.requestId = String(patch.requestId || '');
                    __trim();
                    render();
                    return true;
                } catch {
                    return false;
                }
            }

            function _getEntry(id) {
                try { return (Number.isFinite(id) && state.pending.has(id)) ? state.pending.get(id) : null; } catch { return null; }
            }

            function finishCall(id, entry) {
                try {
                    const e = (Number.isFinite(id) && state.pending.has(id)) ? state.pending.get(id) : null;
                    const now = __now();
                    if (!e) {
                        // Fallback: append as a completed call
                        recordCall(entry);
                        return;
                    }
                    e.state = 'done';
                    e.ts = Number.isFinite(entry?.ts) ? entry.ts : (Number.isFinite(e.ts) ? e.ts : now);
                    e.ok = entry?.ok === true;
                    e.httpStatus = Number.isFinite(entry?.httpStatus) ? entry.httpStatus : (Number.isFinite(e.httpStatus) ? e.httpStatus : null);
                    e.estTokens = Number.isFinite(entry?.estTokens) ? entry.estTokens : e.estTokens;
                    e.actualTokens = Number.isFinite(entry?.actualTokens) ? entry.actualTokens : e.actualTokens;
                    e.latencyMs = Number.isFinite(entry?.latencyMs) ? entry.latencyMs : e.latencyMs;
                    e.requestId = (entry?.requestId != null) ? String(entry.requestId) : e.requestId;
                    e.message = (entry?.message != null) ? String(entry.message) : e.message;
                    state.pending.delete(id);
                    __trim();
                    render();
                } catch { }
            }

            function recordCall(entry) {
                try {
                    state.recentCalls.push({
                        id: state.nextId++,
                        ts: Number.isFinite(entry?.ts) ? entry.ts : __now(),
                        state: 'done',
                        ok: entry?.ok === true,
                        httpStatus: Number.isFinite(entry?.httpStatus) ? entry.httpStatus : null,
                        key: (entry?.key || '').toString(),
                        context: (entry?.context || '').toString(),
                        estTokens: Number.isFinite(entry?.estTokens) ? entry.estTokens : null,
                        actualTokens: Number.isFinite(entry?.actualTokens) ? entry.actualTokens : null,
                        latencyMs: Number.isFinite(entry?.latencyMs) ? entry.latencyMs : null,
                        requestId: entry?.requestId != null ? String(entry.requestId) : null,
                        message: (entry?.message || '').toString(),
                    });
                    __trim();
                    render();
                } catch { }
            }

            function __computeTotals() {
                const totalDone = state.recentCalls.filter(e => e && e.state === 'done').length;
                let waiting = 0;
                let inflight = 0;
                for (const e of state.pending.values()) {
                    if (e?.state === 'waiting') waiting++;
                    else if (e?.state === 'inflight') inflight++;
                }
                let ok = 0;
                for (const e of state.recentCalls) if (e?.state === 'done' && e?.ok) ok++;
                return { total: totalDone, waiting, inflight, ok, fail: totalDone - ok };
            }

            function renderKeyMonitor() {
                const outEl = document.getElementById('key-monitor-output');
                if (!outEl) return;
                try { __apiKeyLive.syncFromInput(); } catch { }
                const now = __now();
                const keys = getApiKeyListFromInput();
                if (!keys.length) {
                    outEl.innerHTML = `<div style="color:var(--text-3); font-family:monospace; font-size:11px;">No API keys configured.</div>`;
                    return;
                }

                const inflightLimit = __getInflightLimitPerKey();
                const rows = [];
                for (let i = 0; i < keys.length; i++) {
                    const rawKey = keys[i];
                    const s = (() => {
                        try { return __apiKeyLive._get?.(rawKey) || null; } catch { return null; }
                    })();
                    const masked = s?.masked || maskKey(rawKey);

                    const cooldownUntil = (() => {
                        try { return __apiKeyLive.getCooldownUntil?.(rawKey); } catch { return null; }
                    })();
                    const retrying = Number.isFinite(cooldownUntil) && cooldownUntil > now;

                    const inflightN = Number.isFinite(s?.inflightCount) ? s.inflightCount : __getInflightCount(rawKey);
                    const hasInflight = inflightN > 0;
                    const pendingN = Number.isFinite(s?.pendingCount) ? s.pendingCount : 0;
                    const hasPending = pendingN > 0;

                    const retryCount = (Number.isFinite(s?.retryCount) && s.retryCount > 0) ? s.retryCount : 0;
                    const isErrorCooldown = retrying && (retryCount > 0 || (cooldownUntil - now > 5000));

                    // Color policy (user-facing):
                    // - inflight: warn (orange) so it stays "busy" throughout the request
                    // - idle: success (green)
                    // - cooldown/error: error (red)
                    // - pacing: accent (purple)
                    const dotColor = isErrorCooldown
                        ? 'var(--error-color)'
                        : ((hasInflight || s?.phase === 'inflight')
                            ? 'var(--warn-color)'
                            : ((hasPending || s?.phase === 'waiting_rate')
                                ? 'var(--warn-color)'
                                : (retrying ? 'var(--accent)' : 'var(--success-color)')));

                    const estTok = Number.isFinite(s?.estTokens) ? s.estTokens.toString() : '-';

                    let age = '-';
                    if (Number.isFinite(s?.lastSentAt)) {
                        const ageSec = Math.max(0, (now - s.lastSentAt) / 1000);
                        age = `${ageSec.toFixed(1)}s`;
                    }

                    const retryCountStr = retryCount > 0 ? retryCount.toString() : '-';
                    let retryCol = retryCountStr;
                    if (retrying) {
                        const left = Math.max(0, Math.ceil((cooldownUntil - now) / 1000));
                        const st = Number.isFinite(s?.retryHttpStatus) ? s.retryHttpStatus : null;
                        retryCol = st ? `${retryCount} ${st} ${left}s` : `${retryCount} ${left}s`;
                    }

                    const msg = (s?.lastMsg || '').toString();
                    const msgEsc = esc(msg);
                    const ctx = (s?.lastUniqueId || '').toString();
                    const ctxEsc = esc(ctx || '-');

                    let statusText = '';
                    if (hasInflight) {
                        const inflightLabel = inflightN > 1 ? `INFLIGHT x${inflightN}` : 'INFLIGHT';
                        statusText = inflightLimit > 0 ? `${inflightLabel} / ${inflightLimit}` : inflightLabel;
                    } else if (hasPending || s?.phase === 'waiting_rate') {
                        statusText = pendingN > 1 ? `WAIT_RATE x${pendingN}` : 'WAIT_RATE';
                    } else if (isErrorCooldown) {
                        statusText = 'COOLDOWN';
                    } else if (retrying) {
                        statusText = 'PACING';
                    } else if (Number.isFinite(s?.lastHttpStatus)) {
                        statusText = `HTTP ${s.lastHttpStatus}`;
                    } else {
                        statusText = 'IDLE';
                    }

                    rows.push(
                        `<div class="key-monitor-row" title="${msgEsc}">` +
                        `<div class="key-monitor-dot" style="color:${dotColor};">â—</div>` +
                        `<div class="key-monitor-col idx">${i + 1}</div>` +
                        `<div class="key-monitor-col key">${esc(masked)}</div>` +
                        `<div class="key-monitor-col arch">${ctxEsc}</div>` +
                        `<div class="key-monitor-col tok">${esc(estTok)}</div>` +
                        `<div class="key-monitor-col age">${esc(age)}</div>` +
                        `<div class="key-monitor-col retry">${esc(retryCol)}</div>` +
                        `<div class="key-monitor-col status">${esc(statusText)}${msg ? ` â€” ${msgEsc}` : ''}</div>` +
                        `</div>`
                    );
                }

                outEl.innerHTML = rows.join('');
            }

            function renderRecentCalls() {
                const outEl = document.getElementById('api-monitor-recent-calls');
                const totalsEl = document.getElementById('api-monitor-totals');
                if (!outEl) return;
                const totals = __computeTotals();
                if (totalsEl) {
                    totalsEl.textContent = __tGuiFmt('apiMonitorTotalsFmt', {
                        total: totals.total,
                        waiting: totals.waiting,
                        inflight: totals.inflight,
                        ok: totals.ok,
                        fail: totals.fail
                    });
                }

                // Always show pending calls, plus most recent completed calls to fill up to 50 lines.
                const pending = Array.from(state.pending.values());
                const done = state.recentCalls.filter(e => e && e.state === 'done');
                const pickDone = done.slice(-Math.max(0, 50 - pending.length));
                const recent = [...pickDone, ...pending].sort((a, b) => (a.ts || 0) - (b.ts || 0));
                const lines = recent.map(e => {
                    const t = __fmtTime(e.ts);
                    const ok = e.state === 'waiting' ? 'WAIT' : (e.state === 'inflight' ? 'INFL' : (e.ok ? 'OK  ' : 'FAIL'));
                    const hs = Number.isFinite(e.httpStatus) ? `HTTP${e.httpStatus}` : 'HTTP-';
                    const key = e.key ? e.key : '-';
                    const tok = Number.isFinite(e.actualTokens) ? `tok ${e.actualTokens}` : (Number.isFinite(e.estTokens) ? `est ${e.estTokens}` : '');
                    const lat = Number.isFinite(e.latencyMs) ? `lat ${(e.latencyMs / 1000).toFixed(1)}s` : '';
                    const rid = e.requestId ? `rid ${String(e.requestId).slice(0, 18)}` : '';
                    const ctx = (e.context || '').toString();
                    const extra = [tok, lat, rid].filter(Boolean).join('  ');
                    return `${t}  ${ok}  ${hs}  ${key}  ${extra ? `${extra}  ` : ''}${ctx}${e.message ? ` â€” ${e.message}` : ''}`.trim();
                });
                outEl.textContent = lines.join('\n');
            }

            function render() {
                renderKeyMonitor();
                renderRecentCalls();
            }

            function start() {
                if (state.timerId) return;
                state.timerId = setInterval(() => { try { render(); } catch { } }, 500);
                try { render(); } catch { }
            }

            function stop() {
                if (!state.timerId) return;
                try { clearInterval(state.timerId); } catch { }
                state.timerId = null;
            }

            function setRunning(on) {
                const want = !!on;
                state.running = want;
                if (want) start();
                else stop();
                try { render(); } catch { }
            }

            return { startCall, updateCall, _getEntry, finishCall, recordCall, render, setRunning, getState: () => state };
        })();

        async function __acquireRateSlot(apiKey, estTokens) {
            const enabled = !!getEl('enable-rate-limit-input')?.checked;

            // Always enforce key cooldown (429 / repeated API errors), even when rate limit is disabled.
            // Loop until the key is ready (cooldown expires).
            while (true) {
                if (processController.stop) throw new Error("Operation cancelled.");

                const until = (() => {
                    try { return __apiKeyLive.getCooldownUntil?.(apiKey); } catch { return null; }
                })();

                // If no cooldown, we can proceed to rate limit check
                if (!Number.isFinite(until)) break;

                const now = Date.now();
                if (now >= until) break;

                // Key is in cooldown. Wait.
                const waitMs = Math.max(0, until - now + 50); // add small buffer
                await __sleepInterruptible(Math.min(1000, waitMs)); // wait in chunks to allow interruption
            }

            if (!enabled) {
                await __acquireInflightSlot(apiKey);
                return;
            }

            const rpmLimitUi = __normalizeRateLimit(getEl('rpm-limit-input')?.value);
            const tpmLimitUi = __normalizeRateLimit(getEl('tpm-limit-input')?.value);
            const tokensForBucket = Number.isFinite(estTokens) ? Math.max(0, estTokens) : 0;

            const state = __applySharedRateLimitsForKey(apiKey, { rpmLimitUi, tpmLimitUi });
            const rpmLimit = Number.isFinite(state?.rpmLimit) ? state.rpmLimit : rpmLimitUi;
            const tpmLimit = Number.isFinite(state?.tpmLimit) ? state.tpmLimit : tpmLimitUi;
            const isTpmOversize = tpmLimit > 0 && tokensForBucket > tpmLimit;

            // RPM smoothing interval (60/RPM) + "Key Minimum 3s gap"
            const paceMs = rpmLimit > 0 ? Math.ceil(60000 / rpmLimit) : 0;
            const gapMs = Math.max(3000, paceMs);

            // If a previous chain got wedged, break it.
            try { __resetRateChainIfStale(state, Date.now()); } catch { }

            const lockId = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
            const prevChain = state.chain;
            state.chainCreatedAt = Date.now();
            state.chain = Promise.resolve(prevChain).catch(() => { }).then(async () => {
                state.chainLockedAt = Date.now();
                state.chainOwner = lockId;
                const hardWaitStart = Date.now();
                while (true) {
                    if (processController.stop) throw new Error("Operation cancelled.");
                    const now = Date.now();
                    __recoverRateStateIfStale(state, now);

                    // (1) Smoothing: Guarantee per-key min gap (gapMs)
                    const nextByGap = state.lastSentAt ? (state.lastSentAt + gapMs) : 0;
                    if (nextByGap && now < nextByGap) {
                        const waitMs = nextByGap - now + 5;
                        await __sleepInterruptible(waitMs);
                        continue;
                    }

                    // (2) TPM/RPM bucket (Minute window)
                    const win = __minuteStart(now);
                    if (win !== state.windowStart) {
                        state.windowStart = win;
                        state.rpm = 0;
                        state.tpm = 0;
                    }

                    const hitRpm = rpmLimit > 0 && (state.rpm + 1 > rpmLimit);
                    const hitTpm = tpmLimit > 0 && (isTpmOversize ? (state.tpm >= tpmLimit) : (state.tpm + tokensForBucket > tpmLimit));

                    if (!hitRpm && !hitTpm) {
                        // IMPORTANT: Apply RPM/TPM gating first, then inflight gating (per user requirement).
                        // Also keep a heartbeat so long inflight waits don't look like a wedged rate-chain.
                        await __acquireInflightSlot(apiKey, {
                            heartbeat: () => { state.chainLockedAt = Date.now(); }
                        });

                        state.rpm += 1;
                        if (tpmLimit > 0) {
                            if (isTpmOversize) {
                                state.tpm = Math.max(state.tpm, tpmLimit); // Saturate this key for the current minute window.
                            } else {
                                state.tpm += tokensForBucket; // provisional
                            }
                        }
                        state.lastSentAt = Date.now(); // Record "sent time" for this key
                        return;
                    }

                    const waitMs = (state.windowStart + 60000) - now + 25;
                    if (Date.now() - hardWaitStart > 90000) {
                        state.windowStart = __minuteStart(Date.now());
                        state.rpm = 0;
                        state.tpm = 0;
                        state.lastSentAt = 0;
                        continue;
                    }
                    await __sleepInterruptible(Math.max(0, waitMs));
                }
            }).finally(() => {
                if (state.chainOwner === lockId) {
                    state.chainLockedAt = 0;
                    state.chainOwner = null;
                    state.chainCreatedAt = 0;
                }
            });

            await state.chain;
        }

        function __reconcileTokens(apiKey, estTokens, actualTokens) {
            const enabled = !!getEl('enable-rate-limit-input')?.checked;
            if (!enabled) return;
            const key = apiKey || '__NO_KEY__';
            const state = __rateState.get(key);
            if (!state) return;
            if (state.windowStart !== __minuteStart(Date.now())) return;
            const delta = (actualTokens || 0) - (estTokens || 0);
            if (delta > 0) state.tpm += delta;
        }

        function __estimateTokensFromMessages(messages) {
            return __estimateTokens(messages);
        }

        function __sanitizeModelText(raw) {
            let s = (raw ?? '').toString().replace(/\uFEFF/g, '').trim();
            for (let i = 0; i < 3; i++) {
                const m =
                    s.match(/^\s*```[a-zA-Z0-9_-]*\s*\n([\s\S]*?)\n```\s*$/) ||
                    s.match(/^\s*```[a-zA-Z0-9_-]*\s*([\s\S]*?)```\s*$/);
                if (!m) break;
                s = (m[1] ?? '').toString().trim();
            }
            return s.trim();
        }

        function __toGeminiPayload(messages) {
            const systemParts = [];
            const contents = [];
            for (const m of (messages || [])) {
                const role = (m?.role || '').toLowerCase();
                const content = m?.content;
                if (role === 'system' || role === 'developer') {
                    if (Array.isArray(content)) {
                        const sysText = content.map(p => (p?.text || '')).join('\n').trim();
                        if (sysText) systemParts.push(sysText);
                    } else if (content) {
                        systemParts.push(String(content));
                    }
                    continue;
                }
                const gemRole = (role === 'assistant' || role === 'model') ? 'model' : 'user';
                const parts = [];
                if (Array.isArray(content)) {
                    content.forEach(part => {
                        if (part?.type === 'text' && part.text) parts.push({ text: String(part.text) });
                        if (part?.type === 'file' && part.file) {
                            const f = part.file || {};
                            const filename = String(f.filename || f.name || '').trim();
                            const data = String(f.file_data || f.fileData || f.data || '').trim();
                            const mimeType = String(f.mime_type || f.mimeType || __inferMimeTypeFromFilename(filename) || '').trim() || 'application/octet-stream';
                            if (data) {
                                parts.push({ inlineData: { mimeType, data } });
                            }
                        }
                        if (part?.type === 'image_url' && part.image_url?.url) {
                            const url = String(part.image_url.url);
                            const m = url.match(/^data:([^;]+);base64,(.+)$/i);
                            if (m) {
                                parts.push({ inlineData: { mimeType: m[1], data: m[2] } });
                            }
                        }
                    });
                } else if (content) {
                    parts.push({ text: String(content) });
                }
                if (parts.length) contents.push({ role: gemRole, parts });
            }
            const systemInstruction = systemParts.length ? { parts: [{ text: systemParts.join('\n\n') }] } : null;
            if (!contents.length && systemInstruction) {
                contents.push({ role: 'user', parts: [{ text: systemParts.join('\n\n') }] });
                return { contents, systemInstruction: null };
            }
            return { contents, systemInstruction };
        }

        function __extractTextContent(content) {
            if (typeof content === 'string') return content;
            if (Array.isArray(content)) {
                return content.map(part => part?.text || '').join('');
            }
            return content ? String(content) : '';
        }

        function __toCfResponsesPayload(messages) {
            const parts = [];
            for (const m of (messages || [])) {
                const role = (m?.role || '').toLowerCase();
                const text = __extractTextContent(m?.content).trim();
                if (!text) continue;
                if (role === 'system' || role === 'developer') {
                    parts.push(`[System]\n${text}`);
                } else if (role === 'assistant') {
                    parts.push(`[Assistant]\n${text}`);
                } else {
                    parts.push(`[User]\n${text}`);
                }
            }
            return { inputText: parts.join('\n\n').trim() };
        }

        function __extractCfResponseText(data, apiMode) {
            if (apiMode === 'cf_ai_run') {
                return (
                    data?.result?.response ||
                    data?.result?.output_text ||
                    data?.result?.output?.[0]?.content?.[0]?.text ||
                    data?.result?.output?.[0]?.text ||
                    data?.result?.choices?.[0]?.message?.content ||
                    ""
                );
            }
            return (
                data?.result?.response ||
                data?.result?.output_text ||
                data?.output_text ||
                data?.response?.output_text ||
                data?.response?.output?.[0]?.content?.[0]?.text ||
                data?.result?.output?.[0]?.content?.[0]?.text ||
                data?.choices?.[0]?.message?.content ||
                ""
            );
        }

        
        function __looksLikeSseText(rawText) {
            const t = String(rawText || '');
            return /^\s*data\s*:/im.test(t);
        }

        function __assembleTextFromSse(sseText) {
            const text = String(sseText || '');
            const lines = text.split(/\r?\n/);
            let out = '';
            for (const lineRaw of lines) {
                const line = String(lineRaw || '');
                const m = line.match(/^\s*data\s*:\s*(.*)\s*$/i);
                if (!m) continue;
                const dataStr = (m[1] || '').trim();
                if (!dataStr || dataStr === '[DONE]') continue;
                let obj = null;
                try { obj = JSON.parse(dataStr); } catch { obj = null; }
                if (!obj) continue;

                // Common OpenAI chat.completion.chunk format
                const delta = obj?.choices?.[0]?.delta;
                if (typeof delta?.content === 'string') { out += delta.content; continue; }

                // Some providers send full message content in a chunk
                const msg = obj?.choices?.[0]?.message;
                if (typeof msg?.content === 'string') { out += msg.content; continue; }

                // OpenAI Responses-style events
                if (typeof obj?.delta === 'string') { out += obj.delta; continue; }
                if (typeof obj?.text === 'string') { out += obj.text; continue; }
                if (typeof obj?.response === 'string') { out += obj.response; continue; }

                // Cloudflare / Workers AI variants
                if (typeof obj?.output_text === 'string') { out += obj.output_text; continue; }
                if (typeof obj?.result?.output_text === 'string') { out += obj.result.output_text; continue; }
                if (typeof obj?.result?.response === 'string') { out += obj.result.response; continue; }
                if (typeof obj?.response?.output_text === 'string') { out += obj.response.output_text; continue; }
            }
            return out;
        }

        function __wrapTextResponseForMode(text, apiMode) {
            const t = String(text || '');
            if (apiMode === 'gemini_generatecontent') {
                return { candidates: [{ content: { parts: [{ text: t }] } }] };
            }
            // OpenAI compat + CF Responses + CF Run (fallback shape)
            return { choices: [{ message: { content: t } }] };
        }

function __extractActualTokens(data) {
            const usage = data?.usage || data?.response?.usage || data?.result?.usage || null;
            if (Number.isFinite(usage?.total_tokens)) return usage.total_tokens;
            if (Number.isFinite(usage?.totalTokens)) return usage.totalTokens;
            if (Number.isFinite(usage?.prompt_tokens) || Number.isFinite(usage?.completion_tokens)) {
                return (usage?.prompt_tokens || 0) + (usage?.completion_tokens || 0);
            }
            const meta = data?.usageMetadata || data?.response?.usageMetadata || data?.result?.usageMetadata || null;
            if (Number.isFinite(meta?.totalTokenCount)) return meta.totalTokenCount;
            if (Number.isFinite(meta?.promptTokenCount) || Number.isFinite(meta?.candidatesTokenCount)) {
                return (meta?.promptTokenCount || 0) + (meta?.candidatesTokenCount || 0);
            }
            return 0;
        }

        function __looksLikeCerebrasUrl(url) {
            const lower = String(url || '').toLowerCase();
            return lower.includes('api.cerebras.ai') || lower.includes('cerebras.ai');
        }

	        function __normalizeOpenAiCompatEndpoint(url) {
	            const raw = String(url || '').trim();
	            if (!raw) return raw;
	            const lower = raw.toLowerCase();

	            // Already a specific endpoint
	            if (lower.includes('/chat/completions')) return raw;

	            // Generic OpenAI-compat bases like ".../v1/solar"
	            if (/\/v1\/[^/]+\/?$/i.test(raw)) return raw.replace(/\/?$/i, '') + '/chat/completions';

	            // Common base URLs: ".../v1" or ".../v1/"
	            if (/\/v1\/?$/i.test(raw)) return raw.replace(/\/v1\/?$/i, '/v1/chat/completions');

            // Some providers expose OpenAI-compat under an "/openai" namespace
            if (/\/openai\/?$/i.test(raw)) return raw.replace(/\/openai\/?$/i, '/openai/chat/completions');

            // Keep as-is otherwise (user may have a custom path)
            return raw;
        }

        function __normalizeOpenAiCompatMessages(messages, { stripImages = false } = {}) {
            const out = [];
            for (const m of (messages || [])) {
                const role = m?.role;
                const content = m?.content;
                if (!Array.isArray(content)) {
                    out.push(m);
                    continue;
                }
                const texts = [];
                content.forEach(part => {
                    if (part?.type === 'text' && part.text) texts.push(String(part.text));
                    // Many OpenAI-compat providers (e.g., Cerebras) are text-only. Strip images safely.
                    if (stripImages && part?.type === 'image_url') {
                        // No-op: drop image parts.
                    }
                });
                out.push({ ...m, role, content: texts.join('\n').trim() });
            }
            return out;
        }

        function __detectLogicalApiError(responseData) {
            if (!responseData || typeof responseData !== 'object') return null;

            // OpenAI-style error
            if (responseData.error) {
                const err = responseData.error;
                const msg = typeof err === 'string'
                    ? err
                    : (err?.message || err?.error?.message || JSON.stringify(err));
                const code = err?.code ?? err?.status ?? err?.http_status ?? err?.httpStatus ?? null;
                const httpStatus = Number.isFinite(code) ? code : null;
                return { message: msg || 'API returned error', httpStatus };
            }

            // Cloudflare-style { success: false, errors: [...] }
            if (responseData.success === false) {
                const errs = Array.isArray(responseData.errors) ? responseData.errors : [];
                const msg = errs.length
                    ? errs.map(e => e?.message || JSON.stringify(e)).join(' | ')
                    : (responseData.message || 'API returned success=false');
                return { message: msg || 'API returned success=false', httpStatus: null };
            }

            // Generic { errors: [...] }
            if (Array.isArray(responseData.errors) && responseData.errors.length) {
                const msg = responseData.errors.map(e => e?.message || JSON.stringify(e)).join(' | ');
                return { message: msg || 'API returned errors[]', httpStatus: null };
            }

            // Nested result error (some gateways)
            if (responseData.result && typeof responseData.result === 'object') {
                const r = responseData.result;
                if (r.success === false) {
                    const errs = Array.isArray(r.errors) ? r.errors : [];
                    const msg = errs.length
                        ? errs.map(e => e?.message || JSON.stringify(e)).join(' | ')
                        : (r.message || 'API returned result.success=false');
                    return { message: msg || 'API returned result.success=false', httpStatus: null };
                }
                if (r.error) {
                    const err = r.error;
                    const msg = typeof err === 'string'
                        ? err
                        : (err?.message || JSON.stringify(err));
                    return { message: msg || 'API returned result.error', httpStatus: null };
                }
            }

            return null;
        }

        async function __pickApiKeyWithBackoff(estTokens) {
            if (!apiKeyManager.hasKeys()) {
                apiKeyManager.setKeys(getApiKeyListFromInput());
            }
            try { __apiKeyLive.syncFromInput(); } catch { }
            const estTokensSafe = Number.isFinite(estTokens) ? Math.max(0, estTokens) : 0;
            const MAX_WAIT_MS = 5 * 60 * 1000; // 5 minutes maximum wait
            const startWaitAt = Date.now();
            while (true) {
                const latestKeys = getApiKeyListFromInput();
                const prevKeys = Array.isArray(apiKeyManager.keys) ? apiKeyManager.keys : [];
                const same = latestKeys.length === prevKeys.length && latestKeys.every((k, i) => k === prevKeys[i]);
                if (!same) apiKeyManager.setKeys(latestKeys);

                const keys = Array.isArray(apiKeyManager.keys) ? apiKeyManager.keys : [];
                if (!keys.length) throw new Error("No API keys configured");
                if (processController.stop) throw new Error("Operation cancelled.");

                // Timeout check: prevent infinite waiting when all keys are in cooldown
                const elapsedMs = Date.now() - startWaitAt;
                if (elapsedMs > MAX_WAIT_MS) {
                    throw new Error(`API key wait timeout (${Math.round(MAX_WAIT_MS / 1000)}s): All keys in cooldown/backoff. Please check API configuration.`);
                }

                const now = Date.now();
                let bestReadyAt = Infinity;
                let bestKeyIdx = -1;
                let chosenKey = null;
                let chosenKeyIdx = -1;
                const startIdx = Number.isFinite(apiKeyManager.idx) ? (apiKeyManager.idx % keys.length) : 0;
                const rateEnabled = !!getEl('enable-rate-limit-input')?.checked;
                const rpmLimit = __normalizeRateLimit(getEl('rpm-limit-input')?.value);
                const tpmLimit = __normalizeRateLimit(getEl('tpm-limit-input')?.value);

                for (let off = 0; off < keys.length; off++) {
                    const idx = (startIdx + off) % keys.length;
                    const k = keys[idx];

                    const cooldownUntil = (() => {
                        try { return __apiKeyLive.getCooldownUntil?.(k); } catch { return null; }
                    })();
                    const cooldownReadyAt = (Number.isFinite(cooldownUntil) && cooldownUntil > now) ? cooldownUntil : now;

                    let rateReadyAt = now;
                    if (rateEnabled) {
                        try {
                            const key = k || '__NO_KEY__';
                            const state = __applySharedRateLimitsForKey(key, { rpmLimitUi: rpmLimit, tpmLimitUi: tpmLimit });
                            __recoverRateStateIfStale(state, now);
                            const effRpmLimit = Number.isFinite(state?.rpmLimit) ? state.rpmLimit : rpmLimit;
                            const effTpmLimit = Number.isFinite(state?.tpmLimit) ? state.tpmLimit : tpmLimit;
                            const effPaceMs = effRpmLimit > 0 ? Math.ceil(60000 / effRpmLimit) : 0;
                            const effGapMs = Math.max(3000, effPaceMs);

                            // (1) Per-key pacing (min gap)
                            const ls = Number.isFinite(state?.lastSentAt) ? state.lastSentAt : 0;
                            const nextByGap = ls ? (ls + effGapMs) : 0;
                            if (nextByGap && now < nextByGap) rateReadyAt = Math.max(rateReadyAt, nextByGap);

                            // (2) Minute RPM/TPM bucket (predict next availability)
                            let windowStart = Number.isFinite(state?.windowStart) ? state.windowStart : __minuteStart(now);
                            let rpm = Number.isFinite(state?.rpm) ? state.rpm : 0;
                            let tpm = Number.isFinite(state?.tpm) ? state.tpm : 0;
                            const win = __minuteStart(now);
                            if (win !== windowStart) {
                                windowStart = win;
                                rpm = 0;
                                tpm = 0;
                            }
                            const isTpmOversize = effTpmLimit > 0 && estTokensSafe > effTpmLimit;
                            const hitRpm = effRpmLimit > 0 && (rpm + 1 > effRpmLimit);
                            const hitTpm = effTpmLimit > 0 && (isTpmOversize ? (tpm >= effTpmLimit) : (tpm + estTokensSafe > effTpmLimit));
                            if (hitRpm || hitTpm) {
                                rateReadyAt = Math.max(rateReadyAt, windowStart + 60000 + 25);
                            }
                        } catch { }
                    }

                    const readyAt = Math.max(cooldownReadyAt, rateReadyAt);
                    if (!chosenKey && readyAt <= now) {
                        chosenKey = k;
                        chosenKeyIdx = idx;
                    }
                    if (readyAt < bestReadyAt) {
                        bestReadyAt = readyAt;
                        bestKeyIdx = idx;
                    }
                }

                if (chosenKey) {
                    // Update index for Round Robin
                    apiKeyManager.idx = (chosenKeyIdx + 1) % keys.length;
                    return chosenKey;
                }

                if (bestReadyAt !== Infinity) {
                    const waitMs = Math.max(0, bestReadyAt - now);
                    await __sleepInterruptible(waitMs);
                    continue;
                }

                // Fallback: if cooldown state is missing for some reason.
                return apiKeyManager.nextKey();
            }
        }

        function __adaptMessagesNoSystem(messages) {
            const systemParts = [];
            const kept = [];
            for (const m of messages) {
                if (m.role === 'system' || m.role === 'developer') systemParts.push(m.content);
                else kept.push({ ...m });
            }
            if (systemParts.length === 0) return kept;

            const prefix = `### INSTRUCTIONS ###\n${systemParts.join('\n\n')}\n\n`;
            const firstUserIdx = kept.findIndex(m => m.role === 'user');
            if (firstUserIdx >= 0) {
                kept[firstUserIdx].content = prefix + kept[firstUserIdx].content;
                return kept;
            }
            return [{ role: 'user', content: prefix.trim() }, ...kept];
        }

        function __extractRequestIdFromHeaders(headers) {
            try {
                if (!headers || typeof headers.get !== 'function') return null;
                const keys = [
                    'x-request-id',
                    'request-id',
                    'openai-request-id',
                    'x-openai-request-id',
                    'x-goog-request-id',
                    'x-amzn-requestid',
                    'x-amz-request-id',
                    'cf-ray',
                ];
                for (const k of keys) {
                    const v = headers.get(k);
                    if (v) return String(v).trim();
                }
            } catch { }
            return null;
        }

        function __summarizeApiPayloadForLog(payload, {
            maxMsgPreviewChars = 900,
            maxMessages = 8,
        } = {}) {
            const p = (payload && typeof payload === 'object') ? payload : {};
            const model = (p.model ?? '').toString();
            const messages = Array.isArray(p.messages) ? p.messages : [];
            const clip = (s, max) => {
                const raw = String(s ?? '');
                const n = Math.max(100, Number(max) || 0);
                if (raw.length <= n) return raw;
                return raw.slice(0, n) + `\nâ€¦ [log preview; total ${raw.length} chars]`;
            };

            let totalChars = 0;
            const parts = [];
            const take = Math.min(messages.length, Math.max(0, maxMessages));
            for (let i = 0; i < take; i++) {
                const m = messages[i] || {};
                const role = String(m.role || '');
                const contentText = __extractTextContent(m.content);
                totalChars += contentText.length;
                parts.push(
                    `[${i}] role=${role || '-'} chars=${contentText.length}\n` +
                    clip(contentText, maxMsgPreviewChars)
                );
            }
            if (messages.length > take) parts.push(`â€¦ (${messages.length - take} more messages omitted)`);
            return `model=${model}\nmessages=${messages.length}, totalCharsâ‰ˆ${totalChars}\n\n${parts.join('\n\n')}`.trim();
        }

        async function resilientLlmRequest(apiPayload, context) {
            if (processController.stop) throw new Error("Operation cancelled.");

            // Keep request options mutable per call so we can auto-downgrade unsupported fields (HTTP 400)
            const basePayload = (apiPayload && typeof apiPayload === 'object') ? apiPayload : {};
            let backoffMs = 1000;
            const requestOptions = {
                temperature: Number.isFinite(basePayload?.temperature) ? basePayload.temperature : null,
                top_p: Number.isFinite(basePayload?.top_p) ? basePayload.top_p : null,
                top_k: Number.isFinite(basePayload?.top_k) ? basePayload.top_k : null,
                max_tokens: Number.isFinite(basePayload?.max_tokens) ? basePayload.max_tokens : null,
                timeoutMs: Number(basePayload?.timeoutMs) || 0,
            };

            let attempt = 0;
            while (true) {
                attempt++;
                if (processController.stop) throw new Error("Operation cancelled.");

                let keyToUse = null;
                let estTokens = 0;
                let keyLivePrepared = false;
                let keyLiveSent = false;
                let keyLiveDone = false;
                let keyRetried = false;
                let inflightAcquired = false;
                let didTimeout = false;
                let timeoutMs = 0;
                let rateWaitMs = 0;
                let latencyMs = 0;
                let monitorCallId = null;
                let requestId = null;
                let fetchStartAt = 0;
                let capEnabled = false;
                let capMessages = null;
                let capBase = null;

                try {
                    logger.info(context, `API call attempt #${attempt}...`);
                    const { apiUrl, model, proxyUrl } = getApiConfig();
                    const rawUrl = (apiUrl || '').trim();
                    const modelName = (model || '').trim().replace(/^models\//i, '');
                    if (!rawUrl || !modelName) throw new Error("API Configuration is incomplete.");

                    const url = rawUrl
                        .replaceAll('{model}', modelName)
                        .replaceAll('{{MODEL}}', modelName);
                    const apiMode = (() => {
                        const lower = url.toLowerCase();
                        if (lower.includes('/ai/run/')) return 'cf_ai_run';
                        if (lower.includes('/ai/v1/responses')) return 'cf_responses';
                        if (lower.includes('/openai/')) return 'openai_chat_completions';
                        if (lower.includes(':generatecontent') || lower.includes(':streamgeneratecontent')) return 'gemini_generatecontent';
                        return 'openai_chat_completions';
                    })();

                    const rawMessages = Array.isArray(basePayload?.messages) ? basePayload.messages : [];
                    let effectiveMessages =
                        (apiMode === 'openai_chat_completions' && __looksLikeCerebrasUrl(url))
                            ? __normalizeOpenAiCompatMessages(rawMessages, { stripImages: true })
                            : rawMessages;

                    if (getEl('bypass-system-role-input')?.checked) {
                        effectiveMessages = __adaptMessagesNoSystem(effectiveMessages);
                    }

                    const messages = effectiveMessages;
                    if (attempt === 1) {
                        try {
                            const summary = __summarizeApiPayloadForLog({ model: modelName, messages });
                            logger.info(context, `API Input (payload):\n${summary}`);
                        } catch { }
                    }

                    capEnabled = (() => { try { return __fullApiCapture?.isEnabled?.() === true; } catch { return false; } })();
                    if (capEnabled) {
                        try { capMessages = __fullApiCapture.sanitizeMessages(messages); } catch { capMessages = null; }
                    }

                    estTokens = __estimateTokensFromMessages(messages);

                    // (1) Pick Key
                    keyToUse = await __pickApiKeyWithBackoff(estTokens);

                    // (2) Prepare & Monitor Start
                    try { __apiKeyLive.onPrepare(keyToUse, { uniqueId: context, estTokens }); keyLivePrepared = true; } catch { }

                    // IMMEDIATE MONITOR START: Show WAITING before rate wait
                    try {
                        monitorCallId = __apiMonitor.startCall({
                            ts: Date.now(),
                            key: maskKey(keyToUse),
                            context,
                            estTokens,
                            message: 'WAITING',
                        });
                    } catch { }

                    // (3) Rate Limit & Inflight Slot
                    const rateWaitStart = Date.now();
                    await __acquireRateSlot(keyToUse, estTokens); // includes per-key inflight gating
                    rateWaitMs = Math.max(0, Date.now() - rateWaitStart);
                    inflightAcquired = true;

                    // (4) Mark Sent
                    try { __apiKeyLive.onSent(keyToUse, { uniqueId: context, estTokens }); keyLiveSent = true; } catch { }

                    // Update monitor: we are past the rate wait; assembling request (not sent yet)
                    try {
                        if (Number.isFinite(monitorCallId)) {
                            __apiMonitor.updateCall?.(monitorCallId, { state: 'waiting', message: 'SENDING' });
                        }
                    } catch { }

                    let requestUrl = url;
                    let headers = { 'Content-Type': 'application/json' };
                    let body = null;
                    if (apiMode === 'gemini_generatecontent') {
                        const gem = __toGeminiPayload(messages);
                        requestUrl = (() => {
                            try {
                                const parsed = new URL(url);
                                parsed.searchParams.set('key', keyToUse);
                                return parsed.toString();
                            } catch {
                                const sep = url.includes('?') ? '&' : '?';
                                return `${url}${sep}key=${encodeURIComponent(keyToUse)}`;
                            }
                        })();
                        const generationConfig = {
                            temperature: Number.isFinite(requestOptions?.temperature) ? requestOptions.temperature : 0.7
                        };
                        if (Number.isFinite(requestOptions?.top_p)) generationConfig.topP = requestOptions.top_p;
                        if (Number.isFinite(requestOptions?.top_k)) generationConfig.topK = requestOptions.top_k;
                        if (Number.isFinite(requestOptions?.max_tokens)) generationConfig.maxOutputTokens = requestOptions.max_tokens;
                        body = { contents: gem.contents, generationConfig };
                        if (gem.systemInstruction) body.systemInstruction = gem.systemInstruction;
                    } else if (apiMode === 'cf_ai_run') {
                        headers = { ...headers, 'Authorization': `Bearer ${keyToUse}` };
                        const cf = __toCfResponsesPayload(messages);
                        body = { input: cf.inputText || '' };
                        body.stream = true; // streaming helps avoid long-call timeouts (SSE supported)
                        if (Number.isFinite(requestOptions?.temperature)) body.temperature = requestOptions.temperature;
                    } else if (apiMode === 'cf_responses') {
                        const cf = __toCfResponsesPayload(messages);
                        headers = { ...headers, 'Authorization': `Bearer ${keyToUse}` };
                        body = { model: modelName, input: cf.inputText || '' };
                        body.stream = true; // streaming helps avoid long-call timeouts (SSE supported)
                        if (Number.isFinite(requestOptions?.temperature)) body.temperature = requestOptions.temperature;
                    } else {
                        headers = { ...headers, 'Authorization': `Bearer ${keyToUse}` };
                        requestUrl = __normalizeOpenAiCompatEndpoint(requestUrl);
                        body = { model: modelName, messages };
                        body.stream = false;
                        if (Number.isFinite(requestOptions?.temperature)) body.temperature = requestOptions.temperature;
                        if (Number.isFinite(requestOptions?.top_p)) body.top_p = requestOptions.top_p;
                        if (Number.isFinite(requestOptions?.top_k)) body.top_k = requestOptions.top_k;
                        if (Number.isFinite(requestOptions?.max_tokens)) body.max_tokens = requestOptions.max_tokens;
                    }

                    const proxy = (proxyUrl || '').trim();
                    if (proxy) {
                        const targetUrl = requestUrl;
                        const encodedTarget = encodeURIComponent(targetUrl);
                        if (proxy.includes('{url}') || proxy.includes('{{URL}}')) {
                            requestUrl = proxy.replaceAll('{url}', encodedTarget).replaceAll('{{URL}}', encodedTarget);
                        } else {
                            const targetHeaders = { ...headers };
                            requestUrl = proxy;
                            headers = { 'Content-Type': 'application/json' };
                            body = {
                                url: targetUrl,
                                method: 'POST',
                                headers: targetHeaders,
                                body
                            };
                        }
                    }

                    // Timeout: default 5 minutes, minimum 10 seconds (aligned with general-test)
                    const DEFAULT_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes
                    const MIN_TIMEOUT_MS = 10 * 1000; // 10 seconds minimum
                    const userTimeoutMs = Number(requestOptions?.timeoutMs) || 0;
                    const clientTimeoutMs = userTimeoutMs > 0 ? Math.max(MIN_TIMEOUT_MS, userTimeoutMs) : DEFAULT_TIMEOUT_MS;
                    timeoutMs = Math.min(clientTimeoutMs, DEFAULT_TIMEOUT_MS); // cap at 5 minutes
                    const abortCtl = new AbortController();
                    let timeoutId = null;
                    const timeoutPromise = timeoutMs > 0
                        ? new Promise((_, reject) => {
                            timeoutId = setTimeout(() => {
                                didTimeout = true;
                                try { abortCtl.abort(); } catch { }
                                reject(new Error(`Timeout (${Math.round(timeoutMs / 1000)}s)`));
                            }, timeoutMs);
                        })
                        : new Promise(() => { });

                    let response = null;
                    let responseData = null;
                    let fetchPromise = null;
                    let bodyPromise = null;
                    try {
                        fetchStartAt = Date.now();
                        const safeUrlForLog = (() => {
                            try {
                                const s = String(requestUrl || '');
                                return s.replace(/([?&]key=)[^&]+/gi, '$1***');
                            } catch { return ''; }
                        })();
                        if (capEnabled) {
                            capBase = {
                                ts: Date.now(),
                                context,
                                attempt,
                                apiMode,
                                model: modelName,
                                url: safeUrlForLog || '',
                                estTokens,
                                rateWaitMs,
                                timeoutMs,
                                options: {
                                    temperature: Number.isFinite(requestOptions?.temperature) ? requestOptions.temperature : null,
                                    top_p: Number.isFinite(requestOptions?.top_p) ? requestOptions.top_p : null,
                                    top_k: Number.isFinite(requestOptions?.top_k) ? requestOptions.top_k : null,
                                    max_tokens: Number.isFinite(requestOptions?.max_tokens) ? requestOptions.max_tokens : null,
                                },
                                messages: capMessages,
                            };
                        }
                        logger.info(
                            context,
                            `â†’ API Request Sent (mode=${apiMode}, url=${safeUrlForLog || '(n/a)'}, key=${maskKey(keyToUse)}, estTokens=${estTokens}, rateWaitMs=${rateWaitMs}, timeoutMs=${timeoutMs})`
                        );
                        const bodyJson = JSON.stringify(body);
                        fetchPromise = fetch(requestUrl, {
                            method: 'POST',
                            headers,
                            body: bodyJson,
                            signal: abortCtl.signal,
                        });
                        try {
                            if (Number.isFinite(monitorCallId)) {
                                __apiMonitor.updateCall?.(monitorCallId, { state: 'inflight', message: 'INFLIGHT' });
                            }
                        } catch { }
                        response = await Promise.race([fetchPromise, timeoutPromise]);
                        latencyMs = Math.max(0, Date.now() - fetchStartAt);
                        requestId = __extractRequestIdFromHeaders(response?.headers);

                        if (!response.ok) {
                            let errorBody = '';
                            try {
                                bodyPromise = response.text();
                                errorBody = await Promise.race([bodyPromise, timeoutPromise]);
                            } catch { }

                            const errLower = (errorBody || '').toLowerCase();
                            if (response.status === 400) {
                                const mentionsTopK = errLower.includes('topk') || errLower.includes('top_k');
                                const mentionsTopP = errLower.includes('topp') || errLower.includes('top_p');
                                const mentionsMax = errLower.includes('maxoutputtokens') || errLower.includes('max_output_tokens') || errLower.includes('max_tokens');

                                if (Number.isFinite(requestOptions.top_k) && mentionsTopK) {
                                    logger.warn(context, `API rejected top_k/topK; retrying without top_k.`);
                                    try {
                                        if (capEnabled && capBase) __fullApiCapture.append({
                                            ...capBase,
                                            ok: false,
                                            httpStatus: response.status,
                                            requestId,
                                            latencyMs,
                                            error: 'HTTP 400 (drop top_k)',
                                            errorBody: String(errorBody || '').slice(0, 30000),
                                        });
                                    } catch { }
                                    requestOptions.top_k = null;
                                    try { __apiKeyLive.onDone(keyToUse, { uniqueId: context, httpStatus: response.status, message: `HTTP ${response.status}` }); keyLiveDone = true; } catch { }
                                    try { __apiMonitor.finishCall(monitorCallId, { ts: Date.now(), ok: false, httpStatus: response.status, key: maskKey(keyToUse), context, estTokens, latencyMs, requestId, message: 'HTTP 400 (drop top_k)' }); } catch { }
                                    await __sleepInterruptible(80);
                                    continue;
                                }
                                if (Number.isFinite(requestOptions.top_p) && mentionsTopP) {
                                    logger.warn(context, `API rejected top_p/topP; retrying without top_p.`);
                                    try {
                                        if (capEnabled && capBase) __fullApiCapture.append({
                                            ...capBase,
                                            ok: false,
                                            httpStatus: response.status,
                                            requestId,
                                            latencyMs,
                                            error: 'HTTP 400 (drop top_p)',
                                            errorBody: String(errorBody || '').slice(0, 30000),
                                        });
                                    } catch { }
                                    requestOptions.top_p = null;
                                    try { __apiKeyLive.onDone(keyToUse, { uniqueId: context, httpStatus: response.status, message: `HTTP ${response.status}` }); keyLiveDone = true; } catch { }
                                    try { __apiMonitor.finishCall(monitorCallId, { ts: Date.now(), ok: false, httpStatus: response.status, key: maskKey(keyToUse), context, estTokens, latencyMs, requestId, message: 'HTTP 400 (drop top_p)' }); } catch { }
                                    await __sleepInterruptible(80);
                                    continue;
                                }
                                if (Number.isFinite(requestOptions.max_tokens) && mentionsMax) {
                                    logger.warn(context, `API rejected max_tokens/maxOutputTokens; retrying without max_tokens.`);
                                    try {
                                        if (capEnabled && capBase) __fullApiCapture.append({
                                            ...capBase,
                                            ok: false,
                                            httpStatus: response.status,
                                            requestId,
                                            latencyMs,
                                            error: 'HTTP 400 (drop max_tokens)',
                                            errorBody: String(errorBody || '').slice(0, 30000),
                                        });
                                    } catch { }
                                    requestOptions.max_tokens = null;
                                    try { __apiKeyLive.onDone(keyToUse, { uniqueId: context, httpStatus: response.status, message: `HTTP ${response.status}` }); keyLiveDone = true; } catch { }
                                    try { __apiMonitor.finishCall(monitorCallId, { ts: Date.now(), ok: false, httpStatus: response.status, key: maskKey(keyToUse), context, estTokens, latencyMs, requestId, message: 'HTTP 400 (drop max_tokens)' }); } catch { }
                                    try { __callStats.recordFailCall({ context, reason: 'HTTP 400 (drop)' }); } catch { }
                                    await __sleepInterruptible(backoffMs);
                                    backoffMs = Math.min(30000, backoffMs * 2);
                                    continue;
                                }
                            }

                            apiKeyManager.consecutiveErrors[keyToUse] = (apiKeyManager.consecutiveErrors[keyToUse] || 0) + 1;
                            try { __apiKeyLive.onDone(keyToUse, { uniqueId: context, httpStatus: response.status, message: `HTTP ${response.status}` }); keyLiveDone = true; } catch { }
                            try { __apiKeyLive.onRetry(keyToUse, { httpStatus: response.status }); keyRetried = true; } catch { }
                            logger.warn(context, `API Error: HTTP ${response.status} ${response.statusText}. Retrying with another key (if available).`);
                            const errBodyText = (errorBody || '').toString();
                            if (errBodyText) logger.warn(context, `API Error Body (HTTP ${response.status}, requestId=${requestId || 'n/a'}):\n${errBodyText}`);
                            try {
                                if (capEnabled && capBase) __fullApiCapture.append({
                                    ...capBase,
                                    ok: false,
                                    httpStatus: response.status,
                                    requestId,
                                    latencyMs,
                                    error: `HTTP ${response.status} ${response.statusText}`.trim(),
                                    errorBody: String(errorBody || '').slice(0, 30000),
                                });
                            } catch { }
                            try {
                                __apiMonitor.finishCall(monitorCallId, {
                                    ts: Date.now(),
                                    ok: false,
                                    httpStatus: response.status,
                                    key: maskKey(keyToUse),
                                    context,
                                    estTokens,
                                    latencyMs,
                                    requestId,
                                    message: `HTTP ${response.status} ${response.statusText}`.trim(),
                                });
                                try { __callStats.recordFailCall({ context, reason: `HTTP ${response.status}` }); } catch { }
                            } catch { }
                            try {
                                logger.warn(
                                    context,
                                    `â† API Error Response (mode=${apiMode}, HTTP ${response.status}, latencyMs=${latencyMs}, requestId=${requestId || 'n/a'})`
                                );
                            } catch { }
                            await __sleepInterruptible(backoffMs);
                            backoffMs = Math.min(30000, backoffMs * 2);
                            continue;
                        }

                        const ct = String(response?.headers?.get('content-type') || '').toLowerCase();
                        bodyPromise = response.text();
                        const rawBodyText = await Promise.race([bodyPromise, timeoutPromise]);
                        if (__looksLikeSseText(rawBodyText) || ct.includes('text/event-stream') || ct.includes('event-stream')) {
                            const assembled = __assembleTextFromSse(rawBodyText);
                            responseData = __wrapTextResponseForMode(assembled, apiMode);
                        } else {
                            try {
                                responseData = JSON.parse(rawBodyText);
                            } catch (e) {
                                // Some proxies/providers return plain text on 200
                                responseData = __wrapTextResponseForMode(rawBodyText, apiMode);
                            }
                        }
} finally {
                        if (timeoutId) {
                            try { clearTimeout(timeoutId); } catch { }
                            timeoutId = null;
                        }
                    }

                    const logicalErr = __detectLogicalApiError(responseData);
                    if (logicalErr) {
                        const e = new Error(logicalErr.message || 'API returned error');
                        if (Number.isFinite(logicalErr.httpStatus)) e.httpStatus = logicalErr.httpStatus;
                        throw e;
                    }

                    // Reset error count on success
                    apiKeyManager.consecutiveErrors[keyToUse] = 0;
                    const rawResponseText = apiMode === 'gemini_generatecontent'
                        ? (responseData?.candidates?.[0]?.content?.parts || []).map(p => p?.text || '').join('')
                        : (apiMode === 'cf_ai_run' || apiMode === 'cf_responses')
                            ? __extractCfResponseText(responseData, apiMode)
                            : (responseData.choices?.[0]?.message?.content || "");

                    const cleaned = __sanitizeModelText(rawResponseText || "");
                    if (!cleaned) {
                        const e = new Error('Empty response content');
                        e.httpStatus = Number.isFinite(response?.status) ? response.status : 0;
                        throw e;
                    }
                    try {
                        const maxChars = 7000;
                        const preview = (cleaned.length <= maxChars)
                            ? cleaned
                            : (cleaned.slice(0, maxChars) + `\nâ€¦ [log preview; total ${cleaned.length} chars]`);
                        logger.info(context, `API Raw Output:\n${preview}`);
                    } catch { }
                    logger.success(
                        context,
                        `API OK (mode=${apiMode}, HTTP ${response.status}, estTokens=${estTokens}, actualTokens=${__extractActualTokens(responseData)}, latencyMs=${latencyMs}, requestId=${requestId || 'n/a'})`
                    );

                    try { __apiKeyLive.onDone(keyToUse, { uniqueId: context, httpStatus: response.status, message: 'OK' }); keyLiveDone = true; } catch { }

                    const actualTokens = __extractActualTokens(responseData);
                    __reconcileTokens(keyToUse, estTokens, actualTokens);

                    successfulApiCallCount++;
                    try { __callStats.recordOkCall({ context, estTokens, actualTokens, latencyMs }); } catch { }
                    updateApiCallCounter();

                    // FINISH MONITOR ON SUCCESS
                    try {
                        __apiMonitor.finishCall(monitorCallId, {
                            ts: Date.now(),
                            ok: true,
                            httpStatus: response.status,
                            key: maskKey(keyToUse),
                            context,
                            estTokens,
                            actualTokens,
                            latencyMs,
                            requestId,
                            message: 'OK',
                        });
                    } catch { }

                    // Added detailed log
                    try {
                        logger.info(
                            context,
                            `â† API Response Received (mode=${apiMode}, HTTP ${response.status}, latencyMs=${latencyMs}, requestId=${requestId || 'n/a'})`
                        );
                    } catch { }
                    try {
                        if (capEnabled && capBase) __fullApiCapture.append({
                            ...capBase,
                            ok: true,
                            httpStatus: response.status,
                            requestId,
                            latencyMs,
                            actualTokens,
                            responseText: cleaned,
                        });
                    } catch { }
                    return cleaned;

                } catch (error) {
                    try {
                        if (Number.isFinite(fetchStartAt) && fetchStartAt > 0) {
                            latencyMs = Math.max(0, Date.now() - fetchStartAt);
                        }
                    } catch { }
                    const msgRaw = (error?.message || error || '').toString();
                    const msg = didTimeout
                        ? `Timeout (${Math.round((Number.isFinite(timeoutMs) ? timeoutMs : 0) / 1000)}s)`
                        : msgRaw;
                    const low = msg.toLowerCase();
                    const isCancelled = processController.stop || low.includes('cancelled') || low.includes('canceled') || low.includes('stopped by user');

                    if (keyToUse) {
                        apiKeyManager.consecutiveErrors[keyToUse] = (apiKeyManager.consecutiveErrors[keyToUse] || 0) + 1;
                        let httpStatus = Number.isFinite(error?.httpStatus) ? error.httpStatus : null;
                        if (!Number.isFinite(httpStatus)) {
                            const m = msg.match(/HTTP\s+(\d{3})/i);
                            if (m) httpStatus = parseInt(m[1], 10);
                        }

                        // If we were canceled while waiting (prepare done, sent not done), reconcile pendingCount.
                        if (isCancelled && keyLivePrepared && !keyLiveSent) {
                            try { __apiKeyLive.onSent(keyToUse, { uniqueId: context, estTokens }); keyLiveSent = true; } catch { }
                        }

                        const doneMsg = isCancelled ? 'Stopped by User' : (msg || 'Error');
                        if (!keyLiveDone) {
                            try { __apiKeyLive.onDone(keyToUse, { uniqueId: context, httpStatus, message: doneMsg }); keyLiveDone = true; } catch { }
                        }
                        if (!isCancelled && !keyRetried) {
                            try { __apiKeyLive.onRetry(keyToUse, { httpStatus }); keyRetried = true; } catch { }
                        }
                        try {
                            __apiMonitor.finishCall(monitorCallId, {
                                ts: Date.now(),
                                ok: false,
                                httpStatus,
                                key: maskKey(keyToUse),
                                context,
                                estTokens,
                                latencyMs,
                                requestId,
                                message: doneMsg.slice(0, 200),
                            });
                            try { __callStats.recordFailCall({ context, reason: doneMsg }); } catch { }
                        } catch { }
                        try {
                            logger.warn(
                                context,
                                `â† API Exception (httpStatus=${Number.isFinite(httpStatus) ? httpStatus : 'n/a'}, latencyMs=${latencyMs}, requestId=${requestId || 'n/a'}): ${doneMsg}`
                            );
                        } catch { }
                        try {
                            if (__fullApiCapture?.isEnabled?.()) {
                                __fullApiCapture.append({
                                    ...(capBase || {
                                        ts: Date.now(),
                                        context,
                                        attempt,
                                        apiMode: '',
                                        model: '',
                                        url: '',
                                        estTokens,
                                        rateWaitMs,
                                        timeoutMs,
                                        options: {},
                                        messages: capMessages,
                                    }),
                                    ok: false,
                                    httpStatus,
                                    requestId,
                                    latencyMs,
                                    error: doneMsg,
                                    didTimeout: !!didTimeout,
                                });
                            }
                        } catch { }
                        if (!isCancelled) await __sleepInterruptible(80);
                    } else if (!isCancelled) {
                        await __sleepInterruptible(200);
                    }

                    if (isCancelled) throw new Error("Operation cancelled.");
                    logger.warn(context, `Attempt #${attempt} failed: ${msg || error}. Retrying...`);
                } finally {
                    if (inflightAcquired && keyToUse) {
                        try { __releaseInflightSlot(keyToUse); } catch { }
                    }
                }
            }
        }

        /**
         * Run a list of jobs with fixed concurrency.
         * @param {Array<any>} jobs
         * @param {function(any, number): Promise<any>} processJob
         * @param {number} concurrency
         * @returns {Promise<{results: any[], errors: Array<{job:any, error:any}>}>}
         */
        async function runWithConcurrency(jobs, processJob, concurrency = 5) {
            logger.info("Concurrency_Debug", `runWithConcurrency started with ${jobs.length} jobs and concurrency=${concurrency}.`);

            const jobQueue = jobs.slice();
            const results = [];
            const errors = [];
            let completed = 0;
            const total = jobQueue.length;

            async function worker(workerId) {
                logger.info(`Concurrency-W${workerId}`, `Worker starting. Job queue size: ${jobQueue.length}.`);
                while (jobQueue.length > 0) {
                    if (processController.stop) {
                        logger.warn(`Concurrency-W${workerId}`, `Stop signal received. Exiting worker.`);
                        break;
                    }
                    const job = jobQueue.shift();
                    if (!job) {
                        logger.warn(`Concurrency-W${workerId}`, `Shifted a null/undefined job, skipping.`);
                        continue;
                    }

                    logger.info(`Concurrency-W${workerId}`, `Took job: ${JSON.stringify(job)}`);

                    try {
                        const res = await processJob(job, workerId);
                        results.push(res);
                    } catch (err) {
                        if (!err.message.toLowerCase().includes('cancelled')) {
                            logger.error(`Concurrency-W${workerId}`, `Job failed: ${JSON.stringify(job)}. Error: ${err.message}`);
                            errors.push({ job, error: err });
                        } else {
                            logger.warn(`Concurrency-W${workerId}`, `Job was cancelled.`);
                        }
                    } finally {
                        completed++;
                        logger.info(`Concurrency-W${workerId}`, `Finished job. Progress: ${completed}/${total}.`);
                    }
                }
                logger.info(`Concurrency-W${workerId}`, `Worker finished. No more jobs in queue.`);
            }

            const workerCount = Math.min(concurrency, Math.max(1, jobQueue.length));
            logger.info("Concurrency_Debug", `Spawning ${workerCount} workers.`);
            const workers = Array.from({ length: workerCount }, (_, i) => worker(i + 1));
            await Promise.all(workers);
            if (processController.stop) { throw new Error("Operation cancelled."); }

            logger.info("Concurrency_Debug", `runWithConcurrency finished. Results: ${results.length}, Errors: ${errors.length}.`);
            return { results, errors };
        }

        function getWorkerConcurrency() {
            const override = getGlobalKeySplitCountOverride();
            const keyCount = getApiKeyListFromInput().length;
            const auto = keyCount > 0 ? keyCount : 1;
            const desired = Number.isFinite(override) ? Math.max(1, override) : auto;
            if (keyCount > 0) return Math.min(desired, keyCount);
            return desired;
        }

        /**
         * Chunk problems respecting problem boundaries and token limits
         * @param {Array} problems - Array of problem objects with qid, question_text, answer_choices, paperName, etc.
         * @param {number} maxTokensPerChunk - Maximum tokens per chunk (default DEFAULT_CHUNK_TOKENS)
         * @param {string} chunkMode - 'file_first' (group by file first) or 'sequential' (original behavior)
         * @returns {Array<Array>} - Array of problem chunks
         */
        function chunkProblemsRespectingBoundaries(problems, maxTokensPerChunk = DEFAULT_CHUNK_TOKENS, chunkMode = 'file_first') {
            // Use actual tokenizer if available, otherwise fallback
            const estimateProblemTokens = (problem) => {
                const officialExp = problem.official_explanation
                    ? `\n[Official Explanation]\n${problem.official_explanation}`
                    : '';
                const problemText = `${problem.qid}:\n${problem.question_text}\n${problem.answer_choices ? 'Choices: ' + problem.answer_choices : ''}${officialExp}\n---`;
                return __estimateTokens(problemText);
            };

            // For file_first mode, group problems by paperName first
            if (chunkMode === 'file_first') {
                // Group problems by paperName
                const byFile = {};
                for (const problem of problems) {
                    const key = problem.paperName || problem.qid?.split('::')[0] || '__unknown__';
                    if (!byFile[key]) byFile[key] = [];
                    byFile[key].push(problem);
                }

                const chunks = [];
                let currentChunk = [];
                let currentChunkSize = 0;

                // Process file by file
                for (const [fileName, fileProblems] of Object.entries(byFile)) {
                    const fileTotalSize = fileProblems.reduce((sum, p) => sum + estimateProblemTokens(p), 0);

                    // If adding entire file would exceed limit and current chunk is not empty
                    if (currentChunkSize + fileTotalSize > maxTokensPerChunk && currentChunk.length > 0) {
                        chunks.push(currentChunk);
                        currentChunk = [];
                        currentChunkSize = 0;
                    }

                    // If entire file fits in remaining space OR current chunk is empty
                    if (currentChunkSize + fileTotalSize <= maxTokensPerChunk || currentChunk.length === 0) {
                        // Try to add entire file
                        if (fileTotalSize <= maxTokensPerChunk) {
                            currentChunk.push(...fileProblems);
                            currentChunkSize += fileTotalSize;
                        } else {
                            // File is too large, need to split within file (fallback to sequential within file)
                            if (currentChunk.length > 0) {
                                chunks.push(currentChunk);
                                currentChunk = [];
                                currentChunkSize = 0;
                            }
                            // Split this large file's problems sequentially
                            for (const problem of fileProblems) {
                                const problemSize = estimateProblemTokens(problem);
                                if (problemSize > maxTokensPerChunk) {
                                    if (currentChunk.length > 0) {
                                        chunks.push(currentChunk);
                                        currentChunk = [];
                                        currentChunkSize = 0;
                                    }
                                    chunks.push([problem]);
                                    logger.warn("Chunking", `Problem ${problem.qid} exceeds chunk limit but cannot be split.`);
                                    continue;
                                }
                                if (currentChunkSize + problemSize > maxTokensPerChunk && currentChunk.length > 0) {
                                    chunks.push(currentChunk);
                                    currentChunk = [problem];
                                    currentChunkSize = problemSize;
                                } else {
                                    currentChunk.push(problem);
                                    currentChunkSize += problemSize;
                                }
                            }
                        }
                    }
                }

                if (currentChunk.length > 0) {
                    chunks.push(currentChunk);
                }

                logger.info("Chunking", `file_first mode: ${Object.keys(byFile).length} files â†’ ${chunks.length} chunks`);
                return chunks;
            }

            // Original sequential mode
            const chunks = [];
            let currentChunk = [];
            let currentChunkSize = 0;

            for (const problem of problems) {
                const problemSize = estimateProblemTokens(problem);

                if (problemSize > maxTokensPerChunk) {
                    if (currentChunk.length > 0) {
                        chunks.push(currentChunk);
                        currentChunk = [];
                        currentChunkSize = 0;
                    }
                    chunks.push([problem]);
                    logger.warn("Chunking", `Problem ${problem.qid} (${problemSize} tokens) exceeds chunk limit but cannot be split.`);
                    continue;
                }

                if (currentChunkSize + problemSize > maxTokensPerChunk && currentChunk.length > 0) {
                    chunks.push(currentChunk);
                    currentChunk = [problem];
                    currentChunkSize = problemSize;
                } else {
                    currentChunk.push(problem);
                    currentChunkSize += problemSize;
                }
            }

            if (currentChunk.length > 0) {
                chunks.push(currentChunk);
            }

            return chunks;
        }

        /**
         * Convert problem array to text for LLM
         */
        function problemsToText(problems) {
            return problems.map(q =>
                `${q.qid}:\n${q.question_text}\n${q.answer_choices ? 'Choices: ' + q.answer_choices : ''}\n---`
            ).join('\n\n');
        }

        // Interleave each problem with its official explanation (if present).
        function problemsToTextInterleaved(arr) {
            return (arr || []).map(q => {
                const header =
                    `${q.qid}:
	${q.question_text}
	${q.answer_choices ? 'Choices: ' + q.answer_choices : ''}`;
                const officialExp = q.official_explanation
                    ? `\n[Official Explanation]\n${q.official_explanation}`
                    : '';
                return `${header}${officialExp}\n---`;
            }).join('\n\n');
        }

        const COVERAGE_MAX_TOKENS_DEFAULT = 10000;
        const COVERAGE_PATCH_MAX_ROUNDS = 3;

        function splitArrayByCount(items, size) {
            const out = [];
            const n = Math.max(1, size || 1);
            for (let i = 0; i < items.length; i += n) out.push(items.slice(i, i + n));
            return out;
        }

        function buildNormalizedMap(text) {
            const map = [];
            let norm = '';
            for (let i = 0; i < text.length; i++) {
                const ch = text[i];
                if (/[0-9A-Za-zê°€-í£]/.test(ch)) {
                    map.push(i);
                    norm += ch.toLowerCase();
                }
            }
            return { norm, map };
        }

        function normalizeSnippet(text) {
            return String(text || '')
                .replace(/[^0-9A-Za-zê°€-í£]+/g, '')
                .toLowerCase();
        }

        function findSnippetRange(text, snippet, fromIndex = 0) {
            const raw = String(snippet || '');
            if (!raw.trim()) return null;
            const sub = text.slice(fromIndex);

            // 1. Exact match (fast)
            const exactIdx = sub.indexOf(raw);
            if (exactIdx !== -1) {
                return { start: fromIndex + exactIdx, end: fromIndex + exactIdx + raw.length };
            }

            // 2. Exact match with whitespace normalization
            // Collapses multiple spaces/newlines to single space for comparison
            const normText = sub.replace(/\s+/g, ' ');
            const normSnippet = raw.replace(/\s+/g, ' ');
            const normIdx = normText.indexOf(normSnippet);
            // This is hard to map back to original indices exactly without a map.
            // Falling back to existing aggressive normalization if exact fails.

            // 3. Aggressive normalization (slow but robust)
            const sn = normalizeSnippet(raw);
            if (!sn) return null;
            const normalized = buildNormalizedMap(sub);
            const idx = normalized.norm.indexOf(sn);
            if (idx === -1) return null;
            const start = normalized.map[idx];
            const end = normalized.map[idx + sn.length - 1] + 1;
            return { start: fromIndex + start, end: fromIndex + end };
        }

        function buildSectionAnchors() {
            return [
                { name: 'Concept Explanation', re: /1\.\s*\*\*Concept Explanation\*\*/i },
                { name: 'Standard Problem Explanation', re: /2\.\s*\*\*Standard Problem Explanation\*\*/i },
                { name: 'Question Patterns & Examinerâ€™s Win Conditions', re: /3\.\s*\*\*Question Patterns\s*&\s*Examiner.?s Win Conditions\*\*/i },
                { name: 'Study Method', re: /4\.\s*\*\*Study Method\*\*/i },
            ];
        }

        //======================================================================
        // 2.x. HYGIENE (Markdown formatting + extraction de-dupe helpers)
        //======================================================================
        // BEGIN_FMM_HYGIENE (used by tests via Node/VM extraction)
        (function (root) {
            const fenceRe = /^\s*```/;
            const normalizeNewlines = (s) => String(s ?? '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');

            const stripForCompare = (s) => String(s ?? '')
                .replace(/`[^`]*`/g, '')     // remove inline code spans
                .replace(/\*\*([^*]+)\*\*/g, '$1')
                .replace(/__([^_]+)__/g, '$1')
                .replace(/\s+/g, '')
                .toLowerCase();

            const choiceStartRe = /^\s*(?:Choices\s*:|ì„ ì§€\s*:|\[ì„ ì§€\]|\(ì„ ì§€\))/i;
            const choiceMarkerRe = /^\s*(?:[A-E]\s*[\)\.]|[â‘ -â‘³]|[0-9]{1,2}\s*[\)\.]|[ê°€-ë¼]\s*[\)\.]|[ã„±-ã…]\s*[\)\.]|[ã„±-ã…]\s*\.|\(\s*[ã„±-ã…]\s*\))\s*/;
            const firstChoiceMarkerIndex = (lines) => {
                for (let i = 0; i < lines.length; i++) {
                    const ln = lines[i] || '';
                    if (choiceStartRe.test(ln) || choiceMarkerRe.test(ln)) return i;
                }
                return -1;
            };

            const lintMarkdown = (text) => {
                const issues = [];
                const lines = normalizeNewlines(text).split('\n');
                let inFence = false;
                let prevWasTable = false;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i] ?? '';
                    if (fenceRe.test(line.trim())) inFence = !inFence;
                    if (inFence) { prevWasTable = false; continue; }

                    // Two list items on one line (common broken patch symptom)
                    if (/(\S)(\s*[*+-]\s+\*\*)/.test(line) || /(\S)(\s*\d+\.\s+\*\*)/.test(line) || /(\S)(\s*[*+-]\s{2,})(?=\S)/.test(line)) {
                        issues.push({ kind: 'merged_list_items', line: i + 1, sample: line.slice(0, 240) });
                    }
                    // Two table rows on one line (common broken patch symptom)
                    if (/^\s*\|/.test(line) && /\|\|\s*\d/.test(line)) {
                        issues.push({ kind: 'merged_table_rows', line: i + 1, sample: line.slice(0, 240) });
                    }
                    // Table block with missing header separator row
                    {
                        const isRow = /^\s*\|/.test(line);
                        const next = lines[i + 1] ?? '';
                        const nextIsRow = /^\s*\|/.test(next);
                        const nextIsSep = /^\s*\|\s*:?-{3,}/.test(String(next).trim());
                        if (!prevWasTable && isRow && nextIsRow && !nextIsSep) {
                            issues.push({ kind: 'table_missing_separator', line: i + 1, sample: line.slice(0, 240) });
                        }
                        prevWasTable = isRow;
                    }
                    // Backticks wrapping LaTeX (rendering killer)
                    if (/`+\s*\$\$?[\s\S]*?\$\$?\s*`+/.test(line)) {
                        issues.push({ kind: 'latex_in_backticks', line: i + 1, sample: line.slice(0, 240) });
                    }
                    // Non-Latin subscripts without \text{...}
                    if (/_\{[ê°€-í£][^}]*\}/.test(line) || /\^\{[ê°€-í£][^}]*\}/.test(line)) {
                        issues.push({ kind: 'nonlatin_subscript_without_text', line: i + 1, sample: line.slice(0, 240) });
                    }
                }
                return issues;
            };

            const fixMarkdown = (text) => {
                const input = normalizeNewlines(text);
                const lines = input.split('\n');
                const out = [];
                let inFence = false;
                let fixCount = 0;

                const fixLine = (line) => {
                    let s = String(line ?? '');

                    // Preserve leading blockquote prefix when we insert newlines.
                    // Without this, a line like "> **Tip** * **A**: ..." gets split into:
                    //   "> **Tip**\n* **A**: ..."
                    // which escapes the blockquote and creates empty ">" lines.
                    const bqMatch = s.match(/^(\s*(?:>\s*)+)(.*)$/);
                    const bqPrefix = bqMatch ? bqMatch[1] : '';
                    let body = bqMatch ? bqMatch[2] : s;

                    // Unwrap LaTeX accidentally wrapped in backticks: `$...$` or `$$...$$`
                    // (Only unwrap when the code span is purely LaTeX-delimited.)
                    {
                        const beforeLatex = body;
                        body = body.replace(/`(\$\$?[^`]*?\$\$?)`/g, '$1');
                        if (body !== beforeLatex) fixCount++;
                    }

                    // Fix common LaTeX hygiene: non-Latin subscripts/superscripts should use \text{...}
                    {
                        const beforeText = body;
                        body = body
                            .replace(/_\{([ê°€-í£\s]+)\}/g, '_{\\text{$1}}')
                            .replace(/\^\{([ê°€-í£\s]+)\}/g, '^{\\text{$1}}');
                        if (body !== beforeText) fixCount++;
                    }

                    // Split merged table rows like: "... | ... || 10.1 | ..."
                    if (/^\s*\|/.test(body) && /\|\|\s*\d/.test(body)) {
                        const next = body.replace(/\|\|\s*(?=\d)/g, '|\n|');
                        if (next !== body) { body = next; fixCount++; }
                    }

                    // Split merged list items like: "... *   **X**: ..." or "... - **X**: ..."
                    const before = body;
                    body = body
                        // Require whitespace before a list marker so we don't break bold boundaries like "**...** **...**".
                        .replace(/(\S)\s+([*+-]\s+\*\*)/g, '$1\n$2')
                        .replace(/(\S)\s+(\d+\.\s+\*\*)/g, '$1\n$2')
                        .replace(/(\S)\s+([*+-]\s{2,})(?=\S)/g, '$1\n$2')
                        .replace(/(\S)\s+(\d+\.\s{2,})(?=\S)/g, '$1\n$2');
                    
                    // Split glued headings like "...ë‹¤.### (1) ..." into proper new paragraphs.
                    body = body
                        // Insert blank line before Markdown headings if they are glued to prior text.
                        // Avoid matching inside real headings like "#### Title".
                        .replace(/([^\s#])\s*(#{2,6}\s+\(?\d+\)?\s*)/g, '$1\n\n$2')
                        // Also handle headings glued without numbering.
                        .replace(/([^\s#])\s*(#{2,6}\s+)/g, '$1\n\n$2');

                    if (body !== before) fixCount++;

                    if (!bqPrefix) return body;
                    // Re-apply the same blockquote prefix to all newly created lines.
                    return body.split('\n').map(ln => `${bqPrefix}${ln}`).join('\n');
                };

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i] ?? '';
                    if (fenceRe.test(line.trim())) {
                        inFence = !inFence;
                        out.push(line);
                        continue;
                    }
                    if (inFence) {
                        out.push(line);
                        continue;
                    }
                    let fixed = fixLine(line);
                    // If the line now contains embedded newlines, split them into separate lines.
                    if (fixed.includes('\n')) out.push(...fixed.split('\n'));
                    else out.push(fixed);
                }

                // Ensure markdown tables have a header separator row so renderers don't treat them as plain text.
                const isRow = (ln) => /^\s*\|/.test(String(ln ?? ''));
                const isSep = (ln) => /^\s*\|\s*:?-{3,}/.test(String(ln ?? '').trim());
                const withSeps = [];
                inFence = false;
                let prevWasTable = false;
                for (let i = 0; i < out.length; i++) {
                    const line = out[i] ?? '';
                    if (fenceRe.test(String(line).trim())) {
                        inFence = !inFence;
                        withSeps.push(line);
                        prevWasTable = false;
                        continue;
                    }
                    if (inFence) {
                        withSeps.push(line);
                        prevWasTable = false;
                        continue;
                    }
                    const curIsRow = isRow(line);
                    const next = out[i + 1] ?? '';
                    const nextIsRow = isRow(next);
                    // Start of a table block (previous line wasn't a table row), and next line is also a row,
                    // but there is no separator row yet â†’ insert one.
                    if (!prevWasTable && curIsRow && nextIsRow && !isSep(next)) {
                        // infer column count from current row
                        const parts = String(line).trim().split('|');
                        const cols = Math.max(1, parts.length - 2);
                        withSeps.push(line);
                        withSeps.push(`| ${Array(cols).fill('---').join(' | ')} |`);
                        fixCount++;
                        prevWasTable = true;
                        continue;
                    }
                    withSeps.push(line);
                    prevWasTable = curIsRow;
                }

                                // Post-pass: repair common table breakages from OCR/LLM:
                // (a) Lines inside a table block that lost leading '|' â†’ treat as continuation of previous row's last cell.
                // (b) Rows with an extra trailing cell that likely belongs to the previous row (spillover).
                const repairTables = (linesIn) => {
                    const rebuilt = [];
                    let inTbl = false;
                    let expectedCols = null;
                    let lastRowIndex = -1;
                    let lastRowCells = null;
                    const rowStack = [];

                    const parseRow = (ln) => {
                        const t = String(ln || '').trim();
                        if (!t.startsWith('|')) return null;
                        // keep empty cells too
                        const raw = t.split('|');
                        const cells = raw.slice(1, raw.length - 1).map(x => String(x).trim());
                        return cells;
                    };
                    const buildRow = (cells) => `| ${cells.join(' | ')} |`;

                    const looksLikeContinuation = (s) => {
                        const t = String(s || '').trim();
                        if (!t) return false;
                        // avoid treating headings/lists as continuation
                        if (/^(#{1,6}\s|[*+-]\s|\d+\.\s)/.test(t)) return false;
                        // short-ish line or begins with a Korean particle/word that often continues
                        return t.length < 180;
                    };

                    const prevEndsIncomplete = (s) => {
                        const t = String(s || '').trim();
                        if (!t) return false;
                        // If it ends with a hanging particle or without sentence-ending punctuation, it's likely incomplete
                        if (/[ì˜ì—ì„ë¥¼ì™€ê³¼ë¡œë©°ë°]$/.test(t)) return true;
                        if (!/[\.\!\?ë‹¤í•¨ë¨]$/.test(t) && t.length < 40) return true;
                        return false;
                    };

                    for (let i = 0; i < linesIn.length; i++) {
                        const ln = linesIn[i] ?? '';
                        if (fenceRe.test(String(ln).trim())) {
                            inTbl = false;
                            expectedCols = null;
                            lastRowIndex = -1;
                            lastRowCells = null;
                            rowStack.length = 0;
                            rebuilt.push(ln);
                            continue;
                        }

                        const isRow = /^\s*\|/.test(String(ln));
                        const isSep = /^\s*\|\s*:?-{3,}/.test(String(ln).trim());

                        if (isRow) {
                            const cells = parseRow(ln);
                            // table start: expected cols from header row (first non-sep row)
                            if (!inTbl) {
                                inTbl = true;
                                expectedCols = (cells || []).length || null;
                                rowStack.length = 0;
                            } else if (!expectedCols && cells) {
                                expectedCols = cells.length;
                            }

                            if (!isSep && cells && expectedCols && cells.length >= expectedCols + 1) {
                                // Spillover heuristic: a trailing chunk belongs to an earlier row whose last cell is incomplete.
                                // 1) If there are extra columns, treat the last chunk(s) as spillover candidate.
                                const spill = cells.slice(expectedCols).join(' | ').trim();
                                if (spill && spill.length > 5) {
                                    // find nearest previous incomplete row (not necessarily immediately previous)
                                    let target = null;
                                    for (let k = rowStack.length - 1; k >= 0; k--) {
                                        const r = rowStack[k];
                                        if (!r || !Array.isArray(r.cells) || r.cells.length !== expectedCols) continue;
                                        const prevLast = r.cells[expectedCols - 1];
                                        if (prevEndsIncomplete(prevLast)) { target = r; break; }
                                    }
                                    if (target) {
                                        const prevLast = target.cells[expectedCols - 1];
                                        target.cells[expectedCols - 1] = (prevLast ? (prevLast + ' ') : '') + spill;
                                        rebuilt[target.idx] = buildRow(target.cells);
                                        fixCount++;

                                        // drop spillover from current row
                                        const trimmed = cells.slice(0, expectedCols);
                                        rebuilt.push(buildRow(trimmed));
                                        continue;
                                    }
                                    // fallback: merge spill into current row's last cell to keep table valid
                                    const trimmed = cells.slice(0, expectedCols);
                                    trimmed[expectedCols - 1] = (trimmed[expectedCols - 1] ? (trimmed[expectedCols - 1] + ' ') : '') + spill;
                                    rebuilt.push(buildRow(trimmed));
                                    fixCount++;
                                    continue;
                                }
                            }

                            // Normal row
                            if (!isSep && cells) {
                                lastRowIndex = rebuilt.length;
                                lastRowCells = cells.slice();
                                rowStack.push({ idx: lastRowIndex, cells: lastRowCells });
                            }
                            rebuilt.push(ln);
                            continue;
                        }

                        if (inTbl && looksLikeContinuation(ln) && lastRowCells && lastRowIndex >= 0) {
                            // Continuation line: append to previous row's last cell.
                            const add = String(ln || '').trim();
                            lastRowCells[lastRowCells.length - 1] = (lastRowCells[lastRowCells.length - 1] ? (lastRowCells[lastRowCells.length - 1] + ' ') : '') + add;
                            rebuilt[lastRowIndex] = buildRow(lastRowCells);
                            fixCount++;
                            continue;
                        }

                        // Exit table on blank line or regular content
                        inTbl = false;
                              rowStack.length = 0;
                  expectedCols = null;
                        lastRowIndex = -1;
                        lastRowCells = null;
                        rebuilt.push(ln);
                    }
                    return rebuilt;
                };

                const repaired = repairTables(withSeps);
                return { text: repaired.join('\n'), fixCount };
            };

            // Prevent duplicate "choices" in both question_text and answer_choices.
            const dedupeChoices = (questionText, answerChoices) => {
                const q0 = normalizeNewlines(questionText);
                const a0 = normalizeNewlines(answerChoices);
                if (!q0.trim() || !a0.trim()) return { question_text: q0, answer_choices: a0, changed: false };

                let q = q0;
                const aStrip = stripForCompare(a0);

                // 1) Exact substring removal (best case)
                if (q.includes(a0)) {
                    q = q.replace(a0, '').trimEnd();
                    return { question_text: q, answer_choices: a0, changed: true };
                }

                // 2) Remove trailing choice block if it strongly matches answer_choices
                const qLines = q.split('\n');
                const idx = firstChoiceMarkerIndex(qLines);
                if (idx !== -1) {
                    const head = qLines.slice(0, idx).join('\n').trimEnd();
                    const tail = qLines.slice(idx).join('\n');
                    const tailStrip = stripForCompare(tail);
                    const looksDuplicate = (tailStrip.includes(aStrip) || aStrip.includes(tailStrip));
                    if (looksDuplicate) {
                        return { question_text: head, answer_choices: a0, changed: true };
                    }
                }

                return { question_text: q0, answer_choices: a0, changed: false };
            };

            const api = { lintMarkdown, fixMarkdown, dedupeChoices };
            try { root.FMMHygiene = api; } catch { }
            try { if (typeof module === 'object' && module && module.exports) module.exports = api; } catch { }
        })(typeof window !== 'undefined' ? window : (typeof globalThis !== 'undefined' ? globalThis : this));
        // END_FMM_HYGIENE

        function findSectionRange(text, sectionName) {
            const anchors = buildSectionAnchors();
            const name = String(sectionName || '').trim();
            let anchorRe = null;
            if (name) {
                const escaped = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                anchorRe = new RegExp(escaped, 'i');
            }
            let start = 0;
            let end = text.length;
            if (anchorRe) {
                const match = anchorRe.exec(text);
                if (match) {
                    start = match.index;
                    const nextMatches = anchors
                        .map(a => {
                            const m = a.re.exec(text.slice(start + 1));
                            return m ? (start + 1 + m.index) : -1;
                        })
                        .filter(idx => idx > start);
                    if (nextMatches.length) end = Math.min(...nextMatches);
                } else {
                    return { start: 0, end: text.length, found: false };
                }
            }
            return { start, end, found: true };
        }

        function parsePatchBlocks(text) {
            const blocks = String(text || '').match(/<\s*patch\s*>[\s\S]*?<\s*\/\s*patch\s*>/gi) || [];
            return blocks.map(block => ({
                section: parseTag(block, 'section') || '',
                op: parseTag(block, 'op') || 'insert_between',
                before: parseTag(block, 'before') || '',
                after: parseTag(block, 'after') || '',
                content: parseTag(block, 'content') || ''
            }));
        }

        function isInsideTableRow(text, index) {
            // Find start of the line containing index
            const lastNewline = text.lastIndexOf('\n', index - 1);
            const startOfLine = lastNewline === -1 ? 0 : lastNewline + 1;
            const nextNewline = text.indexOf('\n', index);
            const endOfLine = nextNewline === -1 ? text.length : nextNewline;

            const line = text.slice(startOfLine, endOfLine);
            return /^\s*\|/.test(line);
        }

        function applyPatchToSection(sectionText, patch) {
            const op = (patch.op || 'insert_between').toLowerCase();
            const before = patch.before || '';
            const after = patch.after || '';
            const content = String(patch.content ?? '');

            if (!content.trim()) return { applied: false, text: sectionText, reason: 'empty_content' };

            const looksLikeBlock = (text) => {
                const t = String(text || '').trimStart();
                if (!t) return false;
                return /^(\||[-*+]\s+|\d+\.\s+|#{1,6}\s+|>\s+|```)/.test(t);
            };

            const glueBlock = (prefix, mid, suffix) => {
                if (!looksLikeBlock(mid)) return mid;
                const needsBefore = !prefix.endsWith('\n') && !mid.startsWith('\n');
                const needsAfter = !suffix.startsWith('\n') && !mid.endsWith('\n');
                return `${needsBefore ? '\n' : ''}${mid}${needsAfter ? '\n' : ''}`;
            };

            if (op === 'append') {
                const glue = sectionText.endsWith('\n') ? '' : '\n';
                return { applied: true, text: `${sectionText}${glue}${content}` };
            }

            const beforeRange = before ? findSnippetRange(sectionText, before, 0) : null;
            if (!beforeRange && (op === 'insert_between' || op === 'insert_after')) {
                return { applied: false, text: sectionText, reason: 'before_not_found' };
            }
            const fromIdx = beforeRange ? beforeRange.end : 0;
            const afterRange = after ? findSnippetRange(sectionText, after, fromIdx) : null;

            if (op === 'insert_between') {
                if (!afterRange) return { applied: false, text: sectionText, reason: 'after_not_found' };
                const insertPos = afterRange.start;
                if (isInsideTableRow(sectionText, insertPos)) return { applied: false, text: sectionText, reason: 'unsafe_table_insertion' };
                const prefix = sectionText.slice(0, insertPos);
                const suffix = sectionText.slice(insertPos);
                const mid = glueBlock(prefix, content, suffix);
                return { applied: true, text: `${prefix}${mid}${suffix}` };
            }

            if (op === 'insert_after') {
                const insertPos = beforeRange.end;
                if (isInsideTableRow(sectionText, insertPos)) return { applied: false, text: sectionText, reason: 'unsafe_table_insertion' };
                const prefix = sectionText.slice(0, insertPos);
                const suffix = sectionText.slice(insertPos);
                const mid = glueBlock(prefix, content, suffix);
                return { applied: true, text: `${prefix}${mid}${suffix}` };
            }

            if (op === 'insert_before') {
                if (!beforeRange) return { applied: false, text: sectionText, reason: 'before_not_found' };
                const insertPos = beforeRange.start;
                if (isInsideTableRow(sectionText, insertPos)) return { applied: false, text: sectionText, reason: 'unsafe_table_insertion' };
                const prefix = sectionText.slice(0, insertPos);
                const suffix = sectionText.slice(insertPos);
                const mid = glueBlock(prefix, content, suffix);
                return { applied: true, text: `${prefix}${mid}${suffix}` };
            }

            return { applied: false, text: sectionText, reason: 'unknown_op' };
        }

        function applyPatchesToGuide(guideText, patches) {
            let updated = guideText;
            const results = [];
            (patches || []).forEach((patch, idx) => {
                const range = findSectionRange(updated, patch.section);
                const sectionText = updated.slice(range.start, range.end);
                const applied = applyPatchToSection(sectionText, patch);
                if (applied.applied) {
                    updated = updated.slice(0, range.start) + applied.text + updated.slice(range.end);
                }
                results.push({ index: idx, applied: applied.applied, reason: applied.reason || null, section: patch.section || '' });
            });
            return { text: updated, results };
        }

        function __applyMarkdownHygieneFix(text, contextLabel, stageLabel) {
            const input = String(text ?? '');
            try {
                const api = (typeof globalThis !== 'undefined' && globalThis.FMMHygiene) ? globalThis.FMMHygiene : null;
                if (!api || typeof api.fixMarkdown !== 'function') return { text: input, fixCount: 0, issues: [] };
                const fixed = api.fixMarkdown(input);
                const nextText = String(fixed?.text ?? input);
                const fixCount = Number(fixed?.fixCount || 0) || 0;
                let issues = [];
                try { issues = (typeof api.lintMarkdown === 'function') ? api.lintMarkdown(nextText) : []; } catch { issues = []; }
                if (fixCount > 0) logger.info(contextLabel, `Markdown hygiene: applied ${fixCount} fix(es)${stageLabel ? ` (${stageLabel})` : ''}.`);
                if (issues.length) logger.warn(contextLabel, `Markdown hygiene: ${issues.length} issue(s) remain${stageLabel ? ` (${stageLabel})` : ''}.`);
                return { text: nextText, fixCount, issues };
            } catch {
                return { text: input, fixCount: 0, issues: [] };
            }
        }

        function parseMissingQidsFromCoverage(text) {
            const raw = String(text || '');
            if (/^\s*<\s*none\s*\/\s*>\s*(?:$|<)/i.test(raw)) return [];
            const items = raw.match(/<\s*missing_qid\s*>[\s\S]*?<\s*\/\s*missing_qid\s*>/gi) || [];
            if (items.length) {
                return items.map(it => parseTag(it, 'missing_qid')).filter(Boolean);
            }
            const fallback = raw.match(/[A-Za-z0-9_\-:.]+::Q\d+[a-z]?/gi) || [];
            return Array.from(new Set(fallback));
        }

        function parseEducationFeedbackFromCoverageVerifier(text) {
            const raw = String(text || '');
            const m = raw.match(/<\s*education_feedback\s*>([\s\S]*?)<\s*\/\s*education_feedback\s*>/i);
            if (!m) return '';
            return String(m[1] || '').trim();
        }

        function parseCoverageVerifierReportItems(text) {
            const raw = String(text || '');
            const items = parsePerfectEnvelope(raw);
            return items.map((it) => {
                const v = String(it?.value || '');
                const qid = (parseTag(v, 'qid') || parseTag(v, 'missing_qid') || '').trim();
                const coveredRaw = (parseTag(v, 'covered') || '').trim().toLowerCase();
                const reason = (parseTag(v, 'reason') || '').trim();
                let covered = null;
                if (coveredRaw) {
                    covered = ['true', 'yes', 'y', '1', 'covered', 'ok', 'pass'].includes(coveredRaw);
                } else if (parseTag(v, 'missing_qid')) {
                    covered = false;
                }
                return { qid, covered, reason };
            });
        }

        function computeMissingQidsFromCoverageReport(reportItems, expectedQids) {
            const expected = Array.isArray(expectedQids) ? expectedQids.map(x => String(x || '').trim()).filter(Boolean) : [];
            const expectedSet = new Set(expected);
            const missing = [];
            (reportItems || []).forEach(it => {
                if (!it || !it.qid) return;
                if (!expectedSet.has(it.qid)) return;
                if (it.covered === false) missing.push(it.qid);
            });
            return Array.from(new Set(missing));
        }

        function validateCoverageVerifierFullReport(reportItems, expectedQids) {
            const expected = Array.isArray(expectedQids) ? expectedQids.map(x => String(x || '').trim()).filter(Boolean) : [];
            const expectedSet = new Set(expected);

            const items = Array.isArray(reportItems) ? reportItems : [];
            if (!expected.length) return;
            if (items.length !== expected.length) {
                throw new Error(`Coverage verifier: expected ${expected.length} item(s), got ${items.length}.`);
            }

            const got = [];
            const unknown = new Set();
            const dup = new Set();
            const seen = new Set();
            const missing = new Set(expected);
            const invalid = [];

            for (const it of items) {
                const qid = String(it?.qid || '').trim();
                if (!qid) invalid.push('empty_qid');
                if (qid) got.push(qid);
                if (qid && seen.has(qid)) dup.add(qid);
                if (qid) seen.add(qid);
                if (qid && !expectedSet.has(qid)) unknown.add(qid);
                if (qid && expectedSet.has(qid)) missing.delete(qid);
                if (typeof it?.covered !== 'boolean') invalid.push(`covered_not_bool:${qid || '?'}`);
            }

            if (invalid.length) throw new Error(`Coverage verifier: invalid item(s): ${invalid.slice(0, 6).join(', ')}${invalid.length > 6 ? '...' : ''}`);
            if (unknown.size) throw new Error(`Coverage verifier: unknown qid(s): ${Array.from(unknown).slice(0, 6).join(', ')}${unknown.size > 6 ? '...' : ''}`);
            if (dup.size) throw new Error(`Coverage verifier: duplicate qid(s): ${Array.from(dup).slice(0, 6).join(', ')}${dup.size > 6 ? '...' : ''}`);
            if (missing.size) throw new Error(`Coverage verifier: missing qid(s): ${Array.from(missing).slice(0, 6).join(', ')}${missing.size > 6 ? '...' : ''}`);
        }

        //======================================================================
        // 2. PARSERS / HELPERS FOR STRUCTURED OUTPUT
        //======================================================================

        function parsePerfectEnvelope(text, { allowEmpty = false } = {}) {
            const wrapperMatch = text.match(/<\s*data\s*>([\s\S]*?)<\s*\/\s*data\s*>/i);
            if (!wrapperMatch) throw new Error('Missing <data> wrapper');
            const inner = wrapperMatch[1];

            // Preferred (safer): <item><id>1</id>...</item>
            const items = [];
            const itemRegex = /<\s*item\s*>([\s\S]*?)<\s*\/\s*item\s*>/gi;
            let m;
            while ((m = itemRegex.exec(inner)) !== null) {
                const value = (m[1] ?? '').toString().trim();
                const idText = (parseTag(value, 'id') || '').trim();
                const parsedId = parseInt(idText, 10);
                const id = Number.isFinite(parsedId) ? parsedId : (items.length + 1);
                items.push({ id, value });
            }
            if (items.length > 0) return items;

            // Legacy: <id:1>...</id:1>
            const legacyRegex = /<\s*id:(\d+)\s*>([\s\S]*?)<\s*\/\s*id:\1\s*>/gi;
            while ((m = legacyRegex.exec(inner)) !== null) {
                items.push({ id: Number(m[1]), value: (m[2] ?? '').toString().trim() });
            }
            if (items.length === 0) {
                if (allowEmpty) return [];
                throw new Error('No items parsed inside <data>.');
            }
            return items;
        }

	        async function collectMissingQidsByBatches(guideText, problems, contextLabel, batchSizeOrOptions, optionsMaybe = {}) {
	            const options = (batchSizeOrOptions && typeof batchSizeOrOptions === 'object' && !Array.isArray(batchSizeOrOptions))
	                ? batchSizeOrOptions
	                : (optionsMaybe && typeof optionsMaybe === 'object' ? optionsMaybe : {});
            const maxTokens = __clampInt(options?.maxTokens ?? COVERAGE_MAX_TOKENS_DEFAULT, { min: 100, max: 1000000, fallback: COVERAGE_MAX_TOKENS_DEFAULT });
            const all = (problems || []).slice();
            const outputMode = String(options?.verifierOutput || 'full').trim().toLowerCase();
            const maxTries = __clampInt(options?.verifierMaxTries ?? 2, { min: 0, max: 99, fallback: 2 });
	            const returnReport = !!options?.returnReport;
	            const eduOn = !!options?.educationFeedback;
	            const eduFlag = eduOn ? 'ON' : 'OFF';
	            const language = __getGuideLanguageFromUi();

            const buildMessagesForBatch = (batch, { batchIndex, batchCount, tryNo } = {}) => {
                const i = Number.isFinite(batchIndex) ? batchIndex : 0;
                const n = Number.isFinite(batchCount) ? batchCount : 999;
                const batchText = problemsToText(batch);
                if (outputMode === 'missing_only') {
                    // Use dedicated MISSING_ONLY prompt to avoid LLM confusion
                    const promptKey = currentPrompts.coverage_verifier_missing_only ? 'coverage_verifier_missing_only' : 'coverage_verifier';
                    const suffix = (Number.isFinite(tryNo) && tryNo > 1) ? `\n\nTRY: ${tryNo}` : '';
	                    return [
	                        { role: 'system', content: __renderPromptTemplateText(currentPrompts[promptKey].system, { language }) },
	                        { role: 'user', content: `EDU_FEEDBACK: ${eduFlag}\n\nGuide:\n${guideText}\n\nProblems (batch ${i + 1}/${n}):\n${batchText}${suffix}\n\nReturn only the required output format.` }
	                    ];
                }
                // Use dedicated FULL prompt to avoid LLM confusion
                const promptKey = currentPrompts.coverage_verifier_full ? 'coverage_verifier_full' : 'coverage_verifier';
                const expectedQids = batch.map(p => p.qid);
                const qidList = expectedQids.map(q => String(q || '').trim()).filter(Boolean).join('\n');
                const suffix = (Number.isFinite(tryNo) && tryNo > 1) ? `\n\nTRY: ${tryNo}` : '';
	                return [
	                    { role: 'system', content: __renderPromptTemplateText(currentPrompts[promptKey].system, { language }) },
	                    { role: 'user', content: `EDU_FEEDBACK: ${eduFlag}\n\nExpected QIDs (exactly once each, in order):\n${qidList}\n\nGuide:\n${guideText}\n\nProblems (batch ${i + 1}/${n}):\n${batchText}${suffix}\n\nReturn only the required output format.` }
	                ];
	            };

            const estimateBatchTokens = (batch, batchIndex, batchCount) => {
                const msgs = buildMessagesForBatch(batch, { batchIndex, batchCount, tryNo: 1 });
                return __estimateTokens(msgs);
            };

            // Token-aware batching so each verifier call stays under maxTokens.
            let batches = (() => {
                const out = [];
                let cur = [];
                for (const p of all) {
                    const next = cur.concat([p]);
                    const tok = estimateBatchTokens(next, 0, 999);
                    if (tok <= maxTokens || cur.length === 0) {
                        cur = next;
                        continue;
                    }
                    out.push(cur);
                    cur = [p];
                }
                if (cur.length) out.push(cur);
                return out;
            })();

            // Second pass: validate with real batchCount and split further if needed.
            for (let guard = 0; guard < 50; guard++) {
                let changed = false;
                const next = [];
                const total = batches.length || 1;
                for (let i = 0; i < batches.length; i++) {
                    const b = batches[i];
                    const tok = estimateBatchTokens(b, i, total);
                    if (tok <= maxTokens) {
                        next.push(b);
                        continue;
                    }
                    if (b.length <= 1) {
                        const qid = b?.[0]?.qid || '(unknown)';
                        let detail = '';
                        try {
                            const msgs = buildMessagesForBatch(b, { batchIndex: i, batchCount: total, tryNo: 1 });
                            const sysTok = msgs?.[0] ? __estimateTokens([msgs[0]]) : 0;
                            const userTok = msgs?.[1] ? __estimateTokens([msgs[1]]) : 0;
                            const guideTok = __countTokens(guideText);
                            const probTok = __countTokens(problemsToText(b));
                            detail = ` (estimated=${tok}; systemâ‰ˆ${sysTok}; userâ‰ˆ${userTok}; guideâ‰ˆ${guideTok}; problemsâ‰ˆ${probTok})`;
                        } catch { }
                        throw new Error(
                            `Coverage verifier: request exceeds maxTokens=${maxTokens}${detail} even for a single problem (${qid}). ` +
                            `maxTokens is the total request-context budget (system + guide + problems). Increase maxTokens or shorten the guide/prompt.`
                        );
                    }
                    const mid = Math.ceil(b.length / 2);
                    next.push(b.slice(0, mid), b.slice(mid));
                    changed = true;
                }
                batches = next;
                if (!changed) break;
            }

            const missing = new Set();
            const qidSet = new Set(all.map(p => p.qid));

            const jobs = batches.map((_, i) => ({ batchIndex: i }));

            async function processJob(job, workerId) {
                const i = job.batchIndex;
                const batch = batches[i];
                const expectedQids = batch.map(p => p.qid);

                if (outputMode === 'missing_only') {
                    let tryNo = 0;
                    while (true) {
                        if (processController.stop) throw new Error('Operation cancelled.');
                        tryNo++;
                        if (maxTries > 0 && tryNo > maxTries) {
                            throw new Error(`Coverage verifier: max tries reached (${maxTries}) for batch ${i + 1}/${batches.length}.`);
                        }
                        const payload = {
                            model: getApiConfig().model,
                            messages: buildMessagesForBatch(batch, { batchIndex: i, batchCount: batches.length, tryNo })
                        };
                        const suffix = (tryNo <= 1) ? '' : `-XMLTry${tryNo}`;
                        const callContext = `${contextLabel}-Coverage${i + 1}-W${workerId}${suffix}`;
                        const raw = await resilientLlmRequest(payload, callContext);
                        const edu = eduOn ? parseEducationFeedbackFromCoverageVerifier(raw) : '';

                        if (/^\s*<\s*none\s*\/\s*>\s*(?:$|<)/i.test(raw)) {
                            return { batchIndex: i, missingQids: [], reportItems: null, educationFeedback: edu };
                        }
                        if (!/<\s*missing_qid\s*>/i.test(raw)) {
                            try {
                                __formatErrors.add({
                                    kind: 'coverage_verifier',
                                    stage: 'MISSING_ONLY',
                                    attempt: tryNo,
                                    context: callContext,
                                    error: 'Expected <none/> or <missing_qid> tags',
                                    request: payload,
                                    responseRaw: raw,
                                    meta: { outputMode: 'missing_only', batchIndex: i, batchCount: batches.length }
                                });
                            } catch { }
                            logger.warn(contextLabel, `Coverage verifier output invalid (MISSING_ONLY, batch ${i + 1}/${batches.length}, try ${tryNo}): expected <none/> or <missing_qid> tags.`);
                            continue;
                        }

                        const miss = parseMissingQidsFromCoverage(raw);
                        return {
                            batchIndex: i,
                            missingQids: miss.filter(qid => qidSet.has(qid)),
                            reportItems: null,
                            educationFeedback: edu,
                        };
                    }
                }

                let tryNo = 0;
                while (true) {
                    if (processController.stop) throw new Error('Operation cancelled.');
                    tryNo++;
                    if (maxTries > 0 && tryNo > maxTries) {
                        throw new Error(`Coverage verifier: max tries reached (${maxTries}) for batch ${i + 1}/${batches.length}.`);
                    }
                    const payload = {
                        model: getApiConfig().model,
                        messages: buildMessagesForBatch(batch, { batchIndex: i, batchCount: batches.length, tryNo })
                    };
                    const suffix = (tryNo <= 1) ? '' : `-XMLTry${tryNo}`;
                    const callContext = `${contextLabel}-Coverage${i + 1}-W${workerId}${suffix}`;
                    const raw = await resilientLlmRequest(payload, callContext);
                    const edu = eduOn ? parseEducationFeedbackFromCoverageVerifier(raw) : '';
                    try {
                        // [FIX] Detect <none/> response which means "all covered" (implicit full coverage)
                        // This prevents infinite loops when model outputs <none/> for "nothing missing"
                        if (/^\s*<\s*none\s*\/\s*>\s*(?:$|<)/i.test(raw)) {
                            const syntheticReport = expectedQids.map(qid => ({
                                qid,
                                covered: true,
                                reason: 'Implicitly covered (<none/> response)'
                            }));
                            return {
                                batchIndex: i,
                                missingQids: [],
                                reportItems: returnReport ? syntheticReport : null,
                                educationFeedback: edu,
                            };
                        }

                        const reportItems = parseCoverageVerifierReportItems(raw);
                        validateCoverageVerifierFullReport(reportItems, expectedQids);
                        const miss = computeMissingQidsFromCoverageReport(reportItems, expectedQids);
                        return {
                            batchIndex: i,
                            missingQids: miss.filter(qid => qidSet.has(qid)),
                            reportItems: returnReport ? reportItems : null,
                            educationFeedback: edu,
                        };
                    } catch (e) {
                        try {
                            __formatErrors.add({
                                kind: 'coverage_verifier',
                                stage: 'FULL',
                                attempt: tryNo,
                                context: callContext,
                                error: e?.message || String(e || ''),
                                request: payload,
                                responseRaw: raw,
                                meta: { outputMode: 'full', batchIndex: i, batchCount: batches.length }
                            });
                        } catch { }
                        logger.warn(contextLabel, `Coverage verifier output invalid (batch ${i + 1}/${batches.length}, try ${tryNo}): ${e.message}`);
                    }
                }
            }

            const { results, errors } = await runWithConcurrency(jobs, processJob, getWorkerConcurrency());
            if (errors.length) {
                const first = errors[0]?.error;
                throw new Error(`Coverage verifier failed (${errors.length} batch(es)); first: ${first?.message || first}`);
            }
            const reportBatches = new Map();
            let bestEdu = '';
            (results || []).forEach(r => {
                if (!r) return;
                const miss = Array.isArray(r.missingQids) ? r.missingQids : [];
                miss.forEach(qid => missing.add(qid));
                if (returnReport && Array.isArray(r.reportItems)) reportBatches.set(r.batchIndex, r.reportItems);
                const ef = String(r.educationFeedback || '').trim();
                if (ef && ef.length > bestEdu.length) bestEdu = ef;
            });
            let reportItems = null;
            if (returnReport) {
                reportItems = [];
                for (let bi = 0; bi < batches.length; bi++) {
                    const items = reportBatches.get(bi);
                    if (Array.isArray(items) && items.length) reportItems.push(...items);
                }
            }
            return { missingQids: Array.from(missing), reportItems, educationFeedback: bestEdu };
        }

	        async function buildCoveragePatches(guideText, missingProblems, contextLabel, options = {}) {
	            const problemsText = problemsToTextInterleaved(missingProblems || []);
	            const patcherMode = String(options?.patcherMode || 'coverage_only').toLowerCase();
	            const useCreatorPrompt = patcherMode === 'creator_patch';
		            const wantsEducationFeedback = patcherMode === 'integrated' || patcherMode === 'creator_patch';
		            const eduFeedbackRaw = String(options?.educationFeedback || '').trim();
		            const eduFeedback = eduFeedbackRaw.length > 3500 ? (eduFeedbackRaw.slice(0, 3500) + '\n...(clipped)') : eduFeedbackRaw;
		            const language = __getGuideLanguageFromUi();
	            const extra =
	                wantsEducationFeedback
	                    ? `\n\nì¶”ê°€ ëª©í‘œ(í†µí•©/êµìœ¡ ëª¨ë“œ, ì œí•œì ):\n- 1ìˆœìœ„: ëˆ„ë½ ë¬¸ì œë¥¼ \"ê°€ì´ë“œë§Œìœ¼ë¡œ\" í’€ ìˆ˜ ìˆê²Œ ë§Œë“œëŠ” ê²ƒ (ì»¤ë²„ì™€ ë¬´ê´€í•œ ì¥ë¬¸ ê°œì„  ê¸ˆì§€).\n- ì»¤ë²„ë¥¼ ìœ„í•´ ì¶”ê°€í•˜ëŠ” ë‚´ìš©ì€ Explanation Creatorì˜ êµ¬ì¡°/ì´ë…ê³¼ ì¼ì¹˜í•˜ê²Œ ì‘ì„±:\n  - \"Question Patterns & Examinerâ€™s Win Conditions\"ì—ëŠ” (ì¶œì œì í•¨ì •/ì „ëµ) + (ì˜¤ë‹µì´ ë§¤ë ¥ì ì¸ ì´ìœ ) + (í•™ìƒ ì°©ê°) + (ìš”ì•½ë…¸íŠ¸ Tip 1ë¬¸ì¥)ì„ í¬í•¨.\n  - \"100% coverage checklist\" í•­ëª©ì€ ë°˜ë“œì‹œ: ë¬¸ì œ ë§¥ë½ + ì¶œì œì ì „ëµ/í•¨ì • + íƒ€ê¹ƒ ì˜¤ê°œë… (+ ê°€ëŠ¥í•˜ë©´ Tip).\n- ì•„ë˜ 'Educational feedback'ì´ ìˆìœ¼ë©´, ì»¤ë²„ì— í•„ìš”í•œ ë²”ìœ„ ë‚´ì—ì„œë§Œ ë°˜ì˜.\n- ëˆ„ë½ ë¬¸ì œê°€ ëª¨ë‘ ì»¤ë²„ë˜ë©´ ì¶”ê°€ ê°œì„ ì€ í•˜ì§€ ë§ê³  ì¢…ë£Œ.\n` +
	                    (eduFeedback ? `\nEducational feedback (secondary; do NOT block coverage completion):\n${eduFeedback}\n` : '')
	                    : '';
		            const systemPrompt = __renderPromptTemplateText(
		                useCreatorPrompt ? currentPrompts.explanation_creator.system : currentPrompts.coverage_patcher.system,
		                { language }
		            );
	            const userContent = useCreatorPrompt
	                ? `PATCH MODE (COVERAGE): Revise the existing guide by applying only minimal, local edits so that the missing problems become solvable using ONLY the guide.
		
		Rules:
		- Do NOT rewrite or re-output the full guide.
		- Output patch instructions in the required <patches> ... </patches> format.
		
		{Current guide (markdown):
		${guideText}
		}
		
		{Missing problems (must be covered):
		${problemsText}
		}
		${extra}
			${__patchOutputDirectiveLine({ phase: 'phase2', context: contextLabel })}`
	                : `Guide:
		${guideText}
		
		Missing problems (must be covered):
		${problemsText}
		${extra}
			${__patchOutputDirectiveLine({ phase: 'phase2', context: contextLabel })}`;
	            const payload = {
	                model: getApiConfig().model,
	                messages: [
	                    { role: 'system', content: systemPrompt },
	                    {
	                        role: 'user',
	                        content: userContent
	                    }
	                ]
	            };
            const payloadTry = __withStructuredRationaleMode(payload, { kind: 'patches', phase: 'phase2', context: `${contextLabel}-Patch` });
            const raw = await resilientLlmRequest(payloadTry, `${contextLabel}-Patch`);
            const patches = parsePatchBlocks(raw);
            const isNone = /<\s*\/\s*none\s*>/i.test(raw) || /<\s*none\s*\/>/i.test(raw);
            if (!patches.length && !isNone) {
                try {
                    __formatErrors.add({
                        kind: 'patches',
                        stage: 'coverage_patcher',
                        attempt: 1,
                        context: `${contextLabel}-Patch`,
                        error: 'No <patch> blocks parsed (and no </none>)',
                        request: payloadTry,
                        responseRaw: raw,
                        meta: { patcherMode }
                    });
                } catch { }
            }
            return { raw, patches };
        }

        async function refineGuideCoverage(guideText, problems, contextLabel, options = {}) {
            // IMPORTANT: Keep patching serial per type to avoid overlapping edits.
            // Strategy: split into fixed-size chunks, patch chunk-by-chunk (apply immediately),
            // and optionally do a final re-verification depending on config.
            let current = String(guideText || '');
            const allProblems = (problems || []).slice();
	            const maxTokens = __clampInt(options?.maxTokens ?? COVERAGE_MAX_TOKENS_DEFAULT, { min: 100, max: 1000000, fallback: COVERAGE_MAX_TOKENS_DEFAULT });
	            const maxRounds = __clampInt(options?.maxRounds ?? COVERAGE_PATCH_MAX_ROUNDS, { min: 0, max: 99, fallback: COVERAGE_PATCH_MAX_ROUNDS });
	            const patcherMode = String(options?.patcherMode || 'coverage_only').toLowerCase();
	            const useCreatorCoveragePatcher = patcherMode === 'creator_patch';
	            const verifierOutput = String(options?.verifierOutput ?? 'full').trim().toLowerCase();
	            const verifierMaxTries = options?.verifierMaxTries;
            const finalVerifyMode = (() => {
                const v = String(options?.finalVerifyMode ?? 'global').trim().toLowerCase();
                if (v === 'global' || v === 'per_chunk' || v === 'none') return v;
                return 'global';
            })();
            const wantReport = verifierOutput === 'full';
            const reportByQid = new Map();
            const updateReport = (items) => {
                if (!wantReport) return;
                if (!Array.isArray(items) || !items.length) return;
                items.forEach(it => {
                    const qid = String(it?.qid || '').trim();
                    if (!qid) return;
                    reportByQid.set(qid, { qid, covered: !!it?.covered, reason: String(it?.reason || '').trim() });
                });
            };
            const missingFinal = new Set();
	            const wantEducationFeedback = patcherMode === 'integrated' || patcherMode === 'creator_patch';
            let lastEducationFeedback = '';
            const autoAcceptAfterPatchMissingLeq = __clampInt(options?.autoAcceptAfterPatchMissingLeq ?? 0, { min: 0, max: 999, fallback: 0 });
            let autoAccepted = false;
            const coverageTrace = {
                totalProblems: allProblems.length,
                chunkCount: 0,
                rounds: [] // [{round:1, coveredBefore:0, coveredAfter:10, remaining:90, attempted:100}]
            };

            // --- TOKEN-AWARE CHUNKING (maxTokens is the single source of truth) ---
            const chunks = chunkProblemsRespectingBoundaries(allProblems, maxTokens, 'sequential');
            coverageTrace.chunkCount = chunks.length;

            // Check if guide is too long for coverage verification
            const guideTokens = __countTokens(guideText);
            if (guideTokens > maxTokens * 0.8) {
                logger.warn(contextLabel, `WARNING: Guide is very long (${guideTokens} tokens). Coverage maxTokens=${maxTokens}. This may cause verification failures.`);
                logger.warn(contextLabel, `Consider: (1) Increase coverage maxTokens, or (2) Shorten the explanation/guide, or (3) Reduce problems per type.`);
            }

            logger.info(contextLabel, `Coverage patching start: ${allProblems.length} problems, ${chunks.length} chunks (maxTokens=${maxTokens}), max ${maxRounds} rounds`);
            logger.info(contextLabel, `Guide tokens: ${guideTokens}, Max allowed: ${maxTokens}`);

            const onGuideUpdate = (typeof options?.onGuideUpdate === 'function') ? options.onGuideUpdate : null;

            const __clipText = (s, maxChars = 3500) => {
                const str = String(s || '').trim();
                if (!str) return '';
                if (str.length <= maxChars) return str;
                return str.slice(0, maxChars) + '\n...(clipped)';
            };

	            const __coveragePatcherExtraText = (educationFeedbackText) => {
	                if (!wantEducationFeedback) return '';
	                const edu = __clipText(educationFeedbackText, 3500);
	                return (
                    `\n\nì¶”ê°€ ëª©í‘œ(í†µí•©/êµìœ¡ ëª¨ë“œ, ì œí•œì ):\n` +
                    `- 1ìˆœìœ„: ëˆ„ë½ ë¬¸ì œë¥¼ \"ê°€ì´ë“œë§Œìœ¼ë¡œ\" í’€ ìˆ˜ ìˆê²Œ ë§Œë“œëŠ” ê²ƒ (ì»¤ë²„ì™€ ë¬´ê´€í•œ ì¥ë¬¸ ê°œì„  ê¸ˆì§€).\n` +
                    `- ì»¤ë²„ë¥¼ ìœ„í•´ ì¶”ê°€í•˜ëŠ” ë‚´ìš©ì€ Explanation Creatorì˜ êµ¬ì¡°/ì´ë…ê³¼ ì¼ì¹˜í•˜ê²Œ ì‘ì„±:\n` +
                    `  - \"Question Patterns & Examinerâ€™s Win Conditions\"ì—ëŠ” (ì¶œì œì í•¨ì •/ì „ëµ) + (ì˜¤ë‹µì´ ë§¤ë ¥ì ì¸ ì´ìœ ) + (í•™ìƒ ì°©ê°) + (ìš”ì•½ë…¸íŠ¸ Tip 1ë¬¸ì¥)ì„ í¬í•¨.\n` +
                    `  - \"100% coverage checklist\" í•­ëª©ì€ ë°˜ë“œì‹œ: ë¬¸ì œ ë§¥ë½ + ì¶œì œì ì „ëµ/í•¨ì • + íƒ€ê¹ƒ ì˜¤ê°œë… (+ ê°€ëŠ¥í•˜ë©´ Tip).\n` +
                    `- ì•„ë˜ 'Educational feedback'ì´ ìˆìœ¼ë©´, ì»¤ë²„ì— í•„ìš”í•œ ë²”ìœ„ ë‚´ì—ì„œë§Œ ë°˜ì˜.\n` +
                    `- ëˆ„ë½ ë¬¸ì œê°€ ëª¨ë‘ ì»¤ë²„ë˜ë©´ ì¶”ê°€ ê°œì„ ì€ í•˜ì§€ ë§ê³  ì¢…ë£Œ.\n` +
                    (edu ? `\nEducational feedback (secondary; do NOT block coverage completion):\n${edu}\n` : '')
                );
            };

		            const __estimateCoveragePatchTokens = (guideTextNow, batchProblems, educationFeedbackText) => {
		                const problemsText = problemsToTextInterleaved(batchProblems || []);
		                const extra = __coveragePatcherExtraText(educationFeedbackText);
		                const language = __getGuideLanguageFromUi();
		                const systemPrompt = __renderPromptTemplateText(
		                    useCreatorCoveragePatcher ? currentPrompts.explanation_creator.system : currentPrompts.coverage_patcher.system,
		                    { language }
		                );
		                const userContent = useCreatorCoveragePatcher
	                    ? `PATCH MODE (COVERAGE): Revise the existing guide by applying only minimal, local edits so that the missing problems become solvable using ONLY the guide.
		
		Rules:
		- Do NOT rewrite or re-output the full guide.
		- Output patch instructions in the required <patches> ... </patches> format.
		
		{Current guide (markdown):
		${guideTextNow}
		}
		
		{Missing problems (must be covered):
		${problemsText}
		}
		${extra}
			${__patchOutputDirectiveLine({ phase: 'phase2', context: contextLabel })}`
	                    : `Guide:\n${guideTextNow}\n\nMissing problems (must be covered):\n${problemsText}\n${extra}\n${__patchOutputDirectiveLine({ phase: 'phase2', context: contextLabel })}`;
	                const messages = [
		                    { role: 'system', content: systemPrompt },
		                    {
		                        role: 'user',
		                        content: userContent
		                    }
		                ];
	                const eff = __withStructuredRationaleMode({ messages }, { kind: 'patches', phase: 'phase2', context: contextLabel });
	                return __estimateTokens(eff?.messages || messages);
	            };

            async function __applyCoveragePatchesTokenAware(missingProblems, patchContextBase, { educationFeedbackText } = {}) {
                const beforeAll = current;
                let anyFailed = false;
                let anyApplied = false;
                let pending = (missingProblems || []).slice();
                let patchBatchNo = 0;

                while (pending.length) {
                    if (processController.stop) throw new Error('Operation cancelled.');
                    patchBatchNo += 1;

                    let batch = [];
                    for (const p of pending) {
                        const next = batch.concat([p]);
                        const tok = __estimateCoveragePatchTokens(current, next, educationFeedbackText);
                        if (tok <= maxTokens || batch.length === 0) {
                            batch = next;
                            continue;
                        }
                        break;
                    }

                    if (!batch.length) break;
                    const tok = __estimateCoveragePatchTokens(current, batch, educationFeedbackText);
                    if (tok > maxTokens && batch.length <= 1) {
                        const qid = batch?.[0]?.qid || '(unknown)';
	                        let detail = '';
		                        try {
		                            const problemsText = problemsToTextInterleaved(batch || []);
		                            const extra = __coveragePatcherExtraText(educationFeedbackText);
		                            const language = __getGuideLanguageFromUi();
		                            const systemPrompt = __renderPromptTemplateText(
		                                useCreatorCoveragePatcher ? currentPrompts.explanation_creator.system : currentPrompts.coverage_patcher.system,
		                                { language }
		                            );
		                            const userContent = useCreatorCoveragePatcher
	                                ? `PATCH MODE (COVERAGE): Revise the existing guide by applying only minimal, local edits so that the missing problems become solvable using ONLY the guide.\n\n{Current guide (markdown):\n${current}\n}\n\n{Missing problems (must be covered):\n${problemsText}\n}\n${extra}\n${__patchOutputDirectiveLine({ phase: 'phase2', context: contextLabel })}`
	                                : `Guide:\n${current}\n\nMissing problems (must be covered):\n${problemsText}\n${extra}\n${__patchOutputDirectiveLine({ phase: 'phase2', context: contextLabel })}`;
	                            const msgs = [
		                                { role: 'system', content: systemPrompt },
		                                { role: 'user', content: userContent }
		                            ];
	                            const effMsgs = __withStructuredRationaleMode({ messages: msgs }, { kind: 'patches', phase: 'phase2', context: contextLabel })?.messages || msgs;
	                            const sysTok = effMsgs?.[0] ? __estimateTokens([effMsgs[0]]) : 0;
	                            const userTok = effMsgs?.[1] ? __estimateTokens([effMsgs[1]]) : 0;
                            const guideTok = __countTokens(current);
                            const probTok = __countTokens(problemsText);
                            detail = ` (estimated=${tok}; systemâ‰ˆ${sysTok}; userâ‰ˆ${userTok}; guideâ‰ˆ${guideTok}; problemsâ‰ˆ${probTok})`;
                        } catch { }
                        throw new Error(
                            `Coverage patcher: request exceeds maxTokens=${maxTokens}${detail} even for a single problem (${qid}). ` +
                            `maxTokens is the total request-context budget (system + guide + problems). Increase maxTokens or shorten the guide/prompt.`
                        );
                    }

                    const patchRes = await buildCoveragePatches(current, batch, `${patchContextBase}-PatchB${patchBatchNo}`, { patcherMode, educationFeedback: educationFeedbackText });
                    const applied = applyPatchesToGuide(current, patchRes.patches);

                    if (applied.results.some(r => !r.applied)) anyFailed = true;
                    if (applied.text !== current) anyApplied = true;
                    try {
                        const hygiene = __applyMarkdownHygieneFix(applied.text, patchContextBase, `coverage_patch_batch_${patchBatchNo}`);
                        current = hygiene.text;
                    } catch {
                        current = applied.text;
                    }
                    try { if (onGuideUpdate) onGuideUpdate(current, { kind: 'coverage_patch', patchBatchNo, context: patchContextBase }); } catch { }

                    const used = new Set(batch.map(p => p?.qid).filter(Boolean));
                    pending = pending.filter(p => !used.has(p?.qid));
                }

                return { changed: current !== beforeAll, anyFailed, anyApplied };
            }

            if (maxRounds > 0) {
                for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                    const chunkAll = chunks[chunkIndex].slice();
                    let remaining = chunkAll.slice();
                    logger.info(contextLabel, `ì²­í¬ ${chunkIndex + 1}/${chunks.length} ì‹œì‘ (${chunkAll.length}ê°œ ë¬¸ì œ)`);
                    for (let round = 1; round <= maxRounds; round++) {
                        if (!remaining.length) break;
                        const verifyRes = await collectMissingQidsByBatches(
                            current,
                            remaining,
                            `${contextLabel}-C${chunkIndex + 1}-R${round}`,
                            {
                                maxTokens,
                                verifierOutput,
                                verifierMaxTries,
                                returnReport: wantReport && finalVerifyMode !== 'global',
                                educationFeedback: wantEducationFeedback,
                            }
                        );
                        updateReport(verifyRes?.reportItems);
                        const eduVerify = String(verifyRes?.educationFeedback || '').trim();
                        if (eduVerify) lastEducationFeedback = eduVerify;
                        let eduForPatcher = eduVerify;
                        let missingQids = Array.isArray(verifyRes?.missingQids) ? verifyRes.missingQids : [];
                        const verifiedN = remaining.length;
                        const missingN = missingQids.length;
                        const coveredN = Math.max(0, verifiedN - missingN);
                        try {
                            coverageTrace.rounds.push({
                                kind: 'verify',
                                chunkIndex: chunkIndex + 1,
                                round,
                                verified: verifiedN,
                                covered: coveredN,
                                missing: missingN,
                                totalInChunk: chunkAll.length,
                                context: `${contextLabel}-C${chunkIndex + 1}-R${round}`,
                            });
                        } catch { }
                        logger.info(
                            contextLabel,
                            `[Tracer] ì²­í¬ ${chunkIndex + 1}/${chunks.length} ë¼ìš´ë“œ ${round}: ì´ë²ˆ ê²€ì¦ ${verifiedN}ê°œ ì¤‘ ${coveredN}ê°œ ì»¤ë²„ / ${missingN}ê°œ ëˆ„ë½ (ëˆ„ì  ì»¤ë²„: ${Math.max(0, chunkAll.length - missingN)}/${chunkAll.length})`
                        );
                        if (!missingQids.length) {
                            if (finalVerifyMode === 'per_chunk' && remaining.length !== chunkAll.length) {
                                const refreshRes = await collectMissingQidsByBatches(
                                    current,
                                    chunkAll,
                                    `${contextLabel}-C${chunkIndex + 1}-R${round}-Refresh`,
                                    {
                                        maxTokens,
                                        verifierOutput,
                                        verifierMaxTries,
                                        returnReport: wantReport && finalVerifyMode !== 'global',
                                        educationFeedback: wantEducationFeedback,
                                    }
                                );
                                updateReport(refreshRes?.reportItems);
                                const eduRefresh = String(refreshRes?.educationFeedback || '').trim();
                                if (eduRefresh) lastEducationFeedback = eduRefresh;
                                if (eduRefresh) eduForPatcher = eduRefresh;
                                const refreshMissing = Array.isArray(refreshRes?.missingQids) ? refreshRes.missingQids : [];
                                try {
                                    const vN = chunkAll.length;
                                    const mN = refreshMissing.length;
                                    const cN = Math.max(0, vN - mN);
                                    coverageTrace.rounds.push({
                                        kind: 'verify_refresh',
                                        chunkIndex: chunkIndex + 1,
                                        round,
                                        verified: vN,
                                        covered: cN,
                                        missing: mN,
                                        totalInChunk: chunkAll.length,
                                        context: `${contextLabel}-C${chunkIndex + 1}-R${round}-Refresh`,
                                    });
                                    logger.info(
                                        contextLabel,
                                        `[Tracer] ì²­í¬ ${chunkIndex + 1}/${chunks.length} ë¼ìš´ë“œ ${round} (Refresh): ì „ì²´ ${vN}ê°œ ì¬ê²€ì¦ â†’ ì»¤ë²„ ${cN} / ëˆ„ë½ ${mN}`
                                    );
                                } catch { }
                                if (!refreshMissing.length) {
                                    remaining = [];
                                    break;
                                }
                                missingQids = refreshMissing;
                                remaining = chunkAll.filter(p => refreshMissing.includes(p.qid));
                            } else {
                                remaining = [];
                                break;
                            }
                        }

                        const missingProblems = remaining.filter(p => missingQids.includes(p.qid));
                        const shouldAutoAccept =
                            autoAcceptAfterPatchMissingLeq > 0 &&
                            missingQids.length > 0 &&
                            missingQids.length <= autoAcceptAfterPatchMissingLeq;
                        const patchRun = await __applyCoveragePatchesTokenAware(
                            missingProblems,
                            `${contextLabel}-C${chunkIndex + 1}-R${round}`,
                            { educationFeedbackText: eduForPatcher }
                        );
                        try {
                            coverageTrace.rounds.push({
                                kind: 'patch',
                                chunkIndex: chunkIndex + 1,
                                round,
                                patchTarget: missingProblems.length,
                                changed: !!patchRun?.changed,
                                anyFailed: !!patchRun?.anyFailed,
                                context: `${contextLabel}-C${chunkIndex + 1}-R${round}`,
                            });
                        } catch { }

                        if (patchRun.anyFailed) {
                            logger.warn(contextLabel, `Coverage patch chunk ${chunkIndex + 1}/${chunks.length} round ${round}: some patches failed to apply.`);
                        }
                        if (!patchRun.changed) {
                            logger.warn(contextLabel, `Coverage patch chunk ${chunkIndex + 1}/${chunks.length} round ${round}: no changes applied.`);
                            break;
                        }

                        if (shouldAutoAccept) {
                            autoAccepted = true;
                            logger.warn(
                                contextLabel,
                                `[Tracer] ë‚¨ì€ ëˆ„ë½ì´ ${missingQids.length}ê°œ(â‰¤${autoAcceptAfterPatchMissingLeq}) â†’ 1íšŒ íŒ¨ì¹˜ í›„ ì¬ê²€ì¦ ìƒëµ(í™•ì •) ì˜µì…˜ ì ìš©`
                            );
                            try {
                                coverageTrace.rounds.push({
                                    kind: 'auto_accept',
                                    chunkIndex: chunkIndex + 1,
                                    round,
                                    missingAtDecision: missingQids.length,
                                    threshold: autoAcceptAfterPatchMissingLeq,
                                    context: `${contextLabel}-C${chunkIndex + 1}-R${round}`,
                                });
                            } catch { }
                            remaining = [];
                            break;
                        }

                        remaining = missingProblems;
                    }
                    if (remaining.length) {
                        remaining.forEach(p => missingFinal.add(p.qid));
                        logger.warn(contextLabel, `ì²­í¬ ${chunkIndex + 1} ì™„ë£Œ: ${remaining.length}ê°œ ë¯¸í•´ê²°`);
                    } else {
                        logger.success(contextLabel, `ì²­í¬ ${chunkIndex + 1} ì™„ë£Œ: ì „ì²´ ì»¤ë²„`);
                    }
                }
            }

            if (maxRounds <= 0 && finalVerifyMode !== 'global') {
                // No patching happened; still produce a coverage signal without a single global "Final" call.
                for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                    const chunkAll = chunks[chunkIndex].slice();
                    const res = await collectMissingQidsByBatches(current, chunkAll, `${contextLabel}-C${chunkIndex + 1}-VerifyOnly`, {
                        maxTokens,
                        verifierOutput,
                        verifierMaxTries,
                        returnReport: wantReport && finalVerifyMode !== 'global',
                        educationFeedback: wantEducationFeedback,
                    });
                    updateReport(res?.reportItems);
                    const edu = String(res?.educationFeedback || '').trim();
                    if (edu) lastEducationFeedback = edu;
                    (res?.missingQids || []).forEach(qid => missingFinal.add(qid));
                }
            }

            if (finalVerifyMode === 'global' && autoAccepted) {
                const remainingQids = allProblems.filter(p => missingFinal.has(p.qid)).map(p => p.qid);
                const coveredCount = allProblems.length - remainingQids.length;
                const pct = allProblems.length > 0 ? ((coveredCount / allProblems.length) * 100).toFixed(1) : '100.0';
                logger.warn(
                    contextLabel,
                    `ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜(ì˜µì…˜) ì™„ë£Œ: ${coveredCount}/${allProblems.length} ì»¤ë²„ (${pct}%) â€” auto-accept ì ìš©ìœ¼ë¡œ Final ì¬ê²€ì¦ì„ ìƒëµí–ˆìŠµë‹ˆë‹¤.`
                );
                return {
                    guideText: current,
                    missingQids: remainingQids,
                    coverageReport: wantReport ? allProblems.map(p => reportByQid.get(p.qid) || { qid: p.qid, covered: false, reason: '(ê²€ì¦ ë¦¬í¬íŠ¸ ì—†ìŒ)' }) : null,
                    coverageMeta: { maxTokens, maxRounds, patcherMode, verifierOutput, verifierMaxTries, finalVerifyMode, autoAcceptAfterPatchMissingLeq, autoAccepted, tracer: coverageTrace, finalVerifySkipped: true },
                    educationFeedback: lastEducationFeedback || null,
                };
            }

            if (finalVerifyMode === 'global') {
                const finalRes = await collectMissingQidsByBatches(current, allProblems, `${contextLabel}-Final`, {
                    maxTokens,
                    verifierOutput,
                    verifierMaxTries,
                    returnReport: wantReport,
                    educationFeedback: wantEducationFeedback,
                });
                const eduFinal = String(finalRes?.educationFeedback || '').trim();
                if (eduFinal) lastEducationFeedback = eduFinal;
                const coveredCount = allProblems.length - (finalRes?.missingQids?.length || 0);
                const pct = allProblems.length > 0 ? ((coveredCount / allProblems.length) * 100).toFixed(1) : '100.0';
                logger.success(contextLabel, `ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜ ì™„ë£Œ: ${coveredCount}/${allProblems.length} ì»¤ë²„ (${pct}%)`);
                return {
                    guideText: current,
                    missingQids: Array.isArray(finalRes?.missingQids) ? finalRes.missingQids : [],
                    coverageReport: Array.isArray(finalRes?.reportItems) ? finalRes.reportItems : null,
                    coverageMeta: { maxTokens, maxRounds, patcherMode, verifierOutput, verifierMaxTries, finalVerifyMode, autoAcceptAfterPatchMissingLeq, autoAccepted, tracer: coverageTrace, finalVerifySkipped: false },
                    educationFeedback: lastEducationFeedback || null,
                };
            }

            return {
                guideText: current,
                missingQids: allProblems.filter(p => missingFinal.has(p.qid)).map(p => p.qid),
                coverageReport: wantReport ? allProblems.map(p => reportByQid.get(p.qid) || { qid: p.qid, covered: false, reason: '(ê²€ì¦ ë¦¬í¬íŠ¸ ì—†ìŒ)' }) : null,
                coverageMeta: { maxTokens, maxRounds, patcherMode, verifierOutput, verifierMaxTries, finalVerifyMode, autoAcceptAfterPatchMissingLeq, autoAccepted, tracer: coverageTrace, finalVerifySkipped: finalVerifyMode === 'global' ? true : false },
                educationFeedback: lastEducationFeedback || null,
            };
        }

        // --- STRICT XML ENVELOPE VALIDATION & BLIND-RETRY HELPER --------------------
        // Ideological reason: LLMs often drift from strict structure; fail-fast + blind-retry
        // with the exact same prompt prevents bad states from propagating through the pipeline.

        /**
         * Attempt to recover partial data from truncated LLM output.
         * This is useful when the LLM hits max_tokens and output is cut off mid-response.
         * Returns { recovered: boolean, text: string, itemsRecovered: number }
         */
        function recoverTruncatedDataEnvelope(rawText) {
            let text = String(rawText || '').trim();
            if (!text) return { recovered: false, text: '', itemsRecovered: 0 };

            // Check if already valid
            const hasDataOpen = /<\s*data\s*>/i.test(text);
            const hasDataClose = /<\s*\/\s*data\s*>/i.test(text);

            if (hasDataOpen && hasDataClose) {
                // Already complete, no recovery needed
                return { recovered: false, text, itemsRecovered: 0 };
            }

            let itemsRecovered = 0;

            // Case 1: Has <data> but no </data> (truncated at the end)
            if (hasDataOpen && !hasDataClose) {
                const hasItemBlocks = /<\s*item\s*>/i.test(text) || /<\s*\/\s*item\s*>/i.test(text);
                if (hasItemBlocks) {
                    // Find the last complete </item>
                    const lastCompleteItemMatch = text.match(/<\s*\/\s*item\s*>\s*$/i)
                        || [...text.matchAll(/<\s*\/\s*item\s*>/gi)].pop();
                    if (lastCompleteItemMatch) {
                        const completeItems = [...text.matchAll(/<\s*\/\s*item\s*>/gi)];
                        itemsRecovered = completeItems.length;
                        const lastIndex = text.lastIndexOf(lastCompleteItemMatch[0]);
                        if (lastIndex > 0) {
                            const endPos = lastIndex + lastCompleteItemMatch[0].length;
                            text = text.substring(0, endPos) + '\n</data>';
                            logger.warn("DataRecovery", `Recovered ${itemsRecovered} items from truncated output (added </data>)`);
                            return { recovered: true, text, itemsRecovered };
                        }
                    }
                    // Fallback: just close the data tag
                    text = text + '\n</data>';
                    itemsRecovered = [...text.matchAll(/<\s*\/\s*item\s*>/gi)].length;
                    if (itemsRecovered > 0) {
                        logger.warn("DataRecovery", `Recovered ${itemsRecovered} items from truncated output (forced </data>)`);
                        return { recovered: true, text, itemsRecovered };
                    }
                } else {
                    // Legacy: Find the last complete </id:N> tag
                    const lastCompleteIdMatch = text.match(/<\s*\/\s*id:\d+\s*>\s*$/i)
                        || [...text.matchAll(/<\s*\/\s*id:(\d+)\s*>/gi)].pop();

                    if (lastCompleteIdMatch) {
                        // Count how many complete id blocks we have
                        const completeIds = [...text.matchAll(/<\s*\/\s*id:(\d+)\s*>/gi)];
                        itemsRecovered = completeIds.length;

                        // Find position after the last complete </id:N>
                        const lastIndex = text.lastIndexOf(lastCompleteIdMatch[0]);
                        if (lastIndex > 0) {
                            const endPos = lastIndex + lastCompleteIdMatch[0].length;
                            text = text.substring(0, endPos) + '\n</data>';
                            logger.warn("DataRecovery", `Recovered ${itemsRecovered} items from truncated output (added </data>)`);
                            return { recovered: true, text, itemsRecovered };
                        }
                    }

                    // Fallback: just close the data tag
                    text = text + '\n</data>';
                    // Count any complete items
                    itemsRecovered = [...text.matchAll(/<\s*\/\s*id:\d+\s*>/gi)].length;
                    if (itemsRecovered > 0) {
                        logger.warn("DataRecovery", `Recovered ${itemsRecovered} items from truncated output (forced </data>)`);
                        return { recovered: true, text, itemsRecovered };
                    }
                }
            }

            // Case 2: No <data> wrapper at all but has id blocks
            if (!hasDataOpen) {
                const hasItemBlocks = /<\s*item\s*>/i.test(text);
                const hasIdBlocks = /<\s*id:\d+\s*>/i.test(text);

                if (hasItemBlocks) {
                    const completeItems = [...text.matchAll(/<\s*\/\s*item\s*>/gi)];
                    if (completeItems.length > 0) {
                        const lastMatch = completeItems[completeItems.length - 1];
                        const lastIndex = text.lastIndexOf(lastMatch[0]);
                        const endPos = lastIndex + lastMatch[0].length;
                        text = '<data>\n' + text.substring(0, endPos) + '\n</data>';
                        itemsRecovered = completeItems.length;
                        logger.warn("DataRecovery", `Recovered ${itemsRecovered} items (added <data> wrapper)`);
                        return { recovered: true, text, itemsRecovered };
                    }
                }

                if (hasIdBlocks) {
                    // Find last complete </id:N>
                    const completeIds = [...text.matchAll(/<\s*\/\s*id:(\d+)\s*>/gi)];
                    if (completeIds.length > 0) {
                        const lastMatch = completeIds[completeIds.length - 1];
                        const lastIndex = text.lastIndexOf(lastMatch[0]);
                        const endPos = lastIndex + lastMatch[0].length;
                        text = '<data>\n' + text.substring(0, endPos) + '\n</data>';
                        itemsRecovered = completeIds.length;
                        logger.warn("DataRecovery", `Recovered ${itemsRecovered} items (added <data> wrapper)`);
                        return { recovered: true, text, itemsRecovered };
                    }
                }
            }

            return { recovered: false, text: rawText, itemsRecovered: 0 };
        }

        /**
         * Validates that:
         * 1) There is **exactly one** <data>...</data> wrapper.
         * 2) No XML-like tags appear **outside** that <data> block.
         * 3) Inside <data>, opening and closing tag counts match for every tag name
         *    (including <item> pairs, or legacy <id:n> pairs).
         * 4) At least one <item> ... </item> block exists (legacy <id:n> supported).
         * Throws an Error with a precise reason if any check fails.
         */
        function validateSingleDataEnvelope(text, { allowEmpty = false } = {}) {
            if (typeof text !== 'string' || !text.trim()) {
                throw new Error('Empty or non-string response.');
            }

            // Normalize HTML self-closing tags to XML format to prevent parsing errors
            let normalized = text
                .replace(/<\s*br\s*\/?>/gi, '<br/>')
                .replace(/<\s*hr\s*\/?>/gi, '<hr/>')
                .replace(/<\s*img\s+([^>]*?)\s*\/?>/gi, '<img $1/>');

            // 1) Exactly one <data>...</data>
            const dataMatches = [...normalized.matchAll(/<\s*data\s*>([\s\S]*?)<\s*\/\s*data\s*>/gi)];
            if (dataMatches.length !== 1) {
                throw new Error(`Expected exactly 1 <data> wrapper, found ${dataMatches.length}.`);
            }

            const fullMatch = dataMatches[0][0];
            const inner = dataMatches[0][1];
            const startIdx = dataMatches[0].index;
            const endIdx = startIdx + fullMatch.length;

            // 2) No tags outside <data> ... </data>
            const outsideBefore = text.slice(0, startIdx);
            const outsideAfter = text.slice(endIdx);
            const tagOutsideRe = /<\s*\/?\s*[a-zA-Z][^>]*>/g; // naive XML-ish tag
            if (tagOutsideRe.test(outsideBefore) || tagOutsideRe.test(outsideAfter)) {
                throw new Error('Found XML-like tags declared outside <data> wrapper.');
            }

            // 3) Opening/closing tag balance check within inner payload
            //    Capture tag names like 'qid', 'question_text', 'id:1', etc.
            const openNames = [];
            const closeNames = [];
            inner.replace(/<\s*(?!\/)([a-zA-Z]+(?::\d+)?)\s*>/g, (_, name) => { openNames.push(name.toLowerCase()); return _; });
            inner.replace(/<\s*\/\s*([a-zA-Z]+(?::\d+)?)\s*>/g, (_, name) => { closeNames.push(name.toLowerCase()); return _; });

            // Require at least one <item> pair (preferred) or legacy <id:n> pair
            const hasItemBlock = openNames.includes('item') && closeNames.includes('item');
            const hasLegacyIdBlock = openNames.some(n => /^id:\d+$/.test(n)) && closeNames.some(n => /^id:\d+$/.test(n));
            if (!hasItemBlock && !hasLegacyIdBlock && !allowEmpty) {
                throw new Error('No <item> ... </item> blocks (or legacy <id:n>) found inside <data>.');
            }

            // Count per tag name
            const count = arr => arr.reduce((m, k) => (m[k] = (m[k] || 0) + 1, m), {});
            const opens = count(openNames);
            const closes = count(closeNames);
            const allNames = new Set([...Object.keys(opens), ...Object.keys(closes)]);
            for (const name of allNames) {
                const o = opens[name] || 0;
                const c = closes[name] || 0;
                if (o !== c) {
                    throw new Error(`Unbalanced tags for <${name}>: openings=${o}, closings=${c}.`);
                }
            }
        }

        // --- LENIENT DATA-ENVELOPE VALIDATION (Standard-Problem stage only) ---
        // ideological reason: we WANT the model to write extra rationale outside <data>
        // to improve reasoning quality, but we still strictly validate the single <data> payload.
        function validateSingleDataEnvelope_lenient(text, { allowEmpty = false } = {}) {
            if (typeof text !== 'string' || !text.trim()) {
                throw new Error('Empty or non-string response.');
            }
            // Normalize HTML self-closing tags to XML format to prevent parsing errors
            let normalized = text
                .replace(/<\s*br\s*\/?>/gi, '<br/>')
                .replace(/<\s*hr\s*\/?>/gi, '<hr/>')
                .replace(/<\s*img\s+([^>]*?)\s*\/?>/gi, '<img $1/>');
            // Exactly one <data>...</data>
            const dataMatches = [...normalized.matchAll(/<\s*data\s*>([\s\S]*?)<\s*\/\s*data\s*>/gi)];
            if (dataMatches.length !== 1) {
                throw new Error(`Expected exactly 1 <data> wrapper, found ${dataMatches.length}.`);
            }
            const inner = dataMatches[0][1];

            // Opening/closing balance inside <data>
            const openNames = [];
            const closeNames = [];
            inner.replace(/<\s*(?!\/)([a-zA-Z]+(?::\d+)?)\s*>/g, (_, name) => { openNames.push(name.toLowerCase()); return _; });
            inner.replace(/<\s*\/\s*([a-zA-Z]+(?::\d+)?)\s*>/g, (_, name) => { closeNames.push(name.toLowerCase()); return _; });

            const hasItemBlock = openNames.includes('item') && closeNames.includes('item');
            const hasLegacyIdBlock = openNames.some(n => /^id:\d+$/.test(n)) && closeNames.some(n => /^id:\d+$/.test(n));
            if (!hasItemBlock && !hasLegacyIdBlock && !allowEmpty) throw new Error('No <item> ... </item> blocks (or legacy <id:n>) found inside <data>.');

            const count = arr => arr.reduce((m, k) => (m[k] = (m[k] || 0) + 1, m), {});
            const opens = count(openNames);
            const closes = count(closeNames);
            const allNames = new Set([...Object.keys(opens), ...Object.keys(closes)]);
            for (const name of allNames) {
                if ((opens[name] || 0) !== (closes[name] || 0)) {
                    throw new Error(`Unbalanced tags for <${name}>: openings=${opens[name] || 0}, closings=${closes[name] || 0}.`);
                }
            }
        }

        function __normalizeStructuredOutputStyle(v, { allowInherit = false } = {}) {
            const s = String(v || '').trim().toLowerCase();
            if (s === 'rationale_then_structured') return 'rationale_then_structured';
            if (s === 'structured_only') return 'structured_only';
            if (allowInherit && s === 'inherit') return 'inherit';
            return allowInherit ? 'inherit' : 'structured_only';
        }

        function __getStructuredOutputStyle(cfg = null) {
            const c = (cfg && typeof cfg === 'object') ? cfg : (() => { try { return getPipelineConfig(); } catch { return null; } })();
            return __normalizeStructuredOutputStyle(c?.format?.structuredOutputStyle || 'structured_only');
        }

        function __inferStructuredPhaseFromContext(context) {
            const c = String(context || '').toLowerCase();
            if (c.includes('classifybatch') || c.includes('phase1b')) return 'phase1b';
            if (c.includes('createtypes') || c.includes('evaltypes') || c.includes('phase1a') || c.includes('merge')) return 'phase1a';
            if (c.startsWith('extract-') || c.includes('phase0')) return 'phase0';
            if (c.startsWith('phase2') || c.startsWith('module-') || c.includes('coverage') || c.includes('revise') || c.includes('feedback')) return 'phase2';
            return null;
        }

        function __getStructuredOutputStyleForPhase(cfg = null, { phase = null, context = null } = {}) {
            const c = (cfg && typeof cfg === 'object') ? cfg : (() => { try { return getPipelineConfig(); } catch { return null; } })();
            const globalStyle = __getStructuredOutputStyle(c);
            const ph = String(phase || '').trim().toLowerCase() || __inferStructuredPhaseFromContext(context);
            if (!ph) return globalStyle;
            const byPhase = (c?.format?.structuredOutputStyleByPhase && typeof c.format.structuredOutputStyleByPhase === 'object')
                ? c.format.structuredOutputStyleByPhase
                : null;
            const override = byPhase ? __normalizeStructuredOutputStyle(byPhase[ph], { allowInherit: true }) : 'inherit';
            if (override === 'inherit') return globalStyle;
            return override;
        }

        function __isStructuredRationaleModeOn({ phase = null, context = null } = {}) {
            try { return __getStructuredOutputStyleForPhase(getPipelineConfig(), { phase, context }) === 'rationale_then_structured'; } catch { return false; }
        }

        function __appendTextToLastUserMessage(apiPayload, suffixText) {
            const base = (apiPayload && typeof apiPayload === 'object') ? apiPayload : {};
            const messages = Array.isArray(base?.messages) ? base.messages : [];
            const suffix = String(suffixText || '');
            if (!suffix || !messages.length) return base;

            const nextMessages = messages.map(m => (m && typeof m === 'object') ? { ...m } : m);
            let idx = -1;
            for (let i = nextMessages.length - 1; i >= 0; i--) {
                const role = String(nextMessages[i]?.role || '').toLowerCase();
                if (role === 'user') { idx = i; break; }
            }
            if (idx < 0) idx = nextMessages.length - 1;
            const msg = nextMessages[idx];
            const content = msg?.content;

            if (typeof content === 'string') {
                nextMessages[idx] = { ...msg, content: content + suffix };
            } else if (Array.isArray(content)) {
                const arr = content.map(p => (p && typeof p === 'object') ? { ...p } : p);
                let appended = false;
                for (let j = arr.length - 1; j >= 0; j--) {
                    if (arr[j]?.type === 'text' && typeof arr[j].text === 'string') {
                        arr[j] = { ...arr[j], text: arr[j].text + suffix };
                        appended = true;
                        break;
                    }
                }
                if (!appended) arr.push({ type: 'text', text: suffix });
                nextMessages[idx] = { ...msg, content: arr };
            } else {
                nextMessages[idx] = { ...msg, content: String(content || '') + suffix };
            }

            return { ...base, messages: nextMessages };
        }

        function __withStructuredRationaleMode(apiPayload, { kind, phase, context } = {}) {
            if (!__isStructuredRationaleModeOn({ phase, context })) return apiPayload;
            const k = String(kind || 'data').toLowerCase();
            const ph = String(phase || '').trim().toLowerCase() || __inferStructuredPhaseFromContext(context);
            const isBrief = ph === 'phase1b';
            const firstLine = isBrief
                ? '- First: write a VERY SHORT methodology summary (max 4 bullets; NO per-item reasoning; no XML/HTML tags; avoid angle brackets < >).'
                : '- First: explain your reasoning in plain text (no XML/HTML tags; avoid angle brackets < >).';
            const note = (k === 'patches')
                ? `\n\nSTRUCTURED_OUTPUT_STYLE: RATIONALE_THEN_PATCHES\n${firstLine}\n- Last: output exactly one <patches>...</patches> block, as the final part of your response.\n- Do not add any content after </patches>.`
                : `\n\nSTRUCTURED_OUTPUT_STYLE: RATIONALE_THEN_STRUCTURED\n${firstLine}\n- Last: output exactly one <data>...</data> block, as the final part of your response.\n- Do not add any content after </data>.`;
            return __appendTextToLastUserMessage(apiPayload, note);
        }

        function __patchOutputDirectiveLine({ phase = null, context = null } = {}) {
            return __isStructuredRationaleModeOn({ phase, context })
                ? 'Return the required <patches> output format.'
                : 'Return patch instructions only.';
        }

        function buildDataEnvelopeRepairPayload(apiPayload, raw, errorMsg, { phase = null, context = null } = {}) {
            const baseMessages = Array.isArray(apiPayload?.messages) ? apiPayload.messages : [];
            const wantRationale = __isStructuredRationaleModeOn({ phase, context });
            const fixNote =
                `The previous output failed <data> format validation.\n\nError:\n${errorMsg}\n\nOriginal output:\n${raw}\n\n` +
                `Return the SAME content, but strictly formatted as:\n<data>\n  <item>\n    <id>1</id>\n    ...\n  </item>\n  <item>\n    <id>2</id>\n    ...\n  </item>\n  ...\n</data>\n(Use <item> blocks; do NOT use <id:n> tags.)\n` +
                (wantRationale
                    ? `In this mode, write your rationale FIRST (plain text only; avoid angle brackets), then output the single <data> block LAST. Do not add content after </data>.`
                    : `If you add any extra explanation, place it AFTER </data>.`);
            return {
                ...apiPayload,
                messages: [...baseMessages, { role: 'user', content: fixNote }]
            };
        }

        async function requestAndParseDataEnvelopeLenient(apiPayload, context, { phase = null, allowEmpty = false } = {}) {
            let tryNo = 0;
            const maxTries = (() => {
                try { return __clampInt(getPipelineConfig()?.format?.maxDataEnvelopeTries ?? 0, { min: 0, max: 99, fallback: 0 }); } catch { return 0; }
            })();
            while (true) {
                if (processController.stop) throw new Error('Operation cancelled.');
                tryNo++;
                if (maxTries > 0 && tryNo > maxTries) {
                    throw new Error(`Max <data> retries reached (${maxTries}) for ${context}`);
                }
                const payloadTry = __withStructuredRationaleMode(apiPayload, { kind: 'data', phase, context });
                const raw = await resilientLlmRequest(payloadTry, `${context}-XMLTry${tryNo}`);
                try {
                    validateSingleDataEnvelope_lenient(raw, { allowEmpty }); // tolerate any text outside <data>
                    return parsePerfectEnvelope(raw, { allowEmpty });        // still parse ONLY inside <data>
                } catch (e) {
                    try {
                        __formatErrors.add({
                            kind: 'data_envelope',
                            stage: 'XMLTry',
                            attempt: tryNo,
                            context,
                            error: e?.message || String(e || ''),
                            request: payloadTry,
                            responseRaw: raw,
                            meta: { mode: 'lenient' }
                        });
                    } catch { }
                    logger.warn(context, `Lenient structured-output validation failed (try ${tryNo}): ${e.message}. Running format refiner...`);
                    const repairPayload = buildDataEnvelopeRepairPayload(apiPayload, raw, e.message || 'Invalid <data> envelope', { phase, context });
                    const payloadRepair = __withStructuredRationaleMode(repairPayload, { kind: 'data', phase, context });
                    const repaired = await resilientLlmRequest(payloadRepair, `${context}-XMLRepair${tryNo}`);
                    try {
                        validateSingleDataEnvelope_lenient(repaired, { allowEmpty });
                        try {
                            __formatErrors.add({
                                kind: 'data_envelope',
                                stage: 'XMLRepair',
                                attempt: tryNo,
                                context,
                                error: '',
                                request: payloadRepair,
                                responseRaw: repaired,
                                meta: { mode: 'lenient', ok: true }
                            });
                        } catch { }
                        return parsePerfectEnvelope(repaired, { allowEmpty });
                    } catch (e2) {
                        try {
                            __formatErrors.add({
                                kind: 'data_envelope',
                                stage: 'XMLRepair',
                                attempt: tryNo,
                                context,
                                error: e2?.message || String(e2 || ''),
                                request: payloadRepair,
                                responseRaw: repaired,
                                meta: { mode: 'lenient' }
                            });
                        } catch { }
                        logger.warn(context, `Refiner failed to fix <data> (try ${tryNo}): ${e2.message}. Retrying...`);
                    }
                }
            }
        }

        /**
         * Calls the LLM with the EXACT SAME payload until a structurally valid
         * <data>...</data> envelope is returned, then parses it with parsePerfectEnvelope.
         * Never sends corrective feedback to the model; purely blind retry.
         */
        async function requestAndParseDataEnvelope(apiPayload, context, { phase = null, allowEmpty = false } = {}) {
            let tryNo = 0;
            const maxTries = (() => {
                try { return __clampInt(getPipelineConfig()?.format?.maxDataEnvelopeTries ?? 0, { min: 0, max: 99, fallback: 0 }); } catch { return 0; }
            })();
            while (true) {
                if (processController.stop) throw new Error('Operation cancelled.');
                tryNo++;
                if (maxTries > 0 && tryNo > maxTries) {
                    throw new Error(`Max <data> retries reached (${maxTries}) for ${context}`);
                }
                const payloadTry = __withStructuredRationaleMode(apiPayload, { kind: 'data', phase, context });
                const raw = await resilientLlmRequest(payloadTry, `${context}-XMLTry${tryNo}`);

                // Try validation first
                try {
                    if (__isStructuredRationaleModeOn({ phase, context })) validateSingleDataEnvelope_lenient(raw, { allowEmpty });
                    else validateSingleDataEnvelope(raw, { allowEmpty });
                    return parsePerfectEnvelope(raw, { allowEmpty });
                } catch (e) {
                    try {
                        __formatErrors.add({
                            kind: 'data_envelope',
                            stage: 'XMLTry',
                            attempt: tryNo,
                            context,
                            error: e?.message || String(e || ''),
                            request: payloadTry,
                            responseRaw: raw,
                            meta: { mode: (__isStructuredRationaleModeOn({ phase, context }) ? 'lenient' : 'strict') }
                        });
                    } catch { }
                    // Try to recover truncated output before expensive repair
                    const recovery = recoverTruncatedDataEnvelope(raw);
                    if (recovery.recovered && recovery.itemsRecovered > 0) {
                        try {
                            validateSingleDataEnvelope_lenient(recovery.text, { allowEmpty });
                            logger.info(context, `Recovered ${recovery.itemsRecovered} items from truncated output (try ${tryNo})`);
                            return parsePerfectEnvelope(recovery.text, { allowEmpty });
                        } catch (recoveryErr) {
                            logger.warn(context, `Recovery validation failed: ${recoveryErr.message}. Falling back to repair...`);
                        }
                    }

                    // Original repair flow
                    logger.warn(context, `Structured-output validation failed (try ${tryNo}): ${e.message}. Running format refiner...`);
                    const repairPayload = buildDataEnvelopeRepairPayload(apiPayload, raw, e.message || 'Invalid <data> envelope', { phase, context });
                    const payloadRepair = __withStructuredRationaleMode(repairPayload, { kind: 'data', phase, context });
                    const repaired = await resilientLlmRequest(payloadRepair, `${context}-XMLRepair${tryNo}`);
                    try {
                        validateSingleDataEnvelope_lenient(repaired, { allowEmpty });
                        try {
                            __formatErrors.add({
                                kind: 'data_envelope',
                                stage: 'XMLRepair',
                                attempt: tryNo,
                                context,
                                error: '',
                                request: payloadRepair,
                                responseRaw: repaired,
                                meta: { mode: 'repair', ok: true }
                            });
                        } catch { }
                        return parsePerfectEnvelope(repaired, { allowEmpty });
                    } catch (e2) {
                        try {
                            __formatErrors.add({
                                kind: 'data_envelope',
                                stage: 'XMLRepair',
                                attempt: tryNo,
                                context,
                                error: e2?.message || String(e2 || ''),
                                request: payloadRepair,
                                responseRaw: repaired,
                                meta: { mode: 'repair' }
                            });
                        } catch { }
                        logger.warn(context, `Refiner failed to fix <data> (try ${tryNo}): ${e2.message}. Retrying...`);
                    }
                }
            }
        }

        function parseBracketLabel(text, allowed = ['perfect', 'pass', 'fail', 'acceptable']) {
            const re = /\[([^\]]+)\]/gi;
            const found = [];
            let m;
            while ((m = re.exec(text)) !== null) {
                const label = String(m[1]).trim().toLowerCase();
                if (allowed.includes(label)) found.push(label);
            }
            if (found.length !== 1) throw new Error('Invalid or ambiguous label markers');
            return found[0];
        }

        // ADD: Decision tag parser (below parseBracketLabel)
        function parseDecisionTag(text, allowed = ['pass', 'fail']) {
            const re = /<\s*(pass|fail|error)\s*>/gi;
            const found = [];
            let m;
            while ((m = re.exec(text)) !== null) {
                const label = String(m[1]).trim().toLowerCase();
                if (allowed.includes(label)) found.push(label);
            }
            if (found.length === 0) throw new Error(`Missing one of <${allowed.join('>, <')}> decision tags`);
            const unique = Array.from(new Set(found));
            if (unique.length > 1) throw new Error('Conflicting decision tags detected');
            return unique[0];
        }

        function parseTag(value, tagName) {
            const m = value.match(new RegExp(`<\\s*${tagName}\\s*>([\\s\\S]*?)<\\s*\\/\\s*${tagName}\\s*>`, 'i'));
            return m ? m[1].trim() : '';
        }

        // Phase 0 QA item
        function parseQAItem(value) {
            return {
                qid: parseTag(value, 'qid') || null,
                question_text: parseTag(value, 'question_text'),
                answer_choices: parseTag(value, 'answer_choices') || '',
                official_answer: parseTag(value, 'official_answer') || null,
                official_explanation: parseTag(value, 'official_explanation') || null
            };
        }


	        // NEW: Build a stable, global question ID that encodes which paper it came from.
	        // This solves the "Q1 from which file?" ambiguity for both humans and other agents.
	        // NEW: Build a stable, global question ID that encodes which paper it came from.
	        // This solves the "Q1 from which file?" ambiguity for both humans and other agents.
	        function makeGlobalQid(paperName, localQid) {
	            // IMPORTANT: OCR units may be split into parts for processing ("(Part N, pX-Y)"),
	            // but QIDs must use the *original source file name* (no Part suffix) for readability.
	            const base = (() => {
	                let s = deriveSourceFileNameFromUnitName(paperName);
	                // Legacy/defensive: handle underscore-style suffixes seen in older QIDs (e.g., ".pdf_Part_6_p16-18").
	                s = s.replace(/_Part_\d+(?:_p\d+(?:-\d+)?)?/gi, '');
	                s = String(s || '').replace(/\s+/g, ' ').trim();
	                // Normalize extension casing (cosmetic but stabilizes output).
	                s = s.replace(/\.pdf$/i, '.pdf').replace(/\.txt$/i, '.txt');
	                return s;
	            })();

	            // We choose "::" as a delimiter because it's visually obvious and easy to parse.
	            // Example: "Midterm2024.pdf::Q1b"
	            return `${base}::${localQid}`;
	        }

        function deriveSourceFileNameFromUnitName(unitName) {
            const name = String(unitName || '').trim();
            if (!name) return '';
            // Matches the suffix we generate during PDF splitting: " (Part N, pX-Y)"
            const stripped = name.replace(/\s*\(Part\s+\d+\s*,\s*p\d+\s*-\s*\d+\)\s*$/i, '').trim();
            return stripped || name;
        }

        const TYPE_SPLIT_LIMIT = 9999; // keep effectively unlimited (no type splitting by default)

        function splitQidsByChunks(qids, limit) {
            const out = [];
            const arr = Array.isArray(qids) ? qids : [];
            const lim = Math.max(1, Number(limit || 0) || 1);
            for (let i = 0; i < arr.length; i += lim) out.push(arr.slice(i, i + lim));
            return out.length ? out : [arr.slice()];
        }

        function buildSplitTypeNames(base, count, used) {
            const names = [];
            for (let i = 1; i <= count; i++) {
                let suffix = `(${i})`;
                let candidate = `${base} ${suffix}`;
                let bump = 2;
                while (used.has(candidate) || names.includes(candidate)) {
                    candidate = `${base} ${suffix}-${bump++}`;
                }
                names.push(candidate);
            }
            return names;
        }

        // (Removed code-similarity based splitting/grouping; keep only simple sequential chunking.)

        function buildPatternClusters(perQuestionArr) {
            const byPattern = new Map(); // pattern_name -> qids[]
            (perQuestionArr || []).forEach(item => {
                const key = String(item?.pattern_name || '').trim() || 'UNCLASSIFIED';
                if (!byPattern.has(key)) byPattern.set(key, []);
                byPattern.get(key).push(item.qid);
            });

            const itemByQid = new Map((perQuestionArr || []).map(it => [it.qid, it]));
            const usedNames = new Set(Array.from(byPattern.keys()));
            const clusters = [];
            const updatedPerQuestion = [];

            Array.from(byPattern.entries()).forEach(([patternName, qidsRaw]) => {
                const qids = (qidsRaw || []).slice();
                if (qids.length > TYPE_SPLIT_LIMIT) {
                    const parts = splitQidsByChunks(qids, TYPE_SPLIT_LIMIT);
                    const names = buildSplitTypeNames(patternName, parts.length, usedNames);
                    parts.forEach((partQids, idx) => {
                        const name = names[idx];
                        usedNames.add(name);
                        clusters.push({
                            pattern_name: name,
                            qids: partQids,
                            parent_pattern_name: patternName
                        });
                        partQids.forEach(qid => {
                            const base = itemByQid.get(qid) || { qid };
                            updatedPerQuestion.push({ ...base, pattern_name: name });
                        });
                    });
                } else {
                    clusters.push({ pattern_name: patternName, qids: qids.slice(), parent_pattern_name: null });
                    qids.forEach(qid => {
                        const base = itemByQid.get(qid) || { qid };
                        updatedPerQuestion.push({ ...base, pattern_name: patternName });
                    });
                }
            });

            return { clusters, perQuestion: updatedPerQuestion };
        }

        // ADD: History builders for Phase 1 and Phase 2

        function buildPhase1HistoryContext(attempts = []) {
            if (!attempts || attempts.length === 0) return '';
            return 'HISTORY OF PREVIOUS CLASSIFICATION ATTEMPTS:\n' + attempts.map((at, idx) => {
                const decision = (at.evaluation && at.evaluation.decision)
                    ? at.evaluation.decision.toUpperCase()
                    : (at.isPassing ? 'PASS' : 'FAIL');
                const evalTxt = at.evaluation?.fullText || '';
                return `\n--- Attempt ${idx + 1} ---
      Types: ${at.typeCount}
      Decision: ${decision}
      ${evalTxt ? `\nEvaluator Output:\n${evalTxt}\n` : ''}`;
            }).join('\n');
        }

        function formatStandardForLLM(standard = []) {
            if (typeof standard === 'string') return standard;
            const arr = Array.isArray(standard) ? standard : [];
            return arr.map(t =>
                `TYPE: ${t.type_name}
      DESCRIPTION: ${t.type_description}
      RECOGNITION: ${t.recognition_criteria}
      CONCEPTS: ${t.core_concepts}`
            ).join('\n\n---\n\n');
        }

        function buildModuleHistoryContext(moduleState) {
            const cycles = moduleState?.refinementCycles || [];
            if (cycles.length === 0) return '';
            return 'Here is the history of previous critiques for this type, including the submitted guides and the critic\'s full response. Use this context to ensure your critique is consistent and thorough.\n'
                + cycles.map((c, i) => {
                    const attemptNum = i + 1;
                    const expl = c.explanationSnapshot || '';
                    const fullV = c.fullVerification || c.feedback || '';
                    return `\n--- Critique of Attempt ${attemptNum} ---
      ### Guide Attempt ${attemptNum} ###
      ${expl}
      
      ### Previous Critic's Full Output for Attempt ${attemptNum} ###
      ${fullV}
      `;
                }).join('\n');
        }

        function summarizeVerification(cycles = []) {
            const total = cycles.length;
            const pass = cycles.filter(c => (c.decisionTag || '').toLowerCase() === 'pass').length;
            const fail = cycles.filter(c => (c.decisionTag || '').toLowerCase() === 'fail').length;
            const last = total ? (cycles[total - 1].decisionTag || 'n/a').toLowerCase() : 'n/a';
            // ëì—ì„œë¶€í„° ì—°ì† pass ìŠ¤íŠ¸ë¦­ ê³„ì‚°
            let streak = 0;
            for (let i = cycles.length - 1; i >= 0; i--) {
                if ((cycles[i].decisionTag || '').toLowerCase() === 'pass') streak++;
                else break;
            }
            return { total, pass, fail, last, streak };
        }

        // Convert internal QIDs like "Q48" found inside text to GLOBAL_QIDs using the module's coverage list.
        function convertInternalQidsToGlobal(text, qidsCovered = []) {
            if (!text) return text;

            // 1) ë¡œì»¬â†’ê¸€ë¡œë²Œ ë©€í‹°ë§µ êµ¬ì¶• (ì¶©ëŒ ê°ì§€ìš©)
            const multi = {};
            qidsCovered.forEach(gid => {
                const ix = String(gid).lastIndexOf('::');
                if (ix !== -1) {
                    const local = gid.slice(ix + 2); // 'Q48' ë“±
                    (multi[local] ||= new Set()).add(gid);
                }
            });

            // 2) ìœ ì¼ ë§¤í•‘ë§Œ ë³„ë„ ë§µìœ¼ë¡œ
            const unique = {};
            Object.entries(multi).forEach(([local, set]) => {
                if (set.size === 1) unique[local] = [...set][0];
            });

            // 3A) ê´„í˜¸í˜• "(Q48)"ì€ í•­ìƒ ì¹˜í™˜ (ì¶©ëŒ ì‹œ ì²« ë²ˆì§¸ ê²ƒìœ¼ë¡œ ê²°ì •ì  ì¹˜í™˜)
            text = text.replace(/\((Q\d+[a-z]?)\)/g, (m, q) => {
                const set = multi[q];
                if (!set || set.size === 0) return m;
                const gid = unique[q] || [...set][0]; // ì¶©ëŒ ì‹œì—ë„ ê²°ì •ì ìœ¼ë¡œ í•˜ë‚˜ ì„ íƒ
                return `(${gid})`;
            });

            // 3B) ë‹¨ë… í† í° ì¹˜í™˜ì€ "í—¤ë”© ë¼ì¸(#...)" ì•ˆì—ì„œ + ìœ ì¼ ë§¤í•‘ì—ë§Œ ìˆ˜í–‰
            const lines = text.split('\n').map(line => {
                if (!/^#{1,6}\s/.test(line)) return line; // í—¤ë”© ì•„ë‹ˆë©´ ê±´ë“œë¦¬ì§€ ì•ŠìŒ
                return line.replace(/\b(Q\d+[a-z]?)\b/g, (m, q) => unique[q] || m);
            });
            text = lines.join('\n');

            return text;
        }

        // ideological reason: centralize ordering so final guide becomes pedagogically coherent.
        async function maybeComputeGlobalTypeOrder() {
            try {
                if (!activeProcess || !Array.isArray(activeProcess.phase2_modules)) return;
                if (activeProcess.typeOrdering?.order?.length) return; // already computed

                const mods = activeProcess.phase2_modules;
                if (!mods.every(m => m.standardProblem && m.standardProblem.problem)) return; // wait until all SPs exist

                const standardList = activeProcess.phase1_patterns?.standardCreation?.finalStandard || [];
                const payloadList = mods.map(m => {
                    const direct = standardList.find(t => t.type_name === m.pattern_name)?.type_description;
                    const parent = m.parent_pattern_name
                        ? standardList.find(t => t.type_name === m.parent_pattern_name)?.type_description
                        : '';
                    return {
                        type_name: m.pattern_name,
                        type_description: direct || parent || '',
                        standard_problem: m.standardProblem.problem
                    };
                });

                const language = __getGuideLanguageFromUi();
                const orderPayload = {
                    model: getApiConfig().model,
                    messages: [
                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.type_orderer.system, { language }) },
                        {
                            role: 'user', content:
                                `Final objective: maximize learning efficiency for beginners across all types.

      Types to order (JSON):
      ${JSON.stringify(payloadList, null, 2)}

      Output only the ordered list of type names in <data><item><id>n</id><type_name>...</type_name></item></data>. You may add rationale after </data>.`
                        }
                    ]
                };

                const items = await requestAndParseDataEnvelopeLenient(orderPayload, 'TypeOrder', { phase: 'phase2' });
                const order = items.map(it => parseTag(it.value, 'type_name')).filter(Boolean);

                activeProcess.typeOrdering = { status: 'completed', order };
                logger.success('TypeOrder', `Computed learning order for ${order.length} types.`);
            } catch (e) {
                logger.warn('TypeOrder', `Could not compute type order: ${e.message}`);
            }
        }

        //======================================================================
        // 3. PROMPTS (NEW PIPELINE AGENTS)
        //======================================================================

	        const DEFAULT_PROMPTS = {
	            extractor: {
	                system:
	                    `You are the Question Extractor Agent.
	
	You will read exam paper content (as OCR images + raw text, or plain text).

LANGUAGE REQUIREMENT:
- Write ALL extracted fields in {language}.
	
	For text-based PDFs: Use the OCR images for layout/structure, but use the raw text to correct any OCR typos or errors.

For EVERY question and sub-question, output ONE <item> per question inside:
<data>
  <item>
    <id>1</id>
    ...
  </item>
  <item>...</item>
</data>

Each <item> MUST include:
<qid>Unique question id like "Q1", "Q1a", "Q2"</qid>
<question_text>The full question text. If the question includes any images, diagrams, graphs, circuits, or other non-textual elements, describe them with extreme detail inside this tag. Your description must be a perfect textual substitute for the visual, capturing all labels, values, connections, and relationships, so that nothing is lost from the original problem.</question_text>
<answer_choices>All answer choices if this is a multiple choice question (e.g., "A) ... B) ... C) ... D) ..."), otherwise leave empty</answer_choices>
<official_answer>The final correct answer ONLY if explicitly shown in the paper (answer key, solution, etc.). If not shown, leave empty.</official_answer>
<official_explanation>The official explanation/solution ONLY if explicitly provided in the paper. If not provided, leave empty.</official_explanation>

	CRITICAL RULES:
	- Do NOT solve problems yourself to generate answers
	- Do NOT invent explanations
	- Include answer choices as part of the problem data
	- If a question has answer choices, put them ONLY in <answer_choices> and do NOT duplicate them inside <question_text>. (Exception: if choices are genuinely interleaved inside the stem and cannot be cleanly separated; in that case keep them in <question_text> and leave <answer_choices> empty.)
	- IMPORTANT (ë³´ê¸°/ã„±ã„´ã„·ã„¹): If the paper shows a "<ë³´ê¸°>" / "ë³´ê¸°" block (e.g., ã„±. ..., ã„´. ..., ã„·. ...) that the options refer to, keep that entire block inside <question_text>. In <answer_choices>, include ONLY the selectable options (e.g., "â‘  ã„±, ã„´", "â‘¡ ã„±, ã„·", ...) and do NOT include the <ë³´ê¸°> block there.
	- If multiple choices are written on one line (e.g., "â‘  ... â‘¡ ... â‘¢ ..."), still transcribe them as separate choices (prefer one choice per line) inside <answer_choices>.
	- Shared passage/data: if a passage, table, figure, graph, or "common stem" is referenced by multiple questions, include the full passage/data in EACH relevant <question_text> so every extracted item is standalone/solvable.
	- Extract ONLY what is actually present in the document
	- Do not skip sub-questions; make Q3a, Q3b, etc as separate blocks
	- No commentary outside <data>...</data>
- Faithfully describe all visuals: Your primary goal is to extract 100% of the problem's information. For any non-textual content, provide a textual description so complete that a person can solve the problem without ever seeing the original image.
- Visual-description safety: Do NOT reveal/guess the answer by naming the object/entity/category unless it is explicitly written/labeled in the document. Describe what is visible (shape, parts, inscriptions, arrangement, labels, values) without adding identifying claims that would shortcut the question.
- When transcribing equations or variables from OCR, write them in LaTeX using $...$ or $$...$$ and **never** wrap LaTeX in backticks.`
            },
            classifier_standard: {
                system:
                    `You are the Classification Standard Creator.

You will receive a set (often a chunk) of exam problems. Your job is to analyze them and create a classification standard that groups them into pattern types.

MAX TYPES LIMIT:
- The maximum number of types is provided in the user message as:
  MAX_TYPES: N
- You MUST output N types or fewer.

CRITICAL REQUIREMENTS:
1. Each type must be **maximally sized** only insofar as **ONE standard problem + explanation can genuinely cover** all problems in that type (teachability is the hard constraint).
2. The **primary objective** of classification is to enable creating such standard problems (coverage-first design).
3. Types should be based on:
   - Core concepts/formulas needed
   - Solution methodology/approach
   - NOT on superficial details like specific numbers or contexts
4. **Educational Efficiency**: For each type, identify "Cheat Sheet" style recognition rulesâ€”visual cues, keywords, or common structures that allow students to instantly identify this type (e.g., "If you see a triangle with two angles, use Sine Rule").

OUTPUT FORMAT:
<data>
  <item>
    <id>1</id>
    <type_name>Short descriptive name</type_name>
    <type_description>What defines this type and what problems belong here</type_description>
    <recognition_criteria>How to instantly recognize if a problem belongs to this type. Include "Cheat Sheet" cues, keywords, and specific visual patterns.</recognition_criteria>
    <core_concepts>Key concepts/formulas that define this type</core_concepts>
  </item>
  <item>...</item>
  ...
</data>

Maximize type coverage within the MAX_TYPES limit.`
            },
            classifier_standard_verifier: {
                system:
                    `You are the Classification Standard Evaluator.
	          
	          Final Objective:
	          Students should be able to solve ALL problems belonging to each type after studying one representative "standard problem" with a thorough explanation for that type.
	          
	          Evaluate whether a proposed GLOBAL classification standard satisfies ALL of the following:
	          1) The standard contains **MAX_TYPES or fewer**, where MAX_TYPES is provided in the user message as "MAX_TYPES: N".
	          2) Each type is maximally sized **subject to teachability**: one representative standard problem and its explanation can genuinely cover that type.
	          3) Types are based on **core concepts and solution approach**, not surface details.
          
          Use the full history context provided to maintain consistency. If the standard splits types unnecessarily or is too broad to be teachable via one standard problem + explanation, then FAIL it and propose concrete merges/splits or rewording to fix.
          
          Your response must include:
          - A concise summary
          - A detailed critique with concrete, actionable fixes (if any)
          - End with exactly one decision tag: <pass> or <fail> (lowercase)`
            },
            classifier_apply: {
                system:
                    `You are the Pattern Classifier Agent.

You have been given a GLOBAL CLASSIFICATION STANDARD with defined pattern types.

Your job: classify the provided problems according to this standard.

OUTPUT FORMAT:
<data>
  <item>
    <id>1</id>
    <qid>GLOBAL_QID exactly as provided</qid>
    <type_name>Exact type name from the standard</type_name>
    <subgroup_tag>Optional: group near-identical problems WITHIN the same type using a short tag like "aa", "ab", ... (leave empty if not in a subgroup)</subgroup_tag>
  </item>
  <item>...</item>
  ...
</data>

SUBGROUP RULES (optional):
- A subgroup is ONLY for problems that share essentially the same solution logic â€” so similar that you could describe the solving method in ONE identical sentence for all of them.
- Only create a subgroup if it has 2+ problems. Singletons must leave <subgroup_tag> empty.
- Subgroups must NEVER cross different <type_name>.
- Use short alphabetical tags like "aa", "ab", "ac"... Reuse the same tag for all problems in the same subgroup. Different subgroups must use different tags.

Classify ALL provided problems. Use ONLY type names from the provided standard.`
            },
            answer_key_extractor: {
                system:
                    `You are the Answer Key Import Agent.

You will be given:
1) A list of candidate exam papers (paper_name + qid patterns).
2) An answer-key / solution document (text and/or OCR images).

Your job:
- Determine which candidate paper the answer-key belongs to.
- Extract the official answers for as many questions as possible.

OUTPUT FORMAT:
<data>
  <item>
    <id>1</id>
    <paper_name>Exact paper_name from the candidate list</paper_name>
    <local_qid>Question id like "Q1", "Q1a", "1", "1-1" (as written in the answer-key)</local_qid>
    <official_answer>Final answer only (keep original format if possible, e.g. "â‘¢" or "3" or "A")</official_answer>
  </item>
  <item>...</item>
</data>

RULES:
- paper_name MUST match one of the candidate paper_name values exactly.
- Output one <item> per answer you can extract.
- If the answer-key does not specify a question number, infer it only when unambiguous.
- Do NOT solve problems. Only extract what is present in the answer-key.
- No commentary outside <data>...</data>.`
            },
            answer_filler: {
                system:
                    `You are the Answer & Explanation Generator.

You will be given a batch of exam problems that are missing official answers (and may also be missing official explanations).

Your job:
- Solve each problem.
- Output the final answer AND a clear explanation.

LANGUAGE REQUIREMENT:
- Write <explanation> in {language}.

OUTPUT FORMAT:
<data>
  <item>
    <id>1</id>
    <qid>GLOBAL_QID exactly as provided</qid>
    <answer>Final answer (for multiple choice: output the choice number/letter/mark, e.g. "3" or "C" or "â‘¢")</answer>
    <explanation>Step-by-step explanation</explanation>
    <confidence>0.0-1.0</confidence>
  </item>
  <item>...</item>
</data>

RULES:
- Solve ALL provided problems.
- Do NOT include any text outside <data>...</data>.
- Keep <answer> concise (final only).
- <explanation> must not be empty.
- <confidence> must be a valid number between 0 and 1.`
            },
            subgroup_creator: {
                system:
                    `You are the Subgrouping Agent.

You will receive one or more pattern types. Each type includes a list of problems (qid + short text).

Your job: find OPTIONAL subgroups WITHIN each type.

SUBGROUP DEFINITION (STRICT):
- A subgroup must contain 2+ problems.
- All problems in a subgroup must share essentially the same solution logic â€” so similar that you can describe the solving method in ONE identical sentence for all of them.
- Be conservative: only create a subgroup if you are very confident the one-sentence rule fits ALL problems in that subgroup.
- Do NOT force grouping. It is OK if a type has no subgroups.
- Subgroups must NEVER cross different <type_name>.
- Each qid can appear in at most one subgroup.

LANGUAGE REQUIREMENT:
- Write <subgroup_rule> in {language}.

OUTPUT FORMAT:
<data>
  <item>
    <id>1</id>
    <type_name>Exact type name as provided</type_name>
    <none>true</none>
  </item>
  <item>
    <id>2</id>
    <type_name>Exact type name as provided</type_name>
    <subgroup_rule>ONE sentence rule of thumb</subgroup_rule>
    <qids>GLOBAL_QID_1
GLOBAL_QID_2
...</qids>
  </item>
  ...
</data>

RULES:
- If a type has NO subgroups, output exactly ONE item for that type with <none>true</none>.
- If a type has one or more subgroups, output ONE item per subgroup and do NOT output <none>true</none> for that type.
- Use only qids that appear in the input, and copy them exactly.
- No commentary outside <data>...</data>.`
            },
	            standard_problem_creator: {
	                system:
	                    `You are the Standard Problem Creator.
	
	Given a set of problems of the same type, create ONE representative "standard problem" that, when explained in detail, will teach students how to solve ALL problems of this type.

LANGUAGE REQUIREMENT:
- Write everything (rationale + the standard problem) in {language}.
	
	The standard problem must:
	1. Be representative of the type's core challenge
2. Not be trivially simple or impossibly complex
3. Exercise all key concepts/formulas of this type
4. **Not** be artificially cobbled together just to meet constraints; it must have **high real-exam representativeness**, matching authentic difficulty and current question trends.

IMPORTANT:
First, **explain in detail your design choices for the problem** you are about to create. This rationale should cover its representativeness, how it fits current trends, and its concept coverage.
After providing this detailed explanation, output the problem itself inside a <data> block.
If the problem naturally lends itself to a simple visual (e.g., phasor/axis diagram, triangle, simple circuit, small block diagram, matrix/table, tree/graph, timeline) that benefits clarity, you can include a concise sketch or brief textual depiction. Standard problem must be representative yet unambiguous to human observers. Keep in mind that a standard problem must be natural enough to seamlessly qualify as one of the presented problems itself.

OUTPUT FORMAT:
[Your detailed rationale and design explanation here...]

<data>
  <item>
    <id>1</id>
    <standard_problem>The complete problem statement, including any answer choices if applicable</standard_problem>
    <correct_answer>The correct answer to this standard problem</correct_answer>
  </item>
</data>

Only the content inside the <data> block will be parsed by the system.
Output exactly ONE standard problem.

CRITICAL: Do NOT use HTML tags like <br>, <p>, <div>, etc. inside the XML tags. Use plain text only. For line breaks, use actual newlines or double newlines.`
            },
            explanation_creator: {
                system:
                    `You are the Detailed Explanation Creator.

LANGUAGE REQUIREMENT:
- Write the entire explanation in {language}.

You will create an extremely detailed, step-by-step explanation for solving a standard problem. Write STRICTLY in the **same language as the standard problem**. Do NOT use English titles (e.g. 'common patterns', 'frequent') if the problem is in Korean. Translate all headers and non-technical terms.

The explanation must:
0. Remember that providing a detailed **story**, causality and explanation of what this is, rather than simply listing information, makes it easier for students to memorize. A piece of writing that is fun and good to read is also highly educational.
1. Start from first principles so that **a middle school student with no prior knowledge** can follow. Everything must be supported by being built up from the very basics. There should not be any concept or word that just suddenly appears.
2. Explain WHICH concepts apply and WHY, in plain language before formalism.
3. Explain WHICH formulas to use, WHAT each symbol means, and WHY this formula applies.
4. All concepts and formulas must be explained clearly, insightfully, and harmoniously, with their clear principles, reasons, and use cases.
5. Show detailed step-by-step solution from start to finish.
6. Explain the reasoning at each step and common pitfalls.
7. Be detailed enough that a student can solve ALL problems of this type after reading it.
8. Avoid excessive abstraction; keep it concrete while maintaining **academic accuracy** (do not lose rigor due to analogies).

The latex rules apply only when using mathematical or Scientific formulas. Ignore them for topics where formulas are not used.

**Formatting rules for math & markdown (STRICT):**
- Use LaTeX math: inline formulas with $...$ and display formulas with $$...$$.
- Do **not** wrap any markdown or equations in backticks (\`) as it prevents rendering and reduces readability.
- Even simple indexed symbols like x_1, x_2 must be written as LaTeX ($x_1$, $x_2$), not as plain text.
- If subscripts/superscripts contain words or non-Latin characters, wrap them with \\text{...} inside LaTeX (e.g., $L_{\\text{ê°€ë™}}$, not $L_{ê°€ë™}$).
- More generally, if you must include *any* words/units/labels inside math mode, wrap them with \\text{...} (e.g., $v_{\\text{ì´ˆê¸°}}$, $\\text{m/s}$). Prefer keeping ordinary words outside $...$ whenever possible.
- **Symbol legends are OPTIONAL and rare**: include a legend table ONLY when the standard problem uses **non-standard technical symbols/diagram marks** (typical in math/science/engineering: circuit symbols, phasors, vector arrows, special diagram annotations, etc.).
- Do **NOT** create a legend for ordinary exam blanks like \`â–¡\` or fill-in boxes; those are answer slots, not symbols.
- If (and only if) a legend is needed, use a 3-column markdown table like â€œ| Symbol sketch | Name | Meaning |â€. Describe the symbol sketch plainly (e.g., "\`â–¡\` ì•ˆì— **B**"), but only when that shape is truly a technical symbol in a diagram.
- Markdown hygiene: ensure every list item and every table row is on its own line (never merge two bullets/rows into one line); add newlines so rendering is unambiguous.
- Also keep bullets atomic: do NOT cram multiple unrelated facts into one bullet; split into separate bullets so students can scan/recall.
- **When many variables appear, it is helpful to organize them into a table explaining what symbol each variable uses and what it means.**
- **It is also recommended to improve readability by appropriately using Markdown, such as \`>\`, and emojis.**
  - Example (optional): Use emoji + blockquote for emphasis.
    - Korean example: > **âš ï¸ ì¤‘ìš”**: ì‹œí—˜ì—ì„œ ìì£¼ ê±¸ë¦¬ëŠ” í•¨ì •ì„ í•œ ì¤„ë¡œ ìš”ì•½.
    - English example: > **âš ï¸ Important**: One-line reminder for a common exam trap.

Additionally, include the following structured sections (use these headings verbatim):
1. **Concept Explanation** â€” (This part needs to be very rich and detailed, so that even a middle school student can understand it) â€” teach from scratch as a connected mini-lesson (**not** a checklist / info dump). Use paragraphs that flow like Aâ†’Bâ†’C:
   - (0) Start with a specific, **very long long long**, and detailed real-life **especial** story to capture the student's interest. This part doesn't need to span the entire subject. It could just be something like the life story of a specific person's enlightenment related to this topic, simply to pique interest.
   - (A) Open with the *core question* this type is really asking (í•™ìƒì´ â€˜ë­˜ ë¬»ëŠ” ê±°ì§€?â€™ë¥¼ ì¡ê²Œ).
   - (B) Define the minimum terms, then introduce the most fundamental/general principle.
   - (C) Show how that principle *naturally leads* to the standard solving method.
   - (D) Close with a brief recap that ties back to (A) (ìˆ˜ë¯¸ìƒê´€).
   Rules: no term appears without being defined; explain *why* before formalism; start from the fully general form first, and only then derive any shortcuts as consequences (never teach shortcuts before the general rule). **Do NOT enumerate many subcases/traps here**â€”save exhaustive variants, exceptions, and exam-facing tricks for sections 3 and 4.
2. **Standard Problem Explanation** â€” step-by-step walkthrough of the standard problem.
3. **Question Patterns & Examinerâ€™s Win Conditions** â€” with specific, actual examples, summarize common surface patterns, the examinerâ€™s intent/traps for this type, and explicit counter-strategies. For each major trap/pattern, also include:
   - (0) How it shows up on exams: typical phrasing/diagram cues, and what similar-looking concepts the examiner mixes in to confuse students.
   - (0.5) What to memorize (1 line): the exact recognition cue or invariant that the student should commit to memory.
   - (0.75) Frequency label: explicitly mark whether this pattern is very frequent / frequent / sometimes / rare (based on repetition within the provided problems; do not claim â€œfrequentâ€ without evidence).
   - (a) Why the wrong answer choices (distractors) feel tempting.
   - (b) What misconception/illusion makes students pick them.
   - (c) **Cheat Sheet Tip**: A single-sentence "Rule of Thumb" or visual cue to quickly handle this pattern. Use > blockquotes for these key takeaways.
   - For calculation problems, explicitly hint at **common answer forms** (e.g., "Answers are usually integers," "Look for square roots canceling out") to help students verify their results.
4. **Study Method** â€” an actionable, efficient plan: what exactly to memorize and what to understand. This section must have two clearly separated parts:
- **Problem intuition**: organize neatly what needs to be memorized and where to focus.
- **100% coverage checklist**: a compact but exhaustive list of all subcases, edge conditions, and low-frequency details that still appear on exams. Do not omit uncommon items.
- **Organization is mandatory**: group related checklist items under short subgroup labels, and order them by prerequisite â†’ core â†’ variants/edge-cases (do not shuffle). When adding new items later, insert them into the right subgroup instead of appending a random list.
	     - Each checklist item MUST include context: how it shows up in real problems, the examiner's trap/strategy, and the exact misconception it targets.
	     - If an item is high-frequency, explicitly mark that it is frequently tested (e.g., "frequent").
     - Prioritize for resource allocation: clearly tell the student to memorize the high-frequency items first; if time remains, cover the low-frequency items.
     - If multiple problems repeat the same concept or trick, explicitly emphasize that repetition and describe the common pattern.
     - Do NOT list raw facts without context; every item must be tied to a problem pattern.
   Also include a big-data-based summary of what most frequently matters in this type (derived from many problems in this family), but keep it secondary to full coverage.

5. **Practical Exam Tips (ì‹¤ì „ ê¿€íŒ)** â€” After the fundamentals, provide actionable strategies for the actual exam:
   - **Apply only to patterns that appear 2+ times**. Do NOT overfit to single-occurrence problems.
   - If a specific choice is always the answer (among distractors): Explain the others briefly, but advise to "focus on this one" because of the recurring pattern.
   - If calculation problems always yield the same answer format (e.g., "always 3" or "always an integer"): Explain the proper solution method first, then drop the hint: "The answer has historically always been ~".
   - If the exam style varies significantly: omit this section to avoid misleading overfitting.
   - **Goal**: Help the student pass the exam efficiently, using past data to their advantage, after ensuring they can solve it the standard way.

	If official explanations are provided for any problems in this type, refer to and incorporate their insights.
	
	OUTPUT MODES (STRICT):
	A) CREATE MODE (default):
	- Output the complete explanation as pure markdown. No XML tags.
	
		B) PATCH MODE (for revisions only; must be explicitly requested):
		- Do NOT rewrite or re-output the full guide.
		- Output patch instructions to minimally fix the existing guide, using this exact format:
		<patches>
		  <patch>
		    <section>Concept Explanation|Standard Problem Explanation|Question Patterns & Examinerâ€™s Win Conditions|Study Method</section>
	    <op>insert_between|insert_after|insert_before|append</op>
	    <before>exact short snippet from guide</before>
	    <after>exact short snippet from guide</after>
	    <content>markdown text to insert (no tags)</content>
	  </patch>
	  ...
		</patches>
		
		Structured-output style override:
		- If the user message includes "STRUCTURED_OUTPUT_STYLE: RATIONALE_THEN_PATCHES":
		  - You MAY write rationale first (plain text only; avoid XML/HTML tags and angle brackets).
		  - The <patches>...</patches> block MUST be the final part of your response, with nothing after </patches>.
		- Otherwise (default): output ONLY the <patches>...</patches> block and nothing else.
		
		Patch rules:
		- Provide anchors using short before/after snippets that already exist in the guide (12â€“40 characters).
		- Use insert_between whenever possible.
	- Insert minimal, precise additions that match the guide's style.`
            },
            explanation_feedback: {
                system:
                    `You are the Explanation Auditor.
	
	Important constraint:
	1) **Language Consistency**: The guide MUST be in the same language as the standard problem. If the guide uses mixed languages (e.g. Korean problem but English titles), FAIL it.
	2) You will NOT be given the original problem set. Therefore you MUST NOT judge whether the guide can solve specific problems, nor verify correctness against unseen questions. Your evaluation is ONLY educational/format compliance based on the provided guide text.
	
	Final Objective (educational):
	A middle school student with no prior knowledge should be able to learn the type effectively from the guide.
	
	Your task:
	- Consider the full feedback history provided (if any).
	- Audit the guide ONLY for whether it follows the educational requirements and is understandable to a middle-school beginner:
	  1) First-principles build-up: no undefined terms or sudden concepts.
	  2) Concepts-before-formalism: explain what applies and why before formulas.
	  3) Symbols and formulas: define every symbol; explain why each formula applies.
	  4) Step-by-step reasoning and common pitfalls.
	  5) Required structure: includes the following headings verbatim:
	     1. **Concept Explanation**
	     2. **Standard Problem Explanation**
	     3. **Question Patterns & Examinerâ€™s Win Conditions**
		     4. **Study Method**
		     And the Study Method contains two clearly separated parts:
		     - **Problem intuition**
		     - **100% coverage checklist** (each item includes concrete problem-context, the examinerâ€™s trap/strategy, and the exact misconception it targets; mark high-frequency items as â€œfrequentâ€; explicitly call out repeated themes; and prioritize high-frequency memorization first).
		     5. **Practical Exam Tips** (only for repeated patterns; "cheat codes" for passing efficiently; do not overfit to single instances).
	  6) Strict formatting compliance:
	     - All formulas and symbolic notation are LaTeX ($...$ or $$...$$).
	     - No markdown, equations, or diagrams are wrapped in backticks (\`...\`).
	     - Symbol legends use markdown tables describing each symbolâ€™s visual appearance (not only its meaning).
	     - If subscripts/superscripts include words or non-Latin characters, they must use \\text{...} inside LaTeX (e.g., $L_{\\text{ê°€ë™}}$).
	     - No broken markdown due to missing newlines (e.g., two bullets or two table rows merged into one line).
	
	Output:
	- Write a brief summary, then a detailed, actionable critique with concrete edits/additions.
	- End with exactly one decision tag: <pass> or <fail> â€” the guide satisfies the educational requirements above.
	  - <fail> â€” the guide needs revision to satisfy the educational requirements above.`
            },
            coverage_verifier_full: {
                system:
                    `You are the Coverage Verifier (FULL MODE).

Goal: Determine whether the provided guide is sufficient to solve EACH problem in the given subset without outside knowledge.

Rules:
- Do NOT solve the problems.
- Be strict about missing requirements, but do NOT invent requirements unrelated to solving.
- Use the guide ONLY; do not assume unstated knowledge.
- Coverage = can a student solve the problem using ONLY the guide?

OUTPUT FORMAT (FULL MODE - YOU MUST FOLLOW THIS EXACTLY):
	- If ALL problems are covered, the FIRST non-empty line MUST be exactly: <none/>
	  - If EDU_FEEDBACK: ON, you MAY append an <education_feedback> block after <none/>.
	- Otherwise, return exactly one <data>...</data> block with ONE <item> PER PROBLEM in the SAME ORDER as provided.
	  Example item shape:
	  <item>
	    <id>1</id>
	    <qid>GLOBAL_QID</qid>
	    <covered>true|false</covered>
	    <reason>Brief reason (why covered / what is missing)</reason>
	  </item>

	CRITICAL RULES:
- You MUST output an entry for EVERY problem, not just the missing ones.
- Even if all 25 problems are covered, you must output 25 entries with <covered>true</covered>.
- The system will reject your response if item count does not match the problem count.
- <qid> MUST match the provided GLOBAL_QID exactly.
- Coverage decisions must be based ONLY on solvability (not on style/clarity).
- If unsure, set <covered>false</covered>.
- Do NOT use <missing_qid> tag - that is for a different mode.

Educational feedback (only when EDU_FEEDBACK: ON):
- Prioritize feedback that improves exam usability: "how it shows up" patterns, what to memorize (1-line cues), frequency/priority labeling, fundamentals-first ordering (general principle before shortcuts), and markdown hygiene (newlines/tables not merged).
- After the coverage output, you may append:
  <education_feedback>
  [brief actionable feedback, max 6 bullets]
  </education_feedback>
- Never include the literal <none/> inside <education_feedback>.`
            },
            coverage_verifier_missing_only: {
                system:
                    `You are the Coverage Verifier (MISSING_ONLY MODE).

Goal: Determine whether the provided guide is sufficient to solve EACH problem in the given subset without outside knowledge.

Rules:
- Do NOT solve the problems.
- Be strict about missing requirements, but do NOT invent requirements unrelated to solving.
- Use the guide ONLY; do not assume unstated knowledge.
- Coverage = can a student solve the problem using ONLY the guide?

OUTPUT FORMAT (MISSING_ONLY MODE - YOU MUST FOLLOW THIS EXACTLY):
	- If ALL problems are covered, the FIRST non-empty line MUST be exactly: <none/>
	  - If EDU_FEEDBACK: ON, you MAY append an <education_feedback> block after <none/>.
	- Otherwise, return exactly one <data>...</data> block with ONE <item> PER MISSING PROBLEM ONLY.
	  Example item shape:
	  <item>
	    <id>1</id>
	    <missing_qid>GLOBAL_QID</missing_qid>
	    <reason>Short reason (what is missing and why)</reason>
	  </item>

	CRITICAL RULES:
- Only output problems that are NOT covered.
- Do NOT output covered problems.
- Do NOT use <qid>/<covered> tags - that is for a different mode.

Educational feedback (only when EDU_FEEDBACK: ON):
- Prioritize feedback that improves exam usability: "how it shows up" patterns, what to memorize (1-line cues), frequency/priority labeling, fundamentals-first ordering (general principle before shortcuts), and markdown hygiene (newlines/tables not merged).
- After the coverage output, you may append:
  <education_feedback>
  [brief actionable feedback, max 6 bullets]
  </education_feedback>
- Never include the literal <none/> inside <education_feedback>.`
            },
            // Legacy alias for backward compatibility
            coverage_verifier: {
                system:
                    `You are the Coverage Verifier.

Goal: Determine whether the provided guide is sufficient to solve EACH problem in the given subset without outside knowledge.

Rules:
- Do NOT solve the problems.
- Be strict about missing requirements, but do NOT invent requirements unrelated to solving.
- Use the guide ONLY; do not assume unstated knowledge.

Control flags (provided in the user message):
- OUTPUT_MODE: FULL | MISSING_ONLY
- EDU_FEEDBACK: ON | OFF

Coverage output:
- If ALL problems are covered, the FIRST non-empty line MUST be exactly: <none/>

	OUTPUT_MODE: FULL
	- Return <data>...</data> with ONE <item> per problem (same order).
	- For every problem: <qid>GLOBAL_QID</qid><covered>true|false</covered><reason>...</reason>

	OUTPUT_MODE: MISSING_ONLY  
	- Return <data>...</data> with ONE <item> per MISSING problem only.
	- For each missing: <missing_qid>GLOBAL_QID</missing_qid><reason>...</reason>

Educational feedback (when EDU_FEEDBACK: ON):
- Prioritize feedback that improves exam usability: "how it shows up" patterns, what to memorize (1-line cues), frequency/priority labeling, fundamentals-first ordering (general principle before shortcuts), and markdown hygiene (newlines/tables not merged).
- After coverage output, optionally append <education_feedback>...</education_feedback>`
            },
            coverage_patcher: {
                system:
                    `You are the Coverage Patch Builder.

Goal: Add minimal, precise content to the guide so that the missing problems become solvable.

Rules:
- Do NOT rewrite entire sections.
- Insert concise additions that match the guide's style.
- Prefer inserting into: "Question Patterns & Examinerâ€™s Win Conditions" or "100% coverage checklist" or "Study Method".
- **Concept Explanation patching rule**: only add the *minimum* fundamentals needed (typically 1â€“4 sentences) in connected paragraph form. Do NOT dump long lists, traps, or many definitions into Concept Explanation; push those to section 3 or the checklist in section 4.
- **Checklist ordering rule**: never append a random list. Insert new checklist items into the most relevant subgroup and keep prerequisite â†’ core â†’ edge-case order. If no suitable subgroup exists, create a short subgroup label and place items coherently.
- Fundamentals-first ordering: if a missing problem requires a new concept, add the general principle in "Concept Explanation" first, then add exam-facing shortcuts/tips in later sections (never the other way around).
- When adding a pattern/trap, include (when relevant): how it shows up on exams, what to memorize (1 line), and whether it is frequent (only if repeated in the provided problems).
- If you add/extend examiner-trap analysis, also add (when relevant): why distractors feel tempting, the misconception that causes the trap, and a 1-sentence Tip to avoid it.
- Do NOT add bare "always choose X" tips without also teaching the underlying concept and why the other choices are wrong; only use "always" claims when strongly supported by repetition.
- If the user message includes "Educational feedback", treat it as secondary: address it only when it can be fixed with small local edits while also covering the missing problems.
- Provide anchors using short before/after snippets that already exist in the guide.
- Snippets should be 12â€“40 characters long to avoid ambiguous matches.
- Use insert_between whenever possible.
- Ensure \`content\` is complete Markdown. If adding a table row, ensure it starts and ends with \`|\` and aligns with the existing table structure.
- Do NOT insert partial Markdown that breaks rendering (e.g. unclosed backticks) or missing-newline content that merges two bullets/rows into one line.
- Math formatting: use LaTeX ($...$ / $$...$$). If subscripts/superscripts include words or non-Latin characters, use \\text{...} (e.g., $L_{\\text{ê°€ë™}}$).

Output format:
<patches>
  <patch>
    <section>Section name</section>
    <op>insert_between|insert_after|insert_before|append</op>
    <before>exact short snippet from guide</before>
    <after>exact short snippet from guide</after>
    <content>text to insert (no tags)</content>
  </patch>
  ...
</patches>`
            },
            type_orderer: {
                system:
                    `You are the Type Sequencing Planner.

          Goal: Arrange pattern types in the most learning-efficient order so a beginner can build concepts progressively and master all types with minimal cognitive load.

          Input context for each type:
          - type_name
          - type_description
          - standard_problem (text)

          Output an ordered list inside:
          <data>
            <item><id>1</id><type_name>...</type_name></item>
            <item><id>2</id><type_name>...</type_name></item>
            ...
          </data>

          IMPORTANT:
          - You may include free-form rationale AFTER </data>. Only <data> will be parsed.`
            },
	            guide_merger: {
	                system:
	                    `You are the Guide Merger.
	
	Goal: Merge multiple partial guides (created for different subsets of problems of the SAME type) into a single, cohesive, comprehensive guide.

LANGUAGE REQUIREMENT:
- Output must be in {language}.
	
	Rules:
	- All input guides cover the SAME type/pattern but were created from different problem subsets.
- Merge overlapping content: remove redundancy while preserving all unique information.
- Maintain consistent structure: use a unified section layout (e.g., Core Concepts, Patterns, Checklist).
- Preserve teaching quality: keep first-principles explanations, examiner traps, tips, and checklists.
- The merged guide should feel like one coherent document, not a concatenation.
- Write in the SAME LANGUAGE as the input guides.

Output: Return the complete merged guide as plain text. No XML tags needed.`
            }
        };

	        let currentPrompts = JSON.parse(JSON.stringify(DEFAULT_PROMPTS)); // Deep copy for editing in UI

	        function __getGuideLanguageFromUi() {
	            try {
	                const raw = String(getEl('std-problem-lang-input')?.value || '').trim();
	                return raw || 'English';
	            } catch {
	                return 'English';
	            }
	        }

	        function __renderPromptTemplateText(text, vars = {}) {
	            let t = String(text ?? '');
	            const lang = String(vars?.language || '').trim();
	            if (lang) t = t.replace(/\{language\}/g, lang);
	            return t;
	        }

        function __migratePromptTextToItemFormat(text) {
            let t = String(text ?? '');

            // Migrate fixed max-type wording from older presets (e.g., "50 OR FEWER") to dynamic MAX_TYPES.
            t = t.replace(/\b50\s*OR\s*FEWER\b/gi, 'MAX_TYPES or fewer');
            t = t.replace(/\b50\s+or\s+fewer\b/gi, 'MAX_TYPES or fewer');

            // Migrate legacy wrapper format: <id:1>...</id:1> â†’ <item><id>1</id>...</item>
            // (The <id> tag is optional for parsing, but preferred for clarity.)
            t = t.replace(/Each\s+<\s*id:n\s*>\s*block\s+MUST\s+include\s*:/gi, 'Each <item> MUST include:');
            t = t.replace(/Each\s+<\s*id:n\s*>\s*block\b/gi, 'Each <item>');

            t = t.replace(/<\s*id:(\d+)\s*>/gi, (_m, n) => `<item><id>${n}</id>`);
            t = t.replace(/<\s*\/\s*id:(\d+)\s*>/gi, '</item>');
            t = t.replace(/<\s*id:n\s*>/gi, '<item><id>n</id>');
            t = t.replace(/<\s*\/\s*id:n\s*>/gi, '</item>');

            return t;
        }

        function __normalizePrompts(rawPrompts) {
            const base = JSON.parse(JSON.stringify(DEFAULT_PROMPTS));
            const src = (rawPrompts && typeof rawPrompts === 'object') ? rawPrompts : {};

            // Overlay any provided keys (including extras) on top of defaults.
            try {
                Object.keys(src).forEach((k) => {
                    if (!src[k] || typeof src[k] !== 'object') return;
                    if (typeof src[k].system !== 'string') return;
                    if (!base[k]) base[k] = { system: src[k].system };
                    else base[k].system = src[k].system;
                });
            } catch { }

            // Apply text migrations to all prompts.
            try {
                Object.keys(base).forEach((k) => {
                    if (!base[k] || typeof base[k] !== 'object') return;
                    if (typeof base[k].system !== 'string') return;
                    base[k].system = __migratePromptTextToItemFormat(base[k].system);
                });
            } catch { }

            return base;
        }

        //======================================================================
        // 4. PIPELINE STATE & WORKFLOW (NEW PHASES)
        //======================================================================

        let processController = { stop: false };   // Allows stop button to signal soft-cancel
        let uploadedFiles = [];                    // [{ file: File, splitPages: 0 }]
        let uploadedAnswerFiles = [];              // [{ file: File, splitPages: 0 }] (optional)
        let examPapers = [];                       // [{ fileName, type:'pdf'|'txt', images?[], rawText? content? }]
        let activeProcess = null;                  // Full process state
        let typeRerunState = { status: 'idle', types: [], results: [], error: null };

        // Phase0 runtime caches (NOT serialized to progress files)
        const __phase0PdfFileCache = new Map(); // sourceFileName -> { filename, mimeType, base64 }
        const __phase0PdfFileCachePromises = new Map(); // sourceFileName -> Promise<cacheEntry>
        let incrementalPatchState = {
            status: 'idle',            // idle|ready|processing|completed|error
            basePayload: null,         // parsed base { types:[...], classificationStandard? }
            baseFileName: null,
            newFiles: [],              // File[]
            patchPayload: null,        // output patch json
            error: null,
            // in-memory cache for 'resume' in incremental mode
            cacheKey: null,
            cachedQuestions: null,
            cachedAt: null
        };

        const __keepAlive = (() => {
            let wakeLock = null;
            let worker = null;
            let workerUrl = null;
            let active = false;

            const supportsWakeLock = !!(navigator && navigator.wakeLock && navigator.wakeLock.request);

            const startWorker = () => {
                if (worker) return;
                const code = `
let timer = null;
const ping = () => { try { postMessage({ t: Date.now() }); } catch {} };
self.onmessage = (e) => {
  const msg = e && e.data ? e.data : {};
  if (msg.type === 'start') {
    if (timer) return;
    timer = setInterval(ping, 20000);
    ping();
    return;
  }
  if (msg.type === 'stop') {
    if (timer) clearInterval(timer);
    timer = null;
  }
};
`;
                try {
                    const blob = new Blob([code], { type: 'text/javascript' });
                    workerUrl = URL.createObjectURL(blob);
                    worker = new Worker(workerUrl);
                    worker.postMessage({ type: 'start' });
                } catch {
                    worker = null;
                }
            };

            const stopWorker = () => {
                if (!worker) return;
                try { worker.postMessage({ type: 'stop' }); } catch { }
                try { worker.terminate(); } catch { }
                worker = null;
                if (workerUrl) {
                    try { URL.revokeObjectURL(workerUrl); } catch { }
                    workerUrl = null;
                }
            };

            const requestWakeLock = async () => {
                if (!supportsWakeLock) return;
                if (document.visibilityState !== 'visible') return;
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => { wakeLock = null; });
                } catch { }
            };

            const releaseWakeLock = async () => {
                if (!wakeLock) return;
                try { await wakeLock.release(); } catch { }
                wakeLock = null;
            };

            const sync = (running) => {
                active = !!running;
                if (active) {
                    startWorker();
                    requestWakeLock();
                } else {
                    releaseWakeLock();
                    stopWorker();
                }
            };

            document.addEventListener('visibilitychange', () => {
                if (!active) return;
                if (document.visibilityState === 'visible') requestWakeLock();
            });

            return { sync };
        })();

        function getProblemId(p, fallback) {
            return p?.qid || p?.id || p?.global_qid || p?.problem_id || fallback || '';
        }

        function parseGuideTypeTitle(text) {
            const m = String(text || '').match(/^\s*#\s+(.+?)\s*$/m);
            return m ? m[1].trim() : '';
        }

        function parseProblemsFromRawText(rawText) {
            const text = String(rawText || '');
            if (!text.trim()) return [];
            if (/^\s*-{8,}\s*$/m.test(text) && /\nQID:\s*/.test(text)) {
                const blocks = text.split(/\n-{8,}\n/).map(b => b.trim()).filter(Boolean);
                const problems = [];
                blocks.forEach((block, idx) => {
                    const qid = (block.match(/^\s*QID:\s*(.+)$/m) || [])[1]?.trim() || `P${idx + 1}`;
                    const question_text = (block.match(/\[ë¬¸ì œ\]\s*\n([\s\S]*?)(?=\n\[ì„ ì§€\]|\n\[ê³µì‹ì •ë‹µ\]|$)/) || [])[1]?.trim() || '';
                    const answer_choices = (block.match(/\[ì„ ì§€\]\s*\n([\s\S]*?)(?=\n\[ê³µì‹ì •ë‹µ\]|$)/) || [])[1]?.trim() || '';
                    const official_answer = (block.match(/\[ê³µì‹ì •ë‹µ\]\s*\n([\s\S]*?)$/) || [])[1]?.trim() || '';
                    if (question_text || answer_choices) {
                        problems.push({
                            qid,
                            question_text,
                            answer_choices,
                            official_answer,
                            official_explanation: ''
                        });
                    }
                });
                if (problems.length) return problems;
            }
            if (/\n---\s*\n/.test(text) && /:\s*\n/.test(text)) {
                const blocks = text.split(/\n---\s*\n/).map(b => b.trim()).filter(Boolean);
                return blocks.map((block, idx) => {
                    const lines = block.split(/\r?\n/);
                    let qid = '';
                    let startIdx = 0;
                    for (let i = 0; i < lines.length; i++) {
                        const m = lines[i].match(/^\s*([A-Za-z0-9_\-:.]+)\s*:\s*$/);
                        if (m) { qid = m[1].trim(); startIdx = i + 1; break; }
                    }
                    const bodyLines = lines.slice(startIdx);
                    let body = bodyLines.join('\n').trim();
                    let answer_choices = '';
                    let official_answer = '';
                    let official_explanation = '';
                    const choiceMatch = body.match(/(?:^|\n)Choices:\s*([^\n]*)/);
                    if (choiceMatch) {
                        answer_choices = choiceMatch[1].trim();
                        body = body.replace(choiceMatch[0], '').trim();
                    }
                    const ansMatch = body.match(/(?:^|\n)\[Official Answer\]\n([\s\S]*?)(?=\n\[Official Explanation\]|\n?$)/);
                    if (ansMatch) {
                        official_answer = ansMatch[1].trim();
                        body = body.replace(ansMatch[0], '').trim();
                    }
                    const expMatch = body.match(/(?:^|\n)\[Official Explanation\]\n([\s\S]*)/);
                    if (expMatch) {
                        official_explanation = expMatch[1].trim();
                        body = body.replace(expMatch[0], '').trim();
                    }
                    const question_text = body.trim();
                    return {
                        qid: qid || `P${idx + 1}`,
                        question_text,
                        answer_choices,
                        official_answer,
                        official_explanation
                    };
                });
            }
            const lines = text.split(/\r?\n/);
            const blocks = [];
            let current = null;
            const markerRe = /^\s*(Q\d+[a-z]?|ë¬¸ì œ\s*\d+|\d+\.)\b/i;

            lines.forEach(line => {
                const m = line.match(markerRe);
                if (m) {
                    if (current) blocks.push(current);
                    const raw = m[1] || '';
                    const qid = raw.toUpperCase().startsWith('Q') ? raw.trim() : `P${blocks.length + 1}`;
                    current = { qid, lines: [line] };
                } else if (current) {
                    current.lines.push(line);
                }
            });
            if (current) blocks.push(current);
            if (!blocks.length) {
                return [{ qid: 'P1', question_text: text.trim() }];
            }
            return blocks.map((b, idx) => ({
                qid: b.qid || `P${idx + 1}`,
                question_text: b.lines.join('\n').trim()
            }));
        }

        function normalizeTypeProblems(type) {
            const raw = Array.isArray(type?.problems) ? type.problems : [];
            return raw.map((p, idx) => {
                const qid = getProblemId(p, `P${idx + 1}`);
                return { ...p, qid };
            });
        }

	        function splitTypeProblemsIfNeeded(type, usedNames) {
	            const normalizedProblems = normalizeTypeProblems(type);
	            const qids = normalizedProblems.map(p => p.qid);
	            const questionIndex = new Map(normalizedProblems.map(p => [p.qid, p]));
	            if (qids.length <= TYPE_SPLIT_LIMIT) {
	                return [{ title: type.title, problems: normalizedProblems }];
	            }
	            const parts = splitQidsByChunks(qids, TYPE_SPLIT_LIMIT);
	            const names = buildSplitTypeNames(type.title, parts.length, usedNames);
	            return parts.map((partQids, idx) => ({
	                title: names[idx],
	                problems: partQids.map(qid => questionIndex.get(qid)).filter(Boolean)
	            }));
	        }

        function buildStandardMarkdown(problem, answer) {
            const prob = String(problem || '').trim();
            const ans = String(answer || '').trim();
            return `## Standard Problem\n${prob}\n\n**Answer:** ${ans}`.trim();
        }

        function buildGuideMarkdown(types) {
            const parts = (types || []).map(t => {
                const title = String(t.title || '').trim();
                const std = String(t.standardMarkdown || '').trim();
                const exp = String(t.explanationMarkdown || '').trim();
                return `# ${title}\n\n${std}\n\n---\n\n${exp}`.trim();
            });
            return parts.join('\n\n========================================\n\n').trim() + '\n';
        }

        // Unified API call helper used by split/merge guide generation
        // Returns: { content: string } on success, or { error: string } on failure.
        async function __callApi(apiPayload, contextLabel) {
            try {
                const content = await resilientLlmRequest(apiPayload, contextLabel || 'ApiCall');
                return { content: String(content ?? '').trim() };
            } catch (e) {
                return { error: (e?.message || String(e || 'Unknown error')) };
            }
        }

        // Guide merger: merge multiple partial guides into one cohesive guide
	        async function mergeGuides(guides, contextLabel) {
	            if (!guides || guides.length === 0) return '';
	            if (guides.length === 1) return guides[0];

	            const language = __getGuideLanguageFromUi();
	            const guidesText = guides.map((g, i) => `--- GUIDE ${i + 1} ---\n${g}`).join('\n\n');

	            const payload = {
	                model: getApiConfig().model,
	                messages: [
	                    { role: 'system', content: __renderPromptTemplateText(currentPrompts.guide_merger.system, { language }) },
	                    { role: 'user', content: `Merge the following ${guides.length} partial guides into ONE unified guide:\n\n${guidesText}` }
	                ]
	            };

            logger.info(contextLabel, `Merging ${guides.length} partial guides...`);
            const result = await __callApi(payload, contextLabel);
            if (result.error) {
                throw new Error(`Guide merge failed: ${result.error}`);
            }
            logger.success(contextLabel, `Guides merged successfully.`);
            return String(result.content || '').trim();
        }

        // Generate explanation for a subset of problems (used in split-merge mode)
	        async function generateExplanationForSubset(patternName, standardProblem, problems, contextLabel, iterations) {
	            const problemsText = problemsToTextInterleaved(problems);
	            const stdProblem = String(standardProblem?.problem || '').trim();
	            const stdAnswer = String(standardProblem?.answer || '').trim();
	            const language = __getGuideLanguageFromUi();

	            const payload = {
	                model: getApiConfig().model,
	                messages: [
	                    { role: 'system', content: __renderPromptTemplateText(currentPrompts.explanation_creator.system, { language }) },
	                    {
	                        role: 'user',
	                        content: `Type: ${patternName}\n\nStandard Problem:\n${stdProblem}\n\nAnswer: ${stdAnswer}\n\nRelated Problems (for coverage context):\n${problemsText}\n\nCreate a detailed explanation for the standard problem that enables solving ALL the related problems.`
	                    }
	                ]
	            };

            const result = await __callApi(payload, contextLabel);
            if (result.error) {
                throw new Error(`Explanation generation failed: ${result.error}`);
            }
            return String(result.content || '').trim();
        }

	        async function regenerateTypeGuide(type) {
	            const language = __getGuideLanguageFromUi();
	            const problemsText = problemsToTextInterleaved(type.problems);
	            const context = `Rerun-${type.title}`;
            const cfg = getPipelineConfig();
            const p2Cfg = cfg?.phase2 || {};
            const enableAuditor = p2Cfg?.enableAuditor !== false;
            const enableCoverage = p2Cfg?.enableCoverage !== false;
            const coverageOpts = p2Cfg?.coverage || {};

            const moduleState = {
                standardProblem: null,
                explanation: null,
                refinementCycles: []
            };

            const PASS_STREAK_TARGET = 1;
            let passStreak = 0;
            let cycleNum = 0;
            let checkpoint = null;
            let revisedOnce = false;
            const loopMode = String(p2Cfg?.auditorLoopMode || 'single_pass').trim().toLowerCase(); // single_pass | until_pass
            const maxCycles = __clampInt(
                (typeof p2Cfg?.auditorMaxCycles !== 'undefined')
                    ? p2Cfg.auditorMaxCycles
                    : (loopMode === 'until_pass' ? 0 : 1),
                { min: 0, max: 99, fallback: 1 }
            );
            const cycleStart = cycleNum;

            while (!processController.stop && passStreak < PASS_STREAK_TARGET) {
                if (!enableAuditor) {
                    logger.info(context, "Auditor disabled by config. Skipping audit loop.");
                    break;
                }
                if (maxCycles > 0 && (cycleNum - cycleStart) >= maxCycles) {
                    logger.warn(context, `Auditor loop: max cycles reached (${maxCycles}). Stopping audit loop.`);
                    break;
                }
	                if (!moduleState.standardProblem) {
	                    const sp_payload = {
	                        model: getApiConfig().model,
	                        messages: [
	                            { role: 'system', content: __renderPromptTemplateText(currentPrompts.standard_problem_creator.system, { language }) },
	                            { role: 'user', content: `Pattern Type: ${type.title}\n\nAll problems of this type:\n\n${problemsText}\n\nCreate ONE standard problem that represents this type.\nLANGUAGE CONSTRAINT: The standard problem must be in ${language}.` }
	                        ]
	                    };
                    const sp_items = await requestAndParseDataEnvelopeLenient(sp_payload, `${context}-StdProblem`, { phase: 'phase2' });
                    moduleState.standardProblem = {
                        problem: parseTag(sp_items[0].value, 'standard_problem'),
                        answer: parseTag(sp_items[0].value, 'correct_answer')
                    };
                }

                if (!moduleState.explanation) {
                    const exp_userText = `Pattern Type: ${type.title}
	
	{Standard problem:
	${moduleState.standardProblem.problem}
	}
	
	{Correct answer:
	${moduleState.standardProblem.answer}
	}
	
	{All problems of this type (each followed by its official explanation if present):
	${problemsText}
	}
	
	Create an extremely detailed, step-by-step explanation that teaches how to solve this standard problem AND enables solving all problems of this type.`;
	                    const exp_payload = {
	                        model: getApiConfig().model,
	                        messages: [
	                            { role: 'system', content: __renderPromptTemplateText(currentPrompts.explanation_creator.system, { language }) },
	                            { role: 'user', content: exp_userText }
	                        ]
	                    };
	                    moduleState.explanation = await resilientLlmRequest(exp_payload, `${context}-Explanation`);
	                }

                // Markdown hygiene guard: fix common broken-newline artifacts early so the auditor/coverage aren't misled.
                try {
                    const hygiene = __applyMarkdownHygieneFix(moduleState.explanation, context, 'explanation_generated');
                    moduleState.explanation = hygiene.text;
                } catch { }

                const feedbackHistoryText = (moduleState.refinementCycles && moduleState.refinementCycles.length)
                    ? moduleState.refinementCycles
                        .map(c => `Cycle ${c.cycleNumber} (<${c.decisionTag}>):\n${c.feedback}`)
                        .join('\n\n---\n\n')
                    : 'None.';

                const feedback_userText = `You will be given ONLY the guide text (no original problems).
	
	{Pattern Type:
	${type.title}
	}
	
	{Guide to audit:
	${moduleState.explanation}
	}
	
	{Feedback history (oldest -> newest):
	${feedbackHistoryText}
	}
	
	Provide a short summary and a detailed, actionable critique. End with exactly one decision tag: <pass> or <fail>.`;

	                const feedback_payload = {
	                    model: getApiConfig().model,
	                    messages: [
	                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.explanation_feedback.system, { language }) },
	                        { role: 'user', content: feedback_userText }
	                    ]
	                };

                const verificationRaw = await resilientLlmRequest(feedback_payload, `${context}-Feedback${cycleNum + 1}`);
                let decision = 'fail';
                try {
                    decision = parseDecisionTag(verificationRaw, ['pass', 'fail']);
                } catch (e) {
                    logger.warn(context, `Verifier did not produce a valid <pass>/<fail> tag: ${e.message}. Treating as <fail>.`);
                }

                const isPass = decision === 'pass';
                moduleState.refinementCycles.push({
                    cycleNumber: cycleNum + 1,
                    feedback: verificationRaw,
                    fullVerification: verificationRaw,
                    decisionTag: decision,
                    isAcceptable: isPass,
                    explanationSnapshot: moduleState.explanation
                });

                if (isPass) {
                    passStreak++;
                    checkpoint = {
                        standardProblem: { ...moduleState.standardProblem },
                        explanation: moduleState.explanation
                    };
                    break;
                } else {
                    passStreak = 0;
                }

                if (!isPass) {
                    const allowMulti = loopMode === 'until_pass';
                    if (!allowMulti && revisedOnce) break;

	                    const exp_revise_payload = {
	                        model: getApiConfig().model,
	                        messages: [
	                            { role: 'system', content: __renderPromptTemplateText(currentPrompts.explanation_creator.system, { language }) },
	                            {
	                                role: 'user',
	                                content:
                                    `PATCH MODE: Revise the existing guide by applying only minimal, local edits based on the audit feedback.
		
		Rules:
		- Do NOT rewrite or re-output the full guide.
		- Output patch instructions in the required <patches> ... </patches> format.
		
		{Current guide (markdown):
		${moduleState.explanation}
		}
	
		{Latest audit feedback:
		${verificationRaw}
		}
		
			${__patchOutputDirectiveLine({ phase: 'phase2', context })}`
                            }
                        ]
                    };

                    const patchPayload = __withStructuredRationaleMode(exp_revise_payload, { kind: 'patches', phase: 'phase2', context: `${context}-ReviseExplanationPatch${cycleNum + 1}` });
                    const patchRaw = await resilientLlmRequest(patchPayload, `${context}-ReviseExplanationPatch${cycleNum + 1}`);
                    const patches = parsePatchBlocks(patchRaw);
                    if (!patches.length) {
                        try {
                            __formatErrors.add({
                                kind: 'patches',
                                stage: 'explanation_patch',
                                attempt: cycleNum + 1,
                                context: `${context}-ReviseExplanationPatch${cycleNum + 1}`,
                                error: 'No <patch> blocks parsed',
                                request: patchPayload,
                                responseRaw: patchRaw,
                                meta: { source: 'type_rerun' }
                            });
                        } catch { }
                    }
                    const beforeExp = moduleState.explanation;
                    const applied = applyPatchesToGuide(beforeExp, patches);

                    if (applied.results.some(r => !r.applied)) {
                        logger.warn(context, `Explanation patch: some patches failed to apply.`);
                    }
                    if (applied.text === beforeExp) {
                        logger.warn(context, `Explanation patch: no changes applied.`);
                    }

                    try {
                        const hygiene = __applyMarkdownHygieneFix(applied.text, context, `explanation_patch_cycle_${cycleNum + 1}`);
                        moduleState.explanation = hygiene.text;
                    } catch {
                        moduleState.explanation = applied.text;
                    }
                    if (!allowMulti) {
                        revisedOnce = true;
                        break;
                    }
                    if (applied.text === beforeExp) {
                        logger.warn(context, `Stopping auditor loop: patch produced no changes (cycle ${cycleNum + 1}).`);
                        break;
                    }
                }

                cycleNum++;
            }

            if (processController.stop) throw new Error("Operation cancelled.");

            const baseExplanation = checkpoint?.explanation || moduleState.explanation || '';
            const coverageRes = enableCoverage
                ? await refineGuideCoverage(baseExplanation, type.problems || [], context, {
                    maxTokens: coverageOpts?.maxTokens,
                    maxRounds: coverageOpts?.maxRounds,
                    patcherMode: coverageOpts?.patcherMode,
                    verifierOutput: coverageOpts?.verifierOutput,
                    verifierMaxTries: coverageOpts?.verifierMaxTries,
                    finalVerifyMode: coverageOpts?.finalVerifyMode,
                })
                : { guideText: baseExplanation, missingQids: [], coverageReport: null, coverageMeta: null };
            if (!enableCoverage) logger.info(context, "Coverage skipped by config.");

            return {
                title: type.title,
                standardProblem: checkpoint?.standardProblem || moduleState.standardProblem,
                explanation: coverageRes.guideText,
                problems: type.problems
            };
        }

        async function startTypeRegeneration() {
            if (typeRerunState.status === 'processing') return;
            const inputTypes = Array.isArray(typeRerunState.types) ? typeRerunState.types : [];
            if (!inputTypes.length) return;

            const existingResults = Array.isArray(typeRerunState.results) ? typeRerunState.results : [];
            const doneTitles = new Set(existingResults.map(r => r.title));
            typeRerunState.status = 'processing';
            typeRerunState.results = existingResults;
            typeRerunState.error = null;
            const statusEl = getEl('type-guide-import-status');
            if (statusEl) statusEl.textContent = __tGui('typeGuideStatusRegenerating');
            const rerunBtn = getEl('type-rerun-btn');
            const exportBtn = getEl('type-export-btn');
            if (rerunBtn) rerunBtn.disabled = true;
            if (exportBtn) exportBtn.disabled = true;

            try {
                const usedNames = new Set(inputTypes.map(t => t.title).filter(Boolean));
                const expanded = [];
                inputTypes.forEach(t => {
                    splitTypeProblemsIfNeeded(t, usedNames).forEach(x => {
                        usedNames.add(x.title);
                        expanded.push(x);
                    });
                });

                const jobByTitle = new Map(expanded.map(t => [t.title, t]));
                const pending = expanded.filter(t => !doneTitles.has(t.title));
                const jobs = pending.map(t => ({ title: t.title }));
                const results = [...existingResults];

                if (!pending.length) {
                    typeRerunState.status = 'completed';
                    if (statusEl) statusEl.textContent = __tGuiFmt('typeGuideStatusRegenerationCompleteFmt', { n: typeRerunState.results.length });
                    if (exportBtn) exportBtn.disabled = typeRerunState.results.length === 0;
                    return;
                }

                async function processJob(job) {
                    const t = jobByTitle.get(job.title);
                    if (!t) return null;
                    const res = await regenerateTypeGuide(t);
                    results.push(res);
                    return res;
                }

                await runWithConcurrency(jobs, processJob, getWorkerConcurrency());

                const byTitle = new Map(results.map(r => [r.title, r]));
                typeRerunState.results = expanded.map(t => byTitle.get(t.title)).filter(Boolean);
                typeRerunState.status = 'completed';
                if (statusEl) statusEl.textContent = __tGuiFmt('typeGuideStatusRegenerationCompleteFmt', { n: typeRerunState.results.length });
                if (exportBtn) exportBtn.disabled = typeRerunState.results.length === 0;
            } catch (e) {
                typeRerunState.status = 'error';
                typeRerunState.error = e.message;
                if (statusEl) statusEl.textContent = `Regeneration failed: ${e.message}`;
                logger.error('TypeRerun', `Failed: ${e.message}`);
            } finally {
                if (rerunBtn) rerunBtn.disabled = typeRerunState.status !== 'completed' && typeRerunState.status !== 'idle';
            }
        }

        function buildTypePatchPayload(results) {
            const types = (results || []).map(r => {
                const standardMarkdown = buildStandardMarkdown(r.standardProblem?.problem, r.standardProblem?.answer);
                return {
                    title: r.title,
                    standardMarkdown,
                    explanationMarkdown: r.explanation || '',
                    problems: Array.isArray(r.problems) ? r.problems : []
                };
            });
            // Optional: embed Phase1A classification standard for future incremental patching.
            // Renderer ignores unknown fields, but builder can reuse this to classify new problems without re-running Phase1A.
            const classificationStandard = (() => {
                const std = activeProcess?.phase1_patterns?.standardCreation?.finalStandard;
                return Array.isArray(std) && std.length ? std : null;
            })();
            return {
                patchVersion: 1,
                generatedAt: new Date().toISOString(),
                types,
                guideMarkdown: buildGuideMarkdown(types),
                ...(classificationStandard ? { classificationStandard } : {})
            };
        }

        //======================================================================
        // INCREMENTAL MODE: Add new problems via coverage-only patches
        //======================================================================

        function parseGuideToTypesForIncremental(text) {
            const src = String(text || '');
            const segments = src.split(/\n={8,}\n/g);
            const types = [];
            segments.forEach((segment) => {
                if (!/^\s*##\s*Standard Problem/m.test(segment)) return;
                const stdMatch = segment.match(/(^\s*##\s*Standard Problem[\s\S]*?)^\s*---\s*$/m);
                let standardMarkdown = '';
                if (stdMatch) standardMarkdown = String(stdMatch[1] || '').trim();
                else {
                    const stdFallback = segment.match(/(^\s*##\s*Standard Problem[\s\S]*)$/m);
                    if (!stdFallback) return;
                    standardMarkdown = String(stdFallback[1] || '').trim();
                }

                let explanationMarkdown = '';
                if (stdMatch) {
                    explanationMarkdown = segment.slice(stdMatch.index + stdMatch[0].length).trim();
                }

                const posStdStart = stdMatch ? stdMatch.index : segment.indexOf('## Standard Problem');
                const before = segment.slice(0, Math.max(0, posStdStart));
                const h1Matches = [...before.matchAll(/^\s*#\s+(.+?)\s*$/gm)];
                const typeTitle = h1Matches.length ? String(h1Matches[h1Matches.length - 1][1] || '').trim() : `ìœ í˜• ${types.length + 1}`;

                types.push({ title: typeTitle, standardMarkdown, explanationMarkdown });
            });
            return types;
        }

        function __normalizeTitleForMatch(title) {
            return String(title || '').trim().toLowerCase().replace(/\s+/g, ' ');
        }

        function parseIncrementalBasePayload(obj) {
            if (!obj || typeof obj !== 'object') throw new Error('ë² ì´ìŠ¤ íŒŒì¼ì´ JSON ê°ì²´ê°€ ì•„ë‹™ë‹ˆë‹¤.');

            const coerceProblems = (value) => {
                if (Array.isArray(value)) return value;
                if (typeof value === 'string') {
                    try {
                        const parsed = JSON.parse(value);
                        if (Array.isArray(parsed)) return parsed;
                        if (parsed && Array.isArray(parsed.items)) return parsed.items;
                        if (parsed && Array.isArray(parsed.list)) return parsed.list;
                    } catch { }
                    return [];
                }
                if (value && typeof value === 'object') {
                    if (Array.isArray(value.items)) return value.items;
                    if (Array.isArray(value.list)) return value.list;
                    if (Array.isArray(value.problems)) return value.problems;
                }
                return [];
            };

            // Some users may have a legacy "types array only" JSON.
            if (Array.isArray(obj)) {
                const types = obj.map(t => ({
                    title: String(t?.title || t?.type_title || t?.typeName || '').trim(),
                    standardMarkdown: String(t?.standardMarkdown ?? t?.standard ?? '').trim(),
                    explanationMarkdown: String(t?.explanationMarkdown ?? t?.explanation ?? '').trim(),
                    problems: coerceProblems(t?.problems)
                })).filter(t => t.title);
                return { types, classificationStandard: null };
            }

            const classificationStandard = Array.isArray(obj.classificationStandard) && obj.classificationStandard.length ? obj.classificationStandard : null;

            // Case A) Builder patch payload (recommended): {types:[...]} (or sometimes empty)
            if (Array.isArray(obj.types)) {
                const coerceProblems = (value) => {
                    if (Array.isArray(value)) return value;
                    if (typeof value === 'string') {
                        try {
                            const parsed = JSON.parse(value);
                            if (Array.isArray(parsed)) return parsed;
                            if (parsed && Array.isArray(parsed.items)) return parsed.items;
                            if (parsed && Array.isArray(parsed.list)) return parsed.list;
                        } catch { }
                        return [];
                    }
                    if (value && typeof value === 'object') {
                        if (Array.isArray(value.items)) return value.items;
                        if (Array.isArray(value.list)) return value.list;
                        if (Array.isArray(value.problems)) return value.problems;
                    }
                    return [];
                };
                const types = obj.types.map(t => ({
                    title: String(t?.title || t?.type_title || t?.typeName || '').trim(),
                    standardMarkdown: String(t?.standardMarkdown ?? t?.standard ?? '').trim(),
                    explanationMarkdown: String(t?.explanationMarkdown ?? t?.explanation ?? '').trim(),
                    problems: coerceProblems(t?.problems)
                })).filter(t => t.title);
                if (types.length) return { types, classificationStandard };
                // Some older patch files may omit `types` and only include `guideMarkdown`.
            }

            // Case A2) Guide markdown only: {guideMarkdown:"..."} (+ optional problems map)
            if (typeof obj.guideMarkdown === 'string' && obj.guideMarkdown.trim()) {
                const typesFromGuide = parseGuideToTypesForIncremental(obj.guideMarkdown);
                if (!typesFromGuide.length) throw new Error('ë² ì´ìŠ¤ íŒŒì¼ì˜ guideMarkdownì—ì„œ ìœ í˜•ì„ íŒŒì‹±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
                // Attach problems if present (optional)
                const problemsMap = (() => {
                    if (obj.problems && typeof obj.problems === 'object') return obj.problems;
                    // Some exports use `types` as a problems map: { types: { "Type": [ ...problems ] } }
                    if (obj.types && typeof obj.types === 'object' && !Array.isArray(obj.types)) return obj.types;
                    return null;
                })();
                const byNorm = new Map();
                if (problemsMap && typeof problemsMap === 'object') {
                    Object.keys(problemsMap).forEach(k => {
                        const list = coerceProblems(problemsMap[k]);
                        byNorm.set(__normalizeTitleForMatch(k), list);
                    });
                }
                const merged = typesFromGuide.map(t => {
                    const list = byNorm.get(__normalizeTitleForMatch(t.title)) || [];
                    return { ...t, problems: list };
                });
                return { types: merged, classificationStandard };
            }

            // Case B) Renderer export bundle (__fmm_bundle__)
            if (obj.__fmm_bundle__ === 1 && obj.items && typeof obj.items === 'object') {
                const readItem = (k) => {
                    const it = obj.items?.[k];
                    if (!it) return null;
                    const kind = String(it.kind || '').toLowerCase();
                    if (kind === 'raw') return String(it.value ?? '');
                    return it.value ?? null;
                };
                const guide = readItem('fmm_source');
                const guideText = (typeof guide === 'string') ? guide : '';
                const guideTypes = parseGuideToTypesForIncremental(guideText);
                const pj = readItem('fmm_problems_json') || readItem('fmm_problems') || null;
                const typesObj = (pj && typeof pj === 'object' && pj.types && typeof pj.types === 'object') ? pj.types : ((pj && typeof pj === 'object') ? pj : null);

                const problemsByNorm = new Map();
                if (typesObj && typeof typesObj === 'object') {
                    Object.keys(typesObj).forEach(k => {
                        const norm = __normalizeTitleForMatch(k);
                        problemsByNorm.set(norm, Array.isArray(typesObj[k]) ? typesObj[k] : []);
                    });
                }
                const merged = guideTypes.map(t => {
                    const norm = __normalizeTitleForMatch(t.title);
                    const list = problemsByNorm.get(norm) || [];
                    return { ...t, problems: list };
                });
                const classificationStandard = (() => {
                    const cs = readItem('fmm_classification_standard');
                    return Array.isArray(cs) && cs.length ? cs : null;
                })();
                if (!merged.length) throw new Error('ë² ì´ìŠ¤ ë²ˆë“¤ì—ì„œ ìœ í˜• ê°€ì´ë“œë¥¼ íŒŒì‹±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (fmm_source í•„ìš”)');
                return { types: merged, classificationStandard };
            }

            throw new Error('ì§€ì›í•˜ì§€ ì•ŠëŠ” ë² ì´ìŠ¤ íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. (builder íŒ¨ì¹˜ íŒŒì¼ ë˜ëŠ” renderer export bundle)');
        }

        async function processFileWrappersToExamUnits(fileWrappers, contextLabel = 'IncFileProcessing') {
            const cfg = getPipelineConfigFromUi();
            const pdfMode = cfg?.phase0?.pdfInputMode || 'multimodal';
            const tessLang = cfg?.phase0?.tesseractLang || 'kor+eng';
            const needsImages = (pdfMode === 'multimodal' || pdfMode === 'tesseract_text');
            const needsTesseract = (pdfMode === 'tesseract_text');
            const out = [];

            for (const fileWrapper of (fileWrappers || [])) {
                const file = fileWrapper?.file;
                if (!file) continue;
                const splitPages = getEffectiveSplitPages(fileWrapper);

                if (file.type === 'text/plain') {
                    const text = await file.text();
                    out.push({
                        fileName: file.name,
                        sourceFileName: file.name,
                        type: 'txt',
                        content: text
                    });
                    continue;
                }
                if (file.type !== 'application/pdf') continue;

                const loadingTask = pdfjsLib.getDocument(URL.createObjectURL(file));
                const pdf = await loadingTask.promise;
                const totalPages = pdf.numPages;
                const pageData = [];

                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    if (processController.stop) throw new Error("Operation cancelled.");
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const rawText = textContent.items.map(item => item.str).join(' ');

                    let imageDataUrl = null;
                    let ocrText = null;
                    if (needsImages) {
                        const viewport = page.getViewport({ scale: 1.5 });
                        const canvas = document.createElement('canvas');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;
                        await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                        imageDataUrl = canvas.toDataURL('image/jpeg', 0.85);
                    }
                    if (needsTesseract && imageDataUrl) {
                        try {
                            const lang = String(tessLang || 'eng').trim() || 'eng';
                            ocrText = await __tesseractOcr(imageDataUrl, lang, `${contextLabel}-${file.name}-p${pageNum}`);
                        } catch (e) {
                            logger.warn(contextLabel, `Tesseract OCR failed for ${file.name} page ${pageNum}: ${e.message}`);
                            ocrText = '';
                        }
                    }
                    pageData.push({ pageNum, imageDataUrl, rawText: rawText.trim(), ocrText: (ocrText || '').trim() });
                }

                const splitInterval = splitPages > 0 ? splitPages : totalPages;
                for (let i = 0; i < totalPages; i += splitInterval) {
                    if (processController.stop) throw new Error("Operation cancelled.");
                    const startPage = i + 1;
                    const endPage = Math.min(i + splitInterval, totalPages);
                    const partIndex = Math.floor(i / splitInterval) + 1;

                    const partName = splitPages > 0
                        ? `${file.name} (Part ${partIndex}, p${startPage}-${endPage})`
                        : file.name;

                    const relevantPages = pageData.slice(i, Math.min(i + splitInterval, totalPages));
                    const images = needsImages ? relevantPages.map(p => p.imageDataUrl).filter(Boolean) : [];
                    const rawTexts = relevantPages.map(p => `[Page ${p.pageNum}]\n${p.rawText}`).join('\n\n');
                    const ocrTexts = needsTesseract
                        ? relevantPages.map(p => `[Page ${p.pageNum}]\n${p.ocrText || ''}`).join('\n\n')
                        : null;

                    out.push({
                        fileName: partName,
                        sourceFileName: file.name,
                        type: 'pdf',
                        images,
                        rawText: rawTexts,
                        ocrText: ocrTexts,
                        partIndex,
                        pageStart: startPage,
                        pageEnd: endPage,
                    });
                }
            }

            logger.info(contextLabel, `Incremental file processing complete. Units=${out.length}`);
            return out;
        }

	        async function incrementalExtractQuestions(examUnits, { experimentalImageCrops } = {}) {
	            const out = [];
	            const jobs = (examUnits || []).map((u, idx) => ({ idx, unit: u }));
	            const concurrency = Math.max(1, __clampInt(getPhase0Concurrency(), { min: 1, max: 16, fallback: 3 }));
	            const language = __getGuideLanguageFromUi();
	            const pCfg = getPipelineConfigFromUi();
	            const pdfInputMode = (pCfg?.phase0?.pdfInputMode || 'multimodal').toString();
	            const tessLang = (pCfg?.phase0?.tesseractLang || 'kor+eng').toString().trim() || 'kor+eng';

            async function processJob(job, workerId) {
                const paper = job.unit;
                const context = `IncExtract-${paper?.fileName || ('U' + job.idx)}-W${workerId}`;
                const basePaperName = String(paper?.sourceFileName || paper?.fileName || '').trim();

                let content;
                if (paper.type === 'txt') {
                    const extractionInstruction = `Extract all problems from this exam paper text.
- Extract all questions, sub-questions, answer choices, answers (if shown), and explanations (if provided)
- LANGUAGE CONSTRAINT: Write ALL extracted fields in ${language}.
`;
                    content = [{
                        type: 'text',
                        text: `${extractionInstruction}\n\n---\n\nEXAM PAPER TEXT:\n\n${paper.content}`
                    }];
                } else {
                    const images = Array.isArray(paper.images) ? paper.images : [];
                    const useImages = (pdfInputMode === 'multimodal') && images.length > 0;
                    if (useImages) {
                        const rawText = String(paper.rawText || '').trim();
                        const extractionInstruction = rawText
                            ? `You are extracting problems from a PDF. I'm providing both OCR images AND raw text extracted from the PDF.

INSTRUCTIONS:
- Use the OCR images to understand the layout and structure
- Use the raw text below to correct any OCR typos or errors
- Extract all questions, sub-questions, answer choices, answers (if shown), and explanations (if provided)
- LANGUAGE CONSTRAINT: Write ALL extracted fields in ${language}. In particular, the <question_text> must include a **fully detailed description** of any non-text visuals in ${language}.
${experimentalImageCrops ? `- EXPERIMENTAL: Do NOT crop images yourself. (A later step may attach image crops.) Still describe visuals in text.\n` : ''}

RAW TEXT (use this to correct OCR errors):
${rawText}

Now examine the OCR images and extract all problems.`
                            : `Extract all problems from this exam paper.
- Extract all questions, sub-questions, answer choices, answers (if shown), and explanations (if provided)
- LANGUAGE CONSTRAINT: Write ALL extracted fields in ${language}. In particular, the <question_text> must include a **fully detailed description** of any non-text visuals in ${language}.
${experimentalImageCrops ? `- EXPERIMENTAL: Do NOT crop images yourself. (A later step may attach image crops.) Still describe visuals in text.\n` : ''}`;

                        content = [{ type: 'text', text: extractionInstruction }];
                        images.forEach(img => content.push({ type: 'image_url', image_url: { url: img } }));
                    } else {
                        let ocrText = String(paper.ocrText || '').trim();
                        if (pdfInputMode === 'tesseract_text' && !ocrText && Array.isArray(paper.images) && paper.images.length > 0) {
                            logger.warn(context, `PDF input mode: tesseract_text (no cached OCR text). Running Tesseract locally...`);
                            const parts = [];
                            for (let i = 0; i < paper.images.length; i++) {
                                if (processController.stop) throw new Error("Operation cancelled.");
                                const txt = await __tesseractOcr(paper.images[i], tessLang, `${context}-Tess${i + 1}/${paper.images.length}`);
                                parts.push(`[Image ${i + 1}/${paper.images.length}]\n${txt}`);
                            }
                            ocrText = parts.join('\n\n').trim();
                        }
                        const rawText = String(paper.rawText || '').trim();
                        const textOnlyInstruction =
                            `You are extracting problems from a PDF as TEXT-ONLY input (no images).

INSTRUCTIONS:
- Extract all questions, sub-questions, answer choices, answers (if shown), and explanations (if provided)
- Reconstruct missing layout as best as possible from the text sources below
- LANGUAGE CONSTRAINT: Write ALL extracted fields in ${language}.

${ocrText ? `TESSERACT OCR TEXT:\n${ocrText}\n\n` : ''}${rawText ? `RAW PDF TEXT:\n${rawText}\n\n` : ''}
Now extract all problems.`;
                        content = [{ type: 'text', text: textOnlyInstruction }];
                    }
                }

	                const payload = {
	                    model: getApiConfig().model,
	                    messages: [
	                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.extractor.system, { language }) },
	                        { role: 'user', content }
	                    ]
	                };

                const items = await requestAndParseDataEnvelope(payload, context, { phase: 'phase0' });
                const extractedQasByQid = {};
                let dedupedChoicesN = 0;
                items.forEach(it => {
                    const qa = parseQAItem(it.value);
                    if (!qa.qid) return;
                    const hint = (() => {
                        const pStart = Number.isFinite(paper?.pageStart) ? paper.pageStart : null;
                        const pEnd = Number.isFinite(paper?.pageEnd) ? paper.pageEnd : null;
                        const pIdx = Number.isFinite(paper?.partIndex) ? paper.partIndex : null;
                        if (pStart && pEnd) return `p${pStart}-${pEnd}`;
                        if (pIdx) return `part${pIdx}`;
                        return String(paper?.fileName || '').slice(0, 30);
                    })();
                    const safeHint = String(hint || '').replace(/[^0-9A-Za-zê°€-í£]+/g, '').slice(0, 30) || 'dup';

                    let globalQid = makeGlobalQid(basePaperName, qa.qid);
                    if (extractedQasByQid[globalQid]) {
                        let local2 = `${qa.qid}@${safeHint}`;
                        globalQid = makeGlobalQid(basePaperName, local2);
                        let n = 2;
                        while (extractedQasByQid[globalQid]) {
                            local2 = `${qa.qid}@${safeHint}${n}`;
                            globalQid = makeGlobalQid(basePaperName, local2);
                            n++;
                        }
                    }

                    let question_text = qa.question_text;
                    let answer_choices = qa.answer_choices;
                    try {
                        const api = (typeof globalThis !== 'undefined' && globalThis.FMMHygiene) ? globalThis.FMMHygiene : null;
                        if (api && typeof api.dedupeChoices === 'function') {
                            const cleaned = api.dedupeChoices(question_text, answer_choices);
                            if (cleaned && typeof cleaned.question_text === 'string') question_text = cleaned.question_text;
                            if (cleaned && typeof cleaned.answer_choices === 'string') answer_choices = cleaned.answer_choices;
                            if (cleaned && cleaned.changed) dedupedChoicesN++;
                        }
                    } catch { }

                    extractedQasByQid[globalQid] = {
                        qid: globalQid,
                        local_qid: qa.qid,
                        paperName: basePaperName,
                        question_text,
                        answer_choices,
                        official_answer: qa.official_answer,
                        official_explanation: qa.official_explanation,
                        __unitImages: (paper.type === 'pdf' && Array.isArray(paper.images) && paper.images.length) ? paper.images : null,
                    };
                });

                if (dedupedChoicesN > 0) {
                    logger.info(context, `Extraction hygiene: removed duplicate choice blocks in ${dedupedChoicesN} item(s).`);
                }

                return Object.values(extractedQasByQid);
            }

            const { results, errors } = await runWithConcurrency(jobs, processJob, concurrency);
            if (errors && errors.length) {
                const first = errors[0]?.error;
                throw new Error(`Incremental extraction failed (${errors.length}): ${first?.message || first}`);
            }
            (results || []).forEach(list => {
                if (Array.isArray(list)) out.push(...list);
            });
            return out;
        }

        async function incrementalLocateAndAttachImageCrops(questions, contextBase = 'IncImageCrop') {
            // Experimental: ask LLM to locate figure crops within the unit images.
            // Stores crops by prepending markdown `![img](data:...)` to question_text.
            const byPaper = new Map();
            (questions || []).forEach(q => {
                const imgs = q?.__unitImages;
                if (!Array.isArray(imgs) || imgs.length === 0) return;
                const head = String(imgs[0] || '').slice(0, 64);
                const key = `${q.paperName}::${imgs.length}::${head}`;
                if (!byPaper.has(key)) byPaper.set(key, { images: imgs, items: [] });
                byPaper.get(key).items.push(q);
            });
            const groups = Array.from(byPaper.values());
            if (!groups.length) return questions;

            const cropImage = async (imgUrl, rect01) => {
                const x0 = Math.max(0, Math.min(1, Number(rect01?.x0 ?? rect01?.x ?? 0)));
                const y0 = Math.max(0, Math.min(1, Number(rect01?.y0 ?? rect01?.y ?? 0)));
                const x1 = Math.max(0, Math.min(1, Number(rect01?.x1 ?? (x0 + Number(rect01?.w ?? 0)) ?? 1)));
                const y1 = Math.max(0, Math.min(1, Number(rect01?.y1 ?? (y0 + Number(rect01?.h ?? 0)) ?? 1)));
                if (!(x1 > x0) || !(y1 > y0)) return null;
                const img = new Image();
                img.crossOrigin = 'anonymous';
                const loaded = new Promise((resolve, reject) => {
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error('Image load failed'));
                });
                img.src = imgUrl;
                await loaded;
                const sx = Math.floor(x0 * img.width);
                const sy = Math.floor(y0 * img.height);
                const sw = Math.max(1, Math.floor((x1 - x0) * img.width));
                const sh = Math.max(1, Math.floor((y1 - y0) * img.height));
                const canvas = document.createElement('canvas');
                canvas.width = sw;
                canvas.height = sh;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
                return canvas.toDataURL('image/jpeg', 0.9);
            };

            for (let gi = 0; gi < groups.length; gi++) {
                const g = groups[gi];
                const images = g.images;
                const items = g.items || [];
                if (!items.length || !images.length) continue;
                const ctxLabel = `${contextBase}-G${gi + 1}/${groups.length}`;
                const brief = items.map(q => `QID: ${q.qid}\nSTEM:\n${String(q.question_text || '').slice(0, 400)}`).join('\n\n---\n\n');

                const sys = `You are a Figure Crop Locator.

Goal: For each question, if there is a relevant non-text visual (figure/table/diagram/photo/graph) on the provided images, return a tight crop rectangle.

Output format:
<data>
  <item>
    <qid>...</qid>
    <page_index>1</page_index>  <!-- 1-based index within provided images -->
    <x0>0.12</x0><y0>0.34</y0><x1>0.56</x1><y1>0.78</y1> <!-- normalized 0..1 -->
  </item>
  ...
</data>

Rules:
- If unsure or no relevant visual for that qid: omit that qid (do not guess).
- Do NOT include any extra commentary outside <data>.
- Do NOT leak the answer in text; this tool is only for cropping.`;

                const content = [{ type: 'text', text: `QUESTIONS:\n\n${brief}\n\nReturn crops only for questions that have a relevant visual.` }];
                images.forEach(img => content.push({ type: 'image_url', image_url: { url: img } }));
                const payload = { model: getApiConfig().model, messages: [{ role: 'system', content: sys }, { role: 'user', content }] };
                const itemsOut = await requestAndParseDataEnvelope(payload, ctxLabel, { phase: 'phase0', allowEmpty: true });

                const cropsByQid = new Map();
                itemsOut.forEach(it => {
                    try {
                        const qid = parseTag(it.value, 'qid');
                        const pageIdx = parseInt(parseTag(it.value, 'page_index'), 10);
                        const x0 = parseFloat(parseTag(it.value, 'x0'));
                        const y0 = parseFloat(parseTag(it.value, 'y0'));
                        const x1 = parseFloat(parseTag(it.value, 'x1'));
                        const y1 = parseFloat(parseTag(it.value, 'y1'));
                        if (!qid) return;
                        if (!Number.isFinite(pageIdx) || pageIdx < 1 || pageIdx > images.length) return;
                        if (![x0, y0, x1, y1].every(Number.isFinite)) return;
                        const rect = { page_index: pageIdx, x0, y0, x1, y1 };
                        if (!cropsByQid.has(qid)) cropsByQid.set(qid, []);
                        cropsByQid.get(qid).push(rect);
                    } catch { }
                });

                for (const q of items) {
                    const rects = cropsByQid.get(q.qid) || [];
                    if (!rects.length) continue;
                    const imgsMd = [];
                    for (let ri = 0; ri < Math.min(2, rects.length); ri++) {
                        const r = rects[ri];
                        const pageUrl = images[r.page_index - 1];
                        try {
                            const crop = await cropImage(pageUrl, r);
                            if (crop) imgsMd.push(`![img](${crop})`);
                        } catch { }
                    }
                    if (imgsMd.length) {
                        const original = String(q.question_text || '');
                        q.question_text = `${imgsMd.join('\n\n')}\n\n${original}`.trim();
                    }
                }
            }
            return questions;
        }

        async function incrementalClassifyQuestions(questions, classificationStandard, contextLabel = 'IncClassify') {
            if (!Array.isArray(questions) || questions.length === 0) return [];
            if (!Array.isArray(classificationStandard) || classificationStandard.length === 0) {
                throw new Error('ë¶„ë¥˜í‘œì¤€(classificationStandard)ì´ ì—†ìŠµë‹ˆë‹¤. (ë² ì´ìŠ¤ íŒŒì¼ì— í¬í•¨ë˜ì–´ì•¼ í•¨)');
            }

            const standardText = classificationStandard.map(t =>
                `TYPE: ${t.type_name}\nDESCRIPTION: ${t.type_description}\nRECOGNITION: ${t.recognition_criteria}\nCONCEPTS: ${t.core_concepts}`
            ).join('\n\n---\n\n');

            const pCfgForBatch = getPipelineConfigFromUi();
            const batchChunkMode = pCfgForBatch?.phase1?.chunkMode || 'file_first';
            const batchTokens = __clampInt(pCfgForBatch?.phase1?.chunkTokens1b ?? pCfgForBatch?.phase1?.chunkTokens ?? DEFAULT_CHUNK_TOKENS, { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS });
            const batches = chunkProblemsRespectingBoundaries(questions, batchTokens, batchChunkMode);

            const perQuestion = [];
            async function processBatch(batch, workerId) {
                const ctx = `${contextLabel}-B${workerId}`;
                const batchText = problemsToText(batch);
	                const payload = {
	                    model: getApiConfig().model,
	                    messages: [
	                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.classifier_apply.system, { language: __getGuideLanguageFromUi() }) },
	                        { role: 'user', content: `CLASSIFICATION STANDARD:\n\n${standardText}\n\n---\n\nPROBLEMS TO CLASSIFY:\n\n${batchText}` }
	                    ]
	                };
	                const items = await requestAndParseDataEnvelope(payload, ctx, { phase: 'phase1b' });
	                items.forEach(it => {
	                    const qid = parseTag(it.value, 'qid');
	                    const type_name = parseTag(it.value, 'type_name');
	                    const q = batch.find(x => x.qid === qid);
	                    if (!q) return;
	                    perQuestion.push({
	                        qid: q.qid,
	                        pattern_name: type_name,
	                        paperName: q.paperName
	                    });
	                });
            }
            await runWithConcurrency(batches, processBatch, getWorkerConcurrency());
            return perQuestion;
        }

	        function buildSkeletonGuideForNewType(title) {
	            return [
	                `1. **Concept Explanation**`,
	                `- (ì‹ ê·œ ë¬¸ì œ ì¶”ê°€ ëª¨ë“œ: ë¨¼ì € ê°€ì´ë“œë¥¼ ìƒì„±í•œ ë’¤, ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜ë¡œ ë³´ê°•í•©ë‹ˆë‹¤.)`,
	                ``,
	                `2. **Standard Problem Explanation**`,
	                `- (ì‹ ê·œ ë¬¸ì œ ì¶”ê°€ ëª¨ë“œ: í‘œì¤€ë¬¸ì œ í•´ì„¤ì´ ìƒì„±ë©ë‹ˆë‹¤.)`,
	                ``,
	                `3. **Question Patterns & Examinerâ€™s Win Conditions**`,
	                `- (ì‹ ê·œ ë¬¸ì œ ì¶”ê°€ ëª¨ë“œ: íŒ¨í„´/í•¨ì •/ì „ëµì´ ìƒì„±ë©ë‹ˆë‹¤.)`,
	                ``,
	                `4. **Study Method**`,
	                `- **Problem intuition**: (ìƒì„±ë¨)`,
	                `- **100% coverage checklist**: (ìƒì„±ë¨)`,
	                ``
	            ].join('\n');
	        }

        function mergeProblemsDedupByQid(existing, added) {
            const out = [];
            const seen = new Set();
            (existing || []).forEach(p => {
                const qid = String(p?.qid || '').trim();
                if (!qid || seen.has(qid)) return;
                seen.add(qid);
                const clone = { ...(p || {}), qid };
                try { delete clone.__unitImages; } catch { }
                out.push(clone);
            });
            (added || []).forEach(p => {
                const qid = String(p?.qid || '').trim();
                if (!qid || seen.has(qid)) return;
                seen.add(qid);
                const clone = { ...(p || {}), qid };
                try { delete clone.__unitImages; } catch { }
                out.push(clone);
            });
            return out;
        }

        function ensureUniqueTitle(baseTitle, existingTitles) {
            const used = new Set((existingTitles || []).map(t => __normalizeTitleForMatch(t)));
            const t0 = String(baseTitle || '').trim() || 'ìƒˆ ìœ í˜•';
            if (!used.has(__normalizeTitleForMatch(t0))) return t0;
            let n = 2;
            while (used.has(__normalizeTitleForMatch(`${t0} (${n})`))) n++;
            return `${t0} (${n})`;
        }

        async function runIncrementalCoverageOnlyPatch({ base, newQuestions, mode, newTypeTitle, experimentalImageCrops }) {
            const baseTypes = (base?.types || []).map(t => ({ ...t }));
            const baseByNorm = new Map(baseTypes.map(t => [__normalizeTitleForMatch(t.title), t]));

            let assignment = new Map(); // typeTitle -> [problems]
            let createdNewType = null;

            if (mode === 'new_type') {
                const title = ensureUniqueTitle(newTypeTitle, baseTypes.map(t => t.title));
                createdNewType = {
                    title,
                    standardMarkdown: buildStandardMarkdown('(ì‹ ê·œ ë¬¸ì œ ì¶”ê°€ ëª¨ë“œ)', '(N/A)'),
                    explanationMarkdown: buildSkeletonGuideForNewType(title),
                    problems: []
                };
                baseTypes.push(createdNewType);
                baseByNorm.set(__normalizeTitleForMatch(title), createdNewType);
                assignment.set(title, newQuestions.slice());
            } else {
	                const perQ = await incrementalClassifyQuestions(newQuestions, base.classificationStandard, 'IncClassify');
	                const byQid = new Map(perQ.map(x => [x.qid, x]));
	                newQuestions.forEach(q => {
	                    const m = byQid.get(q.qid);
	                    const typeName = String(m?.pattern_name || '').trim();
	                    const norm = __normalizeTitleForMatch(typeName);
	                    const target = baseByNorm.get(norm);
	                    const title = target ? target.title : null;
                    if (!title) return;
                    if (!assignment.has(title)) assignment.set(title, []);
                    assignment.get(title).push(q);
                });
                const unassigned = newQuestions.filter(q => {
                    const m = byQid.get(q.qid);
                    const typeName = String(m?.pattern_name || '').trim();
                    return !typeName || !baseByNorm.has(__normalizeTitleForMatch(typeName));
                });
                if (unassigned.length) {
                    const title = ensureUniqueTitle('ğŸ†• ì‹ ê·œ ë¬¸ì œ (ë¯¸ë¶„ë¥˜)', baseTypes.map(t => t.title));
                    createdNewType = {
                        title,
                        standardMarkdown: buildStandardMarkdown('(ë¯¸ë¶„ë¥˜)', '(N/A)'),
                        explanationMarkdown: buildSkeletonGuideForNewType(title),
                        problems: []
                    };
                    baseTypes.push(createdNewType);
                    assignment.set(title, unassigned);
                }
            }

            // Patch per affected type only
            const pCfg = getPipelineConfigFromUi();
            const coverageOpts = pCfg?.phase2?.coverage || {};

            const patchedTypes = [];
            for (const [title, added] of assignment.entries()) {
                if (!added || !added.length) continue;
                const t = baseByNorm.get(__normalizeTitleForMatch(title));
                if (!t) continue;
                const updatedProblems = mergeProblemsDedupByQid(t.problems || [], added);

                // 1) If this type has no real guide yet (new type / skeleton), generate a full guide first.
                const std0 = String(t.standardMarkdown || '').trim();
                const guide0 = String(t.explanationMarkdown || '').trim();

                const isStdPlaceholder = (!std0) || /(\(N\/A\)|ì‹ ê·œ ë¬¸ì œ ì¶”ê°€ ëª¨ë“œ|ë¯¸ë¶„ë¥˜)/.test(std0);
                const isGuideSkeleton =
                    (!guide0) ||
                    /ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤/.test(guide0) ||
                    /\(ì‹ ê·œ ë¬¸ì œ ì¶”ê°€ ëª¨ë“œ:/.test(guide0);

                let standardMarkdown = std0 || buildStandardMarkdown('(N/A)', '(N/A)');
                let baseGuide = guide0 || buildSkeletonGuideForNewType(title);

                if (isGuideSkeleton || isStdPlaceholder) {
                    const contextCreate = `IncCreate-${title}`;
                    try {
                        const language = __getGuideLanguageFromUi();
                        const problemsText = problemsToTextInterleaved(updatedProblems);

                        // (1) Create a representative standard problem
	                        const sp_payload = {
	                            model: getApiConfig().model,
	                            messages: [
	                                { role: 'system', content: __renderPromptTemplateText(currentPrompts.standard_problem_creator.system, { language }) },
	                                { role: 'user', content: `Pattern Type: ${t.title}
	
	All problems of this type:

${problemsText}

Create ONE standard problem that represents this type.
LANGUAGE CONSTRAINT: The standard problem must be in ${language}.` }
                            ],
                            stream: false
                        };
                        const sp_items = await requestAndParseDataEnvelopeLenient(sp_payload, `${contextCreate}-StdProblem`, { phase: 'incremental' });
                        const stdProblem = {
                            problem: parseTag(sp_items[0].value, 'standard_problem'),
                            answer: parseTag(sp_items[0].value, 'correct_answer')
                        };
                        if (!String(stdProblem.problem || '').trim() || !String(stdProblem.answer || '').trim()) {
                            throw new Error('Standard problem creation returned empty fields.');
                        }
                        standardMarkdown = buildStandardMarkdown(stdProblem.problem, stdProblem.answer);

                        // (2) Create a FULL guide (CREATE MODE) BEFORE any coverage patching.
                        baseGuide = await generateExplanationForSubset(t.title, stdProblem, updatedProblems, `${contextCreate}-Guide`, 0);
                        if (!String(baseGuide || '').trim()) {
                            throw new Error('Guide creation returned empty text.');
                        }
                    } catch (e) {
                        // IMPORTANT: Do NOT run coverage patch without a proper guide.
                        throw new Error(`Incremental: guide creation failed for type "${t.title}". ${e?.message || e}`);
                    }
                }

                // 2) Then run coverage patch so the new problems are guaranteed solvable from the guide.
                const context = `IncCoverage-${title}`;
                const cov = await refineGuideCoverage(baseGuide, added, context, {
                    maxTokens: coverageOpts?.maxTokens,
                    maxRounds: coverageOpts?.maxRounds,
                    patcherMode: coverageOpts?.patcherMode,
                    verifierOutput: coverageOpts?.verifierOutput,
                    verifierMaxTries: coverageOpts?.verifierMaxTries,
                    finalVerifyMode: coverageOpts?.finalVerifyMode,
                });

                let guideText = cov.guideText;
                try {
                    const hygiene = __applyMarkdownHygieneFix(guideText, context, 'incremental_coverage');
                    guideText = hygiene.text;
                } catch { }

                patchedTypes.push({
                    title: t.title,
                    standardMarkdown,
                    explanationMarkdown: guideText,
                    problems: updatedProblems
                });
            }

            const patchPayload = {
                patchVersion: 1,
                mode: 'incremental_coverage_only',
                generatedAt: new Date().toISOString(),
                baseInfo: {
                    typeCount: baseTypes.length,
                    addedProblemCount: newQuestions.length,
                    assignmentMode: mode
                },
                types: patchedTypes,
                ...(Array.isArray(base?.classificationStandard) && base.classificationStandard.length ? { classificationStandard: base.classificationStandard } : {})
            };

            return { patchPayload, patchedTypes };
        }

        // Helper: collect ALL questions from phase0_extract
        function collectAllQuestions() {
            if (!activeProcess || !activeProcess.phase0_extract) return [];
            const out = [];
            activeProcess.phase0_extract.forEach(paperState => {
                if (paperState.qasByQid) {
                    Object.entries(paperState.qasByQid).forEach(([globalQid, qa]) => {
                        out.push({
                            // qid is now global, e.g. "Midterm2024.pdf::Q1"
                            qid: globalQid,
                            paperName: qa.paperName || paperState.paperName,
                            local_qid: qa.local_qid || null,
                            question_text: qa.question_text,
                            answer_choices: qa.answer_choices,
                            official_answer: qa.official_answer,
                            official_explanation: qa.official_explanation,
                        });
                    });
                }
            });
            return out;
        }

        // ----- Phase 0 (optional): Apply separate answer-key files to extracted questions -----
        function __normalizeLocalQidForAnswerKey(raw) {
            // Normalize common patterns so "1", "1.", "1ë²ˆ", "Q1" can match.
            let s = String(raw || '').trim();
            if (!s) return '';
            s = s.replace(/\s+/g, '');
            s = s.replace(/ë²ˆ$/i, '');
            s = s.replace(/[.)]$/g, '');
            // If extracted local_qid was disambiguated with "@...", strip it for matching.
            s = s.replace(/@.+$/g, '');
            return s;
        }

        function __buildAnswerKeyCandidateSummary() {
            const states = Array.isArray(activeProcess?.phase0_extract) ? activeProcess.phase0_extract : [];
            const lines = [];
            states.forEach(s => {
                const paperName = String(s?.paperName || '').trim();
                const qas = (s && s.qasByQid && typeof s.qasByQid === 'object') ? s.qasByQid : null;
                const locals = qas ? Object.values(qas).map(qa => __normalizeLocalQidForAnswerKey(qa?.local_qid)).filter(Boolean) : [];
                const uniq = Array.from(new Set(locals));
                uniq.sort((a, b) => String(a).localeCompare(String(b), 'en'));
                const sample = uniq.slice(0, 24).join(', ');
                const hasSubs = uniq.some(x => /[a-z]/i.test(x) || /-/.test(x));
                const hint = [
                    `paper_name: ${paperName}`,
                    `question_count: ${uniq.length}`,
                    `has_subquestions: ${hasSubs ? 'yes' : 'no'}`,
                    `local_qid_examples: ${sample || '(none)'}`
                ].join('\n  ');
                if (paperName) lines.push(`- ${hint}`);
            });
            return `CANDIDATE PAPERS:\n${lines.join('\n')}`.trim();
        }

        function __clipForAnswerKey(text, maxChars = 24000) {
            const s = String(text ?? '').trim();
            const lim = Math.max(1000, Number(maxChars || 0) || 24000);
            if (s.length <= lim) return s;
            return s.slice(0, lim).trim() + '\nâ€¦(clipped)';
        }

        function __buildAnswerKeyDocumentContent(units, { pdfInputMode, tessLang } = {}) {
            const mode = String(pdfInputMode || (getPipelineConfig()?.phase0?.pdfInputMode || 'multimodal'));
            const lang = String(tessLang || (getPipelineConfig()?.phase0?.tesseractLang || 'kor+eng')).trim() || 'kor+eng';
            const useImages = mode === 'multimodal';

            const content = [];
            const textParts = [];
            const images = [];

            (units || []).forEach(u => {
                const name = String(u?.fileName || u?.sourceFileName || '').trim();
                if (u?.type === 'txt') {
                    textParts.push(`[Unit: ${name || 'TXT'}]\n${String(u?.content || '').trim()}`);
                    return;
                }
                // pdf unit
                const raw = String(u?.rawText || '').trim();
                if (raw) textParts.push(`[Unit: ${name || 'PDF'}]\n${raw}`);
                if (mode === 'tesseract_text') {
                    const ocr = String(u?.ocrText || '').trim();
                    if (ocr) textParts.push(`[Unit: ${name || 'PDF'}][Tesseract OCR lang=${lang}]\n${ocr}`);
                }
                if (useImages) {
                    const imgs = Array.isArray(u?.images) ? u.images : [];
                    imgs.forEach(img => images.push(img));
                }
            });

            const combinedText = __clipForAnswerKey(textParts.join('\n\n---\n\n'), 32000);
            content.push({ type: 'text', text: combinedText || '(no text extracted)' });

            // Keep images limited to avoid blowing up multimodal payloads.
            if (useImages && images.length) {
                images.slice(0, 10).forEach(img => content.push({ type: 'image_url', image_url: { url: img } }));
            }
            return content;
        }

        function __parseAnswerKeyItemsToMap(items) {
            const out = []; // {paper_name, local_qid, official_answer}
            (items || []).forEach(it => {
                const v = String(it?.value || '');
                const paper_name = String(parseTag(v, 'paper_name') || '').trim();
                const local_qid = String(parseTag(v, 'local_qid') || '').trim();
                const official_answer = String(parseTag(v, 'official_answer') || '').trim();
                if (!paper_name || !local_qid || !official_answer) return;
                out.push({ paper_name, local_qid, official_answer });
            });
            return out;
        }

        function __applyAnswerMapToPaper(paperState, entries) {
            const qas = (paperState && paperState.qasByQid && typeof paperState.qasByQid === 'object') ? paperState.qasByQid : null;
            if (!qas) return { applied: 0, skipped: 0, unknown: 0 };
            const byLocal = new Map();
            Object.entries(qas).forEach(([globalQid, qa]) => {
                const k = __normalizeLocalQidForAnswerKey(qa?.local_qid);
                if (!k) return;
                // Prefer first occurrence; duplicates can exist if PDF splitting caused collisions.
                if (!byLocal.has(k)) byLocal.set(k, globalQid);
            });
            let applied = 0;
            let skipped = 0;
            let unknown = 0;
            (entries || []).forEach(e => {
                const k = __normalizeLocalQidForAnswerKey(e?.local_qid);
                const ans = String(e?.official_answer || '').trim();
                if (!k || !ans) return;
                const gid = byLocal.get(k);
                if (!gid) { unknown++; return; }
                const qa = qas[gid];
                const has = String(qa?.official_answer || '').trim();
                if (has) { skipped++; return; }
                qa.official_answer = ans;
                qa.official_answer_source = 'answer_key';
                applied++;
            });
            return { applied, skipped, unknown };
        }

        async function applyUploadedAnswerKeyFilesToExtractedQuestions() {
            const wrappers = Array.isArray(uploadedAnswerFiles) ? uploadedAnswerFiles : [];
            if (!wrappers.length) return { appliedFiles: 0, appliedAnswers: 0, skipped: 0, unknown: 0 };
            const inputSig = (() => {
                try {
                    return wrappers
                        .map(w => `${w?.file?.name || ''}::${w?.file?.size || 0}::${w?.file?.lastModified || 0}`)
                        .sort()
                        .join('|');
                } catch {
                    return String(Date.now());
                }
            })();
            try {
                const prev = activeProcess?.phase0_answerKeyImport;
                if (prev && prev.status === 'completed' && String(prev.inputSig || '') === inputSig) {
                    return { appliedFiles: prev.appliedFiles || 0, appliedAnswers: prev.appliedAnswers || 0, skipped: prev.skipped || 0, unknown: prev.unknown || 0 };
                }
            } catch { }
            const states = Array.isArray(activeProcess?.phase0_extract) ? activeProcess.phase0_extract : [];
            const candidates = states.filter(s => s && s.qasByQid && typeof s.qasByQid === 'object' && Object.keys(s.qasByQid).length > 0);
            if (!candidates.length) throw new Error('ì •ë‹µíŒŒì¼ì„ ì ìš©í•  ì¶”ì¶œ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. (0ë‹¨ê³„ë¥¼ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”)');

            updateStatus("Answer Key Import...", "Processing answer files and applying official answers...");
            renderActiveProcess();

            const units = await processFileWrappersToExamUnits(wrappers, 'AnswerKeyFileProcessing');
            const bySrc = new Map(); // sourceFileName -> units[]
            (units || []).forEach(u => {
                const src = String(u?.sourceFileName || u?.fileName || '').trim() || 'Unknown';
                if (!bySrc.has(src)) bySrc.set(src, []);
                bySrc.get(src).push(u);
            });
            const jobs = Array.from(bySrc.entries()).map(([src, us], idx) => ({ idx, src, units: us }));
            if (!jobs.length) return { appliedFiles: 0, appliedAnswers: 0, skipped: 0, unknown: 0 };

            const candidateSummary = __buildAnswerKeyCandidateSummary();
            const cfg = getPipelineConfig();
            const pdfMode = cfg?.phase0?.pdfInputMode || 'multimodal';
            const tessLang = cfg?.phase0?.tesseractLang || 'kor+eng';

            const normalizedPaperNameToState = new Map(candidates.map(s => [__normalizeTitleForMatch(s.paperName), s]));

            let appliedFiles = 0;
            let appliedAnswers = 0;
            let skipped = 0;
            let unknown = 0;

            async function processJob(job, workerId) {
                const ctx = `AnswerKey-${job.src}-W${workerId}`;
                const docContent = __buildAnswerKeyDocumentContent(job.units, { pdfInputMode: pdfMode, tessLang });
                const intro = [
                    `You will be given an answer-key document.`,
                    ``,
                    candidateSummary,
                    ``,
                    `ANSWER-KEY DOCUMENT:`,
                ].join('\n');

                const payload = {
                    model: getApiConfig().model,
                    messages: [
                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.answer_key_extractor.system, { language: __getGuideLanguageFromUi() }) },
                        { role: 'user', content: [{ type: 'text', text: intro }, ...docContent] }
                    ]
                };
                const items = await requestAndParseDataEnvelope(payload, ctx, { phase: 'phase0' });
                const entries = __parseAnswerKeyItemsToMap(items);
                if (!entries.length) return;

                // Group by paper_name (some answer keys may contain multiple sections; we support multiple papers just in case)
                const byPaper = new Map();
                entries.forEach(e => {
                    const pn = String(e.paper_name || '').trim();
                    if (!pn) return;
                    if (!byPaper.has(pn)) byPaper.set(pn, []);
                    byPaper.get(pn).push(e);
                });

                byPaper.forEach((list, pnRaw) => {
                    const st = normalizedPaperNameToState.get(__normalizeTitleForMatch(pnRaw)) || null;
                    if (!st) return;
                    const r = __applyAnswerMapToPaper(st, list);
                    appliedAnswers += r.applied;
                    skipped += r.skipped;
                    unknown += r.unknown;
                    appliedFiles++;
                });
            }

            const concurrency = Math.max(1, __clampInt(getWorkerConcurrency(), { min: 1, max: 16, fallback: 3 }));
            const { errors } = await runWithConcurrency(jobs, processJob, concurrency);
            if (errors && errors.length) {
                logger.warn('AnswerKey', `Some answer-key jobs failed (${errors.length}). First: ${errors[0]?.error?.message || errors[0]?.error}`);
            }

            logger.success('AnswerKey', `Applied answer keys: files=${appliedFiles}, answers=${appliedAnswers}, skipped=${skipped}, unknownQids=${unknown}`);
            try {
                activeProcess.phase0_answerKeyImport = {
                    status: 'completed',
                    appliedFiles,
                    appliedAnswers,
                    skipped,
                    unknown,
                    inputSig,
                    appliedAt: new Date().toISOString(),
                };
            } catch { }
            renderActiveProcess();
            return { appliedFiles, appliedAnswers, skipped, unknown };
        }

        // ----- Phase 0 (optional): Fill missing answers/explanations with LLM -----
        function __answerFillStripDataUris(text) {
            let s = String(text ?? '');
            s = s.replace(/!\[[^\]]*]\(data:[^)]+\)/gi, '[image]');
            s = s.replace(/<\s*img\b[^>]*\bsrc\s*=\s*["']data:[^"']+["'][^>]*>/gi, '[image]');
            s = s.replace(/data:image\/[^;\s]+;base64,[a-z0-9+/=]+/gi, '[image]');
            return s;
        }

        function __answerFillClipText(text, maxChars) {
            const s = String(text ?? '').trim();
            const lim = Math.max(0, Number(maxChars || 0) || 0);
            if (!lim || s.length <= lim) return s;
            return s.slice(0, lim).trim() + 'â€¦';
        }

        function __answerFillBuildDdgQuery(problem) {
            const raw = __answerFillStripDataUris(problem?.question_text || '');
            let s = raw.replace(/\$[^$]+\$/g, ' ').replace(/\s+/g, ' ').trim();
            if (!s) s = String(problem?.qid || '').trim();
            // Keep it short for DDG Instant Answer.
            s = s.slice(0, 180).trim();
            return s;
        }

        async function __ddgInstantAnswer(query) {
            const q = String(query || '').trim();
            if (!q) return '';
            const url = `https://api.duckduckgo.com/?q=${encodeURIComponent(q)}&format=json&no_html=1&skip_disambig=1`;
            const res = await fetch(url, { method: 'GET' });
            if (!res.ok) throw new Error(`DuckDuckGo HTTP ${res.status}`);
            const data = await res.json();
            const parts = [];
            const heading = String(data?.Heading || '').trim();
            const abs = String(data?.AbstractText || '').trim();
            const absSrc = String(data?.AbstractSource || '').trim();
            const absUrl = String(data?.AbstractURL || '').trim();
            if (heading) parts.push(`Heading: ${heading}`);
            if (abs) parts.push(`Abstract: ${abs}`);
            if (absSrc || absUrl) parts.push(`Source: ${[absSrc, absUrl].filter(Boolean).join(' ')}`.trim());
            const rel = Array.isArray(data?.RelatedTopics) ? data.RelatedTopics : [];
            const relTexts = [];
            for (const r of rel) {
                if (relTexts.length >= 4) break;
                if (r && typeof r === 'object' && Array.isArray(r.Topics)) {
                    for (const t of r.Topics) {
                        const tx = String(t?.Text || '').trim();
                        if (tx) relTexts.push(tx);
                        if (relTexts.length >= 4) break;
                    }
                    continue;
                }
                const tx = String(r?.Text || '').trim();
                if (tx) relTexts.push(tx);
            }
            if (relTexts.length) parts.push(`Related: ${relTexts.join(' / ')}`);
            const out = parts.join('\n').trim();
            return __answerFillClipText(out, 900);
        }

        function __packAnswerFillItemsByTokens(items, maxTokens) {
            const maxT = __clampInt(maxTokens ?? DEFAULT_CHUNK_TOKENS, { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS });
            const sep = '\n\n---\n\n';
            const sepTok = __estimateTokens(sep);
            const sorted = (items || []).slice().sort((a, b) => (b.estTokens || 0) - (a.estTokens || 0));
            const batches = [];
            for (const it of sorted) {
                if (!it || !it.text) continue;
                const t = Math.max(0, Number(it.estTokens || 0) || 0);
                if (t > maxT) {
                    batches.push({ items: [it] });
                    continue;
                }
                let placed = false;
                for (const b of batches) {
                    b.__est ||= 0;
                    const nextTok = b.__est + t + (b.items.length ? sepTok : 0);
                    if (nextTok <= maxT) {
                        b.items.push(it);
                        b.__est = nextTok;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    const b = { items: [it] };
                    b.__est = t;
                    batches.push(b);
                }
            }
            return batches.map(b => ({ items: (b.items || []).slice() }));
        }

        async function fillMissingOfficialAnswersWithLlm({ chunkTokens, useDuckDuckGo } = {}) {
            const cfg = getPipelineConfig();
            const enabled = !!cfg?.phase0?.answerFill?.enabled;
            if (!enabled) return { batches: 0, filledAnswers: 0, filledExplanations: 0 };

	            const maxT = __clampInt(
	                chunkTokens ??
	                cfg?.phase0?.answerFill?.fillChunkTokens ??
	                cfg?.phase0?.answerFill?.chunkTokens ??
	                DEFAULT_CHUNK_TOKENS,
	                { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS }
	            );
            const useDdg = (typeof useDuckDuckGo === 'boolean') ? useDuckDuckGo : !!cfg?.phase0?.answerFill?.useDuckDuckGo;
            const language = __getGuideLanguageFromUi();
            const guiLang = (getEl('gui-lang-select')?.value === 'ko') ? 'ko' : 'en';
            const warningPrefix = guiLang === 'ko'
                ? `> âš ï¸ LLM ìƒì„± í•´ì„¤ (ê³µì‹ ì•„ë‹˜)\n\n`
                : `> âš ï¸ LLM-generated explanation (not official)\n\n`;

            // Collect targets (only those missing an answer)
            const targets = [];
            const states = Array.isArray(activeProcess?.phase0_extract) ? activeProcess.phase0_extract : [];
            states.forEach(st => {
                const qas = (st && st.qasByQid && typeof st.qasByQid === 'object') ? st.qasByQid : null;
                if (!qas) return;
                Object.entries(qas).forEach(([qid, qa]) => {
                    const ans = String(qa?.official_answer || '').trim();
                    if (ans) return;
                    targets.push({
                        qid: String(qid || '').trim(),
                        qa,
                        question_text: qa?.question_text || '',
                        answer_choices: qa?.answer_choices || '',
                    });
                });
            });
            if (!targets.length) {
                logger.info('AnswerFill', 'No missing answers found; skipping LLM fill.');
                return { batches: 0, filledAnswers: 0, filledExplanations: 0 };
            }

            updateStatus("Answer Fill...", `Filling ${targets.length} missing answer(s) with LLM...`);
            renderActiveProcess();

            // Optional: fetch DDG snippets (free) as extra context
            const ddgCache = new Map();
            if (useDdg) {
                const jobs = targets.map((t, idx) => ({ idx, t }));
                async function processJob(job, workerId) {
                    const ctx = `DDG-W${workerId}`;
                    const q = __answerFillBuildDdgQuery(job.t);
                    if (!q) return;
                    if (ddgCache.has(q)) { job.t.__ddg = ddgCache.get(q); return; }
                    try {
                        const snip = await __ddgInstantAnswer(q);
                        ddgCache.set(q, snip);
                        job.t.__ddg = snip;
                    } catch (e) {
                        logger.warn(ctx, `DuckDuckGo lookup failed: ${e?.message || e}`);
                    }
                }
                await runWithConcurrency(jobs, processJob, Math.max(1, Math.min(6, getWorkerConcurrency())));
            }

            // Build item blocks and pack into batches
            const items = targets.map(t => {
                const qid = String(t.qid || '').trim();
                const qText = __answerFillClipText(__answerFillStripDataUris(t.question_text), 6500);
                const cText = __answerFillClipText(__answerFillStripDataUris(t.answer_choices), 1600);
                const ddg = String(t.__ddg || '').trim();
                const ref = ddg ? `\n\n[DuckDuckGo Instant Answer]\n${ddg}` : '';
                const block =
                    `QID: ${qid}\n` +
                    `QUESTION:\n${qText || '(empty)'}\n` +
                    (cText ? `\nCHOICES:\n${cText}\n` : '') +
                    ref;
                return { qid, qa: t.qa, text: block, estTokens: __estimateTokens(block) };
            }).filter(it => it.qid);

            const batches = __packAnswerFillItemsByTokens(items, maxT);
            logger.info('AnswerFill', `Missing answers: ${items.length} â†’ ${batches.length} batch(es) (maxTokensâ‰ˆ${maxT}, ddg=${useDdg ? 'on' : 'off'})`);

            let filledAnswers = 0;
            let filledExplanations = 0;

            async function processBatch(batch, workerId) {
                const ctx = `AnswerFillBatch-W${workerId}`;
                const list = (batch && Array.isArray(batch.items)) ? batch.items : [];
                if (!list.length) return;

                const userText =
                    `Solve ALL problems below.\n` +
                    `- Use the given QID exactly.\n` +
                    `- Output ONLY <data>...</data>.\n\n` +
                    list.map(x => x.text).join('\n\n---\n\n');

                const payload = {
                    model: getApiConfig().model,
                    messages: [
                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.answer_filler.system, { language }) },
                        { role: 'user', content: userText }
                    ]
                };

                // Semantic retry loop (XML repair handles structure, not completeness)
                const expected = new Set(list.map(x => x.qid));
                const MAX_TRIES = 3;
                let lastErr = '';
                for (let tryNo = 1; tryNo <= MAX_TRIES; tryNo++) {
                    if (processController.stop) throw new Error('Operation cancelled.');
                    try {
                        const parsed = await requestAndParseDataEnvelope(payload, `${ctx}-T${tryNo}`, { phase: 'phase0' });
                        const byQid = new Map();
                        parsed.forEach(it => {
                            const v = String(it?.value || '');
                            const qid = String(parseTag(v, 'qid') || '').trim();
                            const answer = String(parseTag(v, 'answer') || '').trim();
                            const explanation = String(parseTag(v, 'explanation') || '').trim();
                            const confRaw = String(parseTag(v, 'confidence') || '').trim();
                            const conf = (() => { const n = parseFloat(confRaw); return Number.isFinite(n) ? Math.max(0, Math.min(1, n)) : null; })();
                            if (!qid) return;
                            byQid.set(qid, { answer, explanation, confidence: conf });
                        });

                        const missing = [];
                        expected.forEach(qid => {
                            const rec = byQid.get(qid);
                            if (!rec) { missing.push(`${qid}:no_item`); return; }
                            if (!String(rec.answer || '').trim()) missing.push(`${qid}:empty_answer`);
                            if (!String(rec.explanation || '').trim()) missing.push(`${qid}:empty_explanation`);
                        });
                        if (missing.length) throw new Error(`Incomplete batch output: ${missing.slice(0, 8).join(', ')}${missing.length > 8 ? '...' : ''}`);

                        // Apply
                        list.forEach(x => {
                            const rec = byQid.get(x.qid);
                            if (!rec) return;
                            const qa = x.qa;
                            if (!qa || typeof qa !== 'object') return;
                            const ansNow = String(qa.official_answer || '').trim();
                            if (!ansNow && rec.answer) {
                                qa.official_answer = rec.answer;
                                qa.official_answer_source = 'llm';
                                qa.llm_answer_confidence = rec.confidence;
                                filledAnswers++;
                            }
                            const expNow = String(qa.official_explanation || '').trim();
                            if (!expNow && rec.explanation) {
                                qa.official_explanation = `${warningPrefix}${rec.explanation}`.trim();
                                qa.official_explanation_source = 'llm';
                                filledExplanations++;
                            }
                        });
                        return;
                    } catch (e) {
                        lastErr = e?.message || String(e || '');
                        logger.warn('AnswerFill', `${ctx}: try ${tryNo}/${MAX_TRIES} failed: ${lastErr}`);
                        if (tryNo >= MAX_TRIES) throw e;
                    }
                }
                throw new Error(lastErr || 'Answer fill failed.');
            }

            await runWithConcurrency(batches, processBatch, Math.max(1, Math.min(6, getWorkerConcurrency())));

            logger.success('AnswerFill', `LLM fill done. filledAnswers=${filledAnswers}, filledExplanations=${filledExplanations}`);
            try {
                activeProcess.phase0_answerFill = {
                    status: 'completed',
                    filledAnswers,
                    filledExplanations,
                    batches: batches.length,
                    maxTokens: maxT,
                    useDuckDuckGo: useDdg,
                    filledAt: new Date().toISOString(),
                };
            } catch { }
            renderActiveProcess();
            return { batches: batches.length, filledAnswers, filledExplanations };
        }

        // ----- PHASE 0: Extract Q&A from each paper -----
        async function generatePhase0Extraction() {
            const p0 = (() => { try { return getPipelineConfig()?.phase0 || {}; } catch { return {}; } })();
            const srOn = !!p0?.smartRouter?.enabled;
            const pdfMode = String(p0?.pdfInputMode || 'multimodal');
            const transport = String(p0?.multimodalTransport || 'images_raw_text');
            const subtext = srOn
                ? "Smart router: extracting by routed QID batches (PDF attached for routing)..."
                : (pdfMode === 'multimodal' && transport === 'pdf_raw_text'
                    ? "Extracting problems with PDF+rawText transport (no rendered images)..."
                    : "Extracting problems from OCR units...");
            updateStatus("Phase 0: Extract Q&A", subtext);
            activeProcess.activeTabId = 'phase0-extract';
            renderActiveProcess();

            const unitById = new Map((examPapers || []).map(p => [p.fileName, p]));

            const jobs = [];
            (activeProcess.phase0_extract || []).forEach(s => {
                const parts = Array.isArray(s?.parts) ? s.parts : null;
                if (parts && parts.length) {
                    parts.forEach(part => {
                        if ((part?.status || 'pending') === 'pending') {
                            jobs.push({ paperName: s.paperName, unitId: part.unitId });
                        }
                    });
                    return;
                }
                // Legacy: 1 state = 1 unit
                if (s.status === 'pending') {
                    jobs.push({ paperName: s.paperName, unitId: s.paperName });
                }
            });

            if (jobs.length === 0) {
                logger.info("Phase0", "No pending extraction jobs.");
                return;
            }

            async function processJob(job, workerId) {
                const state = activeProcess.phase0_extract.find(s => s.paperName === job.paperName);
                const hasParts = Array.isArray(state?.parts) && state.parts.length > 0;
                const partState = hasParts ? (state.parts.find(p => p.unitId === job.unitId) || null) : null;
                const paper = unitById.get(job.unitId) || unitById.get(job.paperName) || null;
                const unitLabel = partState?.unitLabel || job.unitId || job.paperName;
                const context = hasParts
                    ? `Extract-${state.paperName} (${unitLabel})-W${workerId}`
                    : `Extract-${paper?.fileName || job.paperName}-W${workerId}`;

                if (!state || !paper) {
                    logger.error("Phase0", `Extraction job skipped: missing state/paper. paperName=${job.paperName}, unitId=${job.unitId}`);
                    return { paperName: job.paperName, unitId: job.unitId };
                }

                try {
                    if (hasParts && partState) {
                        partState.status = 'processing';
                        partState.error = null;
                    }
                    state.status = 'processing';
                    state.error = null;
                    renderActiveProcess();

	                    const language = __getGuideLanguageFromUi();
	                    const pCfg = getPipelineConfig();
	                    const pdfInputMode = (pCfg?.phase0?.pdfInputMode || 'multimodal').toString();
	                    const multimodalTransport = String(pCfg?.phase0?.multimodalTransport || 'images_raw_text').trim() || 'images_raw_text';
	                    const wantsPdfTransport = (pdfInputMode === 'multimodal' && multimodalTransport === 'pdf_raw_text');
	                    const tessLang = (pCfg?.phase0?.tesseractLang || 'kor+eng').toString().trim() || 'kor+eng';
	                    const enableImageCrops = !!pCfg?.phase0?.experimentalImageCrops;
	
	                    let content;
	                    let unitImages = null;
	                    const targetLocalQids = Array.isArray(paper?.targetLocalQids)
	                        ? paper.targetLocalQids.map(x => String(x || '').trim()).filter(Boolean)
	                        : [];
	                    const targetBlock = targetLocalQids.length
	                        ? `\n\nTARGET_QIDS (extract ONLY these; copy EXACTLY into <qid>):\n${targetLocalQids.map(q => `- ${q}`).join('\n')}\n\nOUTPUT CONSTRAINT:\n- Output exactly one <item> per TARGET_QID.\n- Do NOT output any other QIDs.\n`
	                        : '';
	                    const focusPagesHint = (() => {
	                        const nums = Array.isArray(paper?.pageNums) ? paper.pageNums : null;
	                        if (nums && nums.length) return `FOCUS_PAGES: ${nums.join(', ')}`;
	                        const pStart = Number.isFinite(paper?.pageStart) ? paper.pageStart : null;
	                        const pEnd = Number.isFinite(paper?.pageEnd) ? paper.pageEnd : null;
	                        if (pStart && pEnd) return `FOCUS_PAGES: ${pStart}-${pEnd}`;
	                        return '';
	                    })();
	                    if (paper.type === 'txt') {
	                        const extractionInstruction = `Extract all problems from this exam paper text.
	- Extract all questions, sub-questions, answer choices, answers (if shown), and explanations (if provided)
	- LANGUAGE CONSTRAINT: Write ALL extracted fields in ${language}. In particular, the <question_text> must include a **fully detailed description** of any non-text visuals in ${language}.
	`;
                        content = [{
                            type: 'text',
                            text: `${extractionInstruction}\n\n---\n\nEXAM PAPER TEXT:\n\n${paper.content}`
                        }];
	                    } else {
	                        const images = Array.isArray(paper.images) ? paper.images : [];
	                        unitImages = images;
	                        const usePdfFile = wantsPdfTransport;
	                        const useImages = (pdfInputMode === 'multimodal') && !usePdfFile && images.length > 0;
	
	                        if (useImages) {
	                            const extractionInstruction = paper.rawText
	                                ? `You are extracting problems from a PDF. I'm providing both OCR images AND raw text extracted from the PDF.

	INSTRUCTIONS:
	- Use the OCR images to understand the layout and structure
	- Use the raw text below to correct any OCR typos or errors
	- Extract all questions, sub-questions, answer choices, answers (if shown), and explanations (if provided)
	- LANGUAGE CONSTRAINT: Write ALL extracted fields in ${language}. In particular, the <question_text> must include a **fully detailed description** of any non-text visuals in ${language}.
	${enableImageCrops ? `- Do NOT crop images yourself. (A later step may attach image crops.) Still describe visuals in text.\n` : ''}
	${focusPagesHint ? `\n${focusPagesHint}\n` : ''}
	${targetBlock}
	
	RAW TEXT (use this to correct OCR errors):
	${paper.rawText}
	
	Now examine the OCR images and extract all problems.`
	                                : `Extract all problems from this exam paper.
	- Extract all questions, sub-questions, answer choices, answers (if shown), and explanations (if provided)
	- LANGUAGE CONSTRAINT: Write ALL extracted fields in ${language}. In particular, the <question_text> must include a **fully detailed description** of any non-text visuals in ${language}.
	${enableImageCrops ? `- Do NOT crop images yourself. (A later step may attach image crops.) Still describe visuals in text.\n` : ''}
	${focusPagesHint ? `\n${focusPagesHint}\n` : ''}
	${targetBlock}
	`;

                            logger.info(context, `PDF input mode: multimodal (images=${images.length})`);
                            content = [{ type: 'text', text: extractionInstruction }];
                            images.forEach(img => {
                                content.push({
                                    type: 'image_url',
                                    image_url: { url: img }
                                });
                            });
                        } else if (usePdfFile) {
                            const basePaperName = hasParts ? state.paperName : (paper.sourceFileName || paper.fileName);
                            const pdfEntry = await __getPdfEntryBySourceFileName(basePaperName);
                            const pdfDataUrl = pdfEntry ? __makeDataUrlFromBase64(pdfEntry) : '';
                            const pdfPart = pdfDataUrl ? { type: 'image_url', image_url: { url: pdfDataUrl } } : null;

                            if (!pdfPart) {
                                logger.warn(context, `PDF transport requested but PDF bytes are unavailable (sourceFileName=${basePaperName}). Falling back to text-only extraction.`);
                            } else {
                                const rawText = String(paper.rawText || '').trim();
                                const extractionInstruction = `You are extracting problems from a PDF. I'm providing the PDF file AND raw text extracted from the PDF.

INSTRUCTIONS:
- Use the attached PDF as the primary source for layout and visuals.
- Use the raw text below for search/navigation; it may be empty for scanned PDFs.
- Extract all questions, sub-questions, answer choices, answers (if shown), and explanations (if provided)
- LANGUAGE CONSTRAINT: Write ALL extracted fields in ${language}. In particular, the <question_text> must include a **fully detailed description** of any non-text visuals in ${language}.
${enableImageCrops ? `- Do NOT crop images yourself. (A later step may attach image crops.) Still describe visuals in text.\n` : ''}
${focusPagesHint ? `\n${focusPagesHint}\n` : ''}
${targetBlock}

RAW TEXT (use this to correct OCR errors):
${rawText || '(empty)'}

Now examine the attached PDF and extract the requested problems.`;

                                logger.info(context, `PDF input mode: multimodal (PDF transport, rawText=${rawText ? 'yes' : 'no'})`);
                                content = [{ type: 'text', text: extractionInstruction }, pdfPart];
                            }
                            if (!content) {
                                // fall through to text-only
                            }
                        }
                        if (!content) {
                            let ocrText = String(paper.ocrText || '').trim();
                            if (pdfInputMode === 'tesseract_text' && !ocrText && images.length > 0) {
                                logger.warn(context, `PDF input mode: tesseract_text (no cached OCR text). Running Tesseract locally...`);
                                const parts = [];
                                for (let i = 0; i < images.length; i++) {
                                    if (processController.stop) throw new Error("Operation cancelled.");
                                    const txt = await __tesseractOcr(images[i], tessLang, `${context}-Tess${i + 1}/${images.length}`);
                                    parts.push(`[Image ${i + 1}/${images.length}]\n${txt}`);
                                }
                                ocrText = parts.join('\n\n').trim();
                                try { paper.ocrText = ocrText; } catch { }
                            }

                            const rawText = String(paper.rawText || '').trim();
                            const textOnlyInstruction =
                                `You are extracting problems from a PDF as TEXT-ONLY input (no images).

INSTRUCTIONS:
- Extract all questions, sub-questions, answer choices, answers (if shown), and explanations (if provided)
- Reconstruct missing layout as best as possible from the text sources below
- LANGUAGE CONSTRAINT: Write ALL extracted fields in ${language}.
${focusPagesHint ? `\n${focusPagesHint}\n` : ''}${targetBlock}

${ocrText ? `TESSERACT OCR TEXT:\n${ocrText}\n\n` : ''}${rawText ? `RAW PDF TEXT:\n${rawText}\n\n` : ''}
Now extract all problems.`;

                            logger.info(context, `PDF input mode: ${pdfInputMode} (images sent=no, ocrText=${ocrText ? 'yes' : 'no'}, rawText=${rawText ? 'yes' : 'no'})`);
                            content = [{ type: 'text', text: textOnlyInstruction }];
                        }
                    }


	                    const payload = {
	                        model: getApiConfig().model,
	                        messages: [
	                            { role: 'system', content: __renderPromptTemplateText(currentPrompts.extractor.system, { language }) },
	                            { role: 'user', content }
	                        ]
	                    };

                    const items = await requestAndParseDataEnvelope(payload, context, { phase: 'phase0' });

	                    const extractedQasByQid = {};
	                    const targetSet = targetLocalQids.length ? new Set(targetLocalQids) : null;
	                    const seenTargetLocal = new Set();
	                    let ignoredNonTargetN = 0;
	                    let dedupedChoicesN = 0;
	                    items.forEach(it => {
                        const qa = parseQAItem(it.value);
                        const localQid = String(qa.qid || '').trim();
                        if (!localQid) return;
                        if (targetSet && !targetSet.has(localQid)) { ignoredNonTargetN++; return; }
                        if (targetSet) seenTargetLocal.add(localQid);
                        if (qa.qid) {
                            const basePaperName = hasParts ? state.paperName : paper.fileName;
                            const hint = (() => {
                                if (!hasParts || !partState) return '';
                                if (Number.isFinite(partState?.pageStart) && Number.isFinite(partState?.pageEnd)) return `p${partState.pageStart}-${partState.pageEnd}`;
                                if (Number.isFinite(partState?.partIndex)) return `part${partState.partIndex}`;
                                return String(partState?.unitLabel || partState?.unitId || '').slice(0, 30);
                            })();
                            const safeHint = String(hint || '').replace(/[^0-9A-Za-zê°€-í£]+/g, '').slice(0, 30) || 'dup';

                            let globalQid = makeGlobalQid(basePaperName, localQid);
                            if (extractedQasByQid[globalQid] || (hasParts && state.qasByQid && state.qasByQid[globalQid])) {
                                let local2 = `${localQid}@${safeHint}`;
                                globalQid = makeGlobalQid(basePaperName, local2);
                                let n = 2;
                                while (extractedQasByQid[globalQid] || (hasParts && state.qasByQid && state.qasByQid[globalQid])) {
                                    local2 = `${localQid}@${safeHint}${n}`;
                                    globalQid = makeGlobalQid(basePaperName, local2);
                                    n++;
                                }
                            }

                            let question_text = qa.question_text;
                            let answer_choices = qa.answer_choices;
                            try {
                                const api = (typeof globalThis !== 'undefined' && globalThis.FMMHygiene) ? globalThis.FMMHygiene : null;
                                if (api && typeof api.dedupeChoices === 'function') {
                                    const cleaned = api.dedupeChoices(question_text, answer_choices);
                                    if (cleaned && typeof cleaned.question_text === 'string') question_text = cleaned.question_text;
                                    if (cleaned && typeof cleaned.answer_choices === 'string') answer_choices = cleaned.answer_choices;
                                    if (cleaned && cleaned.changed) dedupedChoicesN++;
                                }
                            } catch { }

	                            extractedQasByQid[globalQid] = {
	                                local_qid: localQid,
	                                paperName: basePaperName,
	                                question_text,
	                                answer_choices,
	                                official_answer: qa.official_answer,
	                                official_explanation: qa.official_explanation
	                            };
	                        }
	                    });
	                    if (targetSet) {
	                        const missing = targetLocalQids.filter(q => !seenTargetLocal.has(q));
	                        if (ignoredNonTargetN > 0) {
	                            logger.warn(context, `Smart router: ignored ${ignoredNonTargetN} non-target item(s).`);
	                        }
	                        if (missing.length) {
	                            logger.warn(context, `Smart router: missing TARGET_QIDS (${missing.length}): ${missing.slice(0, 12).join(', ')}${missing.length > 12 ? 'â€¦' : ''}`);
	                        }
	                    }
	                    if (dedupedChoicesN > 0) {
	                        logger.info(context, `Extraction hygiene: removed duplicate choice blocks in ${dedupedChoicesN} item(s).`);
	                    }
	
	                    if (enableImageCrops && Array.isArray(unitImages) && unitImages.length > 0) {
	                        try {
	                            const list = Object.entries(extractedQasByQid).map(([qid, qa]) => {
	                                try { qa.qid = qid; } catch { }
	                                try { qa.__unitImages = unitImages; } catch { }
	                                return qa;
	                            });
	                            if (list.length) {
	                                logger.info(context, `ì´ë¯¸ì§€ í¬ë¡­(ì „ì—­ ì˜µì…˜) ì‹œë„: ë¬¸ì œ ${list.length}ê°œ Â· í˜ì´ì§€ ${unitImages.length}ê°œ`);
	                                await incrementalLocateAndAttachImageCrops(list, `${context}-Crop`);
	                            }
	                        } catch (e) {
	                            logger.warn(context, `ì´ë¯¸ì§€ í¬ë¡­ ì‹¤íŒ¨(ê³„ì† ì§„í–‰): ${e?.message || e}`);
	                        } finally {
	                            try { Object.values(extractedQasByQid).forEach(qa => { delete qa.__unitImages; }); } catch { }
	                        }
	                    }
	
	                    if (hasParts && partState) {
	                        partState.qasByQid = extractedQasByQid;
	                        partState.status = 'completed';
                        if (!state.qasByQid) state.qasByQid = {};
                        Object.entries(extractedQasByQid).forEach(([qid, qa]) => {
                            state.qasByQid[qid] = qa;
                        });

                        const pending = state.parts.some(p => p.status === 'pending');
                        const processing = state.parts.some(p => p.status === 'processing');
                        const error = state.parts.some(p => p.status === 'error');
                        if (processing) state.status = 'processing';
                        else if (pending) state.status = 'pending';
                        else state.status = error ? 'error' : 'completed';

                        logger.success("Phase0", `Extracted ${Object.keys(extractedQasByQid).length} problems from ${state.paperName} (${unitLabel})`);
                    } else {
                        state.qasByQid = extractedQasByQid;
                        state.status = 'completed';
                        logger.success("Phase0", `Extracted ${Object.keys(extractedQasByQid).length} problems from ${paper.fileName}`);
                    }
                } catch (e) {
                    if (hasParts && partState) {
                        partState.status = 'error';
                        partState.error = e.message;
                        const pending = state.parts.some(p => p.status === 'pending');
                        const processing = state.parts.some(p => p.status === 'processing');
                        const error = state.parts.some(p => p.status === 'error');
                        if (processing) state.status = 'processing';
                        else if (pending) state.status = 'pending';
                        else state.status = error ? 'error' : 'completed';
                        logger.error("Phase0", `Extraction failed for ${state.paperName} (${unitLabel}): ${e.message}`);
                    } else {
                        state.status = 'error';
                        state.error = e.message;
                        logger.error("Phase0", `Extraction failed for ${paper?.fileName || state.paperName}: ${e.message}`);
                    }
                } finally {
                    renderActiveProcess();
                }
                return { paperName: job.paperName, unitId: job.unitId };
            }

            await runWithConcurrency(jobs, processJob, getPhase0Concurrency());
        }


        // ----- PHASE 1: Pattern discovery / clustering (reworked: per-chunk verify -> one-shot merge) -----
        async function generatePhase1Patterns() {
            updateStatus("Phase 1: Global Pattern Classification", "Per-chunk type lists â†’ verify â†’ one-shot merge...");
            activeProcess.activeTabId = 'phase0-extract';
            renderActiveProcess();

            const CONCURRENCY_P1A = getWorkerConcurrency();

            if (!activeProcess.phase1_patterns) {
                activeProcess.phase1_patterns = {
                    status: 'pending',
                    standardCreation: {
                        status: 'pending',
                        perChunk: [],
                        finalStandard: null
                    },
                    perQuestion: [],
                    clusters: [],
                    error: null
                };
            }

            const p1 = activeProcess.phase1_patterns;

            // =========================
            // PHASE 1A: Per-chunk standard creation & single-pass + 1 revision
            // =========================
            if (p1.standardCreation.status === 'pending' || p1.standardCreation.status === 'processing') {
                const isResuming = p1.standardCreation.status === 'processing';
                if (!isResuming) p1.standardCreation.status = 'processing';
                renderActiveProcess();

                const allQuestions = collectAllQuestions();
                const pCfgForChunk = getPipelineConfig();
                const chunkMode = pCfgForChunk?.phase1?.chunkMode || 'file_first';
                const maxTypes = pCfgForChunk?.phase1?.maxTypes || 30;
                const problemChunks = chunkProblemsRespectingBoundaries(allQuestions, activeProcess.chunkTokens || DEFAULT_CHUNK_TOKENS, chunkMode);
                const objectives = `
      MAX_TYPES: ${maxTypes}

      OBJECTIVES:
      - Create a TYPE STANDARD for THIS CHUNK ONLY.
      - You MUST output ${maxTypes} types or fewer.
      - Each type is defined by core concepts and solution approach (not surface detail).
      - The "one standard problem + explanation" should be able to teach ALL problems in the type.
      - If you would exceed ${maxTypes}, merge the most similar types while preserving teachability by writing composite descriptions/criteria.`;

                {
                    const pCfg = getPipelineConfig();
                    const enableEval = pCfg?.phase1?.enableEvaluator !== false;
                    const rawAttempts = __clampInt(pCfg?.phase1?.maxAttempts ?? 2, { min: 0, max: 99, fallback: 2 });
                    const attemptsLabel = (rawAttempts === 0) ? 'ë¬´ì œí•œ' : String(rawAttempts);
                    const modeLabel =
                        (!enableEval ? 'pass@1 ì›ìƒ·(ê²€ì¦ ìƒëµ)' :
                            (rawAttempts === 0 ? 'passê¹Œì§€ ë°˜ë³µ(ë¬´ì œí•œ)' :
                                (rawAttempts === 1 ? 'ì›ìƒ·(1íšŒ)' : `ìµœëŒ€ ${rawAttempts}íšŒ`)));
                    logger.info(
                        "Phase1A",
                        `Total problems: ${allQuestions.length}. Chunk size = ${(activeProcess.chunkTokens || DEFAULT_CHUNK_TOKENS)} tokens. ` +
                        `Chunks: ${problemChunks.length}. Mode: ${modeLabel} (maxTypes=${maxTypes}, evaluator=${enableEval ? 'on' : 'off'}, maxAttempts=${attemptsLabel})`
                    );
                    logger.info(
                        "1ë‹¨ê³„",
                        `ìœ í˜•í‘œì¤€ ìƒì„± ì‹œì‘: ì „ì²´ ${allQuestions.length}ê°œ ë¬¸ì œ â†’ ${problemChunks.length}ê°œ ì²­í¬ (maxTypes=${maxTypes}, ${modeLabel})`
                    );
                }

                // Prepare perChunk slots, preserving history on resume
                {
                    const need = problemChunks.length;
                    const prev = Array.isArray(p1.standardCreation.perChunk) ? p1.standardCreation.perChunk : [];
                    const prevCount = prev.length;

                    if (isResuming && prevCount !== need && prevCount > 0) {
                        logger.warn("Phase1A", `ì²­í¬ êµ¬ì„± ë³€ê²½ ê°ì§€ (í† í° ê³„ì‚° ìˆ˜ì • ë“±): ${prevCount}ê°œ ì²­í¬ â†’ ${need}ê°œ ì²­í¬. ë¯¸ì™„ë£Œ ìŠ¬ë¡¯ì„ ì¬ì¡°ì •í•©ë‹ˆë‹¤.`);
                    }

                    p1.standardCreation.perChunk = Array.from({ length: need }, (_, i) => {
                        // Try to preserve existing slot if it was valid and finalized
                        const existing = prev[i];
                        if (existing && existing.finalStandardChunk) {
                            return existing;
                        }
                        // Otherwise (or if index is new), create empty slot
                        return { chunkIndex: i, typeCount: 0, attempts: [], finalStandardChunk: null };
                    });
                    logger.info("Phase1A_Debug", `Initialized/loaded ${p1.standardCreation.perChunk.length} perChunk state slots.`);
                    renderActiveProcess();
                }

                const chunkJobs = p1.standardCreation.perChunk
                    .filter(slot => !slot.finalStandardChunk)
                    .map(slot => ({ chunkIndex: slot.chunkIndex })); // Pass object for better logging

                logger.info("Phase1A_Debug", `Created ${chunkJobs.length} chunk jobs to process.`);

                async function processChunk(job, workerId) {
                    const idx = job.chunkIndex;
                    if (processController.stop) return;
                    const chunk = problemChunks[idx];
                    const chunkText = problemsToText(chunk);
                    const slot = p1.standardCreation.perChunk[idx];
                    let round = slot.attempts.length; // Resume from last attempt
	                    const pCfg = getPipelineConfig();
	                    const language = __getGuideLanguageFromUi();
	                    const rawAttempts = __clampInt(pCfg?.phase1?.maxAttempts ?? 2, { min: 0, max: 99, fallback: 2 });
                    const MAX_ATTEMPTS = (rawAttempts === 0) ? Infinity : rawAttempts;
                    const maxAttemptsLabel = Number.isFinite(MAX_ATTEMPTS) ? String(MAX_ATTEMPTS) : 'ë¬´ì œí•œ';
                    const ENABLE_EVAL = pCfg?.phase1?.enableEvaluator !== false;
                    let currentStandardForChunk = null;
                    let checkpointStandard = null;

                    logger.info(
                        `Phase1A-Chunk${idx + 1}-W${workerId}`,
                        `Worker started processing chunk. Current attempts: ${round}.`
                    );


                    while (!processController.stop && round < MAX_ATTEMPTS) {
                        round++;

                        // --- NEW (no long history; only last attempt + last evaluator feedback) ---
                        // Ideological reason: Avoid exponential context growth and prompt drift; use only immediate prior signal.
                        const prev = slot.attempts[slot.attempts.length - 1];
                        const prevStandard = prev?.standard ? formatStandardForLLM(prev.standard) : '';
                        const prevFeedback = prev?.evaluation?.fullText || '';

	                        const createPayload_inner = {
	                            model: getApiConfig().model,
	                            messages: [
	                                { role: 'system', content: __renderPromptTemplateText(currentPrompts.classifier_standard.system, { language }) },
	                                {
	                                    role: 'user',
	                                    content:
                                        `${objectives}

If revising, use ONLY the immediately previous attempt and the evaluator's LAST feedback below:
${prevStandard ? `\n{Your previous response:\n${prevStandard}\n}\n` : ''}
${prevFeedback ? `\n{Previous feedback:\n${prevFeedback}\n}\n` : ''}

	Analyze ONLY the following problems and propose types for THIS CHUNK.
	Output only the required <data>...</data> format:

{Problems (Chunk ${idx + 1}/${problemChunks.length}): 
${chunkText}
}`
                                }
                            ]
                        };

                        const createItems = await requestAndParseDataEnvelope(createPayload_inner, `CreateTypes-Chunk${idx + 1}-Round${round}-W${workerId}`, { phase: 'phase1a' });
                        currentStandardForChunk = createItems.map(it => ({
                            type_name: parseTag(it.value, 'type_name'),
                            type_description: parseTag(it.value, 'type_description'),
                            recognition_criteria: parseTag(it.value, 'recognition_criteria'),
                            core_concepts: parseTag(it.value, 'core_concepts')
                        }));
                        const typeCount = currentStandardForChunk.length;

                        let decision = 'fail';
                        let evalRaw = '';
                        if (ENABLE_EVAL) {
	                            const evalPayload_inner = {
	                                model: getApiConfig().model,
	                                messages: [
	                                    { role: 'system', content: __renderPromptTemplateText(currentPrompts.classifier_standard_verifier.system, { language }) },
	                                    {
	                                        role: 'user',
	                                        content:
                                            `${objectives}

        Evaluate the following CHUNK-LEVEL classification standard.

        TOTAL TYPES (chunk): ${typeCount}

        CURRENT STANDARD (chunk):
        ${formatStandardForLLM(currentStandardForChunk)}

        PROBLEMS IN THIS CHUNK (reference only):
        ${chunkText}

        Provide summary + detailed critique if needed, then end with exactly one decision tag: <pass> or <fail>.`
                                    }
                                ]
                            };
                            evalRaw = await resilientLlmRequest(evalPayload_inner, `EvalTypes-Chunk${idx + 1}-Round${round}-W${workerId}`);
                            try {
                                decision = parseDecisionTag(evalRaw);
                            } catch (e) {
                                logger.warn("Phase1A", `Chunk ${idx + 1} round ${round}: missing decision tag. Treat as <fail>. ${e.message}`);
                            }
                        } else {
                            decision = 'pass';
                            evalRaw = '<pass>\n(Skipped evaluator by config)';
                            logger.info("Phase1A", `Chunk ${idx + 1} (W${workerId}): evaluator disabled â†’ auto <pass>.`);
                        }

                        slot.attempts.push({
                            round,
                            typeCount,
                            standard: currentStandardForChunk,
                            evaluation: { decision, fullText: evalRaw }
                        });
                        slot.typeCount = typeCount;
                        renderActiveProcess();

                        if (decision === 'pass') {
                            checkpointStandard = currentStandardForChunk;
                            logger.success("Phase1A", `Chunk ${idx + 1} (W${workerId}): Round ${round} <pass> (accepted)`);
                            break;
                        } else {
                            logger.warn("Phase1A", `Chunk ${idx + 1} (W${workerId}): Round ${round} <fail>.`);
                        }

                        if (Number.isFinite(MAX_ATTEMPTS) && round >= MAX_ATTEMPTS) {
                            logger.warn("Phase1A", `Chunk ${idx + 1}: max attempts reached. Finalizing with best-known standard.`);
                            if (checkpointStandard && checkpointStandard.length) {
                                currentStandardForChunk = checkpointStandard;
                                slot.typeCount = checkpointStandard.length;
                            }
                            break;
                        }
                    }

                    slot.finalStandardChunk = currentStandardForChunk;
                    logger.success("Phase1A", `Chunk ${idx + 1} finalized. Types: ${slot.typeCount} (maxAttempts=${maxAttemptsLabel}, evaluator=${ENABLE_EVAL ? 'on' : 'off'})`);
                    renderActiveProcess();
                }

                if (chunkJobs.length > 0) {
                    await runWithConcurrency(chunkJobs, processChunk, CONCURRENCY_P1A);
                } else {
                    logger.warn("Phase1A", "No pending chunks needed processing. Skipping verification step.");
                }


                if (processController.stop) {
                    logger.warn("Phase1A", "Operation cancelled before merge.");
                    p1.standardCreation.status = 'pending';
                    renderActiveProcess();
                    return;
                }

                // =========================
                // PHASE 1A-merge: One-shot merge of all 'finalized' chunk standards
                // =========================
                logger.info("Phase1A_Merge", "Entering merge phase.");
                const verifiedLists = p1.standardCreation.perChunk
                    .map(c => c.finalStandardChunk || [])
                    .flat();

                logger.info("Phase1A_Merge_Debug", `Gathered ${verifiedLists.length} total types from ${p1.standardCreation.perChunk.length} chunks for merging.`);

                // !!! CRITICAL FIX: Add a guard clause here !!!
                if (verifiedLists.length === 0) {
                    logger.warn("Phase1A_Merge", "No verified chunk standards available to merge. Setting global standard to empty and completing Phase 1.");
                    p1.standardCreation.finalStandard = [];
                    p1.standardCreation.status = 'completed';
                    p1.status = 'completed'; // Mark the whole phase as done.

                    // Also initialize phase 2 to avoid errors.
                    if (!activeProcess.phase2_modules || activeProcess.phase2_modules.length === 0) {
                        activeProcess.phase2_modules = [];
                    }

                    renderActiveProcess();
                } else {
                    const MERGER_SYS_PROMPT = `
      You are the Global Standard Merger.

      Task:
      - You will receive multiple CHUNK-LEVEL classification standards (already verified for their own chunks).
      - MERGE **academically equivalent** types into unified global types.
      - Names matching is **strong evidence** for equivalence; merge unless content genuinely differs.
      - Names differing does **not** preclude merging if core approach is identical.
      - If two types are near-duplicates, merge them and adjust the description/recognition so one global type remains teachable.
      - **You MUST output â‰¤ ${maxTypes} global types.** If >${maxTypes} remain, keep merging the most similar types while **preserving teachability** by writing composite descriptions/criteria.
	      - Do NOT re-scan problem statements; base decisions on provided type fields.
	      Output the unified global standard in:
	      <data>
	        <item>
	          <id>1</id>
	          <type_name>...</type_name>
	          <type_description>...</type_description>
	          <recognition_criteria>...</recognition_criteria>
	          <core_concepts>...</core_concepts>
	        </item>
	        ...
	      </data>`;

                    const mergePayload = {
                        model: getApiConfig().model,
                        messages: [
                            { role: 'system', content: MERGER_SYS_PROMPT },
                            { role: 'user', content: `Here are the VERIFIED CHUNK STANDARDS to merge (array of objects):\n${JSON.stringify(verifiedLists, null, 2)}\n\nUnify equivalent types; preserve distinct ones. Output in the required <data>...</data> format.` }
                        ]
                    };

                    const mergedItems = await requestAndParseDataEnvelope(mergePayload, `Merge-Verified-Chunk-Standards`, { phase: 'phase1a' });
                    const rawStandard = mergedItems.map(it => ({
                        type_name: parseTag(it.value, 'type_name'),
                        type_description: parseTag(it.value, 'type_description'),
                        recognition_criteria: parseTag(it.value, 'recognition_criteria'),
                        core_concepts: parseTag(it.value, 'core_concepts')
                    }));

                    // Deduplicate by type_name - LLM may return duplicate names despite instructions
                    const typeMap = new Map();
                    rawStandard.forEach(t => {
                        const name = (t.type_name || '').trim();
                        if (!name) return;
                        if (typeMap.has(name)) {
                            // Merge descriptions for duplicate names
                            const existing = typeMap.get(name);
                            const mergeField = (a, b) => {
                                const sa = (a || '').trim();
                                const sb = (b || '').trim();
                                if (!sb || sa === sb || sa.includes(sb)) return sa;
                                if (!sa) return sb;
                                return `${sa}\n${sb}`;
                            };
                            existing.type_description = mergeField(existing.type_description, t.type_description);
                            existing.recognition_criteria = mergeField(existing.recognition_criteria, t.recognition_criteria);
                            existing.core_concepts = mergeField(existing.core_concepts, t.core_concepts);
                            logger.warn("Phase1A_Merge", `Merged duplicate type name: "${name}"`);
                        } else {
                            typeMap.set(name, { ...t });
                        }
                    });
                    const unifiedStandard = Array.from(typeMap.values());

                    if (unifiedStandard.length < rawStandard.length) {
                        logger.warn("Phase1A_Merge", `Deduplicated types: ${rawStandard.length} â†’ ${unifiedStandard.length}`);
                    }

                    p1.standardCreation.finalStandard = unifiedStandard;
                    p1.standardCreation.status = 'completed';
                    logger.success("Phase1A", `Unified global standard created. Types: ${unifiedStandard.length}`);
                    renderActiveProcess();

                    // Phase 1B (classification) must run after a successful merge
                    await applyGlobalClassification(p1, unifiedStandard);
                }
            } else {
                logger.info("Phase1", "Phase 1A already completed. Checking if classification needs to be run.");
                // If resuming and standard is ready but classification is not, run classification.
                if (p1.standardCreation.status === 'completed' && p1.perQuestion.length === 0) {
                    await applyGlobalClassification(p1, p1.standardCreation.finalStandard);
                }
            }
        }

        // Helper function to de-duplicate the classification logic
        async function applyGlobalClassification(p1_state, standard) {
            logger.info("Phase1B", "Applying global classification to all problems...");

            const allQuestions = collectAllQuestions();
            if (allQuestions.length === 0) {
                logger.warn("Phase1B", "No questions extracted, cannot apply classification.");
                p1_state.status = 'completed';
                return;
            }
            if (!standard || standard.length === 0) {
                logger.warn("Phase1B", "Global standard is empty, cannot apply classification.");
                p1_state.status = 'completed';
                return;
            }

            const standardText = standard.map(t =>
                `TYPE: ${t.type_name}\nDESCRIPTION: ${t.type_description}\nRECOGNITION: ${t.recognition_criteria}\nCONCEPTS: ${t.core_concepts}`
            ).join('\n\n---\n\n');

            const pCfgForBatch = getPipelineConfig();
            const batchChunkMode = pCfgForBatch?.phase1?.chunkMode || 'file_first';
            const batchTokens = Number.isFinite(activeProcess?.chunkTokensPhase1b)
                ? activeProcess.chunkTokensPhase1b
                : (activeProcess.chunkTokens || DEFAULT_CHUNK_TOKENS);
            let batches = chunkProblemsRespectingBoundaries(allQuestions, batchTokens, batchChunkMode);
            logger.info(
                "Phase1B",
                `Classifying ${allQuestions.length} problems in ${batches.length} batch(es)...`
            );
            logger.info(
                "1ë‹¨ê³„B",
                `ìœ í˜•ë¶„ë¥˜ ì‹œì‘: ${allQuestions.length}ê°œ ë¬¸ì œ â†’ ${batches.length}ê°œ ë°°ì¹˜, ${standard.length}ê°œ ìœ í˜• ê¸°ì¤€`
            );

            async function processBatch(batch, workerId) {
                const context = `ClassifyBatch-W${workerId}`;
                const batchText = problemsToText(batch);
                try {
	                    const payload = {
	                        model: getApiConfig().model,
	                        messages: [
	                            { role: 'system', content: __renderPromptTemplateText(currentPrompts.classifier_apply.system, { language: __getGuideLanguageFromUi() }) },
	                            { role: 'user', content: `CLASSIFICATION STANDARD:\n\n${standardText}\n\n---\n\nPROBLEMS TO CLASSIFY:\n\n${batchText}` }
	                        ]
	                    };
	                    const items = await requestAndParseDataEnvelope(payload, context, { phase: 'phase1b' });
	                    items.forEach(it => {
	                        const qid = parseTag(it.value, 'qid');
	                        const type_name = parseTag(it.value, 'type_name');
	                        const question = batch.find(q => q.qid === qid);
	                        if (question) {
	                            p1_state.perQuestion.push({
	                                qid: question.qid,
	                                pattern_name: type_name,
	                                paperName: question.paperName
	                            });
	                        }
	                    });
	                    logger.success("Phase1B", `Classified batch of ${batch.length} problems.`);
                } catch (e) {
                    logger.error("Phase1B", `Batch classification failed: ${e.message}`);
                    throw e;
                }
            }

            await runWithConcurrency(batches, processBatch, getWorkerConcurrency());
            batches = null; // free memory

            // --- p1_coverage_style: Retry Unclassified ---
            const pCfg = getPipelineConfig();
            if (pCfg?.phase1?.classificationMode === 'coverage') {
                const maxRetries = __clampInt(pCfg?.phase1?.maxUnclassifiedRetries, { min: 0, max: 5, fallback: 2 });
                logger.info("Phase1B-Coverage", `Coverage mode active. Checking for unclassified problems (Max retries: ${maxRetries})...`);

                for (let retry = 1; retry <= maxRetries; retry++) {
                    if (processController.stop) break;

                    // Identify unclassified QIDs
                    const classifiedQids = new Set(p1_state.perQuestion.map(p => p.qid));
                    const unclassifiedQs = allQuestions.filter(q => !classifiedQids.has(q.qid));

                    if (unclassifiedQs.length === 0) {
                        logger.success("Phase1B-Coverage", "All problems classified. No retries needed.");
                        break;
                    }

                    logger.info("Phase1B-Coverage", `Retry ${retry}/${maxRetries}: Found ${unclassifiedQs.length} unclassified problems.`);

                    const retryBatches = chunkProblemsRespectingBoundaries(unclassifiedQs, batchTokens, batchChunkMode);

                    // Re-use processBatch but with a suffix in context to distinguish logging/stats?
                    // processBatch uses `ClassifyBatch-W...`. It's fine.
                    // But to avoid "Other" in api stats if user checks context specifically, 
                    // processBatch sets context inside. We can't easily change it without refactoring processBatch.
                    // Actually, processBatch hardcodes `ClassifyBatch-W...`. 
                    // This is fine, it will just log as ClassifyBatch.

                    await runWithConcurrency(retryBatches, processBatch, getWorkerConcurrency());
                }
            }

            const rebuilt = buildPatternClusters(p1_state.perQuestion);
            p1_state.perQuestion = rebuilt.perQuestion;
            p1_state.clusters = rebuilt.clusters;

	            p1_state.status = 'completed';

            if (!activeProcess.phase2_modules || activeProcess.phase2_modules.length === 0) {
                // Deduplicate clusters by pattern_name in case LLM returned duplicates
                const moduleMap = new Map();
                p1_state.clusters.forEach(cl => {
                    const name = (cl.pattern_name || '').trim();
                    if (!name) return;
                    if (moduleMap.has(name)) {
                        // Merge qids for duplicate names
                        const existing = moduleMap.get(name);
                        const qidSet = new Set(existing.qidsCovered);
                        (cl.qids || []).forEach(q => qidSet.add(q));
                        existing.qidsCovered = Array.from(qidSet);
                        logger.warn("Phase1B", `Merged duplicate cluster name into phase2_modules: "${name}"`);
                    } else {
                        moduleMap.set(name, {
                            pattern_name: name,
                            parent_pattern_name: cl.parent_pattern_name || null,
                            status: 'pending',
                            qidsCovered: (cl.qids || []).slice(),
                        });
                    }
                });
                activeProcess.phase2_modules = Array.from(moduleMap.values());
            }
            logger.success("Phase1B", `All problems classified into ${p1_state.clusters.length} types.`);
            const unclassifiedCount = p1_state.perQuestion.filter(pq => !pq.pattern_name || pq.pattern_name === 'ë¯¸ë¶„ë¥˜').length;
            logger.success(
                "1ë‹¨ê³„",
                `ìœ í˜•ë¶„ë¥˜ ì™„ë£Œ: ${p1_state.perQuestion.length}ê°œ ë¬¸ì œ â†’ ${p1_state.clusters.length}ê°œ ìœ í˜•` +
                (unclassifiedCount > 0 ? ` (ë¯¸ë¶„ë¥˜: ${unclassifiedCount}ê°œ)` : '')
            );
            renderActiveProcess();
        }

        // ----- PHASE 1 (experimental): Subgrouping within types -----
        function __subgroupingStripDataUris(text) {
            let s = String(text ?? '');
            // Remove markdown images with data URIs (can be huge)
            s = s.replace(/!\[[^\]]*]\(data:[^)]+\)/gi, '[image]');
            // Remove HTML data-uri images
            s = s.replace(/<\s*img\b[^>]*\bsrc\s*=\s*["']data:[^"']+["'][^>]*>/gi, '[image]');
            // Remove raw data:image base64 blobs that may appear inline
            s = s.replace(/data:image\/[^;\s]+;base64,[a-z0-9+/=]+/gi, '[image]');
            return s;
        }

        function __subgroupingClipText(text, maxChars) {
            const s = String(text ?? '').trim();
            const lim = Math.max(0, Number(maxChars || 0) || 0);
            if (!lim || s.length <= lim) return s;
            return s.slice(0, lim).trim() + 'â€¦';
        }

        function __subgroupingNormalizeSignatureText(text) {
            let s = __subgroupingStripDataUris(text);
            s = String(s ?? '').toLowerCase();
            s = s.replace(/\d+/g, '#');
            s = s.replace(/[^a-z0-9ê°€-í£#]+/gi, ' ');
            s = s.replace(/\s+/g, ' ').trim();
            return s;
        }

        function __subgroupingSignatureForProblem(p) {
            const q = String(p?.question_text || '');
            const c = String(p?.answer_choices || '');
            const s = __subgroupingNormalizeSignatureText(`${q}\n${c}`);
            const parts = s.split(/\s+/).filter(Boolean);
            const uniq = Array.from(new Set(parts.filter(x => String(x).length >= 2)));
            uniq.sort();
            return uniq.slice(0, 30).join('|');
        }

        function __buildSubgroupingProblemBlock(problem, limits) {
            const qid = String(problem?.qid || '').trim();
            const maxQ = Number.isFinite(limits?.maxQuestionChars) ? limits.maxQuestionChars : 900;
            const maxC = Number.isFinite(limits?.maxChoicesChars) ? limits.maxChoicesChars : 250;
            const qTextRaw = __subgroupingStripDataUris(problem?.question_text || '');
            const cTextRaw = __subgroupingStripDataUris(problem?.answer_choices || '');
            const qText = __subgroupingClipText(qTextRaw, maxQ);
            const cText = __subgroupingClipText(cTextRaw, maxC);
            const lines = [];
            lines.push(`QID: ${qid}`);
            if (qText) lines.push(`Q: ${qText}`);
            if (cText) lines.push(`Choices: ${cText}`);
            return lines.join('\n').trim();
        }

        function __buildSubgroupingTypeUnitText(typeName, problems, limits) {
            const name = String(typeName || '').trim();
            const items = (problems || []).map(p => __buildSubgroupingProblemBlock(p, limits)).filter(Boolean);
            return `TYPE: ${name}\n\n${items.join('\n\n---\n\n')}`.trim();
        }

	        function __parseQidsFromText(raw) {
	            const s = String(raw || '').trim();
	            if (!s) return [];
	            // IMPORTANT: QIDs may contain spaces (e.g., "2018 ì „ê¸°ì´ë¡ ...pdf::Q11").
	            // Never split on whitespace; prefer line-based parsing and keep internal spaces intact.
	            const lines = s.split(/\r?\n/).map(x => String(x || '').trim()).filter(Boolean);
	            const out = [];
	            for (const lineRaw of lines) {
	                let t = String(lineRaw || '').trim();
	                if (!t) continue;
	                // Common noisy prefixes from LLMs
	                t = t.replace(/^qids?\s*[:ï¼š]\s*/i, '').trim();
	                t = t.replace(/^qid\s*[:ï¼š]\s*/i, '').trim();
	                t = t.replace(/^[-*â€¢\u2022\s]+/, '').trim();
	                t = t.replace(/^\d+\s*[\).]\s*/, '').trim();
	                t = t.replace(/^[`"â€œâ€']+|[`"â€œâ€']+$/g, '').trim();
	                if (!t) continue;

	                // Sometimes multiple QIDs are put on one line separated by commas.
	                if (t.includes(',') && (t.match(/::\s*Q/gi) || []).length >= 2) {
	                    t.split(',').map(x => String(x || '').trim()).filter(Boolean).forEach(part => {
	                        let p = part.replace(/^[-*â€¢\u2022\s]+/, '').trim();
	                        p = p.replace(/^\d+\s*[\).]\s*/, '').trim();
	                        p = p.replace(/^[`"â€œâ€']+|[`"â€œâ€']+$/g, '').trim();
	                        if (p) out.push(p);
	                    });
	                    continue;
	                }

	                out.push(t);
	            }
	            return Array.from(new Set(out));
	        }

        function __buildSubgroupingUnitsForType(typeName, problems, { maxTokens } = {}) {
            const maxT = __clampInt(maxTokens ?? DEFAULT_CHUNK_TOKENS, { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS });
            const arr = Array.isArray(problems) ? problems.slice() : [];
            if (arr.length < 2) return [];

            // Start with moderately compact per-problem excerpts to avoid huge prompts (esp. data-URI crops).
            let limits = { maxQuestionChars: 900, maxChoicesChars: 250 };
            let fullText = __buildSubgroupingTypeUnitText(typeName, arr, limits);
            let fullTokens = __estimateTokens(fullText);

            // If too big, shrink excerpts before splitting.
            while (fullTokens > maxT && limits.maxQuestionChars > 240) {
                limits = {
                    maxQuestionChars: Math.max(240, Math.floor(limits.maxQuestionChars * 0.75)),
                    maxChoicesChars: Math.max(80, Math.floor(limits.maxChoicesChars * 0.75)),
                };
                fullText = __buildSubgroupingTypeUnitText(typeName, arr, limits);
                fullTokens = __estimateTokens(fullText);
            }

            if (fullTokens <= maxT) {
                return [{
                    typeName: String(typeName || '').trim(),
                    unitId: `${String(typeName || '').trim()}::1`,
                    qids: arr.map(p => String(p?.qid || '').trim()).filter(Boolean),
                    userText: fullText,
                    estTokens: fullTokens,
                }];
            }

            // Still too big: split within the type. Order by loose "code" similarity to avoid splitting near-identical families.
            const ordered = arr
                .map(p => ({ p, sig: __subgroupingSignatureForProblem(p) }))
                .sort((a, b) => String(a.sig).localeCompare(String(b.sig), 'en'))
                .map(x => x.p);

            // Estimate per-problem tokens using the current (shrunk) limits
            const headerTokens = __estimateTokens(`TYPE: ${String(typeName || '').trim()}\n\n`);
            const blocks = ordered.map(p => __buildSubgroupingProblemBlock(p, limits));
            const blockTokens = blocks.map(t => __estimateTokens(t) + 8); // include separators/overhead

            const chunks = [];
            let cur = [];
            let curTok = headerTokens;
            for (let i = 0; i < ordered.length; i++) {
                const p = ordered[i];
                const tok = blockTokens[i] || 0;
                if (cur.length > 0 && curTok + tok > maxT) {
                    chunks.push(cur);
                    cur = [];
                    curTok = headerTokens;
                }
                cur.push(p);
                curTok += tok;
            }
            if (cur.length) chunks.push(cur);

            const units = chunks
                .map((ps, idx) => {
                    if (!Array.isArray(ps) || ps.length < 2) return null; // cannot form a subgroup
                    const t = __buildSubgroupingTypeUnitText(typeName, ps, limits);
                    return {
                        typeName: String(typeName || '').trim(),
                        unitId: `${String(typeName || '').trim()}::${idx + 1}`,
                        qids: ps.map(p => String(p?.qid || '').trim()).filter(Boolean),
                        userText: t,
                        estTokens: __estimateTokens(t),
                    };
                })
                .filter(Boolean);
            return units;
        }

        function __packSubgroupingUnits(units, maxTokens) {
            const maxT = __clampInt(maxTokens ?? DEFAULT_CHUNK_TOKENS, { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS });
            const sep = '\n\n====================\n\n';
            const sepTok = __estimateTokens(sep);
            const sorted = (units || []).slice().sort((a, b) => (b.estTokens || 0) - (a.estTokens || 0));

            const batches = [];
            for (const u of sorted) {
                if (!u || !u.userText) continue;
                const ut = Math.max(0, Number(u.estTokens || 0) || 0);
                if (ut > maxT) {
                    // Shouldn't happen (we split earlier), but guard anyway.
                    batches.push({ units: [u] });
                    continue;
                }
                let placed = false;
                for (const b of batches) {
                    if (!b || !Array.isArray(b.units)) continue;
                    b.__typeNames ||= new Set();
                    b.__est ||= 0;
                    if (b.__typeNames.has(u.typeName)) continue; // avoid same type twice in one request
                    const nextN = b.units.length + 1;
                    const nextTok = b.__est + ut + (b.units.length ? sepTok : 0);
                    if (nextTok <= maxT) {
                        b.units.push(u);
                        b.__typeNames.add(u.typeName);
                        b.__est = nextTok;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    const b = { units: [u] };
                    b.__typeNames = new Set([u.typeName]);
                    b.__est = ut;
                    batches.push(b);
                }
            }
            // strip private fields
            return batches.map(b => ({ units: (b.units || []).slice() }));
        }

        async function subgroupifyTypeProblemMap(typeToProblems, { chunkTokens, language, contextPrefix = 'SubgroupBatch' } = {}) {
            const typesObj = (typeToProblems && typeof typeToProblems === 'object') ? typeToProblems : {};
            const typeNames = Object.keys(typesObj);
            const normalizedToType = new Map(typeNames.map(t => [__normalizeTitleForMatch(t), t]));
            const qidSetByType = new Map();
            typeNames.forEach(t => {
                const list = Array.isArray(typesObj[t]) ? typesObj[t] : [];
                const qids = list.map(p => String(p?.qid || '').trim()).filter(Boolean);
                qidSetByType.set(t, new Set(qids));
            });

            const maxT = __clampInt(chunkTokens ?? (getPipelineConfig()?.phase1?.subgrouping?.chunkTokens ?? DEFAULT_CHUNK_TOKENS), { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS });
            const lang = String(language || __getGuideLanguageFromUi() || 'English').trim() || 'English';

            // Build per-type units (avoid per-question output; group-level only)
            const allUnits = [];
            for (const typeName of typeNames) {
                const probs = Array.isArray(typesObj[typeName]) ? typesObj[typeName] : [];
                const units = __buildSubgroupingUnitsForType(typeName, probs, { maxTokens: maxT });
                units.forEach(u => allUnits.push(u));
            }
            if (!allUnits.length) {
                return { assignmentsByQid: new Map(), groupsByType: new Map() };
            }

            const batches = __packSubgroupingUnits(allUnits, maxT);

            const groupsByType = new Map(); // typeName -> [{ rule, qids[] }]
            const observedTypes = new Set();
            const processedUnits = new Set();

            async function processBatch(batch, workerId) {
                const ctx = `${contextPrefix}-W${workerId}`;
                const units = (batch && Array.isArray(batch.units)) ? batch.units : [];
                if (!units.length) return;
                units.forEach(u => {
                    if (u?.typeName) observedTypes.add(u.typeName);
                    if (u?.unitId) processedUnits.add(u.unitId);
                });
                const userText = units.map(u => u.userText).join('\n\n====================\n\n');
                const payload = {
                    model: getApiConfig().model,
                    messages: [
                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.subgroup_creator.system, { language: lang }) },
                        { role: 'user', content: userText }
                    ]
                };
                const items = await requestAndParseDataEnvelope(payload, ctx, { phase: 'phase1b' });
                items.forEach(it => {
                    const v = String(it?.value || '');
                    const typeRaw = String(parseTag(v, 'type_name') || '').trim();
                    if (!typeRaw) return;
                    const typeName = normalizedToType.get(__normalizeTitleForMatch(typeRaw)) || typeRaw;
                    if (!qidSetByType.has(typeName)) return;

                    const noneRaw = String(parseTag(v, 'none') || '').trim().toLowerCase();
                    const isNone = ['true', 'yes', 'y', '1', 'none'].includes(noneRaw);
                    if (isNone) return;

                    const rule = String(parseTag(v, 'subgroup_rule') || '').trim();
                    const qids = __parseQidsFromText(parseTag(v, 'qids') || '');
                    if (!qids.length) return;
                    const allowed = qidSetByType.get(typeName) || new Set();
                    const filtered = qids.filter(qid => allowed.has(qid));
                    const uniq = Array.from(new Set(filtered));
                    if (uniq.length < 2) return;
                    if (!groupsByType.has(typeName)) groupsByType.set(typeName, []);
                    groupsByType.get(typeName).push({ rule, qids: uniq });
                });
            }

            await runWithConcurrency(batches, processBatch, getWorkerConcurrency());

            // Post-process: ensure each qid appears in at most one subgroup per type; assign stable tags.
            const assignmentsByQid = new Map(); // qid -> { typeName, tag, rule }
            groupsByType.forEach((groups, typeName) => {
                const list = Array.isArray(groups) ? groups.slice() : [];
                list.sort((a, b) => {
                    const na = Array.isArray(a?.qids) ? a.qids.length : 0;
                    const nb = Array.isArray(b?.qids) ? b.qids.length : 0;
                    if (nb !== na) return nb - na;
                    return String(a?.rule || '').localeCompare(String(b?.rule || ''), 'en');
                });
                const seen = new Set();
                const kept = [];
                list.forEach(g => {
                    const qids = Array.isArray(g?.qids) ? g.qids.slice() : [];
                    const uniq = qids.filter(qid => qid && !seen.has(qid));
                    if (uniq.length < 2) return;
                    uniq.forEach(qid => seen.add(qid));
                    kept.push({ rule: String(g?.rule || '').trim(), qids: uniq });
                });
                groupsByType.set(typeName, kept);

                kept.forEach((g, idx) => {
                    const tag = `sg${String(idx + 1).padStart(2, '0')}`;
                    g.qids.forEach(qid => {
                        assignmentsByQid.set(qid, { typeName, tag, rule: g.rule });
                    });
                });
            });

            return { assignmentsByQid, groupsByType, meta: { processedUnits: processedUnits.size, typesObserved: observedTypes.size, maxTokens: maxT } };
        }

        async function runPhase1SubgroupingFromClusters(p1_state, { chunkTokens } = {}) {
            const p1 = p1_state || activeProcess?.phase1_patterns;
            if (!p1) throw new Error('Phase1 state not found.');
            const clusters = Array.isArray(p1?.clusters) ? p1.clusters : [];
            const perQ = Array.isArray(p1?.perQuestion) ? p1.perQuestion : [];
            if (!clusters.length || !perQ.length) throw new Error('No Phase1 clusters/perQuestion available.');

            const all = collectAllQuestions();
            const byQid = new Map(all.map(q => [String(q.qid || '').trim(), q]));

            const typeToProblems = {};
            const missing = [];
            clusters.forEach(cl => {
                const typeName = String(cl?.pattern_name || '').trim();
                const qids = Array.isArray(cl?.qids) ? cl.qids : [];
                const probs = [];
                qids.forEach(qid => {
                    const q = byQid.get(String(qid || '').trim());
                    if (q) probs.push(q);
                    else missing.push(qid);
                });
                typeToProblems[typeName] = probs;
            });
            if (missing.length) logger.warn('Phase1Subgroup', `Missing ${missing.length} qid(s) while building subgrouping input (sample: ${missing.slice(0, 3).join(', ')})`);

            const res = await subgroupifyTypeProblemMap(typeToProblems, {
                chunkTokens,
                language: __getGuideLanguageFromUi(),
                contextPrefix: 'SubgroupBatch',
            });

            const map = res?.assignmentsByQid instanceof Map ? res.assignmentsByQid : new Map();

            let assigned = 0;
            perQ.forEach(pq => {
                const qid = String(pq?.qid || '').trim();
                const a = map.get(qid) || null;
                pq.subgroup_tag = a ? a.tag : '';
                pq.subgroup_rule = a ? (a.rule || '') : '';
                if (a) assigned++;
            });

            try {
                p1.subgrouping = p1.subgrouping && typeof p1.subgrouping === 'object' ? p1.subgrouping : {};
                p1.subgrouping.assigned = assigned;
                p1.subgrouping.groups = (() => {
                    try {
                        let n = 0;
                        (res?.groupsByType || new Map()).forEach(gs => { n += Array.isArray(gs) ? gs.length : 0; });
                        return n;
                    } catch { return 0; }
                })();
                p1.subgrouping.types = (res?.groupsByType && typeof res.groupsByType.forEach === 'function')
                    ? Array.from(res.groupsByType.keys()).length
                    : 0;
            } catch { }

            logger.success('Phase1Subgroup', `Subgrouping applied: assigned ${assigned} problem(s) to subgroup tags.`);
            renderActiveProcess();
        }

        // ----- PHASE 2: Module drafting for each pattern cluster (and gap-fix patches) -----
        async function generatePhase2Modules() {
            updateStatus("Phase 2: Standard Problems & Explanations", "Creating standard problems and detailed explanations...");
            activeProcess.activeTabId = 'phase2-modules';
            renderActiveProcess();

            const pCfg = getPipelineConfig();
            const p2Cfg = pCfg?.phase2 || {};
            const matcher = (p2Cfg?.singleType?.enabled && String(p2Cfg?.singleType?.query || '').trim())
                ? __makeTypeMatcher(p2Cfg.singleType.query)
                : null;

            let jobs = (activeProcess.phase2_modules || [])
                .filter(m => m.status === 'pending')
                .map(m => ({ pattern_name: m.pattern_name }));

            if (p2Cfg?.singleType?.enabled) {
                const q = String(p2Cfg?.singleType?.query || '').trim();
                if (!q) {
                    logger.warn("Phase2", "Single-type mode is enabled but the query is empty. No modules selected.");
                    jobs = [];
                } else if (matcher) {
                    jobs = jobs.filter(j => matcher(j.pattern_name));
                    logger.info("Phase2", `Single-type filter applied (${jobs.length} pending match(es)). query=${q}`);
                } else {
                    logger.warn("Phase2", `Single-type mode query is invalid; no matcher created. query=${q}`);
                    jobs = [];
                }
            }

            const maxModules = __clampInt(p2Cfg?.maxModules ?? 0, { min: 0, max: 9999, fallback: 0 });
            if (maxModules > 0 && jobs.length > maxModules) {
                jobs = jobs.slice(0, maxModules);
                logger.info("Phase2", `Max modules limit applied: running ${jobs.length} module(s).`);
            }

            if (jobs.length === 0) {
                logger.info("Phase2", "No pending module generation jobs.");
                return;
            }

            logger.info(
                "2ë‹¨ê³„",
                `ëª¨ë“ˆ ìƒì„± ì‹œì‘: ${jobs.length}ê°œ ìœ í˜• ëŒ€ê¸° ì¤‘ (ì „ì²´ ${(activeProcess.phase2_modules || []).length}ê°œ)`
            );

            async function processJob(job, workerId) {
                const moduleState = activeProcess.phase2_modules.find(m => m.pattern_name === job.pattern_name);
                moduleState.status = 'processing';
                moduleState.refinementCycles = moduleState.refinementCycles || [];
                moduleState.events = moduleState.events || [];
                const __evt = (msg) => {
                    try {
                        const ts = new Date();
                        moduleState.events.push({
                            tsIso: ts.toISOString(),
                            tsUi: ts.toLocaleTimeString('en-US', { hour12: false }),
                            message: String(msg || ''),
                        });
                    } catch { }
                };
                const cfg = getPipelineConfig();
                const p2Cfg = cfg?.phase2 || {};
                const enableAuditor = p2Cfg?.enableAuditor !== false;
                const enableCoverage = p2Cfg?.enableCoverage !== false;
                const coverageOpts = p2Cfg?.coverage || {};
                renderActiveProcess();

                const context = `Module-${job.pattern_name}-W${workerId}`;
                const qids = moduleState.qidsCovered;
                const allQuestions = collectAllQuestions();
                const relevantQs = allQuestions.filter(q => qids.includes(q.qid));

                const problemsText = problemsToTextInterleaved(relevantQs);
                const isResume = !!(moduleState.standardProblem || moduleState.explanation);
                __evt(`${isResume ? 'Resumed' : 'Started'} (auditor=${enableAuditor ? 'on' : 'off'}, coverage=${enableCoverage ? 'on' : 'off'})`);

                try {
                    // Step 1: Create standard problem
                    if (!moduleState.standardProblem) {
                        logger.info(context, "Creating standard problem...");
                        const language = __getGuideLanguageFromUi();
	                        const sp_payload = {
	                            model: getApiConfig().model,
	                            messages: [
	                                { role: 'system', content: __renderPromptTemplateText(currentPrompts.standard_problem_creator.system, { language }) },
	                                { role: 'user', content: `Pattern Type: ${job.pattern_name}\n\nAll problems of this type:\n\n${problemsText}\n\nCreate ONE standard problem that represents this type.\nLANGUAGE CONSTRAINT: The standard problem must be in ${language}.` }
	                            ]
	                        };

                        const sp_items = await requestAndParseDataEnvelopeLenient(sp_payload, `${context}-StdProblem`, { phase: 'phase2' }); // lenient: allow rationale outside <data>
                        moduleState.standardProblem = {
                            problem: parseTag(sp_items[0].value, 'standard_problem'),
                            answer: parseTag(sp_items[0].value, 'correct_answer')
                        };

                        logger.success(context, "Standard problem created.");
                        __evt("Standard problem created.");
                        renderActiveProcess();
                        await maybeComputeGlobalTypeOrder(); // compute once all SPs exist
                    } else {
                        logger.info(context, "Standard problem already exists. (Skipping step 1)");
                    }

                    // Step 2: Create initial explanation
                    if (!moduleState.explanation) {
                        logger.info(context, "Creating detailed explanation...");
                        // --- UPDATED: ê³µì‹í•´ì„¤ì€ problemsTextì— ì´ë¯¸ ì¸í„°ë¦¬ë¸Œë˜ì–´ ìˆìŒ ---
                        const exp_userText = `Pattern Type: ${job.pattern_name}

{Standard problem:
${moduleState.standardProblem.problem}
}

{Correct answer:
${moduleState.standardProblem.answer}
}

{All problems of this type (each followed by its official explanation if present):
${problemsText}
}

Create an extremely detailed, step-by-step explanation that teaches how to solve this standard problem AND enables solving all problems of this type.`;

	                        const exp_payload = {
	                            model: getApiConfig().model,
	                            messages: [
	                                { role: 'system', content: __renderPromptTemplateText(currentPrompts.explanation_creator.system, { language: __getGuideLanguageFromUi() }) },
	                                { role: 'user', content: exp_userText }
	                            ]
	                        };

                        const exp_raw = await resilientLlmRequest(exp_payload, `${context}-Explanation`);
                        moduleState.explanation = exp_raw;

                        logger.success(context, "Initial explanation created.");
                        __evt("Initial explanation created.");
                        renderActiveProcess();
                    } else {
                        logger.info(context, "Initial explanation already exists. (Skipping step 2)");
                    }

                    // Step 3: Auditor loop (mode-dependent)
                    {
                        const PASS_STREAK_TARGET = 1;
                        let passStreak = 0;
                        let cycleNum = moduleState.refinementCycles.length;
                        let revisedOnce = false;
                        let checkpoint = null;
                        const loopMode = String(p2Cfg?.auditorLoopMode || 'single_pass').trim().toLowerCase(); // single_pass | until_pass
                        const maxCycles = __clampInt(
                            (typeof p2Cfg?.auditorMaxCycles !== 'undefined')
                                ? p2Cfg.auditorMaxCycles
                                : (loopMode === 'until_pass' ? 0 : 1),
                            { min: 0, max: 99, fallback: 1 }
                        );
                        const cycleStart = cycleNum;

                        while (!processController.stop && passStreak < PASS_STREAK_TARGET) {
                            if (!enableAuditor) {
                                logger.info(context, "Auditor disabled by config. Skipping verification/refinement.");
                                __evt("Auditor skipped by config.");
                                break;
                            }
                            if (maxCycles > 0 && (cycleNum - cycleStart) >= maxCycles) {
                                logger.warn(context, `Auditor loop: max cycles reached (${maxCycles}). Stopping audit loop.`);
                                __evt(`Auditor loop max cycles reached (${maxCycles})`);
                                break;
                            }
                            // Ensure we have a standard problem
                            if (!moduleState.standardProblem) {
                                logger.info(context, "Creating standard problem...");
                                const language = __getGuideLanguageFromUi();
	                                const sp_payload = {
	                                    model: getApiConfig().model,
	                                    messages: [
	                                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.standard_problem_creator.system, { language }) },
	                                        {
	                                            role: 'user',
	                                            content:
                                                `Pattern Type: ${job.pattern_name}
                  
                  All problems of this type:
                  ${problemsText}
                  
                  Create ONE standard problem that represents this type.
                  Make it approachable to a middle school student yet fully representative of all required concepts.
                  LANGUAGE CONSTRAINT: The standard problem must be in ${language}.
                  Output in the required <data> ... </data> format.`
                                        }
                                    ]
                                };

                                const sp_items = await requestAndParseDataEnvelopeLenient(sp_payload, `${context}-StdProblem`, { phase: 'phase2' }); // lenient: allow rationale outside <data>
                                moduleState.standardProblem = {
                                    problem: parseTag(sp_items[0].value, 'standard_problem'),
                                    answer: parseTag(sp_items[0].value, 'correct_answer')
                                };

                                logger.success(context, "Standard problem created.");
                                __evt(`Standard problem created (cycle ${cycleNum + 1} bootstrap).`);
                                renderActiveProcess();
                                await maybeComputeGlobalTypeOrder(); // compute once all SPs exist
                            }

                            // Ensure we have an explanation
                            if (!moduleState.explanation) {
                                logger.info(context, "Creating detailed explanation...");

                                const exp_userText =
                                    `Pattern Type: ${job.pattern_name}

{Standard problem:
${moduleState.standardProblem.problem}
}

{Correct answer:
${moduleState.standardProblem.answer}
}

{All problems of this type (each followed by its official explanation if present):
${problemsText}
}

Create an extremely detailed, step-by-step explanation that teaches how to solve this standard problem AND enables solving all problems of this type. Write so a middle school student can follow, avoid excessive abstraction, and maintain academic accuracy.`;

	                                const exp_payload = {
	                                    model: getApiConfig().model,
	                                    messages: [
	                                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.explanation_creator.system, { language: __getGuideLanguageFromUi() }) },
	                                        { role: 'user', content: exp_userText }
	                                    ]
	                                };

                                const exp_raw = await resilientLlmRequest(exp_payload, `${context}-Explanation`);
                                moduleState.explanation = exp_raw;

                                logger.success(context, "Initial explanation created.");
                                __evt(`Initial explanation created (cycle ${cycleNum + 1} bootstrap).`);
                                renderActiveProcess();
                            }

                            // Verification step (auditor sees full history of this module)
                            logger.info(context, `Verification cycle ${cycleNum + 1} (pass streak ${passStreak}/${PASS_STREAK_TARGET})...`);

                            const feedbackHistoryText = (moduleState.refinementCycles && moduleState.refinementCycles.length)
                                ? moduleState.refinementCycles
                                    .map(c => `Cycle ${c.cycleNumber} (<${c.decisionTag}>):\n${c.feedback}`)
                                    .join('\n\n---\n\n')
                                : 'None.';

                            const feedback_userText =
                                `You will be given ONLY the guide text (no original problems).
	
	{Pattern Type:
	${job.pattern_name}
	}
	
	{Guide to audit:
	${moduleState.explanation}
	}
	
	{Feedback history (oldest -> newest):
	${feedbackHistoryText}
	}
	
	Provide a short summary and a detailed, actionable critique. End with exactly one decision tag: <pass> or <fail>.`;

	                            const feedback_payload = {
	                                model: getApiConfig().model,
	                                messages: [
	                                    { role: 'system', content: __renderPromptTemplateText(currentPrompts.explanation_feedback.system, { language: __getGuideLanguageFromUi() }) },
	                                    { role: 'user', content: feedback_userText }
	                                ]
	                            };

                            const verificationRaw = await resilientLlmRequest(feedback_payload, `${context}-Feedback${cycleNum + 1}`);

                            let decision = 'fail';
                            try {
                                decision = parseDecisionTag(verificationRaw, ['pass', 'fail']);
                            } catch (e) {
                                logger.warn(context, `Verifier did not produce a valid <pass>/<fail> tag: ${e.message}. Treating as <fail>.`);
                            }

                            const isPass = (decision === 'pass');
                            const isError = (decision === 'error');

                            // Store full history item (snapshot of explanation)
                            moduleState.refinementCycles.push({
                                cycleNumber: cycleNum + 1,
                                feedback: verificationRaw,
                                fullVerification: verificationRaw,
                                decisionTag: decision,
                                isAcceptable: isPass,
                                explanationSnapshot: moduleState.explanation
                            });
                            __evt(`Feedback cycle ${cycleNum + 1}: <${decision}>`);

                            renderActiveProcess();

                            if (isPass) {
                                passStreak++;
                                checkpoint = {
                                    standardProblem: { ...moduleState.standardProblem },
                                    explanation: moduleState.explanation
                                };
                                logger.success(context, `PASSED (<pass>) | accepted`);

                                break;
                            } else { // FAIL or ERROR handling
                                passStreak = 0;
                                const tagShown = isError ? '<error>' : '<fail>';
                                const allowMulti = loopMode === 'until_pass';
                                logger.warn(context, `Verifier returned ${tagShown}. ${allowMulti ? 'Revising and re-verifying until <pass>.' : 'Applying at most one revision.'}`);
                                if (!allowMulti && revisedOnce) break;

                                // Proceed with revision logic based on <error> or <fail>
                                const language = __getGuideLanguageFromUi();

                                // --- NEW (revise with only the latest critique; no long history) ---
                                // Ideological reason: Tight feedback loop = faster convergence, less token bloat.

                                // 1) Revise/replace the standard problem when <error>
	                                const sp_revise_payload = {
	                                    model: getApiConfig().model,
	                                    messages: [
	                                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.standard_problem_creator.system, { language }) },
	                                        {
	                                            role: 'user',
	                                            content:
                                                `Revise or replace the standard problem to satisfy the Final Objective.

Final Objective:
A beginner (middle school level) should be able to solve ALL problems of this type after studying the standard problem and its explanation.

{Problems in this type:
${problemsText}
}

{Your previous response (current standard problem):
${moduleState.standardProblem.problem}
}

{Current correct answer:
${moduleState.standardProblem.answer}
}

{Previous feedback:
${verificationRaw}
}

Requirements:
- The new standard problem must be representative of the type's core challenge and cover all key concepts.
- Do not make it trivial or impossibly complex.
- Keep it approachable to a middle-school student with no prior knowledge, without sacrificing academic accuracy.
- Make only the **minimal** necessary changes to fix issues (do not rewrite wholesale unless essential).
- LANGUAGE CONSTRAINT: The standard problem must be in ${language}.
- Output exactly ONE standard problem in the required <data> ... </data> format.`
                                        }
                                    ]
                                };

                                // --- UPDATED: patch-mode local edits only ---
	                                const exp_revise_payload = {
	                                    model: getApiConfig().model,
	                                    messages: [
	                                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.explanation_creator.system, { language }) },
	                                        {
	                                            role: 'user',
	                                            content:
                                                `PATCH MODE: Revise the existing guide by applying only minimal, local edits based on the audit feedback.
		
		Rules:
		- Do NOT rewrite or re-output the full guide.
		- Output patch instructions in the required <patches> ... </patches> format.
		
		{Current guide (markdown):
		${moduleState.explanation}
		}
	
		{Latest audit feedback:
		${verificationRaw}
		}
		
			${__patchOutputDirectiveLine({ phase: 'phase2', context })}`
                                        }
                                    ]
                                };

                                if (isError) {
                                    // Standard problem is the issue â†’ revise SP only, then re-evaluate
                                    logger.info(context, "Revising standard problem based on critique (<error>)...");
                                    const sp_revise_items = await requestAndParseDataEnvelopeLenient(sp_revise_payload, `${context}-ReviseStdProblem${cycleNum + 1}`, { phase: 'phase2' }); // lenient for rationale
                                    moduleState.standardProblem = {
                                        problem: parseTag(sp_revise_items[0].value, 'standard_problem'),
                                        answer: parseTag(sp_revise_items[0].value, 'correct_answer')
                                    };
                                    __evt(`Revised standard problem (cycle ${cycleNum + 1})`);
                                    logger.info(context, `Revised standard problem for cycle ${cycleNum + 1}. Re-evaluating without changing explanation.`);
                                    await maybeComputeGlobalTypeOrder(); // keep order in sync if SP changed
                                } else {
                                    // <fail>: explanation needs work; SP is valid â†’ revise explanation only
                                    logger.info(context, "Revising explanation based on critique (<fail>)...");
                                    const patchPayload = __withStructuredRationaleMode(exp_revise_payload, { kind: 'patches', phase: 'phase2', context: `${context}-ReviseExplanationPatch${cycleNum + 1}` });
                                    const patchRaw = await resilientLlmRequest(patchPayload, `${context}-ReviseExplanationPatch${cycleNum + 1}`);
                                    const patches = parsePatchBlocks(patchRaw);
                                    if (!patches.length) {
                                        try {
                                            __formatErrors.add({
                                                kind: 'patches',
                                                stage: 'explanation_patch',
                                                attempt: cycleNum + 1,
                                                context: `${context}-ReviseExplanationPatch${cycleNum + 1}`,
                                                error: 'No <patch> blocks parsed',
                                                request: patchPayload,
                                                responseRaw: patchRaw,
                                                meta: { source: 'phase2_module' }
                                            });
                                        } catch { }
                                    }
                                    const beforeExp = moduleState.explanation;
                                    const applied = applyPatchesToGuide(beforeExp, patches);

                                    if (applied.results.some(r => !r.applied)) {
                                        logger.warn(context, `Explanation patch: some patches failed to apply.`);
                                    }
                                    if (applied.text === beforeExp) {
                                        logger.warn(context, `Explanation patch: no changes applied.`);
                                    }

                                    try {
                                        const hygiene = __applyMarkdownHygieneFix(applied.text, context, `explanation_patch_cycle_${cycleNum + 1}`);
                                        moduleState.explanation = hygiene.text;
                                    } catch {
                                        moduleState.explanation = applied.text;
                                    }
                                    __evt(`Applied explanation patch (cycle ${cycleNum + 1}, patches=${(patches || []).length}, failed=${applied.results.filter(r => !r.applied).length})`);
                                    logger.info(context, `Revised explanation by patches in cycle ${cycleNum + 1}.`);
                                    if (allowMulti && applied.text === beforeExp) {
                                        logger.warn(context, `Stopping auditor loop: patch produced no changes (cycle ${cycleNum + 1}).`);
                                        __evt(`Auditor loop stopped: no-change patch (cycle ${cycleNum + 1})`);
                                        renderActiveProcess();
                                        break;
                                    }
                                    if (allowMulti) renderActiveProcess();
                                }
                                if (!allowMulti) {
                                    revisedOnce = true;
                                    renderActiveProcess();
                                    break;
                                }
                            }

                            // --- After each cycle (pass or fail) ---
                            cycleNum++;
                        }

                        if (processController.stop) {
                            logger.warn(context, "Operation cancelled during refinement.");
                            moduleState.status = 'pending'; // allow resume
                        } else {
                            if (moduleState.coverage) {
                                logger.info(context, "Coverage already exists. (Skipping step 4)");
                                __evt("Coverage already exists (resume).");
                            } else if (moduleState.explanation && enableCoverage) {
                                __evt(`Coverage patching start (maxTokens=${coverageOpts?.maxTokens ?? '?'} maxRounds=${coverageOpts?.maxRounds ?? '?'} finalVerify=${coverageOpts?.finalVerifyMode ?? '?'})`);
                                const coverageRes = await refineGuideCoverage(
                                    moduleState.explanation,
                                    relevantQs,
                                    `${context}-Coverage`,
                                    {
                                        maxTokens: coverageOpts?.maxTokens,
                                        maxRounds: coverageOpts?.maxRounds,
                                        patcherMode: coverageOpts?.patcherMode,
                                        verifierOutput: coverageOpts?.verifierOutput,
                                        verifierMaxTries: coverageOpts?.verifierMaxTries,
                                        finalVerifyMode: coverageOpts?.finalVerifyMode,
                                        onGuideUpdate: (nextText) => {
                                            try { moduleState.explanation = String(nextText || ''); } catch { }
                                        },
                                    }
                                );
                                try {
                                    const hygiene = __applyMarkdownHygieneFix(coverageRes.guideText, context, 'coverage_final');
                                    moduleState.explanation = hygiene.text;
                                } catch {
                                    moduleState.explanation = coverageRes.guideText;
                                }
                                moduleState.coverage = {
                                    missingQids: coverageRes.missingQids || [],
                                    report: coverageRes.coverageReport || null,
                                    meta: coverageRes.coverageMeta || null,
                                    educationFeedback: coverageRes.educationFeedback || null,
                                };
                                __evt(`Coverage done (missing=${(coverageRes.missingQids || []).length})`);
                            } else if (!enableCoverage) {
                                logger.info(context, "Coverage skipped by config.");
                                __evt("Coverage skipped by config.");
                                moduleState.coverage = moduleState.coverage || null;
                            }
                            moduleState.status = 'completed';
                            logger.success(context, `Module completed for ${job.pattern_name}.`);
                        }
                    }


                } catch (e) {
                    const msg = (e?.message || e || '').toString();
                    const low = msg.toLowerCase();
                    if (processController.stop || low.includes('cancelled') || low.includes('canceled') || low.includes('stopped by user')) {
                        moduleState.status = 'pending'; // allow resume
                        moduleState.error = null;
                        __evt(`Stopped (resumable): ${msg}`);
                        logger.warn(context, `Module generation stopped: ${msg}`);
                    } else if (low.includes('exceeds maxtokens') || low.includes('request exceeds')) {
                        // Coverage overflow error - check overflow mode
                        const overflowMode = coverageOpts?.overflowMode || 'guide_merge';
                        const overflowThreshold = coverageOpts?.overflowThreshold || 2;
                        moduleState.__overflowErrors = (moduleState.__overflowErrors || 0) + 1;

                        logger.warn(context, `Coverage overflow error (${moduleState.__overflowErrors}/${overflowThreshold}): ${msg}`);

                        if (moduleState.__overflowErrors >= overflowThreshold) {
                            if (overflowMode === 'guide_merge') {
                                // Split problems, generate guides separately, then merge
                                logger.info(context, `Attempting guide split-merge mode...`);
                                __evt(`Guide overflow â†’ split-merge mode activated`);

                                try {
                                    const mid = Math.ceil(relevantQs.length / 2);
                                    const subset1 = relevantQs.slice(0, mid);
                                    const subset2 = relevantQs.slice(mid);

                                    logger.info(context, `Splitting ${relevantQs.length} problems into ${subset1.length} + ${subset2.length}`);

                                    // Generate explanations for each subset
                                    const guide1 = await generateExplanationForSubset(
                                        job.pattern_name,
                                        moduleState.standardProblem,
                                        subset1,
                                        `${context}-Split1`,
                                        p2Iterations
                                    );

                                    const guide2 = await generateExplanationForSubset(
                                        job.pattern_name,
                                        moduleState.standardProblem,
                                        subset2,
                                        `${context}-Split2`,
                                        p2Iterations
                                    );

                                    // Merge the guides
                                    const mergedGuide = await mergeGuides([guide1, guide2], `${context}-Merge`);

                                    moduleState.explanation = mergedGuide;
                                    moduleState.coverage = { note: 'Created via split-merge mode (coverage verification skipped)' };
                                    moduleState.status = 'completed';
                                    moduleState.__overflowErrors = 0;
                                    logger.success(context, `Module completed via split-merge mode.`);
                                    __evt(`Split-merge completed successfully.`);
                                } catch (splitErr) {
                                    moduleState.status = 'error';
                                    moduleState.error = `Split-merge failed: ${splitErr.message}`;
                                    logger.error(context, `Split-merge failed: ${splitErr.message}`);
                                }
                            } else if (overflowMode === 'type_split') {
                                // Mark for type splitting (will be handled at a higher level)
                                moduleState.status = 'error';
                                moduleState.error = `Overflow - type split required: ${msg}`;
                                moduleState.__needsTypeSplit = true;
                                logger.warn(context, `Type split required for ${job.pattern_name}`);
                            } else {
                                // error mode - just fail
                                moduleState.status = 'error';
                                moduleState.error = msg;
                                logger.error(context, `Module generation failed: ${msg}`);
                            }
                        } else {
                            // Haven't hit threshold yet, mark as pending for retry
                            moduleState.status = 'pending';
                            moduleState.error = null;
                            logger.info(context, `Will retry (${moduleState.__overflowErrors}/${overflowThreshold} errors)`);
                        }
                    } else {
                        moduleState.status = 'error';
                        moduleState.error = msg;
                        logger.error(context, `Module generation failed: ${msg}`);
                    }
                } finally {
                    renderActiveProcess();
                }
            }

            // Phase 2ë„ 5 ì›Œì»¤ë¡œ ë³‘ë ¬ ì²˜ë¦¬:
            // ê° ì›Œì»¤ëŠ” "í‘œì¤€ë¬¸ì œ ìƒì„± â†’ ì„¤ëª… ìƒì„± â†’ ë‹¨ì¼ ê²€ì¦ â†’ í•„ìš” ì‹œ 1íšŒ ìˆ˜ì •"ì„ ëª¨ë“ˆ ë‹¨ìœ„ë¡œ ë…ë¦½ ìˆ˜í–‰
            const CONCURRENCY_P2 = getWorkerConcurrency();
            await runWithConcurrency(jobs, processJob, CONCURRENCY_P2);

            const completedCount = (activeProcess.phase2_modules || []).filter(m => m.status === 'completed').length;
            const errorCount = (activeProcess.phase2_modules || []).filter(m => m.status === 'error').length;
            const pendingCount = (activeProcess.phase2_modules || []).filter(m => m.status === 'pending').length;
            logger.success(
                "2ë‹¨ê³„",
                `ëª¨ë“ˆ ìƒì„± ì™„ë£Œ: ${completedCount}ê°œ ì™„ë£Œ, ${errorCount}ê°œ ì˜¤ë¥˜, ${pendingCount}ê°œ ëŒ€ê¸°`
            );
        }

        // ----- PHASE 3: Final Mastery Manual synthesis -----
        function buildFinalManual() {
            updateStatus("Phase 3: Final Manual", "Synthesizing explanations into the final manual...");
            activeProcess.activeTabId = 'phase3-final';

            const finalState = activeProcess.phase3_finalManual;
            finalState.status = 'processing';
            renderActiveProcess();

            try {
                const allModules = (activeProcess.phase2_modules || []).filter(m => m.status === 'completed' && m.explanation);
                if (allModules.length === 0) {
                    throw new Error("No completed explanations available to build the manual.");
                }

                const order = activeProcess?.typeOrdering?.order || [];
                const orderIndex = new Map(order.map((name, i) => [name, i]));

                // ideological reason: pedagogy-first rendering improves retention and transfer.
                const modules = allModules.slice().sort((a, b) =>
                    (orderIndex.has(a.pattern_name) ? orderIndex.get(a.pattern_name) : Number.MAX_SAFE_INTEGER) -
                    (orderIndex.has(b.pattern_name) ? orderIndex.get(b.pattern_name) : Number.MAX_SAFE_INTEGER)
                );

                const manualContent = modules.map(mod => {
                    const coverage = (mod.qidsCovered && mod.qidsCovered.length)
                        ? mod.qidsCovered.join(', ')
                        : 'N/A';

                    const { total, pass, fail, last, streak } = summarizeVerification(mod.refinementCycles || []);

                    // Keep explanations using GLOBAL_QIDs
                    const explanationWithGlobal = convertInternalQidsToGlobal(mod.explanation, mod.qidsCovered);

                    return `
# ${mod.pattern_name}

## Standard Problem
${mod.standardProblem.problem}

**Answer:** ${mod.standardProblem.answer}

---

## Coverage (GLOBAL_QIDs)
${coverage}

## Verification Summary
- Cycles: ${total} (pass ${pass} / fail ${fail})
- Final decision: ${last}
          - Consecutive-pass streak at finish: ${streak} (target: 1)

---

## Detailed Explanation
${explanationWithGlobal}
`;
                }).join('\n\n========================================\n\n');

                finalState.content = manualContent;
                finalState.status = 'completed';
                logger.success("Phase3", "Final mastery manual collated successfully.");
                logger.success("3ë‹¨ê³„", `ìµœì¢… ë§ˆìŠ¤í„°ë¦¬ ë§¤ë‰´ì–¼ ìƒì„± ì™„ë£Œ: ${modules.length}ê°œ ìœ í˜• í¬í•¨`);
            } catch (e) {
                finalState.status = 'error';
                finalState.error = e.message;
                logger.error("Phase3", `Final manual collation failed: ${e.message}`);
            } finally {
                renderActiveProcess();
            }
        }

        // ----- ORCHESTRATOR -----
        async function startGenerationProcess() {
            // Only load gpt-tokenizer if user selected that mode
            const tokMode = __getTokenizerMode();
            if (tokMode === 'gpt_tokenizer_lazy') {
                try {
                    const loaded = await __loadGptTokenizerLazy();
                    if (!loaded) {
                        logger.warn('Tokenizer', 'gpt-tokenizer not available; using char estimate fallback.');
                    }
                } catch (e) {
                    logger.warn('Tokenizer', `Failed to load gpt-tokenizer: ${e?.message || e}`);
                }
            } else {
                logger.info('Tokenizer', `Using tokenizer mode: ${tokMode}`);
            }

            // Normalize any loaded state
            if (activeProcess) activeProcess = migrateActiveProcessForResume(activeProcess);
            const isResuming = isProcessResumable();
            // Resume: start from saved config, but let current UI config override (including maxTokens changes).
            const uiCfg = __migratePipelineConfig(getPipelineConfigFromUi());
            const savedCfg = __migratePipelineConfig(getPipelineConfig());
            const pipelineConfig = isResuming ? __deepMerge(savedCfg, uiCfg) : uiCfg;
            pipelineConfig.runPlan = uiCfg.runPlan || pipelineConfig.runPlan || {};
            pipelineConfig.runPhases = __computeRunPhases(pipelineConfig.runPlan);
            const requestedStartFrom = __normalizeStartFrom(pipelineConfig?.runPlan?.startFrom);
            const shouldResetFromPhase = requestedStartFrom !== 'continue';
            const consumeStartFromOneShot = () => {
                if (!shouldResetFromPhase) return;
                try {
                    const el = getEl('run-start-from-select');
                    if (el) el.value = 'continue';
                    savePipelineConfigToStorage();
                } catch { }
            };
            try {
                const rp = pipelineConfig?.runPlan || {};
                const run = pipelineConfig?.runPhases || __computeRunPhases(rp);
                logger.info(
                    "ì„¤ì •",
                    `ì‹¤í–‰ ê³„íš: ì¬ì‹œì‘=${rp.startFrom} Â· ì¢…ë£Œ=${rp.stopAfter} ` +
                    `(0ë‹¨ê³„=${run.phase0 ? 'on' : 'off'}, 1ë‹¨ê³„=${run.phase1 ? 'on' : 'off'}, 2ë‹¨ê³„=${run.phase2 ? 'on' : 'off'}, 3ë‹¨ê³„=${run.phase3 ? 'on' : 'off'})`
                );
            } catch { }

            updateUIState(true);

            if (isResuming) {
                // New log session per resume, and prune overwritten-stage logs when rerunning from a phase.
                try {
                    if (shouldResetFromPhase) {
                        logger.deleteEntriesFromPhase(requestedStartFrom);
                        try { __formatErrors.deleteEntriesFromPhase?.(requestedStartFrom); } catch { }
                        try { __rebuildCallStatsFromLogs(); } catch { }
                    }
                    logger.startNewSession({ reason: shouldResetFromPhase ? `resume (reset ${requestedStartFrom})` : 'resume' });
                    try {
                        const sel = getEl('log-filter-session-select');
                        if (sel) sel.value = 'current';
                        logger.setFilters({ session: 'current' });
                    } catch { }
                } catch { }
                logger.info("Workflow", "Resuming existing process...");
                activeProcess.status = 'processing';
                try { applyPipelineConfigToActiveProcess(pipelineConfig, activeProcess); } catch { }
                try {
                    if (pipelineConfig?.runPlan?.resetCallCountersOnStart) {
                        successfulApiCallCount = 0;
                        updateApiCallCounter();
                        __callStats.reset();
                        logger.info('API', 'Call counters reset (config).');
                    }
                } catch { }
                try {
                    if (shouldResetFromPhase) {
                        logger.warn("Workflow", `Rerun requested: reset from ${requestedStartFrom}.`);
                        resetProcessFromPhase(activeProcess, requestedStartFrom, pipelineConfig);
                        try {
                            const p1 = activeProcess?.phase1_patterns || {};
                            const clustersN = Array.isArray(p1?.clusters) ? p1.clusters.length : 0;
                            const perQn = Array.isArray(p1?.perQuestion) ? p1.perQuestion.length : 0;
                            const modsN = Array.isArray(activeProcess?.phase2_modules) ? activeProcess.phase2_modules.length : 0;
                            logger.info("ì„¤ì •", `ì¬ì‹œì‘ ì ìš©: phase1.status=${p1?.status || 'n/a'}, clusters=${clustersN}, perQuestion=${perQn}, modules=${modsN}`);
                        } catch { }
                        consumeStartFromOneShot();
                    }
                } catch { }
            } else {
                const hasOcrCache = Array.isArray(examPapers) && examPapers.length > 0;
                if (uploadedFiles.length === 0 && !hasOcrCache) {
                    alert("ì‹œí—˜ì§€ íŒŒì¼ì„ ìµœì†Œ 1ê°œ ì—…ë¡œë“œí•˜ì„¸ìš”. (ë˜ëŠ” OCR ìºì‹œ ì €ì¥íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”.)");
                    updateUIState(false);
                    return;
                }

                // New log session per new run; keep previous sessions unless the user explicitly clears.
                try {
                    logger.startNewSession({ reason: 'new' });
                    try {
                        const sel = getEl('log-filter-session-select');
                        if (sel) sel.value = 'current';
                        logger.setFilters({ session: 'current' });
                    } catch { }
                } catch { }

                successfulApiCallCount = 0;
                try { __callStats.reset(); } catch { }
                updateApiCallCounter();
                consumeStartFromOneShot();

                if (uploadedFiles.length > 0) {
                    try {
                        await processUploadedFiles();
                    } catch (e) {
                        logger.error("Workflow", `íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨: ${e.message}`);
                        updateUIState(false);
                        return;
                    }
                } else {
                    logger.info("Workflow", `OCR ìºì‹œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. íŒŒì¼ ì²˜ë¦¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤. (ë‹¨ìœ„: ${examPapers.length})`);
                }

                if (examPapers.length === 0) {
                    logger.error("Workflow", "File processing resulted in zero valid exam papers.");
                    updateUIState(false);
                    return;
                }

                logger.info("Workflow", "íŒŒì´í”„ë¼ì¸ì„ ì‹œì‘í•©ë‹ˆë‹¤...");

                // Fresh pipeline state
                // New process always starts from Phase 0 (extraction); override any UI startFrom.
                try {
                    pipelineConfig.runPlan = pipelineConfig.runPlan || {};
                    pipelineConfig.runPlan.startFrom = 'phase0';
                    pipelineConfig.runPhases = __computeRunPhases(pipelineConfig.runPlan);
                } catch { }
                activeProcess = {
                    status: 'processing',
                    activeTabId: 'phase0-extract',
                    chunkTokens: __clampInt(pipelineConfig?.phase1?.chunkTokens ?? DEFAULT_CHUNK_TOKENS, { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS }),
                    chunkTokensPhase1b: __clampInt(pipelineConfig?.phase1?.chunkTokens1b ?? (pipelineConfig?.phase1?.chunkTokens ?? DEFAULT_CHUNK_TOKENS), { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS }),
                    pipelineConfig: pipelineConfig,

                    phase0_extract: (() => {
                        const groups = new Map(); // sourceFileName -> [examUnit]
                        (examPapers || []).forEach(p => {
                            const src = p?.sourceFileName || p?.fileName || 'Unknown';
                            if (!groups.has(src)) groups.set(src, []);
                            groups.get(src).push(p);
                        });

                        return Array.from(groups.entries()).map(([paperName, units]) => {
                            const sorted = (units || []).slice().sort((a, b) => {
                                const ap = Number.isFinite(a?.pageStart) ? a.pageStart : Infinity;
                                const bp = Number.isFinite(b?.pageStart) ? b.pageStart : Infinity;
                                if (ap !== bp) return ap - bp;
                                const ai = Number.isFinite(a?.partIndex) ? a.partIndex : Infinity;
                                const bi = Number.isFinite(b?.partIndex) ? b.partIndex : Infinity;
                                if (ai !== bi) return ai - bi;
                                return String(a?.fileName || '').localeCompare(String(b?.fileName || ''));
                            });

                            const parts = sorted.map(u => {
                                const uFileName = u?.fileName || '';
                                const uSource = u?.sourceFileName || uFileName;
                                const isSplit = (u?.type === 'pdf') && (uFileName !== uSource);
                                const pStart = Number.isFinite(u?.pageStart) ? u.pageStart : null;
                                const pEnd = Number.isFinite(u?.pageEnd) ? u.pageEnd : null;
                                const pIdx = Number.isFinite(u?.partIndex) ? u.partIndex : null;
                                const unitLabel = (() => {
                                    if (u?.type !== 'pdf') return 'TXT';
                                    const smart = !!u?.smartRouter;
                                    if (smart) {
                                        const qids = Array.isArray(u?.targetLocalQids)
                                            ? u.targetLocalQids.map(x => String(x || '').trim()).filter(Boolean)
                                            : [];
                                        const qidPreview = qids.length
                                            ? `QIDs ${qids.slice(0, 6).join(', ')}${qids.length > 6 ? 'â€¦' : ''}`
                                            : '';
                                        const range = (pStart && pEnd) ? `p${pStart}-${pEnd}` : '';
                                        if (u?.smartRouterUnassigned) {
                                            return `Smart Unassigned${range ? `, ${range}` : ''}`;
                                        }
                                        const part = (pIdx && range) ? `Part ${pIdx}, ${range}` : (range ? range : (pIdx ? `Part ${pIdx}` : ''));
                                        const extras = [qidPreview, part].filter(Boolean).join(' Â· ');
                                        return extras ? `Smart Â· ${extras}` : 'Smart';
                                    }
                                    if (isSplit && pIdx && pStart && pEnd) return `Part ${pIdx}, p${pStart}-${pEnd}`;
                                    if (pStart && pEnd) return `Full PDF (p${pStart}-${pEnd})`;
                                    return 'Full PDF';
                                })();
                                return {
                                    unitId: uFileName,
                                    unitLabel,
                                    status: 'pending',
                                    qasByQid: null,
                                    error: null,
                                    partIndex: pIdx,
                                    pageStart: pStart,
                                    pageEnd: pEnd,
                                };
                            });

                            return {
                                paperName,
                                status: 'pending',
                                parts,
                                qasByQid: null,
                                error: null
                            };
                        });
                    })(),

                    phase1_patterns: {
                        status: 'pending',
                        standardCreation: { status: 'pending', perChunk: [], finalStandard: null },
                        perQuestion: [],
                        clusters: [],
                        error: null
                    },

                    phase2_modules: [],

                    typeOrdering: {
                        status: 'pending',
                        order: null,
                        error: null
                    },

                    phase3_finalManual: {
                        status: 'pending',
                        content: null,
                        error: null
                    }
                };
            }

            try {
                renderActiveProcess();

                const cfg = getPipelineConfig(activeProcess);
                const run = cfg?.runPhases || DEFAULT_PIPELINE_CONFIG.runPhases;
                const fullRun = !!(run.phase0 && run.phase1 && run.phase2 && run.phase3);

                // --- PHASE 0: EXTRACTION ---
                if (run.phase0) {
                    const hasPendingExtraction = activeProcess.phase0_extract.some(s => s.status === 'pending');
                    if (hasPendingExtraction) {
                        await generatePhase0Extraction();
                    } else {
                        logger.info("Workflow", "Phase 0: pending í•­ëª©ì´ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.");
                    }
                    if (processController.stop) throw new Error("Operation cancelled.");
                } else {
                    logger.info("Workflow", "Phase 0 skipped by config.");
                }

                // --- OPTIONAL: Apply separate answer-key files (if provided) ---
                if (!processController.stop) {
                    try {
                        const hasAnswerFiles = Array.isArray(uploadedAnswerFiles) && uploadedAnswerFiles.length > 0;
                        const hasExtracted = collectAllQuestions().length > 0;
                        if (hasAnswerFiles && hasExtracted) {
                            await applyUploadedAnswerKeyFilesToExtractedQuestions();
                        }
                    } catch (e) {
                        logger.warn("AnswerKey", `ì •ë‹µíŒŒì¼ ì ìš© ì‹¤íŒ¨(ê³„ì† ì§„í–‰): ${e?.message || e}`);
                    }
                }

	                // --- GUARD: Need extracted questions for Phase 1/2 ---
	                const allQuestions = collectAllQuestions();
	                if ((run.phase1 || run.phase2) && allQuestions.length === 0) {
	                    logger.warn("Workflow", "No extracted questions available for Phase 1/2.");
                    throw new Error("ì¶”ì¶œëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤. 0ë‹¨ê³„(ì¶”ì¶œ)ë¥¼ ì‹¤í–‰í•˜ê±°ë‚˜, ì¶”ì¶œ ê²°ê³¼ê°€ ë“¤ì–´ìˆëŠ” ì €ì¥íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”.");
                }

                // --- PHASE 1: CLASSIFICATION ---
                if (run.phase1) {
                    const p1Status = activeProcess.phase1_patterns?.status || 'unknown';
                    if (p1Status === 'pending') {
                        await generatePhase1Patterns();
                    } else {
                        logger.info("Workflow", `Phase 1: status=${p1Status} â†’ ê±´ë„ˆëœë‹ˆë‹¤.`);
                    }
                    if (processController.stop) throw new Error("Operation cancelled.");

                    const clusters = activeProcess.phase1_patterns?.clusters || [];
                    if (clusters.length === 0) {
                        logger.warn("Workflow", "Phase 1 did not produce any question clusters.");
                        throw new Error("ìœ í˜•ë¶„ë¥˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì–´ë–¤ ìœ í˜•ì—ë„ ë¶„ë¥˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
                    }
                } else {
                    logger.info("Workflow", "Phase 1 skipped by config.");

                    // If Phase 2 is enabled but modules were not built, build from existing clusters (if present).
                    if (run.phase2) {
                        const hasModules = Array.isArray(activeProcess.phase2_modules) && activeProcess.phase2_modules.length > 0;
                        if (!hasModules) {
                            const clusters = activeProcess.phase1_patterns?.clusters || [];
                            if (!clusters.length) {
                                logger.warn("Workflow", "2ë‹¨ê³„ëŠ” ìœ í˜•ë¶„ë¥˜ ê²°ê³¼(í´ëŸ¬ìŠ¤í„°/ëª¨ë“ˆ)ê°€ í•„ìš”í•©ë‹ˆë‹¤.");
                                throw new Error("ìœ í˜•ë¶„ë¥˜ ê²°ê³¼(í´ëŸ¬ìŠ¤í„°/ëª¨ë“ˆ)ê°€ ì—†ìŠµë‹ˆë‹¤. â€˜ì¬ì‹œì‘ ì§€ì â€™ì„ 1ë‹¨ê³„ë¡œ ì„¤ì •í•˜ê±°ë‚˜(ìœ í˜•ë¶„ë¥˜ ì¬ì‹¤í–‰), í´ëŸ¬ìŠ¤í„°/ëª¨ë“ˆì´ í¬í•¨ëœ ì €ì¥íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”.");
                            }
                            activeProcess.phase2_modules = clusters.map(cl => ({
                                pattern_name: cl.pattern_name,
                                parent_pattern_name: cl.parent_pattern_name || null,
                                status: 'pending',
                                qidsCovered: (cl.qids || []).slice(),
                            }));
                        }
                    }
                }

                // --- PHASE 2: MODULE GENERATION ---
                if (run.phase2) {
                    const hasPendingModules = (activeProcess.phase2_modules || []).some(m => m.status === 'pending');
                    if (hasPendingModules) {
                        await generatePhase2Modules();
                    } else {
                        logger.info("Workflow", "Phase 2: pending ëª¨ë“ˆì´ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.");
                    }
                    if (processController.stop) throw new Error("Operation cancelled.");

                    const completedModules = (activeProcess.phase2_modules || []).filter(m => m.status === 'completed');
                    if (completedModules.length === 0) {
                        logger.warn("Workflow", "2ë‹¨ê³„ì—ì„œ ì™„ë£Œëœ ëª¨ë“ˆì´ ì—†ìŠµë‹ˆë‹¤.");
                        throw new Error("ì„¤ëª… ëª¨ë“ˆì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (ì™„ë£Œëœ ëª¨ë“ˆì´ 0ê°œ)");
                    }
                } else {
                    logger.info("Workflow", "2ë‹¨ê³„ê°€ ì‹¤í–‰ ê³„íšì—ì„œ ì œì™¸ë˜ì—ˆìŠµë‹ˆë‹¤.");
                }

	                // --- PHASE 3: FINAL COLLATION ---
	                if (run.phase3) {
	                    if (activeProcess.phase3_finalManual?.status === 'pending') {
	                        buildFinalManual();
	                    }
	                    // --- OPTIONAL: export postprocess (postprocess-equivalent subgroupify / fill) ---
	                    if (!processController.stop) {
	                        try { await runExportPostprocessIfEnabled(); } catch (e) {
	                            logger.warn('ExportPostprocess', `Failed (continuing): ${e?.message || e}`);
	                        }
	                    }
	                } else {
	                    logger.info("Workflow", "3ë‹¨ê³„ê°€ ì‹¤í–‰ ê³„íšì—ì„œ ì œì™¸ë˜ì—ˆìŠµë‹ˆë‹¤.");
	                }

                if (!processController.stop) {
                    const pendingModulesRemain = Array.isArray(activeProcess.phase2_modules) && activeProcess.phase2_modules.some(m => m.status === 'pending');
                    if (fullRun && !pendingModulesRemain) {
                        activeProcess.status = 'completed';
                        logger.success("Workflow", "ì™„ë£Œ!");
                        updateStatus(__tGui('statusTitleCompleted'), __tGui('statusCompletedSubtext'));
                    } else {
                        activeProcess.status = 'paused';
                        logger.success("Workflow", "ì‹¤í–‰ ê³„íšì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. (ì¬ê°œ ê°€ëŠ¥)");
                        updateStatus(
                            __tGui('statusTitlePaused'),
                            pendingModulesRemain
                                ? __tGui('statusPausedPendingModulesSubtext')
                                : __tGui('statusPausedStopAfterSubtext')
                        );
                    }
                }

            } catch (error) {
                if (error.message.includes("cancelled")) {
                    activeProcess.status = 'stopped';
                    logger.warn("Workflow", "ì‚¬ìš©ìê°€ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.");
                    updateStatus(__tGui('statusTitleStopped'), __tGui('statusStoppedSubtext'));
                } else {
                    activeProcess.status = 'error';
                    activeProcess.error = error.message;
                    logger.error("Workflow", `ì¹˜ëª…ì  ì˜¤ë¥˜: ${error.message}`);
                    updateStatus(__tGui('statusTitleError'), __tGui('statusErrorSubtext'));
                }
            } finally {
                renderActiveProcess();
                updateUIState(false);
            }
        }

        //======================================================================
        // 5. FILE & INPUT HANDLING
        //======================================================================

        function getGlobalSplitPagesOverride() {
            const raw = getEl('global-split-pages-input')?.value;
            if (raw === '' || raw === null || raw === undefined) return null;
            const n = parseInt(raw, 10);
            if (!Number.isFinite(n) || n < 0) return null;
            return n;
        }

        function getGlobalKeySplitCountOverride() {
            const raw = getEl('global-key-split-count-input')?.value;
            if (raw === '' || raw === null || raw === undefined) return null;
            const n = parseInt(raw, 10);
            if (!Number.isFinite(n) || n < 1) return null;
            return Math.min(999, n);
        }

        function getEffectiveSplitPages(fileWrapper) {
            const local = parseInt(fileWrapper?.splitPages, 10);
            if (Number.isFinite(local) && local > 0) return local;
            const global = getGlobalSplitPagesOverride();
            if (Number.isFinite(global) && global > 0) return global;
            return 0;
        }

        function __inferMimeTypeFromFilename(filename) {
            const name = String(filename || '').toLowerCase().trim();
            if (!name) return '';
            if (name.endsWith('.pdf')) return 'application/pdf';
            if (name.endsWith('.png')) return 'image/png';
            if (name.endsWith('.jpg') || name.endsWith('.jpeg')) return 'image/jpeg';
            if (name.endsWith('.webp')) return 'image/webp';
            if (name.endsWith('.gif')) return 'image/gif';
            if (name.endsWith('.txt')) return 'text/plain';
            return '';
        }

        function __readFileAsDataUrl(file) {
            const f = file;
            return new Promise((resolve, reject) => {
                try {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(String(e?.target?.result || ''));
                    reader.onerror = () => reject(reader.error || new Error('FileReader failed'));
                    reader.readAsDataURL(f);
                } catch (e) {
                    reject(e);
                }
            });
        }

        async function __getCachedPdfFileEntry(file) {
            const f = file;
            const key = String(f?.name || '').trim();
            if (!key) throw new Error('Missing PDF file name');
            if (__phase0PdfFileCache.has(key)) return __phase0PdfFileCache.get(key);
            if (__phase0PdfFileCachePromises.has(key)) return await __phase0PdfFileCachePromises.get(key);

            const p = (async () => {
                const dataUrl = await __readFileAsDataUrl(f);
                const m = String(dataUrl || '').match(/^data:([^;]+);base64,(.+)$/i);
                if (!m) throw new Error('Failed to read PDF as base64 data URL');
                const mimeType = String(m[1] || '').trim() || (__inferMimeTypeFromFilename(f.name) || 'application/octet-stream');
                const base64 = String(m[2] || '').trim();
                const entry = { filename: f.name, mimeType, base64 };
                __phase0PdfFileCache.set(key, entry);
                return entry;
            })();

            __phase0PdfFileCachePromises.set(key, p);
            try {
                return await p;
            } finally {
                __phase0PdfFileCachePromises.delete(key);
            }
        }

        function __makeDataUrlFromBase64(entry) {
            const mimeType = String(entry?.mimeType || '').trim() || 'application/octet-stream';
            const base64 = String(entry?.base64 || '').trim();
            if (!base64) return '';
            return `data:${mimeType};base64,${base64}`;
        }

        function addFilesToList(files) {
            const globalSplitPages = getGlobalSplitPagesOverride();
            for (const file of files) {
                if (
                    (file.type === 'application/pdf' || file.type === 'text/plain') &&
                    !uploadedFiles.some(f => f.file.name === file.name)
                ) {
                    const splitPages = (file.type === 'application/pdf' && Number.isFinite(globalSplitPages) && globalSplitPages > 0)
                        ? globalSplitPages
                        : 0;
                    uploadedFiles.push({ file, splitPages });
                }
            }
            renderFileList();
        }

        function addAnswerFilesToList(files) {
            const globalSplitPages = getGlobalSplitPagesOverride();
            for (const file of files) {
                if (
                    (file.type === 'application/pdf' || file.type === 'text/plain') &&
                    !uploadedAnswerFiles.some(f => f.file.name === file.name)
                ) {
                    const splitPages = (file.type === 'application/pdf' && Number.isFinite(globalSplitPages) && globalSplitPages > 0)
                        ? globalSplitPages
                        : 0;
                    uploadedAnswerFiles.push({ file, splitPages });
                }
            }
            renderAnswerFileList();
        }

        function renderFileList() {
            const fileListEl = getEl('file-list');
            fileListEl.innerHTML = '';
            uploadedFiles.forEach((fileWrapper, index) => {
                const isPdf = fileWrapper.file.type === 'application/pdf';
                const li = document.createElement('li');
                li.className = 'file-list-item';

	                const pdfControls = isPdf ? `
	              <div class="file-list-item-controls">
	                <label for="split-${index}">${escapeHtmlForInnerHTML(__tGui('fileListSplitEveryLabel'))}</label>
	                <input type="number" id="split-${index}" class="ui-input" min="0" value="${fileWrapper.splitPages}" data-index="${index}">
	                <label for="split-${index}">${escapeHtmlForInnerHTML(__tGui('fileListSplitPagesLabel'))}</label>
	              </div>` : '';

                li.innerHTML = `
                <div class="file-list-item-header">
                    <span class="file-list-item-name" title="${fileWrapper.file.name}">${fileWrapper.file.name}</span>
	                    <button class="ui-btn" data-index="${index}" title="${escapeHtmlForInnerHTML(__tGui('fileListRemoveFileTitle'))}">
	                        <span class="material-symbols-outlined">delete</span>
	                    </button>
                </div>
                ${pdfControls}
              `;

                li.querySelector('button').addEventListener('click', (e) => {
                    const idx = e.currentTarget.dataset.index;
                    uploadedFiles.splice(idx, 1);
                    renderFileList();
                });

                if (isPdf) {
                    li.querySelector(`#split-${index}`).addEventListener('change', (e) => {
                        const idx = e.currentTarget.dataset.index;
                        const value = parseInt(e.currentTarget.value, 10);
                        uploadedFiles[idx].splitPages = isNaN(value) || value < 0 ? 0 : value;
                    });
                }

                fileListEl.appendChild(li);
            });

            const hasOcrCache = Array.isArray(examPapers) && examPapers.length > 0;
            const startDisabled = !isProcessResumable() && uploadedFiles.length === 0 && !hasOcrCache;
            getEl('start-button').disabled = startDisabled;
            if (uploadedFiles.length > 0) {
                updateStatus(__tGui('statusReadyTitle'), __tGuiFmt('statusReadyFilesLoadedFmt', { n: uploadedFiles.length }));
            } else if (hasOcrCache) {
                updateStatus(__tGui('statusReadyTitle'), __tGuiFmt('statusReadyOcrCacheLoadedFmt', { n: examPapers.length }));
            } else {
                updateStatus(__tGui('statusReadyTitle'), __tGui('statusReadySubtext'));
            }
        }

        function renderAnswerFileList() {
            const fileListEl = getEl('answer-file-list');
            if (!fileListEl) return;
            fileListEl.innerHTML = '';
            uploadedAnswerFiles.forEach((fileWrapper, index) => {
                const isPdf = fileWrapper.file.type === 'application/pdf';
                const li = document.createElement('li');
                li.className = 'file-list-item';

                const pdfControls = isPdf ? `
	              <div class="file-list-item-controls">
	                <label for="ans-split-${index}">${escapeHtmlForInnerHTML(__tGui('fileListSplitEveryLabel'))}</label>
	                <input type="number" id="ans-split-${index}" class="ui-input" min="0" value="${fileWrapper.splitPages}" data-index="${index}">
	                <label for="ans-split-${index}">${escapeHtmlForInnerHTML(__tGui('fileListSplitPagesLabel'))}</label>
	              </div>` : '';

                li.innerHTML = `
                <div class="file-list-item-header">
                    <span class="file-list-item-name" title="${fileWrapper.file.name}">${fileWrapper.file.name}</span>
	                    <button class="ui-btn" data-index="${index}" title="${escapeHtmlForInnerHTML(__tGui('answerFileListRemoveFileTitle'))}">
	                        <span class="material-symbols-outlined">delete</span>
	                    </button>
                </div>
                ${pdfControls}
              `;

                li.querySelector('button').addEventListener('click', (e) => {
                    const idx = e.currentTarget.dataset.index;
                    uploadedAnswerFiles.splice(idx, 1);
                    renderAnswerFileList();
                });

                if (isPdf) {
                    li.querySelector(`#ans-split-${index}`).addEventListener('change', (e) => {
                        const idx = e.currentTarget.dataset.index;
                        const value = parseInt(e.currentTarget.value, 10);
                        uploadedAnswerFiles[idx].splitPages = isNaN(value) || value < 0 ? 0 : value;
                    });
                }

                fileListEl.appendChild(li);
            });
        }

        // --- Optional local OCR via Tesseract.js (Phase 0) ---
        let __tesseractScriptPromise = null;
        async function __ensureTesseractJs() {
            if (typeof window !== 'undefined' && window.Tesseract) return window.Tesseract;
            if (!__tesseractScriptPromise) {
                __tesseractScriptPromise = new Promise((resolve, reject) => {
                    try {
                        const existing = document.querySelector('script[data-tesseract-js=\"1\"]');
                        if (existing) {
                            if (existing.dataset.loaded === '1') return resolve();
                            existing.addEventListener('load', () => resolve(), { once: true });
                            existing.addEventListener('error', () => reject(new Error('Failed to load Tesseract.js')), { once: true });
                            return;
                        }
                        const s = document.createElement('script');
                        s.dataset.tesseractJs = '1';
                        s.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
                        s.async = true;
                        s.onload = () => { try { s.dataset.loaded = '1'; } catch { } resolve(); };
                        s.onerror = () => reject(new Error('Failed to load Tesseract.js'));
                        document.head.appendChild(s);
                    } catch (e) {
                        reject(e);
                    }
                });
            }
            await __tesseractScriptPromise;
            if (typeof window === 'undefined' || !window.Tesseract) throw new Error('Tesseract.js not available after load');
            return window.Tesseract;
        }

        async function __tesseractOcr(imageDataUrl, lang, contextLabel) {
            const ctx = String(contextLabel || 'Tesseract');
            const language = String(lang || 'eng').trim() || 'eng';
            const T = await __ensureTesseractJs();
            logger.info(ctx, `Tesseract OCR start (lang=${language})`);
            const res = await T.recognize(imageDataUrl, language);
            const text = String(res?.data?.text || '').trim();
            logger.success(ctx, `Tesseract OCR done (${text.length} chars)`);
            return text;
        }

        // --- gpt-tokenizer CDN loader for accurate token counting ---
        let __tokenizerScriptPromise = null;
        let __tokenizerLoaded = false;
        async function __ensureGptTokenizer() {
            try {
                const tok = (typeof window !== 'undefined')
                    ? (window.o200k_base || window.GPTTokenizer_o200k_base || null)
                    : null;
                if (tok && typeof tok.encode === 'function') {
                    __tokenizerLoaded = true;
                    return tok;
                }
            } catch { }
            if (!__tokenizerScriptPromise) {
                __tokenizerScriptPromise = new Promise((resolve, reject) => {
                    try {
                        const existing = document.querySelector('script[data-gpt-tokenizer="1"]');
                        if (existing) {
                            if (existing.dataset.loaded === '1') { __tokenizerLoaded = true; return resolve(); }
                            // If the script loaded before we attached listeners, fall back to the global.
                            try {
                                const tok = window.o200k_base || window.GPTTokenizer_o200k_base || null;
                                if (tok && typeof tok.encode === 'function') { __tokenizerLoaded = true; return resolve(); }
                            } catch { }
                            existing.addEventListener('load', () => { __tokenizerLoaded = true; resolve(); }, { once: true });
                            existing.addEventListener('error', () => reject(new Error('Failed to load gpt-tokenizer')), { once: true });
                            return;
                        }
                        const s = document.createElement('script');
                        s.dataset.gptTokenizer = '1';
                        s.src = 'https://cdn.jsdelivr.net/npm/gpt-tokenizer@3.4.0/dist/o200k_base.min.js';
                        s.async = true;
                        s.onload = () => { try { s.dataset.loaded = '1'; __tokenizerLoaded = true; } catch { } resolve(); };
                        s.onerror = () => reject(new Error('Failed to load gpt-tokenizer'));
                        document.head.appendChild(s);
                    } catch (e) {
                        reject(e);
                    }
                });
            }
            await __tokenizerScriptPromise;
            try {
                const tok = window.o200k_base || window.GPTTokenizer_o200k_base || null;
                if (tok && typeof tok.encode === 'function') { __tokenizerLoaded = true; return tok; }
            } catch { }
            return null;
        }

        // gpt-tokenizer loading is now handled by __loadGptTokenizerLazy when user selects that mode

        /**
         * Count tokens in text using gpt-tokenizer (o200k_base).
         * Falls back to character-based estimate if tokenizer not loaded.
         */
        function countTokens(text) {
            return __countTokens(text);
        }

        /**
         * Async version that loads gpt-tokenizer if needed.
         */
        async function countTokensAsync(text) {
            if (__getTokenizerMode() === 'gpt_tokenizer_lazy') {
                try { await __loadGptTokenizerLazy(); } catch { }
            }
            return __countTokens(text);
        }

        function __parseQidsBlockText(raw) {
            const s = String(raw || '').replace(/\r/g, '').trim();
            if (!s) return [];
            // Prefer newline-separated (safe for QIDs with spaces)
            const lines = s.split('\n').map(x => x.trim()).filter(Boolean);
            if (lines.length > 1) return lines;
            // Fallback: allow comma/semicolon-separated on a single line
            const one = lines[0] || '';
            if (one.includes(',') || one.includes(';')) {
                return one
                    .split(/[;,]/g)
                    .map(x => x.trim())
                    .filter(Boolean);
            }
            return [one];
        }

        async function __getPdfEntryBySourceFileName(sourceFileName) {
            const key = String(sourceFileName || '').trim();
            if (!key) return null;
            if (__phase0PdfFileCache.has(key)) return __phase0PdfFileCache.get(key);
            const fw = (uploadedFiles || []).find(w => w?.file?.name === key);
            if (!fw || !fw.file) return null;
            try { return await __getCachedPdfFileEntry(fw.file); } catch { return null; }
        }

        async function __runPageToQidRouterForPdfFile(file, totalPages, { contextLabel } = {}) {
            const f = file;
            if (!f) throw new Error('Router: missing file');
            if (!Number.isFinite(totalPages) || totalPages <= 0) throw new Error('Router: invalid totalPages');

            const pdfEntry = await __getCachedPdfFileEntry(f);
            const pdfDataUrl = __makeDataUrlFromBase64(pdfEntry);
            const pdfPart = pdfDataUrl
                ? { type: 'image_url', image_url: { url: pdfDataUrl } }
                : null;
            if (!pdfPart) throw new Error('Router: failed to build PDF attachment');

            const userText =
                `You are a Pageâ†’QID router.\n` +
                `You are given ONE exam PDF file. Your task is to map each PDF page to the question IDs (QIDs) that the page belongs to.\n\n` +
                `RULES:\n` +
                `- A page can belong to multiple QIDs (e.g., two questions on the same page, or a solution page covering multiple QIDs).\n` +
                `- Include both question statements and any official answer/solution/explanation pages.\n` +
                `- If a page is a continuation with no explicit QID, infer the most likely QID(s) from context.\n` +
                `- In <qids>, output ONE QID per line. Preserve spaces if present.\n` +
                `- If a page contains no question/solution content (cover/blank), leave <qids> empty.\n\n` +
                `OUTPUT FORMAT (exactly ${totalPages} items; one per page_num 1..${totalPages}):\n` +
                `<data>\n` +
                `  <item>\n` +
                `    <id>1</id>\n` +
                `    <page_num>1</page_num>\n` +
                `    <qids>\n` +
                `Q1\n` +
                `Q2\n` +
                `    </qids>\n` +
                `    <confidence>0.82</confidence>\n` +
                `    <note>optional</note>\n` +
                `  </item>\n` +
                `  ...\n` +
                `</data>\n\n` +
                `Return ONLY the single <data> block.`;

            const payload = {
                model: getApiConfig().model,
                messages: [
                    {
                        role: 'system',
                        content: 'You route PDF pages to question IDs. Be conservative; do not hallucinate QIDs not supported by the PDF.'
                    },
                    { role: 'user', content: [{ type: 'text', text: userText }, pdfPart] }
                ]
            };

            const context = String(contextLabel || `PageToQidRouter-${f.name}`);
            const items = await requestAndParseDataEnvelope(payload, context, { phase: 'phase0' });

            const pageToQids = new Map(); // pageNum -> string[]
            const qidToPages = new Map(); // qid -> Set<number>
            const pageMeta = new Map(); // pageNum -> { confidence, note }

            (items || []).forEach(it => {
                const v = String(it?.value || '').trim();
                if (!v) return;
                const pageNum = parseInt(parseTag(v, 'page_num'), 10);
                if (!Number.isFinite(pageNum) || pageNum < 1 || pageNum > totalPages) return;
                const qids = __parseQidsBlockText(parseTag(v, 'qids'));
                const conf = parseFloat(parseTag(v, 'confidence'));
                const note = String(parseTag(v, 'note') || '').trim();
                pageToQids.set(pageNum, qids);
                pageMeta.set(pageNum, {
                    confidence: Number.isFinite(conf) ? conf : null,
                    note: note || null,
                });
                qids.forEach(qid => {
                    if (!qidToPages.has(qid)) qidToPages.set(qid, new Set());
                    qidToPages.get(qid).add(pageNum);
                });
            });

            // Ensure every page is present (empty qids allowed)
            for (let p = 1; p <= totalPages; p++) {
                if (!pageToQids.has(p)) pageToQids.set(p, []);
            }

            const unassignedPages = [];
            for (let p = 1; p <= totalPages; p++) {
                const q = pageToQids.get(p) || [];
                if (!q.length) unassignedPages.push(p);
            }

            return { pageToQids, qidToPages, unassignedPages, pageMeta };
        }

        function __packQidBlocksToBatches(qidToPages, maxPagesPerBatch) {
            const maxPages = Number.isFinite(maxPagesPerBatch) && maxPagesPerBatch > 0 ? maxPagesPerBatch : Infinity;

            const blocks = Array.from((qidToPages || new Map()).entries()).map(([qid, pagesSet]) => {
                const pages = Array.from(pagesSet || []).filter(p => Number.isFinite(p)).sort((a, b) => a - b);
                return { qid: String(qid || '').trim(), pages, minPage: pages.length ? pages[0] : Infinity };
            }).filter(b => b.qid && b.pages.length);

            blocks.sort((a, b) => {
                if (a.minPage !== b.minPage) return a.minPage - b.minPage;
                return a.qid.localeCompare(b.qid);
            });

            const batches = [];
            let cur = { qids: [], pagesSet: new Set(), qidToPages: {} };

            const flush = () => {
                if (!cur.qids.length) return;
                const pages = Array.from(cur.pagesSet).sort((a, b) => a - b);
                batches.push({
                    qids: cur.qids.slice(),
                    pages,
                    qidToPages: { ...cur.qidToPages },
                    pageStart: pages.length ? pages[0] : null,
                    pageEnd: pages.length ? pages[pages.length - 1] : null,
                });
                cur = { qids: [], pagesSet: new Set(), qidToPages: {} };
            };

            for (const b of blocks) {
                const nextPages = new Set(cur.pagesSet);
                b.pages.forEach(p => nextPages.add(p));
                if (cur.qids.length > 0 && nextPages.size > maxPages) {
                    flush();
                }
                // Atomic block: never split a single QID across batches.
                cur.qids.push(b.qid);
                cur.qidToPages[b.qid] = b.pages.slice();
                b.pages.forEach(p => cur.pagesSet.add(p));
            }
            flush();
            return batches;
        }

        async function processUploadedFiles() {
            examPapers = [];
            logger.info("FileProcessing", "Starting file processing with OCR...");

            // Phase 0 PDF input mode decides whether we generate images / run OCR.
            try {
                __phase0PdfFileCache.clear();
                __phase0PdfFileCachePromises.clear();
            } catch { }
            const cfg = getPipelineConfigFromUi();
            const pdfMode = cfg?.phase0?.pdfInputMode || 'multimodal';
            const multimodalTransport = String(cfg?.phase0?.multimodalTransport || 'images_raw_text').trim() || 'images_raw_text';
            const smartRouterEnabled = !!cfg?.phase0?.smartRouter?.enabled;
            const tessLang = cfg?.phase0?.tesseractLang || 'kor+eng';
            const enableImageCrops = !!cfg?.phase0?.experimentalImageCrops;
            const wantsPdfTransport = (pdfMode === 'multimodal' && multimodalTransport === 'pdf_raw_text');
            const needsImages =
                (pdfMode === 'tesseract_text') ||
                (pdfMode === 'multimodal' && multimodalTransport === 'images_raw_text') ||
                (pdfMode === 'multimodal' && enableImageCrops);
            const needsTesseract = (pdfMode === 'tesseract_text');
            updateStatus(
                "Processing Files...",
                smartRouterEnabled
                    ? "Smart router enabled: extracting pages â†’ Pageâ†’QID routing â†’ building QID-batch units..."
                    : (wantsPdfTransport
                        ? "Extracting raw PDF text (and caching PDF) for PDF+rawText OCR mode..."
                        : "Converting files and extracting text (PDF images/raw text)...")
            );
            if (needsTesseract) {
                logger.warn("FileProcessing", `Tesseract mode enabled (lang=${tessLang}). This runs OCR locally and can be slow.`);
            } else if (!needsImages) {
                logger.info("FileProcessing", `PDF mode = text-only / PDF transport (no rendered images). This is cheaper locally but may fail if the model cannot read the PDF.`);
            }
            if (smartRouterEnabled) {
                logger.info("FileProcessing", `Smart router: ON (Pageâ†’QID). splitPages is treated as max pages per extraction request; atomic QID blocks are never split.`);
            }

            const processingPromises = uploadedFiles.map(async (fileWrapper) => {
                const { file } = fileWrapper;
                const splitPages = getEffectiveSplitPages(fileWrapper);

                if (file.type === 'text/plain') {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            examPapers.push({
                                fileName: file.name,
                                sourceFileName: file.name,
                                type: 'txt',
                                content: e.target.result
                            });
                            logger.success("FileProcessing", `Processed TXT file: ${file.name}`);
                            resolve();
                        };
                        reader.onerror = () => reject(new Error(`Error reading ${file.name}`));
                        reader.readAsText(file);
                    });
                }

                if (file.type === 'application/pdf') {
                    // Cache the PDF for later router/extraction attachment (OpenAI-compatible file part / Gemini inlineData).
                    if (smartRouterEnabled || wantsPdfTransport) {
                        try {
                            await __getCachedPdfFileEntry(file);
                        } catch (e) {
                            logger.warn("FileProcessing", `Failed to cache PDF base64 for ${file.name}: ${e?.message || e}`);
                        }
                    }

                    const loadingTask = pdfjsLib.getDocument(URL.createObjectURL(file));
                    const pdf = await loadingTask.promise;
                    const totalPages = pdf.numPages;

                    // Process each page individually for OCR
                    const pageData = []; // [{pageNum, imageDataUrl?, rawText, ocrText?}]

                    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                        if (processController.stop) throw new Error("Operation cancelled.");

                        const page = await pdf.getPage(pageNum);

                        // Extract raw text
                        const textContent = await page.getTextContent();
                        const rawText = textContent.items.map(item => item.str).join(' ');

                        // Optionally render images for multimodal and/or local OCR
                        let imageDataUrl = null;
                        let ocrText = null;
                        if (needsImages) {
                            const viewport = page.getViewport({ scale: 1.5 });
                            const canvas = document.createElement('canvas');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            await page.render({
                                canvasContext: canvas.getContext('2d'),
                                viewport
                            }).promise;
                            imageDataUrl = canvas.toDataURL('image/jpeg', 0.85);
                        }
                        if (needsTesseract && imageDataUrl) {
                            try {
                                const lang = String(tessLang || 'eng').trim() || 'eng';
                                ocrText = await __tesseractOcr(imageDataUrl, lang, `Tesseract-${file.name}-p${pageNum}`);
                            } catch (e) {
                                logger.warn("FileProcessing", `Tesseract OCR failed for ${file.name} page ${pageNum}: ${e.message}`);
                                ocrText = '';
                            }
                        }

                        pageData.push({
                            pageNum,
                            imageDataUrl,
                            rawText: rawText.trim(),
                            ocrText: (ocrText || '').trim()
                        });

                        logger.info("FileProcessing", `Processed page ${pageNum}/${totalPages} of ${file.name}`);
                    }

                    const byPage = new Map(pageData.map(p => [p.pageNum, p]));

                    if (smartRouterEnabled) {
                        let routed = null;
                        try {
                            routed = await __runPageToQidRouterForPdfFile(file, totalPages, { contextLabel: `PageToQidRouter-${file.name}` });
                            logger.success(
                                "FileProcessing",
                                `Smart router OK: ${file.name} (qids=${routed?.qidToPages?.size || 0}, unassignedPages=${Array.isArray(routed?.unassignedPages) ? routed.unassignedPages.length : 0})`
                            );
                        } catch (e) {
                            logger.warn("FileProcessing", `Smart router failed for ${file.name} (fallback to sequential split): ${e?.message || e}`);
                            routed = null;
                        }

                        if (routed && routed.qidToPages) {
                            const batches = __packQidBlocksToBatches(routed.qidToPages, splitPages);
                            let smartPartIndex = 0;
                            for (const batch of (batches || [])) {
                                if (processController.stop) throw new Error("Operation cancelled.");
                                const pages = Array.isArray(batch?.pages) ? batch.pages : [];
                                const targetLocalQids = Array.isArray(batch?.qids) ? batch.qids.slice().filter(Boolean) : [];
                                if (!pages.length || !targetLocalQids.length) continue;

                                smartPartIndex++;
                                const startPage = Number.isFinite(batch?.pageStart) ? batch.pageStart : pages[0];
                                const endPage = Number.isFinite(batch?.pageEnd) ? batch.pageEnd : pages[pages.length - 1];
                                const partName = `${file.name} (Smart Part ${smartPartIndex}, p${startPage}-${endPage})`;

                                const relevantPages = pages.map(pn => byPage.get(pn)).filter(Boolean);
                                const images = needsImages ? relevantPages.map(p => p.imageDataUrl).filter(Boolean) : [];
                                const rawTexts = relevantPages.map(p => `[Page ${p.pageNum}]\n${p.rawText}`).join('\n\n');
                                const ocrTexts = needsTesseract
                                    ? relevantPages.map(p => `[Page ${p.pageNum}]\n${p.ocrText || ''}`).join('\n\n')
                                    : null;

                                examPapers.push({
                                    fileName: partName,
                                    sourceFileName: file.name,
                                    type: 'pdf',
                                    images,
                                    rawText: rawTexts,
                                    ocrText: ocrTexts,
                                    partIndex: smartPartIndex,
                                    pageStart: startPage,
                                    pageEnd: endPage,
                                    pageNums: pages.slice(),
                                    targetLocalQids,
                                    targetQidPages: (batch?.qidToPages && typeof batch.qidToPages === 'object') ? batch.qidToPages : null,
                                    smartRouter: true,
                                });

                                logger.success("FileProcessing", `Created smart exam unit: ${partName} (qids=${targetLocalQids.length}, pages=${pages.length})`);
                            }

                            const unassigned = (Array.isArray(routed?.unassignedPages) ? routed.unassignedPages : [])
                                .filter(pn => {
                                    const pd = byPage.get(pn);
                                    if (!pd) return false;
                                    const raw = String(pd.rawText || '').trim();
                                    return raw.length > 0 || !!pd.imageDataUrl || wantsPdfTransport;
                                })
                                .sort((a, b) => a - b);
                            if (unassigned.length) {
                                const maxPages = splitPages > 0 ? splitPages : unassigned.length;
                                let idx = 0;
                                for (let i = 0; i < unassigned.length; i += maxPages) {
                                    if (processController.stop) throw new Error("Operation cancelled.");
                                    idx++;
                                    const pages = unassigned.slice(i, i + maxPages);
                                    const startPage = pages[0];
                                    const endPage = pages[pages.length - 1];
                                    const partName = `${file.name} (Smart Unassigned ${idx}, p${startPage}-${endPage})`;

                                    const relevantPages = pages.map(pn => byPage.get(pn)).filter(Boolean);
                                    const images = needsImages ? relevantPages.map(p => p.imageDataUrl).filter(Boolean) : [];
                                    const rawTexts = relevantPages.map(p => `[Page ${p.pageNum}]\n${p.rawText}`).join('\n\n');
                                    const ocrTexts = needsTesseract
                                        ? relevantPages.map(p => `[Page ${p.pageNum}]\n${p.ocrText || ''}`).join('\n\n')
                                        : null;

                                    examPapers.push({
                                        fileName: partName,
                                        sourceFileName: file.name,
                                        type: 'pdf',
                                        images,
                                        rawText: rawTexts,
                                        ocrText: ocrTexts,
                                        partIndex: smartPartIndex + idx,
                                        pageStart: startPage,
                                        pageEnd: endPage,
                                        pageNums: pages.slice(),
                                        targetLocalQids: null,
                                        targetQidPages: null,
                                        smartRouter: true,
                                        smartRouterUnassigned: true,
                                    });
                                    logger.success("FileProcessing", `Created smart unassigned unit: ${partName} (pages=${pages.length})`);
                                }
                            }

                            // Done for this PDF in smart router mode.
                            return;
                        }
                    }

                    // Fallback: sequential chunking by splitPages
                    const splitInterval = splitPages > 0 ? splitPages : totalPages;
                    for (let i = 0; i < totalPages; i += splitInterval) {
                        if (processController.stop) throw new Error("Operation cancelled.");

                        const startPage = i + 1;
                        const endPage = Math.min(i + splitInterval, totalPages);
                        const partIndex = Math.floor(i / splitInterval) + 1;

                        const partName = splitPages > 0
                            ? `${file.name} (Part ${partIndex}, p${startPage}-${endPage})`
                            : file.name;

                        const relevantPages = pageData.slice(i, Math.min(i + splitInterval, totalPages));
                        const images = needsImages ? relevantPages.map(p => p.imageDataUrl).filter(Boolean) : [];
                        const rawTexts = relevantPages.map(p => `[Page ${p.pageNum}]\n${p.rawText}`).join('\n\n');
                        const ocrTexts = needsTesseract
                            ? relevantPages.map(p => `[Page ${p.pageNum}]\n${p.ocrText || ''}`).join('\n\n')
                            : null;

                        examPapers.push({
                            fileName: partName,
                            sourceFileName: file.name,
                            type: 'pdf',
                            images,
                            rawText: rawTexts,
                            ocrText: ocrTexts,
                            partIndex,
                            pageStart: startPage,
                            pageEnd: endPage,
                            pageNums: relevantPages.map(p => p.pageNum),
                            targetLocalQids: null,
                            targetQidPages: null,
                            smartRouter: false,
                        });

                        logger.success("FileProcessing", `Created exam unit: ${partName}`);
                    }
                }
            });

            await Promise.all(processingPromises);
            logger.info("FileProcessing", `File processing complete. Generated ${examPapers.length} total exam paper units.`);
        }

	        //======================================================================
	        // 6. UI RENDERING (TABS + CARDS)
	        //======================================================================

	        let __uiTabId = 'phase0-extract'; // when no activeProcess is loaded/created yet

	        function __renderNoActiveProcessTab(tabId) {
	            const t = String(tabId || '');
	            if (t === 'postprocess-save') return renderSavePostprocessing();
	            return `
	              <div class="ui-panel">
	                <div class="muted">
	                  No active pipeline state loaded yet.<br>
	                  - Upload exam papers and click Start, or<br>
	                  - Load a progress file, or<br>
	                  - Use "${escapeHtmlForInnerHTML(__tGui('tabPostprocessSave'))}" to patch an existing renderer save.
	                </div>
	              </div>
	            `;
	        }

	        function renderActiveProcess() {
	            renderTabs();
	            const container = getEl('pipelines-content-container');
	            const tabId = (activeProcess && activeProcess.activeTabId) ? activeProcess.activeTabId : (__uiTabId || 'phase0-extract');
	            if (!activeProcess) {
	                container.innerHTML = __renderNoActiveProcessTab(tabId);
	                return;
	            }
	            switch (tabId) {
	                case 'phase0-extract':
	                    container.innerHTML = renderPhase0AndPatternMap();
	                    break;
	                case 'phase2-modules':
	                    container.innerHTML = renderPhase2Modules();
	                    break;
	                case 'phase3-final':
	                    container.innerHTML = renderPhase3Final();
	                    break;
	                case 'postprocess-save':
	                    container.innerHTML = renderSavePostprocessing();
	                    break;
	            }
	        }

	        function renderTabs() {
	            const tabs = [
	                { id: 'phase0-extract', label: '1. Extraction & Classification' },
	                { id: 'phase2-modules', label: '2. Standard Problems & Explanations' },
	                { id: 'phase3-final', label: '3. Final Mastery Manual' },
	                { id: 'postprocess-save', label: __tGui('tabPostprocessSave') },
	            ];
	            const nav = getEl('tabs-nav-container');
	            const current = (activeProcess && activeProcess.activeTabId) ? activeProcess.activeTabId : (__uiTabId || 'phase0-extract');
		            nav.innerHTML = tabs.map(t =>
		                `<button class="ui-btn tab-button ${current === t.id ? 'active' : ''}" data-tab-id="${t.id}">${t.label}</button>`
		            ).join('');

	            nav.querySelectorAll('.tab-button').forEach(btn => {
	                btn.onclick = () => {
	                    const next = btn.dataset.tabId;
	                    if (activeProcess) activeProcess.activeTabId = next;
	                    else __uiTabId = next;
	                    renderActiveProcess();
	                };
	            });
	        }

        function renderMarkdown(text) {
            return text ? marked.parse(text) : '<p>No content yet.</p>';
        }

        function renderPhase0AndPatternMap() {
            if (!activeProcess) return '';

            // Extraction cards
            const extractionCards = (activeProcess.phase0_extract || []).map(s => {
                const parts = Array.isArray(s?.parts) ? s.parts : null;
                const partCounts = parts ? {
                    total: parts.length,
                    pending: parts.filter(p => p.status === 'pending').length,
                    processing: parts.filter(p => p.status === 'processing').length,
                    completed: parts.filter(p => p.status === 'completed').length,
                    error: parts.filter(p => p.status === 'error').length,
                } : null;
                const effectiveStatus = parts
                    ? (partCounts.processing > 0 ? 'processing' : (partCounts.pending > 0 ? 'pending' : (partCounts.error > 0 ? 'error' : 'completed')))
                    : (s.status || 'pending');

                const qCount = s.qasByQid ? Object.keys(s.qasByQid).length : 0;
                const partDetails = parts ? `
                <details>
                  <summary>View Parts (${partCounts.completed}/${partCounts.total} completed${partCounts.error ? `, ${partCounts.error} error` : ''})</summary>
                  <div class="refinement-card-body">
                    ${parts.map(p => {
                    const pc = p.qasByQid ? Object.keys(p.qasByQid).length : 0;
                    const label = p.unitLabel || p.unitId || 'Part';
                    const err = p.error ? `<div style="margin-top:4px; color: var(--error-color);">${escapeHtmlForInnerHTML(p.error)}</div>` : '';
                    return `
                        <p style="margin:0 0 8px 0;">
                          <strong>${escapeHtmlForInnerHTML(label)}</strong> (${pc} q)
                          <span class="status-badge status-${p.status}">${p.status}</span>
                          ${err}
                        </p>`;
                }).join('')}
                  </div>
                </details>` : '';

                const qaDetails = s.qasByQid ? `
                <details>
                  <summary>View Extracted Problems (${qCount})</summary>
                  <div class="refinement-card-body">
                    ${Object.entries(s.qasByQid).map(([qid, qa]) => `
                      <p>
                        <strong>${escapeHtmlForInnerHTML(qa.local_qid || qid)}</strong>: ${escapeHtmlForInnerHTML(qa.question_text)}<br>
                        <em>Choices:</em> ${escapeHtmlForInnerHTML(qa.answer_choices) || 'N/A'}<br>
                        <em>Ans:</em> ${escapeHtmlForInnerHTML(qa.official_answer) || 'N/A'}
                      </p>
                    `).join('')}
                  </div>
                </details>` : '';

	                return `
	                  <div class="ui-panel">
                      <h4 style="color: var(--accent);">
                        ${s.paperName}
                        <span class="status-badge status-${effectiveStatus}">${effectiveStatus}</span>
                      </h4>
                      ${s.error
                        ? `<p style="color: var(--error-color);">${escapeHtmlForInnerHTML(s.error)}</p>`
                        : `<p>${qCount} problems extracted.</p>`
                    }
                      ${partDetails}
                      ${qaDetails}
                  </div>
              `;
            }).join('');

            // Pattern clusters
            let patternSection = '';
            if (activeProcess.phase1_patterns) {
                const pat = activeProcess.phase1_patterns;
                const standard = pat.standardCreation ? pat.standardCreation.finalStandard : null;

                const standardDetails = standard ? `
                <details>
                  <summary>View Global Classification Standard (${standard.length} types)</summary>
                  <div class="refinement-card-body">
                    ${standard.map(t => `
                      <p>
                        <strong>${escapeHtmlForInnerHTML(t.type_name)}</strong><br>
                        ${escapeHtmlForInnerHTML(t.type_description)}
                      </p>
                    `).join('')}
                  </div>
                </details>
              ` : '';

                const perChunk = (activeProcess.phase1_patterns?.standardCreation?.perChunk) || [];
	                const perChunkDetails = perChunk.length ? `
                <details>
                  <summary>${escapeHtmlForInnerHTML(__tGuiFmt('p1PerChunkVerifyFmt', { n: perChunk.length }))}</summary>
                  <div class="refinement-card-body">
                    ${perChunk.map(c => {
                    const passCount = (c.attempts || []).filter(a => (a.evaluation?.decision || '').toLowerCase() === 'pass').length;
                    const failCount = (c.attempts || []).filter(a => (a.evaluation?.decision || '').toLowerCase() === 'fail').length;
                    const rounds = (c.attempts || []).length;
                    return `
                        <p>
                          <strong>Chunk ${c.chunkIndex + 1}</strong> â€” Types: ${c.typeCount}, Rounds: ${rounds}, 
                          Pass: ${passCount}, Fail: ${failCount}
                        </p>`;
                }).join('')}
                  </div>
                </details>
              ` : '';

	                const clusterCards = (pat.clusters || []).map(cl => `
	                  <div class="ui-panel" style="background: rgba(15, 23, 42, 0.35);">
                      <h5 style="color: var(--accent);">
                        ${escapeHtmlForInnerHTML(cl.pattern_name)}
                        <span class="status-badge status-${pat.status}">${pat.status}</span>
                      </h5>
                      <p><strong>QIDs:</strong> ${escapeHtmlForInnerHTML(cl.qids.join(', '))}</p>
                  </div>
              `).join('');

		                patternSection = `
		                  <div class="ui-panel">
		                      <h3 style="color: var(--accent);">
		                        ${escapeHtmlForInnerHTML(__tGui('p1ClustersTitle'))}
		                        <span class="status-badge status-${pat.status}">${pat.status}</span>
		                      </h3>
                      ${pat.error ? `<p style="color: var(--error-color);">${escapeHtmlForInnerHTML(pat.error)}</p>` : ''}
                      ${standardDetails}
                      ${perChunkDetails}
                      <div style="margin:0.5rem 0; display:flex; gap:8px; flex-wrap:wrap;">
			                        <button class="ui-btn" id="download-type-bundle-btn" ${!((activeProcess.phase1_patterns?.perQuestion || []).length) ? 'disabled' : ''}>
			                          ${escapeHtmlForInnerHTML(__tGui('p1TypeBundleDownloadButton'))}
			                        </button>
			                        <button class="ui-btn" id="run-subgrouping-btn" ${!((activeProcess.phase1_patterns?.perQuestion || []).length) ? 'disabled' : ''}>
			                          ${escapeHtmlForInnerHTML(__tGui('p1RunSubgroupingButton'))}
			                        </button>
			                        <button class="ui-btn" id="subgroupify-save-btn">
			                          ${escapeHtmlForInnerHTML(__tGui('p1SubgroupifySaveButton'))}
			                        </button>
                      </div>
                      <div style="display:flex; flex-direction:column; gap:0.5rem; margin-top:1rem;">
                          ${clusterCards}
                      </div>
                  </div>
              `;
            }

            return `<div class="card-grid">${extractionCards}</div>${patternSection}`;
        }

        function renderPhase2Modules() {
            const modules = activeProcess.phase2_modules || [];
            if (!modules.length) return '';

            // 1. Summary Header
            const pending = modules.filter(m => m.status === 'pending').length;
            const processing = modules.filter(m => m.status === 'processing' || m.status === 'in_progress' || m.status === 'running').length;
            const completed = modules.filter(m => m.status === 'completed' || m.status === 'done').length;
            const error = modules.filter(m => m.status === 'error' || m.status === 'failed').length;
            const total = modules.length;

	            const summaryHtml = `
	              <div class="ui-panel" style="margin-bottom:1rem;">
                <h4 style="margin-top:0;">${escapeHtmlForInnerHTML(__tGui('p2ProgressSummaryTitle'))}</h4>
                <div style="display:flex; gap:1rem; flex-wrap:wrap; margin-bottom: 0.5rem;">
                  <span>${escapeHtmlForInnerHTML(__tGuiFmt('p2ProgressTotalFmt', { n: total }))}</span>
                  <span class="status-badge status-pending">${escapeHtmlForInnerHTML(__tGuiFmt('p2ProgressPendingFmt', { n: pending }))}</span>
                  <span class="status-badge status-processing">${escapeHtmlForInnerHTML(__tGuiFmt('p2ProgressProcessingFmt', { n: processing }))}</span>
                  <span class="status-badge status-completed">${escapeHtmlForInnerHTML(__tGuiFmt('p2ProgressCompletedFmt', { n: completed }))}</span>
                  <span class="status-badge status-error">${escapeHtmlForInnerHTML(__tGuiFmt('p2ProgressErrorFmt', { n: error }))}</span>
                </div>
                <details>
                    <summary>${escapeHtmlForInnerHTML(__tGui('p2ProgressDetailsSummary'))}</summary>
                    <table style="margin-top:0.5rem; font-size:12px; width:100%; border-collapse: collapse;">
                      <tr style="text-align:left; border-bottom:1px solid var(--border);">
                        <th style="padding:4px;">${escapeHtmlForInnerHTML(__tGui('p2ProgressTableType'))}</th>
                        <th style="padding:4px;">${escapeHtmlForInnerHTML(__tGui('p2ProgressTableStatus'))}</th>
                        <th style="padding:4px;">${escapeHtmlForInnerHTML(__tGui('p2ProgressTableCalls'))}</th>
                        <th style="padding:4px;">${escapeHtmlForInnerHTML(__tGui('p2ProgressTableCoverage'))}</th>
                      </tr>
                      ${modules.map(m => {
                const calls = __callStats.getTypeCounts(m.pattern_name)?.total || 0;
                const cov = m.coverage;
                const covStr = cov?.missingQids ?
                    `${(m.qidsCovered?.length || 0) - (cov.missingQids.length)}/${m.qidsCovered?.length || 0}` : '-';
                return `<tr style="border-bottom:1px solid var(--border-subtle);">
                          <td style="padding:4px;">${escapeHtmlForInnerHTML(m.pattern_name)}</td>
                          <td style="padding:4px;"><span class="status-badge status-${m.status}">${m.status}</span></td>
                          <td style="padding:4px;">${calls}</td>
                          <td style="padding:4px;">${covStr}</td>
                        </tr>`;
            }).join('')}
                    </table>
                </details>
              </div>
            `;

            const cards = modules.map(m => {
                const cycles = m.refinementCycles || [];
                const lastCycle = cycles[cycles.length - 1];
                const accepted = lastCycle && lastCycle.isAcceptable;
                const cycleSummary = accepted
                    ? `Accepted after ${cycles.length} cycle(s).`
                    : (cycles.length > 0 ? `Completed ${cycles.length} cycle(s).` : 'No refinement yet.');

                const callCounts = (() => {
                    try { return __callStats.getTypeCounts(m.pattern_name); } catch { return { total: 0, stages: {}, cycles: {} }; }
                })();
                const st = callCounts?.stages || {};
                const avgLatType = (Number.isFinite(callCounts?.latencyMsTotal) && (callCounts?.total || 0) > 0)
                    ? `${((callCounts.latencyMsTotal / callCounts.total) / 1000).toFixed(2)}s`
                    : '-';
                const callsLine =
                    `total ${callCounts?.total || 0}` +
                    ` (avgLat ${avgLatType})` +
                    ` Â· std ${st.p2_std_problem || 0}` +
                    ` Â· exp ${st.p2_explanation || 0}` +
                    ` Â· fb ${st.p2_auditor || 0}` +
                    ` Â· revStd ${st.p2_revise_std_problem || 0}` +
                    ` Â· revExp ${st.p2_revise_explanation_patch || 0}` +
                    ` Â· covV ${st.p2_coverage_verify || 0}` +
                    ` Â· covP ${st.p2_coverage_patch || 0}`;

                const cov = m.coverage || null;
                const covMissing = Array.isArray(cov?.missingQids) ? cov.missingQids.length : null;
                const covMeta = cov?.meta || null;
                const covTotal = Array.isArray(m?.qidsCovered) ? m.qidsCovered.length : 0;
                const covCovered = (covMissing == null) ? null : Math.max(0, covTotal - covMissing);
                const covPct = (covCovered == null || covTotal <= 0)
                    ? null
                    : ((covCovered / covTotal) * 100).toFixed(1);
                const covSummary = (covMissing == null)
                    ? 'n/a'
                    : `${covCovered}/${covTotal} ì»¤ë²„ (${covPct ?? '0.0'}%) â€¢ missing ${covMissing}` +
                    (covMeta
                        ? ` (maxTokens=${covMeta.maxTokens}, maxRounds=${covMeta.maxRounds}, final=${covMeta.finalVerifyMode || 'n/a'}${covMeta.autoAccepted ? ', autoAccept=on' : ''})`
                        : '');

                const covTraceLines = (() => {
                    const rounds = covMeta?.tracer?.rounds;
                    if (!Array.isArray(rounds) || !rounds.length) return [];
                    const lines = [];
                    rounds.forEach(r => {
                        if (!r || typeof r !== 'object') return;
                        if (r.kind === 'verify') {
                            lines.push(`VERIFY  C${r.chunkIndex} R${r.round}: covered ${r.covered}/${r.verified} (missing ${r.missing})`);
                        } else if (r.kind === 'patch') {
                            lines.push(`PATCH   C${r.chunkIndex} R${r.round}: target ${r.patchTarget} (changed=${r.changed ? 'yes' : 'no'}${r.anyFailed ? ', applyFailed' : ''})`);
                        } else if (r.kind === 'auto_accept') {
                            lines.push(`AUTO    C${r.chunkIndex} R${r.round}: missing ${r.missingAtDecision} â‰¤ ${r.threshold} â†’ í™•ì •(ì¬ê²€ì¦ ìƒëµ)`);
                        } else {
                            // keep other tracer kinds if present
                            const k = String(r.kind || '').trim();
                            if (k) lines.push(`${k.toUpperCase()}  C${r.chunkIndex} R${r.round}`);
                        }
                    });
                    return lines;
                })();

                const events = Array.isArray(m.events) ? m.events : [];

                const covDisplay = (covTraceLines.length > 0) ? `
                    <details>
                      <summary>Coverage Trace (${covTraceLines.length})</summary>
                      <div class="refinement-card-body">${escapeHtmlForInnerHTML(covTraceLines.join('\\n'))}</div>
                    </details>
                  ` : '';

                const stdDisplay = m.standardProblem ? `
                    <details>
                      <summary>View Standard Problem</summary>
                      <div class="refinement-card-body">
                        <p><strong>Problem:</strong><br>${escapeHtmlForInnerHTML(m.standardProblem.problem)}</p>
                        <p><strong>Answer:</strong><br>${escapeHtmlForInnerHTML(m.standardProblem.answer)}</p>
                      </div>
                    </details>
                  ` : '';

                const expDisplay = m.explanation ? `
                    <details>
                      <summary>View Final Explanation</summary>
                      <div class="markdown-content">${renderMarkdown(m.explanation)}</div>
                    </details>
                  ` : '';

                const missingDisplay = (cov && Array.isArray(cov?.missingQids)) ? `
                    <details>
                      <summary>Coverage Missing QIDs (${cov.missingQids.length})</summary>
                      <div class="refinement-card-body">${escapeHtmlForInnerHTML((cov.missingQids || []).join('\\n'))}</div>
                    </details>
                  ` : '';

                const reportDisplay = (cov && Array.isArray(cov?.report)) ? `
                    <details>
                      <summary>Coverage Report (${cov.report.length})</summary>
                      <div class="refinement-card-body">${escapeHtmlForInnerHTML((cov.report || []).map(it => {
                    const st = it?.covered ? '[ì¶©ì¡±]' : '[ë¯¸ì¶©ì¡±]';
                    const qid = String(it?.qid || '').trim();
                    const reason = String(it?.reason || '').replace(/\s+/g, ' ').trim();
                    return `${st} ${qid}${reason ? ' â€” ' + reason : ''}`;
                }).join('\\n'))}</div>
                    </details>
                  ` : '';

                const feedbackDisplay = (cov && cov?.educationFeedback) ? `
                    <details>
                      <summary>Coverage Educational Feedback</summary>
                      <div class="markdown-content">${renderMarkdown(String(cov.educationFeedback))}</div>
                    </details>
                  ` : '';

	                return `
	              <div class="ui-panel">
	                  <details ${m.status !== 'completed' ? 'open' : ''}>
                      <summary>
                          <span style="color: var(--accent); font-weight:bold;">${escapeHtmlForInnerHTML(m.pattern_name)}</span>
                          <span class="status-badge status-${m.status}">${m.status}</span>
                      </summary>
                      <div style="margin-top:0.5rem;">
                          <p><strong>QIDs Covered:</strong> ${escapeHtmlForInnerHTML(m.qidsCovered.join(', '))}</p>
                          <p><strong>Calls (ok):</strong> ${escapeHtmlForInnerHTML(callsLine)}</p>
                          <p><strong>Refinement:</strong> ${cycleSummary}</p>
                          <p><strong>Coverage:</strong> ${escapeHtmlForInnerHTML(covSummary)}</p>
                          ${covDisplay}
                          ${m.error ? `<p style="color: var(--error-color);">${escapeHtmlForInnerHTML(m.error)}</p>` : ''}
                          ${stdDisplay}
                          ${expDisplay}
                          ${missingDisplay}
                          ${reportDisplay}
                          ${feedbackDisplay}
                          ${events.length ? `<details><summary>Events (${events.length})</summary><div class="refinement-card-body">${escapeHtmlForInnerHTML(events.map(e => `[${e.ts ? new Date(e.ts).toLocaleTimeString() : ''}] ${e.message}`).join('\\n'))}</div></details>` : ''}
                      </div>
                  </details>
              </div>
              `;
            }).join('');

            return summaryHtml + `<div class="card-grid">${cards}</div>`;
        }


	        function renderPhase3Final() {
            const g = activeProcess.phase3_finalManual || {};
            const content = g.content ||
                (g.status === 'pending'
                    ? __tGui('finalGuideNotReady')
                    : __tGui('finalGuideBuilding'));

	            return `
		              <div class="ui-panel">
	                  <h3 style="color: var(--accent);">
	                    ${escapeHtmlForInnerHTML(__tGui('finalGuideTitle'))}
	                    <span class="status-badge status-${g.status}">${g.status}</span>
	                  </h3>
	                  ${g.error ? `<p style="color: var(--error-color);">${escapeHtmlForInnerHTML(g.error)}</p>` : ''}
                    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top: 0.25rem;">
                      <button class="ui-btn" id="download-renderer-save-btn"
                        style="border-color: var(--secondary-accent); background: rgba(56, 189, 248, 0.10);"
                        ${!g.content ? 'disabled' : ''}>
                        ${escapeHtmlForInnerHTML(__tGui('finalGuideDownloadRendererSaveButton'))}
                      </button>
                    </div>
		                  <textarea class="ui-input" rows="20" readonly>${content}</textarea>
		                  <button class="ui-btn" id="download-btn" style="margin-top: 1rem;" ${!g.content ? 'disabled' : ''}>
		                      ${escapeHtmlForInnerHTML(__tGui('finalGuideDownloadTxtButton'))}
		                  </button>
		              </div>
			          `;
	        }

	        // ----- SAVE POSTPROCESSING (import a renderer save and patch it) -----
	        const POSTPROCESS_SAVE_SETTINGS_KEY = 'mastery_manual_postprocess_save_settings_v1';
	        const __postprocessSave = (() => {
	            const DEFAULT = {
	                subgroupChunkTokens: DEFAULT_CHUNK_TOKENS,
	                fillChunkTokens: DEFAULT_CHUNK_TOKENS,
	                typeGuideMaxChars: 12000,
	                includeTypeGuide: true,
	                fillAnswers: true,
	                fillExplanations: true,
	                overwriteAnswers: false,
	                overwriteExplanations: false,
	                useDuckDuckGo: false,
	            };
	            const state = {
	                fileName: '',
	                original: null,
	                working: null,
	                loadedAt: null,
	                summary: null,
	                settings: { ...DEFAULT },
	                run: { running: false, stop: false, status: '', progress: '' },
	            };
	
	            const loadSettings = () => {
	                try {
	                    const raw = localStorage.getItem(POSTPROCESS_SAVE_SETTINGS_KEY);
	                    const parsed = raw ? JSON.parse(raw) : null;
	                    if (parsed && typeof parsed === 'object') {
	                        state.settings = { ...DEFAULT, ...parsed };
	                    } else {
	                        state.settings = { ...DEFAULT };
	                    }
	                } catch {
	                    state.settings = { ...DEFAULT };
	                }
	            };
	            const saveSettings = () => {
	                try { localStorage.setItem(POSTPROCESS_SAVE_SETTINGS_KEY, JSON.stringify(state.settings)); } catch { }
	            };
	
	            const resetWorking = () => {
	                state.working = state.original ? __deepClone(state.original) : null;
	                state.summary = state.working ? __summarizeImportedSaveForPostprocess(state.working) : null;
	            };
	
	            // Initialize once
	            loadSettings();
	
	            return { state, DEFAULT, loadSettings, saveSettings, resetWorking };
	        })();
	
	        function __summarizeImportedSaveForPostprocess(obj) {
	            const out = {
	                kind: '',
	                typesCount: 0,
	                problemsCount: 0,
	                missingAnswers: 0,
	                missingExplanations: 0,
	                subgroupTagged: 0,
	                hasGuide: false,
	            };
	            try {
	                const extracted = __extractTypesFromImportedSave(obj);
	                out.kind = extracted.kind || '';
	                const types = extracted.types || {};
	                out.typesCount = Object.keys(types).length;
	                for (const listRaw of Object.values(types)) {
	                    const list = Array.isArray(listRaw) ? listRaw : [];
	                    out.problemsCount += list.length;
	                    list.forEach(p => {
	                        const ans = String(p?.official_answer ?? p?.officialAnswer ?? '').trim();
	                        const exp = String(p?.official_explanation ?? p?.officialExplanation ?? '').trim();
	                        if (!ans) out.missingAnswers++;
	                        if (!exp) out.missingExplanations++;
	                        const sg = String(p?.subgroup_tag ?? p?.subgroupTag ?? '').trim();
	                        if (sg) out.subgroupTagged++;
	                    });
	                }
	            } catch { }
	            try {
	                out.hasGuide = !!(obj && obj.__fmm_bundle__ === 1 && obj.items && obj.items.fmm_source && obj.items.fmm_source.value);
	            } catch { }
	            return out;
	        }
	
	        function renderSavePostprocessing() {
	            const st = __postprocessSave.state;
	            const s = st.settings || {};
	            const sum = st.summary || null;
	            const disabled = !st.working || st.run.running;
	            const canRunFill = !!st.working;
	
	            const summaryHtml = sum ? `
	              <div class="ui-panel" style="margin-top:0.75rem;">
	                <div style="font-size:12px; color:var(--text-2); font-family:monospace;">
	                  <div>kind: ${escapeHtmlForInnerHTML(sum.kind || '-')}</div>
	                  <div>types: ${sum.typesCount} Â· problems: ${sum.problemsCount}</div>
	                  <div>missing official_answer: ${sum.missingAnswers} Â· missing official_explanation: ${sum.missingExplanations}</div>
	                  <div>subgroup_tag present: ${sum.subgroupTagged}</div>
	                  <div>guide attached (fmm_source): ${sum.hasGuide ? 'YES' : 'NO'}</div>
	                </div>
	              </div>
	            ` : '';
	
	            const runStatus = st.run.status ? `<div class="muted" style="margin-top:6px;">${escapeHtmlForInnerHTML(st.run.status)}</div>` : '';
	            const runProgress = st.run.progress ? `<div class="muted" style="margin-top:4px; font-family:monospace; font-size:12px; white-space:pre-wrap;">${escapeHtmlForInnerHTML(st.run.progress)}</div>` : '';
	
	            return `
	              <div class="ui-panel">
	                <h3 style="color: var(--accent); margin-top:0;">${escapeHtmlForInnerHTML(__tGui('tabPostprocessSave'))}</h3>
	                <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
	                  <button class="ui-btn" id="postprocess-load-btn">${escapeHtmlForInnerHTML(__tGui('ppLoadSaveButton'))}</button>
	                  <button class="ui-btn" id="postprocess-reset-btn" ${!st.original || st.run.running ? 'disabled' : ''}>${escapeHtmlForInnerHTML(__tGui('ppResetWorkingButton'))}</button>
	                  <button class="ui-btn" id="postprocess-download-btn" ${!st.working ? 'disabled' : ''}>${escapeHtmlForInnerHTML(__tGui('ppDownloadWorkingButton'))}</button>
	                  <button class="ui-btn" id="postprocess-stop-btn" ${!st.run.running ? 'disabled' : ''}>${escapeHtmlForInnerHTML(__tGui('ppStopButton'))}</button>
	                  <span class="muted" style="font-size:12px;">${escapeHtmlForInnerHTML(st.fileName ? (__tGuiFmt('ppLoadedFileFmt', { name: st.fileName })) : __tGui('ppNoFileLoaded'))}</span>
	                </div>
	                ${summaryHtml}
	
	                <div class="ui-panel" style="margin-top:0.75rem;">
	                  <h4 style="margin:0 0 6px 0;">${escapeHtmlForInnerHTML(__tGui('ppSubgroupSectionTitle'))}</h4>
	                  <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
	                    <label class="muted" style="font-size:12px;">${escapeHtmlForInnerHTML(__tGui('ppChunkTokensLabel'))}
	                      <input class="ui-input" id="pp-subgroup-chunk-tokens" type="number" min="1000" max="400000"
	                        value="${escapeHtmlForInnerHTML(String(s.subgroupChunkTokens || DEFAULT_CHUNK_TOKENS))}"
	                        style="width:140px; margin-left:6px;">
	                    </label>
	                    <button class="ui-btn" id="postprocess-run-subgroup-btn" ${disabled ? 'disabled' : ''}>${escapeHtmlForInnerHTML(__tGui('ppRunSubgroupButton'))}</button>
	                  </div>
	                </div>
	
	                <div class="ui-panel" style="margin-top:0.75rem;">
	                  <h4 style="margin:0 0 6px 0;">${escapeHtmlForInnerHTML(__tGui('ppFillSectionTitle'))}</h4>
	                  <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
	                    <label class="muted" style="font-size:12px;">
	                      <input type="checkbox" id="pp-fill-answers" ${s.fillAnswers ? 'checked' : ''}>
	                      ${escapeHtmlForInnerHTML(__tGui('ppFillAnswersLabel'))}
	                    </label>
	                    <label class="muted" style="font-size:12px;">
	                      <input type="checkbox" id="pp-fill-explanations" ${s.fillExplanations ? 'checked' : ''}>
	                      ${escapeHtmlForInnerHTML(__tGui('ppFillExplanationsLabel'))}
	                    </label>
	                    <label class="muted" style="font-size:12px;">
	                      <input type="checkbox" id="pp-overwrite-answers" ${s.overwriteAnswers ? 'checked' : ''}>
	                      ${escapeHtmlForInnerHTML(__tGui('ppOverwriteAnswersLabel'))}
	                    </label>
	                    <label class="muted" style="font-size:12px;">
	                      <input type="checkbox" id="pp-overwrite-explanations" ${s.overwriteExplanations ? 'checked' : ''}>
	                      ${escapeHtmlForInnerHTML(__tGui('ppOverwriteExplanationsLabel'))}
	                    </label>
	                  </div>
	                  <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:6px;">
	                    <label class="muted" style="font-size:12px;">
	                      <input type="checkbox" id="pp-include-type-guide" ${s.includeTypeGuide ? 'checked' : ''}>
	                      ${escapeHtmlForInnerHTML(__tGui('ppIncludeTypeGuideLabel'))}
	                    </label>
	                    <label class="muted" style="font-size:12px;">${escapeHtmlForInnerHTML(__tGui('ppTypeGuideMaxCharsLabel'))}
	                      <input class="ui-input" id="pp-type-guide-max-chars" type="number" min="200" max="200000"
	                        value="${escapeHtmlForInnerHTML(String(s.typeGuideMaxChars || 12000))}"
	                        style="width:140px; margin-left:6px;">
	                    </label>
	                    <label class="muted" style="font-size:12px;">${escapeHtmlForInnerHTML(__tGui('ppChunkTokensLabel'))}
	                      <input class="ui-input" id="pp-fill-chunk-tokens" type="number" min="1000" max="400000"
	                        value="${escapeHtmlForInnerHTML(String(s.fillChunkTokens || DEFAULT_CHUNK_TOKENS))}"
	                        style="width:140px; margin-left:6px;">
	                    </label>
	                    <label class="muted" style="font-size:12px;">
	                      <input type="checkbox" id="pp-fill-ddg" ${s.useDuckDuckGo ? 'checked' : ''}>
	                      ${escapeHtmlForInnerHTML(__tGui('ppUseDuckDuckGoLabel'))}
	                    </label>
	                  </div>
	                  <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:8px;">
	                    <button class="ui-btn" id="postprocess-run-fill-btn" ${(!canRunFill || st.run.running) ? 'disabled' : ''}>${escapeHtmlForInnerHTML(__tGui('ppRunFillButton'))}</button>
	                    <button class="ui-btn" id="postprocess-run-both-btn" ${(!canRunFill || st.run.running) ? 'disabled' : ''}>${escapeHtmlForInnerHTML(__tGui('ppRunBothButton'))}</button>
	                  </div>
	                  <div class="muted" style="margin-top:6px; font-size:12px; line-height:1.4;">
	                    ${escapeHtmlForInnerHTML(__tGui('ppFillHelpText'))}
	                  </div>
	                </div>
	
	                ${runStatus}
	                ${runProgress}
	              </div>
	            `;
	        }


        // Download final manual as .txt
        document.body.addEventListener('click', e => {
            if (e.target && e.target.id === 'download-btn') {
                const ta = document.querySelector('#pipelines-content-container textarea');
                const text = ta ? ta.value : '';
                const blob = new Blob([text], { type: 'text/plain' });
                const a = document.createElement('a');
                a.download = `mastery_manual_final.txt`;
                a.href = URL.createObjectURL(blob);
                a.click();
                URL.revokeObjectURL(a.href);
            }
        });

        // Phase1: manual subgrouping run (without re-running classification)
        document.body.addEventListener('click', async (e) => {
            if (!e.target || e.target.id !== 'run-subgrouping-btn') return;
            try {
                const p1 = activeProcess?.phase1_patterns || null;
                if (!p1 || !(Array.isArray(p1?.perQuestion) && p1.perQuestion.length) || !(Array.isArray(p1?.clusters) && p1.clusters.length)) {
                    alert(__tGui('exportNoTypeResultsError'));
                    return;
                }
                const st = String(p1?.subgrouping?.status || '').toLowerCase();
                if (st === 'processing' || st === 'in_progress' || st === 'running') {
                    logger.warn('Phase1Subgroup', 'Subgrouping is already running.');
                    return;
                }
                const sgCfg = (() => {
                    try { return getPipelineConfig(activeProcess)?.phase1?.subgrouping || getPipelineConfigFromUi()?.phase1?.subgrouping || {}; } catch { return {}; }
                })();
                p1.subgrouping = p1.subgrouping && typeof p1.subgrouping === 'object' ? p1.subgrouping : {};
                p1.subgrouping.status = 'processing';
                p1.subgrouping.error = null;
                renderActiveProcess();
                await runPhase1SubgroupingFromClusters(p1, { chunkTokens: sgCfg?.chunkTokens });
                p1.subgrouping.status = 'completed';
                p1.subgrouping.completedAt = new Date().toISOString();
                renderActiveProcess();
            } catch (err) {
                const msg = err?.message || String(err || '');
                try {
                    activeProcess.phase1_patterns.subgrouping = activeProcess.phase1_patterns.subgrouping && typeof activeProcess.phase1_patterns.subgrouping === 'object'
                        ? activeProcess.phase1_patterns.subgrouping
                        : {};
                    activeProcess.phase1_patterns.subgrouping.status = 'error';
                    activeProcess.phase1_patterns.subgrouping.error = msg;
                } catch { }
                logger.error('Phase1Subgroup', `Failed to run subgrouping: ${msg}`);
                alert(__tGui('exportFailedCheckLogsAlert'));
                renderActiveProcess();
            }
        });

	        // Phase1 tool: subgroupify an existing renderer save (.json)
	        document.body.addEventListener('click', (e) => {
	            if (!e.target || e.target.id !== 'subgroupify-save-btn') return;
	            const input = getEl('subgroupify-save-input');
	            if (input) input.click();
	        });

	        // Save postprocessing: load input trigger
	        document.body.addEventListener('click', (e) => {
	            if (!e.target || e.target.id !== 'postprocess-load-btn') return;
	            const input = getEl('postprocess-save-input');
	            if (input) input.click();
	        });

	        // Save postprocessing: settings sync
	        document.body.addEventListener('change', (e) => {
	            const id = e?.target?.id || '';
	            const s = __postprocessSave?.state?.settings;
	            if (!s) return;
	            const clampTokens = (v) => __clampInt(v, { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS });
	            const clampChars = (v) => __clampInt(v, { min: 200, max: 200000, fallback: 12000 });
	
	            if (id === 'pp-subgroup-chunk-tokens') s.subgroupChunkTokens = clampTokens(e.target.value);
	            else if (id === 'pp-fill-chunk-tokens') s.fillChunkTokens = clampTokens(e.target.value);
	            else if (id === 'pp-type-guide-max-chars') s.typeGuideMaxChars = clampChars(e.target.value);
	            else if (id === 'pp-fill-answers') s.fillAnswers = !!e.target.checked;
	            else if (id === 'pp-fill-explanations') s.fillExplanations = !!e.target.checked;
	            else if (id === 'pp-overwrite-answers') s.overwriteAnswers = !!e.target.checked;
	            else if (id === 'pp-overwrite-explanations') s.overwriteExplanations = !!e.target.checked;
	            else if (id === 'pp-include-type-guide') s.includeTypeGuide = !!e.target.checked;
	            else if (id === 'pp-fill-ddg') s.useDuckDuckGo = !!e.target.checked;
	            else return;
	
	            try { __postprocessSave.saveSettings(); } catch { }
	            try { renderActiveProcess(); } catch { }
	        });

	        // Save postprocessing: actions
	        document.body.addEventListener('click', async (e) => {
	            const id = e?.target?.id || '';
	            if (!id || !id.startsWith('postprocess-')) return;
	            const st = __postprocessSave.state;
	            if (!st) return;
	
	            if (id === 'postprocess-reset-btn') {
	                if (!st.original || st.run.running) return;
	                __postprocessSave.resetWorking();
	                renderActiveProcess();
	                logger.success('Postprocess', 'Reset working copy to original.');
	                return;
	            }
	            if (id === 'postprocess-download-btn') {
	                if (!st.working) return;
	                try {
	                    const stamp = new Date().toISOString().slice(0, 10);
	                    const base = (st.fileName || 'save').replace(/\.[^.]+$/, '') || 'save';
	                    __downloadJsonFile(`${base}_postprocessed_${stamp}.json`, st.working);
	                    logger.success('Postprocess', 'Downloaded working save.');
	                } catch (err) {
	                    logger.error('Postprocess', `Download failed: ${err?.message || err}`);
	                    alert(__tGui('exportFailedCheckLogsAlert'));
	                }
	                return;
	            }
	            if (id === 'postprocess-stop-btn') {
	                if (!st.run.running) return;
	                st.run.stop = true;
	                try { processController.stop = true; } catch { }
	                st.run.status = __tGui('ppStopRequested');
	                renderActiveProcess();
	                logger.warn('Postprocess', 'Stop requested (will stop after current call).');
	                return;
	            }
	
	            if (!st.working) return;
	            if (st.run.running) return;
	
	            const runWrap = async (label, fn) => {
	                st.run.running = true;
	                st.run.stop = false;
	                st.run.status = label;
	                st.run.progress = '';
	                try { processController.stop = false; } catch { }
	                renderActiveProcess();
	                try {
	                    await fn();
	                } catch (err) {
	                    const msg = err?.message || String(err || '');
	                    const low = msg.toLowerCase();
	                    const isCancelled =
	                        processController.stop ||
	                        low.includes('cancelled') ||
	                        low.includes('canceled') ||
	                        low.includes('operation cancelled') ||
	                        low.includes('stopped by user');
	                    st.run.status = isCancelled ? __tGui('ppStopRequested') : msg;
	                    logger.error('Postprocess', `Run failed: ${msg}`);
	                    if (!isCancelled) alert(__tGui('exportFailedCheckLogsAlert'));
	                } finally {
	                    st.run.running = false;
	                    renderActiveProcess();
	                }
	            };
	
	            if (id === 'postprocess-run-subgroup-btn') {
	                await runWrap(__tGui('ppRunningSubgroup'), async () => {
	                    const tok = st.settings?.subgroupChunkTokens;
	                    const res = await subgroupifyImportedSaveObject(st.working, { chunkTokens: tok });
	                    st.working = res.updated;
	                    st.summary = __summarizeImportedSaveForPostprocess(st.working);
	                    st.run.status = __tGuiFmt('ppDoneSubgroupFmt', { n: res.assigned || 0 });
	                    logger.success('Postprocess', `Subgroupify done. assigned=${res.assigned || 0}`);
	                });
	                return;
	            }
	            if (id === 'postprocess-run-fill-btn') {
	                await runWrap(__tGui('ppRunningFill'), async () => {
	                    const res = await fillAnswersForImportedSaveObject(st.working, { settings: st.settings });
	                    st.working = res.updated;
	                    st.summary = __summarizeImportedSaveForPostprocess(st.working);
	                    st.run.status = __tGuiFmt('ppDoneFillFmt', { a: res.filledAnswers || 0, e: res.filledExplanations || 0 });
	                    logger.success('Postprocess', `Answer fill done. answers=${res.filledAnswers || 0}, expl=${res.filledExplanations || 0}`);
	                });
	                return;
	            }
	            if (id === 'postprocess-run-both-btn') {
	                await runWrap(__tGui('ppRunningBoth'), async () => {
	                    const tok = st.settings?.subgroupChunkTokens;
	                    const sg = await subgroupifyImportedSaveObject(st.working, { chunkTokens: tok });
	                    st.working = sg.updated;
	                    st.summary = __summarizeImportedSaveForPostprocess(st.working);
	                    st.run.progress = __tGuiFmt('ppProgressAfterSubgroupFmt', { n: sg.assigned || 0 });
	                    renderActiveProcess();
	
	                    const fill = await fillAnswersForImportedSaveObject(st.working, { settings: st.settings });
	                    st.working = fill.updated;
	                    st.summary = __summarizeImportedSaveForPostprocess(st.working);
	                    st.run.status = __tGuiFmt('ppDoneBothFmt', { sg: sg.assigned || 0, a: fill.filledAnswers || 0, e: fill.filledExplanations || 0 });
	                    logger.success('Postprocess', `Both done. subgroup=${sg.assigned || 0}, answers=${fill.filledAnswers || 0}, expl=${fill.filledExplanations || 0}`);
	                });
	                return;
	            }
	        });

	        function __downloadJsonFile(filename, obj) {
	            const jsonString = JSON.stringify(obj, null, 2);
	            const blob = new Blob([jsonString], { type: 'application/json' });
            const a = document.createElement('a');
            a.download = filename;
            a.href = URL.createObjectURL(blob);
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function __extractTypesFromImportedSave(obj) {
            if (!obj || typeof obj !== 'object') throw new Error('JSON root is not an object.');
            // Preferred: fmm_export bundle
            if (obj.__fmm_bundle__ === 1 && obj.items && obj.items.fmm_problems_json && obj.items.fmm_problems_json.value) {
                const v = obj.items.fmm_problems_json.value;
                if (v && typeof v === 'object' && v.types && typeof v.types === 'object' && !Array.isArray(v.types)) {
                    return { kind: 'bundle', root: obj, types: v.types };
                }
            }
            // Fallback: plain { types: { ... } }
            if (obj.types && typeof obj.types === 'object' && !Array.isArray(obj.types)) {
                return { kind: 'types', root: obj, types: obj.types };
            }
            throw new Error('Unsupported file. Expected fmm_export bundle (__fmm_bundle__==1) or {types:{...}} JSON.');
        }

        async function subgroupifyImportedSaveObject(obj, { chunkTokens } = {}) {
            const cloned = __deepClone(obj);
            const extracted = __extractTypesFromImportedSave(cloned);
            const types = extracted.types;
            const typeNames = Object.keys(types || {});
            if (!typeNames.length) throw new Error('No types found in save file.');

            // Normalize problem fields for subgrouping input only (preserve original objects for output).
            const inputMap = {};
            for (const [typeName, listRaw] of Object.entries(types || {})) {
                const list = Array.isArray(listRaw) ? listRaw : [];
                inputMap[typeName] = list.map(p => ({
                    qid: String(p?.qid || '').trim(),
                    question_text: String(p?.question_text ?? p?.questionText ?? p?.question ?? ''),
                    answer_choices: String(p?.answer_choices ?? p?.answerChoices ?? p?.choices ?? ''),
                })).filter(p => p.qid);
            }

            const sgCfg = (() => {
                try { return getPipelineConfigFromUi()?.phase1?.subgrouping || {}; } catch { return {}; }
            })();
            const res = await subgroupifyTypeProblemMap(inputMap, {
                chunkTokens: chunkTokens ?? sgCfg?.chunkTokens,
                language: __getGuideLanguageFromUi(),
                contextPrefix: 'SubgroupifySaveBatch',
            });

            const map = res?.assignmentsByQid instanceof Map ? res.assignmentsByQid : new Map();
            let assigned = 0;
            for (const [typeName, listRaw] of Object.entries(types || {})) {
                const list = Array.isArray(listRaw) ? listRaw : [];
                list.forEach(p => {
                    const qid = String(p?.qid || '').trim();
                    const a = qid ? map.get(qid) : null;
                    if (a) {
                        p.subgroup_tag = a.tag;
                        if (a.rule) p.subgroup_rule = a.rule;
                        assigned++;
                    } else {
                        try { delete p.subgroup_tag; } catch { }
                        try { delete p.subgroup_rule; } catch { }
                    }
                });
            }

            logger.success('SubgroupifySave', `Updated save file: assigned ${assigned} problem(s) to subgroup tags.`);
            return { updated: cloned, assigned };
        }

        function __stripLlmBannerFromExplanation(text) {
            let s = String(text ?? '');
            // Remove our own first-line banners to avoid stacking on repeated runs.
            // Examples:
            // - "> âš ï¸ LLM ìƒì„±: ì •ë‹µë§Œ (ê³µì‹ ì•„ë‹˜)"
            // - "> âš ï¸ LLM-generated: answer only (not official)"
            // - legacy: "> âš ï¸ LLM ìƒì„± í•´ì„¤ (ê³µì‹ ì•„ë‹˜)"
            const lines = s.split(/\r?\n/);
            if (!lines.length) return s;
            const first = String(lines[0] || '').trim();
            const isBanner = /^>\s*âš ï¸\s*/.test(first) && /llm/i.test(first);
            if (!isBanner) return s.trim();
            // Drop first line, then drop one optional blank line.
            const rest = lines.slice(1);
            if (rest.length && String(rest[0] || '').trim() === '') rest.shift();
            return rest.join('\n').trim();
        }

        function __makeLlmProvenanceBanner({ guiLang, answerGenerated, explanationGenerated }) {
            const lang = (guiLang === 'ko') ? 'ko' : 'en';
            const mode = (answerGenerated && explanationGenerated)
                ? 'both'
                : (answerGenerated ? 'answer_only' : 'explanation_only');
            if (lang === 'ko') {
                const label = (mode === 'both') ? 'ì •ë‹µ+í•´ì„¤' : (mode === 'answer_only' ? 'ì •ë‹µë§Œ' : 'í•´ì„¤ë§Œ');
                return `> âš ï¸ LLM ìƒì„±: ${label} (ê³µì‹ ì•„ë‹˜)\n\n`;
            }
            const label = (mode === 'both') ? 'answer + explanation' : (mode === 'answer_only' ? 'answer only' : 'explanation only');
            return `> âš ï¸ LLM-generated: ${label} (not official)\n\n`;
        }

        function __extractTypeGuideSectionsFromFmmSource(markdown) {
            const text = String(markdown ?? '');
            const lines = text.split(/\r?\n/);
            const sections = [];
            let cur = null;
            for (const line of lines) {
                const m = String(line || '').match(/^\s*#\s+(.+?)\s*$/);
                if (m) {
                    if (cur) sections.push(cur);
                    cur = { title: String(m[1] || '').trim(), body: [] };
                    continue;
                }
                if (cur) cur.body.push(String(line || ''));
            }
            if (cur) sections.push(cur);

            const byNormTitle = new Map();
            sections.forEach(sec => {
                const title = String(sec?.title || '').trim();
                if (!title) return;
                const body = String((sec?.body || []).join('\n')).trim();
                byNormTitle.set(__normalizeTitleForMatch(title), body);
            });
            return { byNormTitle, titles: sections.map(s => s.title).filter(Boolean) };
        }

        function __normalizeAnswerForCompare(ans) {
            let s = String(ans ?? '').trim();
            if (!s) return '';
            const circled = {
                'â‘ ': '1', 'â‘¡': '2', 'â‘¢': '3', 'â‘£': '4', 'â‘¤': '5',
                'â‘¥': '6', 'â‘¦': '7', 'â‘§': '8', 'â‘¨': '9', 'â‘©': '10',
            };
            s = s.replace(/[â‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨â‘©]/g, (ch) => circled[ch] || ch);
            s = s.replace(/[()\[\]{}]/g, '');
            s = s.replace(/\s+/g, '');
            s = s.toUpperCase();
            return s;
        }

        function __getProblemOfficialAnswer(p) {
            return String(p?.official_answer ?? p?.officialAnswer ?? '').trim();
        }

        function __setProblemOfficialAnswer(p, v) {
            const val = String(v ?? '').trim();
            if (!p || typeof p !== 'object') return;
            if ('official_answer' in p || !('officialAnswer' in p)) p.official_answer = val;
            if ('officialAnswer' in p) p.officialAnswer = val;
        }

        function __getProblemOfficialExplanation(p) {
            return String(p?.official_explanation ?? p?.officialExplanation ?? '').trim();
        }

        function __setProblemOfficialExplanation(p, v) {
            const val = String(v ?? '').trim();
            if (!p || typeof p !== 'object') return;
            if ('official_explanation' in p || !('officialExplanation' in p)) p.official_explanation = val;
            if ('officialExplanation' in p) p.officialExplanation = val;
        }

        function __getProblemQuestionText(p) {
            return String(p?.question_text ?? p?.questionText ?? p?.question ?? '').trim();
        }

        function __getProblemAnswerChoices(p) {
            return String(p?.answer_choices ?? p?.answerChoices ?? p?.choices ?? '').trim();
        }

	        async function fillAnswersForImportedSaveObject(obj, { settings } = {}) {
	            const extracted = __extractTypesFromImportedSave(obj);
	            const types = extracted.types || {};

            const s = (settings && typeof settings === 'object') ? settings : {};
            const fillAnswers = (typeof s.fillAnswers === 'boolean') ? s.fillAnswers : true;
            const fillExplanations = (typeof s.fillExplanations === 'boolean') ? s.fillExplanations : true;
            const overwriteAnswers = !!s.overwriteAnswers;
            const overwriteExplanations = !!s.overwriteExplanations;
            const includeTypeGuide = (typeof s.includeTypeGuide === 'boolean') ? s.includeTypeGuide : true;
            const typeGuideMaxChars = __clampInt(s.typeGuideMaxChars, { min: 200, max: 200000, fallback: 12000 });
            const maxT = __clampInt(s.fillChunkTokens, { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS });
            const useDdg = !!s.useDuckDuckGo;

            if (!fillAnswers && !fillExplanations) {
                logger.warn('PostprocessFill', 'Both fillAnswers and fillExplanations are off; nothing to do.');
                return { updated: obj, filledAnswers: 0, filledExplanations: 0, bannered: 0, skipped: 0 };
            }

            const language = __getGuideLanguageFromUi();
            const guiLang = (getEl('gui-lang-select')?.value === 'ko') ? 'ko' : 'en';

            let guideSections = null;
            if (includeTypeGuide && extracted.kind === 'bundle') {
                try {
                    const guideText = extracted?.root?.items?.fmm_source?.value;
                    if (guideText) guideSections = __extractTypeGuideSectionsFromFmmSource(String(guideText));
                } catch { }
            }

            const ddgCache = new Map();

            let filledAnswersCount = 0;
            let filledExplanationsCount = 0;
            let banneredCount = 0;
            let skipped = 0;

	            const typeNames = Object.keys(types || {});
	            if (!typeNames.length) throw new Error('No types found in save file.');

	            const targetsByType = new Map(); // typeName -> targets[]
	            for (const typeName of typeNames) {
	                if (processController.stop) throw new Error('Operation cancelled.');
	                const listRaw = types[typeName];
	                const list = Array.isArray(listRaw) ? listRaw : [];
	                if (!list.length) continue;

	                const targets = [];
	                for (const p of list) {
	                    const qid = String(p?.qid || '').trim();
	                    if (!qid) continue;
	                    const curAns = __getProblemOfficialAnswer(p);
	                    const curExp = __getProblemOfficialExplanation(p);

	                    const needAnswer = fillAnswers && (overwriteAnswers || !curAns);
	                    const needExp = fillExplanations && (overwriteExplanations || !curExp);
	                    if (!needAnswer && !needExp) continue;

	                    // If user asked for explanation-only fill, require an existing official answer.
	                    if (needExp && !fillAnswers && !curAns) { skipped++; continue; }

	                    const lockAnswer = !!curAns && !(fillAnswers && overwriteAnswers);

	                    targets.push({
	                        qid,
	                        p,
	                        needAnswer,
	                        needExp,
	                        lockAnswer,
	                        curAns,
	                        curExp,
	                        __ddg: '',
	                    });
	                }
	                if (targets.length) targetsByType.set(typeName, targets);
	            }

	            if (targetsByType.size === 0) {
	                logger.info('PostprocessFill', 'No fill targets found; skipping.');
	                return { updated: obj, filledAnswers: 0, filledExplanations: 0, bannered: 0, skipped };
	            }

	            // Optional: fetch DDG snippets as extra context (global)
	            if (useDdg) {
	                const jobs = [];
	                targetsByType.forEach((targets, typeName) => {
	                    targets.forEach((t, idx) => jobs.push({ typeName, idx, t }));
	                });
	                async function processJob(job, workerId) {
	                    const ctx = `DDG-PP-${__normalizeTitleForMatch(job.typeName)}-W${workerId}`;
	                    const q = __answerFillBuildDdgQuery({
	                        qid: job.t.qid,
	                        question_text: __getProblemQuestionText(job.t.p),
	                        answer_choices: __getProblemAnswerChoices(job.t.p),
	                    });
	                    if (!q) return;
	                    if (ddgCache.has(q)) { job.t.__ddg = ddgCache.get(q); return; }
	                    try {
	                        const snip = await __ddgInstantAnswer(q);
	                        ddgCache.set(q, snip);
	                        job.t.__ddg = snip;
	                    } catch (e) {
	                        logger.warn(ctx, `DuckDuckGo lookup failed: ${e?.message || e}`);
	                    }
	                }
	                await runWithConcurrency(jobs, processJob, Math.max(1, Math.min(6, getWorkerConcurrency())));
	            }

	            // Build all batch jobs
	            const batchJobs = [];
	            targetsByType.forEach((targets, typeName) => {
	                const guideBody = (() => {
	                    if (!includeTypeGuide || !guideSections?.byNormTitle) return '';
	                    const norm = __normalizeTitleForMatch(typeName);
	                    const body = guideSections.byNormTitle.get(norm) || '';
	                    return __answerFillClipText(body, typeGuideMaxChars);
	                })();

	                const headerText = (() => {
	                    const parts = [];
	                    parts.push(`TYPE: ${typeName}`);
	                    if (guideBody) parts.push(`\n[TYPE GUIDE]\n${guideBody}`);
	                    parts.push(
	                        `\nRULES:\n` +
	                        `- Use the given QID exactly.\n` +
	                        `- Output ONLY <data>...</data>.\n` +
	                        `- If an item includes OFFICIAL ANSWER, copy it EXACTLY into <answer>.\n`
	                    );
	                    return parts.join('\n').trim();
	                })();

	                const overheadTok = __estimateTokens(headerText + '\n\n');
	                const perBatchMaxT = Math.max(1000, maxT - overheadTok);

	                const items = targets.map(t => {
	                    const qText = __answerFillClipText(__answerFillStripDataUris(__getProblemQuestionText(t.p)), 6500);
	                    const cText = __answerFillClipText(__answerFillStripDataUris(__getProblemAnswerChoices(t.p)), 1600);
	                    const ddg = String(t.__ddg || '').trim();
	                    const ref = ddg ? `\n\n[DuckDuckGo Instant Answer]\n${ddg}` : '';
	                    const lock = t.lockAnswer ? `\n\nOFFICIAL ANSWER (copy EXACTLY): ${t.curAns}` : '';
	                    const block =
	                        `QID: ${t.qid}\n` +
	                        `QUESTION:\n${qText || '(empty)'}\n` +
	                        (cText ? `\nCHOICES:\n${cText}\n` : '') +
	                        lock +
	                        ref;
	                    return { qid: t.qid, t, text: block, estTokens: __estimateTokens(block) };
	                }).filter(it => it.qid);

	                const batches = __packAnswerFillItemsByTokens(items, perBatchMaxT);
	                logger.info('PostprocessFill', `Type "${typeName}": targets=${items.length} â†’ batches=${batches.length} (maxTokensâ‰ˆ${maxT}, overheadâ‰ˆ${overheadTok}, ddg=${useDdg ? 'on' : 'off'})`);

	                for (let i = 0; i < batches.length; i++) {
	                    const list = (batches[i] && Array.isArray(batches[i].items)) ? batches[i].items : [];
	                    if (!list.length) continue;
	                    batchJobs.push({ typeName, headerText, list, batchIndex: i });
	                }
	            });

	            async function processBatchJob(job, workerId) {
	                const typeName = job.typeName;
	                const headerText = job.headerText;
	                const list = job.list || [];
	                const batchIndex = job.batchIndex || 0;
	                if (!list.length) return;

	                const ctx = `PostprocessFill-${__normalizeTitleForMatch(typeName)}-B${batchIndex}-W${workerId}`;
	                const userText =
	                    `${headerText}\n\n` +
	                    `Solve ALL problems below.\n\n` +
	                    list.map(x => x.text).join('\n\n---\n\n');

	                const payload = {
	                    model: getApiConfig().model,
	                    messages: [
	                        { role: 'system', content: __renderPromptTemplateText(currentPrompts.answer_filler.system, { language }) },
	                        { role: 'user', content: userText }
	                    ]
	                };

	                const expected = new Set(list.map(x => x.qid));
	                const locked = new Map(list.map(x => [x.qid, x?.t?.lockAnswer ? (x?.t?.curAns || '') : '']).filter(([_, v]) => String(v || '').trim()));

	                const MAX_TRIES = 3;
	                let lastErr = '';
	                for (let tryNo = 1; tryNo <= MAX_TRIES; tryNo++) {
	                    if (processController.stop) throw new Error('Operation cancelled.');
	                    try {
	                        const parsed = await requestAndParseDataEnvelope(payload, `${ctx}-T${tryNo}`, { phase: 'phase0' });
	                        const byQid = new Map();
	                        parsed.forEach(it => {
	                            const v = String(it?.value || '');
	                            const qid = String(parseTag(v, 'qid') || '').trim();
	                            const answer = String(parseTag(v, 'answer') || '').trim();
	                            const explanation = String(parseTag(v, 'explanation') || '').trim();
	                            const confRaw = String(parseTag(v, 'confidence') || '').trim();
	                            const conf = (() => { const n = parseFloat(confRaw); return Number.isFinite(n) ? Math.max(0, Math.min(1, n)) : null; })();
	                            if (!qid) return;
	                            byQid.set(qid, { answer, explanation, confidence: conf });
	                        });

	                        const missing = [];
	                        expected.forEach(qid => {
	                            const rec = byQid.get(qid);
	                            if (!rec) { missing.push(`${qid}:no_item`); return; }
	                            if (!String(rec.answer || '').trim()) missing.push(`${qid}:empty_answer`);
	                            if (!String(rec.explanation || '').trim()) missing.push(`${qid}:empty_explanation`);
	                            const lockAns = locked.get(qid);
	                            if (lockAns) {
	                                const a0 = __normalizeAnswerForCompare(lockAns);
	                                const a1 = __normalizeAnswerForCompare(rec.answer);
	                                if (a0 && a1 && a0 !== a1) missing.push(`${qid}:answer_mismatch`);
	                            }
	                        });
	                        if (missing.length) throw new Error(`Incomplete batch output: ${missing.slice(0, 8).join(', ')}${missing.length > 8 ? '...' : ''}`);

	                        // Apply
	                        list.forEach(x => {
	                            const qid = x.qid;
	                            const rec = byQid.get(qid);
	                            if (!rec) return;
	                            const t = x.t;
	                            const p = t?.p;
	                            if (!p || typeof p !== 'object') return;

	                            const beforeAns = __getProblemOfficialAnswer(p);
	                            const beforeExp = __getProblemOfficialExplanation(p);

	                            let didAnswer = false;
	                            let didExp = false;

	                            if (t.needAnswer && String(rec.answer || '').trim()) {
	                                __setProblemOfficialAnswer(p, rec.answer);
	                                p.official_answer_source = 'llm';
	                                p.llm_answer_confidence = rec.confidence;
	                                filledAnswersCount++;
	                                didAnswer = true;
	                            } else if (t.lockAnswer && beforeAns) {
	                                __setProblemOfficialAnswer(p, beforeAns);
	                            }

	                            if (t.needExp && String(rec.explanation || '').trim()) {
	                                const body = __stripLlmBannerFromExplanation(rec.explanation);
	                                const banner = __makeLlmProvenanceBanner({ guiLang, answerGenerated: didAnswer, explanationGenerated: true });
	                                __setProblemOfficialExplanation(p, (banner + body).trim());
	                                p.official_explanation_source = 'llm';
	                                filledExplanationsCount++;
	                                didExp = true;
	                                banneredCount++;
	                            }

	                            if (didAnswer && !didExp) {
	                                const body = __stripLlmBannerFromExplanation(beforeExp);
	                                const banner = __makeLlmProvenanceBanner({ guiLang, answerGenerated: true, explanationGenerated: false });
	                                __setProblemOfficialExplanation(p, (banner + (body ? body : '')).trim());
	                                if (!body) p.official_explanation_source = 'llm_meta';
	                                banneredCount++;
	                            }
	                        });
	                        return;
	                    } catch (e) {
	                        lastErr = e?.message || String(e || '');
	                        logger.warn('PostprocessFill', `${ctx}: try ${tryNo}/${MAX_TRIES} failed: ${lastErr}`);
	                        if (tryNo >= MAX_TRIES) throw e;
	                    }
	                }
	                throw new Error(lastErr || 'Postprocess fill failed.');
	            }

	            const { errors } = await runWithConcurrency(batchJobs, processBatchJob, Math.max(1, Math.min(6, getWorkerConcurrency())));
	            if (errors && errors.length) {
	                throw (errors[0]?.error || new Error('Postprocess fill failed.'));
	            }

	            logger.success('PostprocessFill', `Done. filledAnswers=${filledAnswersCount}, filledExplanations=${filledExplanationsCount}, bannered=${banneredCount}, skipped=${skipped}`);
	            return { updated: obj, filledAnswers: filledAnswersCount, filledExplanations: filledExplanationsCount, bannered: banneredCount, skipped };
	        }

	        function __buildFmmBundleForExportFromActiveProcess() {
	            const guide = String(activeProcess?.phase3_finalManual?.content || '').trim();
	            if (!guide) throw new Error('Phase 3 final guide (fmm_source) is empty.');
	            const { types } = __buildTypeProblemsBundleForExport();
	            const guiLang = (getEl('gui-lang-select')?.value === 'ko') ? 'ko' : 'en';
	            return {
	                __fmm_bundle__: 1,
	                exportedAt: new Date().toISOString(),
	                items: {
	                    fmm_source: { kind: 'raw', value: guide },
	                    fmm_problems_json: { kind: 'json', value: { types } },
	                    fmm_ui_lang: { kind: 'raw', value: guiLang },
	                }
	            };
	        }

	        function __applyPostprocessedBundleBackToActiveProcess(bundle, { applyFill = false, applySubgroup = false } = {}) {
	            const extracted = __extractTypesFromImportedSave(bundle);
	            const types = extracted.types || {};

	            const byQid = new Map();
	            Object.values(types).forEach(listRaw => {
	                const list = Array.isArray(listRaw) ? listRaw : [];
	                list.forEach(p => {
	                    const qid = String(p?.qid || '').trim();
	                    if (!qid) return;
	                    byQid.set(qid, p);
	                });
	            });

	            if (applyFill) {
	                (activeProcess?.phase0_extract || []).forEach(paperState => {
	                    const qas = (paperState && paperState.qasByQid && typeof paperState.qasByQid === 'object') ? paperState.qasByQid : null;
	                    if (!qas) return;
	                    Object.entries(qas).forEach(([qid, qa]) => {
	                        const p = byQid.get(String(qid || '').trim());
	                        if (!p || !qa || typeof qa !== 'object') return;
	                        const ans = __getProblemOfficialAnswer(p);
	                        const exp = __getProblemOfficialExplanation(p);
	                        if (ans) qa.official_answer = ans;
	                        if (exp) qa.official_explanation = exp;
	                        if (p.official_answer_source) qa.official_answer_source = p.official_answer_source;
	                        if (p.llm_answer_confidence != null) qa.llm_answer_confidence = p.llm_answer_confidence;
	                        if (p.official_explanation_source) qa.official_explanation_source = p.official_explanation_source;
	                    });
	                });
	            }

	            if (applySubgroup) {
	                const p1 = activeProcess?.phase1_patterns;
	                const perQ = Array.isArray(p1?.perQuestion) ? p1.perQuestion : null;
	                if (perQ) {
	                    perQ.forEach(pq => {
	                        const qid = String(pq?.qid || '').trim();
	                        const p = byQid.get(qid);
	                        if (!p) return;
	                        const tag = String(p?.subgroup_tag ?? p?.subgroupTag ?? '').trim();
	                        const rule = String(p?.subgroup_rule ?? p?.subgroupRule ?? '').trim();
	                        pq.subgroup_tag = tag;
	                        pq.subgroup_rule = rule;
	                    });
	                }
	            }
	        }

	        function __buildAnswerFillSettingsFromPipelineConfig(cfg) {
	            const af = (cfg?.phase0?.answerFill && typeof cfg.phase0.answerFill === 'object') ? cfg.phase0.answerFill : {};
	            return {
	                fillAnswers: (typeof af.fillAnswers === 'boolean') ? af.fillAnswers : true,
	                fillExplanations: (typeof af.fillExplanations === 'boolean') ? af.fillExplanations : true,
	                overwriteAnswers: !!af.overwriteAnswers,
	                overwriteExplanations: !!af.overwriteExplanations,
	                includeTypeGuide: (typeof af.includeTypeGuide === 'boolean') ? af.includeTypeGuide : true,
	                typeGuideMaxChars: __clampInt(af.typeGuideMaxChars, { min: 200, max: 200000, fallback: 12000 }),
	                fillChunkTokens: __clampInt(af.fillChunkTokens ?? af.chunkTokens, { min: 1000, max: 400000, fallback: DEFAULT_CHUNK_TOKENS }),
	                useDuckDuckGo: !!af.useDuckDuckGo,
	            };
	        }

	        async function runExportPostprocessIfEnabled() {
	            const cfg = getPipelineConfig(activeProcess);
	            const doSubgroup = !!cfg?.phase1?.subgrouping?.enabled;
	            const doFill = !!cfg?.phase0?.answerFill?.enabled;
	            if (!doSubgroup && !doFill) return { didRun: false };

	            const phase3Ok = String(activeProcess?.phase3_finalManual?.status || '').toLowerCase() === 'completed';
	            if (!phase3Ok) {
	                logger.warn('ExportPostprocess', 'Skipped: Phase 3 is not completed (fmm_source not available).');
	                return { didRun: false, skipped: 'phase3_not_completed' };
	            }

	            const cfgSig = (() => {
	                try {
	                    return JSON.stringify({
	                        model: getApiConfig()?.model || null,
	                        doSubgroup,
	                        subgroupChunkTokens: doSubgroup ? (cfg?.phase1?.subgrouping?.chunkTokens ?? null) : null,
	                        doFill,
	                        fill: doFill ? __buildAnswerFillSettingsFromPipelineConfig(cfg) : null,
	                    });
	                } catch {
	                    return String(Date.now());
	                }
	            })();
	            if (activeProcess?.export_postprocess?.status === 'completed' && activeProcess?.export_postprocess?.configSig === cfgSig) {
	                logger.info('ExportPostprocess', 'Skipped: already completed with the same settings.');
	                return { didRun: false, skipped: 'already_completed' };
	            }

	            const statusBits = [
	                doSubgroup ? 'subgroupify' : null,
	                doFill ? 'fill' : null
	            ].filter(Boolean).join(' + ');
	            updateStatus('Export Postprocess...', `Running ${statusBits} (postprocess-equivalent) on final export...`);
	            renderActiveProcess();

	            const startedAt = new Date().toISOString();
	            activeProcess.export_postprocess = { status: 'processing', startedAt, doSubgroup, doFill, configSig: cfgSig };

	            try {
	                let working = __buildFmmBundleForExportFromActiveProcess();
	                let subgroupAssigned = 0;
	                let fillRes = null;

	                if (doSubgroup) {
	                    const tok = cfg?.phase1?.subgrouping?.chunkTokens;
	                    const sg = await subgroupifyImportedSaveObject(working, { chunkTokens: tok });
	                    working = sg.updated;
	                    subgroupAssigned = sg.assigned || 0;
	                }

	                if (doFill) {
	                    const settings = __buildAnswerFillSettingsFromPipelineConfig(cfg);
	                    fillRes = await fillAnswersForImportedSaveObject(working, { settings });
	                    working = fillRes.updated;
	                }

	                __applyPostprocessedBundleBackToActiveProcess(working, { applyFill: doFill, applySubgroup: doSubgroup });

	                activeProcess.export_postprocess = {
	                    status: 'completed',
	                    startedAt,
	                    completedAt: new Date().toISOString(),
	                    doSubgroup,
	                    doFill,
	                    configSig: cfgSig,
	                    subgroupAssigned,
	                    filledAnswers: fillRes?.filledAnswers || 0,
	                    filledExplanations: fillRes?.filledExplanations || 0,
	                    bannered: fillRes?.bannered || 0,
	                    skipped: fillRes?.skipped || 0,
	                };

	                logger.success(
	                    'ExportPostprocess',
	                    `Done. subgroupAssigned=${subgroupAssigned}, filledAnswers=${fillRes?.filledAnswers || 0}, filledExplanations=${fillRes?.filledExplanations || 0}`
	                );
	                renderActiveProcess();
	                return { didRun: true, subgroupAssigned, fill: fillRes };
	            } catch (e) {
	                const msg = e?.message || String(e || '');
	                activeProcess.export_postprocess = { status: 'error', startedAt, error: msg, configSig: cfgSig };
	                logger.warn('ExportPostprocess', `Failed: ${msg}`);
	                renderActiveProcess();
	                return { didRun: false, error: msg };
	            }
	        }

	        function __buildTypeProblemsBundleForExport() {
	            const perQ = activeProcess?.phase1_patterns?.perQuestion || [];
	            if (!perQ.length) throw new Error(__tGui('exportNoTypeResultsError'));
	            const p1 = activeProcess?.phase1_patterns || {};
            const globalTypeNameMap = p1?.globalTypeNameMap;
            const all = collectAllQuestions();
            const byId = new Map(all.map(q => [q.qid, q]));
            const types = {};
            const missingQids = [];
            perQ.forEach((pq) => {
                const qid = pq?.qid;
                const pattern_name = pq?.pattern_name;
                const subgroupTag = String(pq?.subgroup_tag || '').trim();
                const subgroupRule = String(pq?.subgroup_rule || '').trim();
                const q = byId.get(qid);
                if (!q) { missingQids.push(qid); return; }
                const finalTypeName = globalTypeNameMap?.[pattern_name] || pattern_name;
                const item = {
                    qid: q.qid,
                    paperName: q.paperName,
                    question_text: q.question_text,
                    answer_choices: q.answer_choices || '',
                    official_answer: q.official_answer || null,
                    official_explanation: q.official_explanation || null
                };
                if (subgroupTag) item.subgroup_tag = subgroupTag;
                if (subgroupTag && subgroupRule) item.subgroup_rule = subgroupRule;
                (types[finalTypeName] ||= []).push(item);
            });
            return { types, missingQids, phase1: p1 };
        }

        // Download renderer import save (fmm_export.json-compatible)
        document.body.addEventListener('click', e => {
            if (e.target && e.target.id === 'download-renderer-save-btn') {
                try {
                    const guide = String(activeProcess?.phase3_finalManual?.content || '').trim();
                    if (!guide) { alert(__tGui('exportNoFinalGuideAlert')); return; }
                    const { types } = __buildTypeProblemsBundleForExport();
                    const guiLang = (getEl('gui-lang-select')?.value === 'ko') ? 'ko' : 'en';
                    const bundle = {
                        __fmm_bundle__: 1,
                        exportedAt: new Date().toISOString(),
                        items: {
                            fmm_source: { kind: 'raw', value: guide },
                            fmm_problems_json: { kind: 'json', value: { types } },
                            fmm_ui_lang: { kind: 'raw', value: guiLang }
                        }
                    };
                    const blob = new Blob([JSON.stringify(bundle, null, 2)], { type: 'application/json' });
                    const a = document.createElement('a');
                    a.download = `fmm_export_from_guide_maker_${new Date().toISOString().slice(0, 10)}.json`;
                    a.href = URL.createObjectURL(blob);
                    a.click();
                    URL.revokeObjectURL(a.href);
                } catch (err) {
                    logger.error('Export', `Failed to export renderer save: ${err.message}`);
                    alert(__tGui('exportFailedCheckLogsAlert'));
                }
            }
        });

        // Download types + original problems bundle
        document.body.addEventListener('click', e => {
            if (e.target && e.target.id === 'download-type-bundle-btn') {
                try {
                    const { types, missingQids, phase1: p1 } = __buildTypeProblemsBundleForExport();
                    const globalTypeNameMap = p1?.globalTypeNameMap;
                    const pipelineCfg = getPipelineConfig(activeProcess);
                    const exportObj = {
                        generatedAt: new Date().toISOString(),
                        config: {
                            chunkTokens: Number.isFinite(activeProcess?.chunkTokens) ? activeProcess.chunkTokens : null,
                            phase1: {
                                archId: pipelineCfg?.phase1?.archId || null,
                                chunkTokens: pipelineCfg?.phase1?.chunkTokens ?? null,
                            },
                            phase2: {
                                archId: pipelineCfg?.phase2?.archId || null,
                            }
                        },
                        phase1: {
                            status: p1?.status || null,
                            standard: p1?.standardCreation?.finalStandard || null,
                            clusters: p1?.clusters || [],
                            perQuestion: p1?.perQuestion || [],
                            globalTypeNameMap: globalTypeNameMap || null,
                        },
                        missingQids,
                        types
                    };
                    const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: 'application/json' });
                    const a = document.createElement('a');
                    a.download = 'type_bundle_with_original_problems.json';
                    a.href = URL.createObjectURL(blob);
                    a.click();
                    URL.revokeObjectURL(a.href);
                } catch (err) {
                    logger.error('Export', `Failed to export bundle: ${err.message}`);
                    alert(__tGui('exportFailedCheckLogsAlert'));
                }
            }
        });

        //======================================================================
        // 7. SAVE / LOAD / PROMPT MANAGEMENT
        //======================================================================

        function hasTypeRerunState() {
            const hasTypes = Array.isArray(typeRerunState?.types) && typeRerunState.types.length > 0;
            const hasResults = Array.isArray(typeRerunState?.results) && typeRerunState.results.length > 0;
            return hasTypes || hasResults;
        }

        function normalizeTypeRerunState(state) {
            if (!state || typeof state !== 'object') return { status: 'idle', types: [], results: [], error: null };
            const status = state.status === 'processing' ? 'ready' : (state.status || 'idle');
            return {
                status,
                types: Array.isArray(state.types) ? state.types : [],
                results: Array.isArray(state.results) ? state.results : [],
                error: state.error || null
            };
        }

        function refreshTypeRerunUI() {
            const statusEl = getEl('type-guide-import-status');
            const rerunBtn = getEl('type-rerun-btn');
            const exportBtn = getEl('type-export-btn');
            const saveBtn = getEl('save-button');
            const hasTypes = Array.isArray(typeRerunState.types) && typeRerunState.types.length > 0;
            const hasResults = Array.isArray(typeRerunState.results) && typeRerunState.results.length > 0;

            if (statusEl) {
                if (typeRerunState.status === 'error') {
                    statusEl.textContent = __tGuiFmt('typeGuideStatusImportFailedFmt', { error: typeRerunState.error || __tGui('unknownError') });
                } else if (hasResults) {
                    statusEl.textContent = __tGuiFmt('typeGuideStatusResultsReadyFmt', { n: typeRerunState.results.length });
                } else if (hasTypes) {
                    statusEl.textContent = __tGuiFmt('typeGuideStatusImportLoadedFmt', { titles: typeRerunState.types.map(t => t.title).join(', ') });
                } else {
                    statusEl.textContent = __tGui('typeGuideImportStatusEmpty');
                }
            }
            if (rerunBtn) rerunBtn.disabled = !hasTypes || typeRerunState.status === 'processing';
            if (exportBtn) exportBtn.disabled = !hasResults;
            if (saveBtn) saveBtn.disabled = !activeProcess && !hasTypeRerunState();
        }

        function refreshIncrementalUiText() {
            try {
                const incNewFilesStatus = getEl('inc-new-files-status');
                if (incNewFilesStatus) {
                    const files = Array.isArray(incrementalPatchState?.newFiles) ? incrementalPatchState.newFiles : [];
                    incNewFilesStatus.textContent = files.length
                        ? __tGuiFmt('incNewFilesStatusSelectedFmt', { n: files.length, names: files.map(f => f.name).join(', ') })
                        : __tGui('incNewFilesStatusNone');
                }
            } catch { }

            try {
                const incStatusEl = getEl('inc-status');
                if (!incStatusEl) return;
                const st = String(incrementalPatchState?.status || 'idle');
                if (st === 'idle') {
                    incStatusEl.textContent = __tGui('incStatusIdle');
                    return;
                }
                if (st === 'error') {
                    incStatusEl.textContent = __tGuiFmt('incStatusFailedFmt', { error: incrementalPatchState?.error || __tGui('unknownError') });
                    return;
                }
                if (st === 'completed') {
                    const payload = incrementalPatchState?.patchPayload || null;
                    const n = Number(payload?.baseInfo?.addedProblemCount) || (Array.isArray(incrementalPatchState?.cachedQuestions) ? incrementalPatchState.cachedQuestions.length : 0);
                    const patchedN = Array.isArray(payload?.types) ? payload.types.length : 0;
                    incStatusEl.textContent = __tGuiFmt('incStatusCompletedFmt', { n, patchedN });
                    return;
                }
                if (st === 'ready' && incrementalPatchState?.basePayload) {
                    const base = incrementalPatchState.basePayload;
                    const typesN = Array.isArray(base?.types) ? base.types.length : 0;
                    const hasStd = Array.isArray(base?.classificationStandard) && base.classificationStandard.length > 0;
                    incStatusEl.textContent = __tGuiFmt('incStatusBaseLoadedFmt', {
                        typesN,
                        std: hasStd ? __tGui('incStatusStdPresent') : __tGui('incStatusStdMissing')
                    });
                }
            } catch { }
        }

        function saveProgress() {
            if (!activeProcess && !hasTypeRerunState()) {
                logger.warn("Save", "No active process or regeneration state to save.");
                return;
            }

            try {
                logger.info("Save", "Gathering application state...");

                // We cannot serialize raw File objects. We'll store metadata only.
                const serializableUploadedFiles = uploadedFiles.map(f => ({
                    name: f.file.name,
                    size: f.file.size,
                    type: f.file.type,
                    splitPages: f.splitPages
                }));

                const state = {
                    savedAt: new Date().toISOString(),
                    apiConfig: getApiConfig(),
                    uiConfig: {
                        globalSplitPages: getGlobalSplitPagesOverride(),
                        globalKeySplitCount: getGlobalKeySplitCountOverride(),
                        pipelineConfig: (() => { try { return getPipelineConfigFromUi(); } catch { return null; } })(),
                    },
                    prompts: currentPrompts,
                    // rpmLimit removed
                    uploadedFilesInfo: serializableUploadedFiles,
                    examPapers: examPapers,
                    activeProcess: activeProcess,
                    successfulApiCallCount: successfulApiCallCount,
                    callStats: (() => { try { return __callStats.exportState(); } catch { return null; } })(),
                    formatErrors: (() => { try { return __formatErrors.exportState(); } catch { return null; } })(),
                    typeRerunState: typeRerunState,
                    logState: (() => { try { return logger.exportState(); } catch { return null; } })(),
                };

                const jsonString = JSON.stringify(state, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');

                const date = new Date().toISOString().slice(0, 10);
                a.download = `mastery-manual-progress-${date}.json`;
                a.href = url;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                logger.success("Save", "Progress saved successfully.");
            } catch (error) {
                logger.error("Save", `Failed to save progress: ${error.message}`);
                alert("Could not save progress. See logs for details.");
            }
        }

        function loadProgress(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const ocrOnly = !!getEl('load-ocr-only-input')?.checked;
                    const state = JSON.parse(e.target.result);
                    logger.info("Load", `Loading state from ${file.name}, saved at ${state.savedAt}`);

                    // Clear non-serializable file handles from any prior session
                    uploadedFiles = [];

                    // Restore UI config (optional)
                    const uiCfg = state.uiConfig || {};
                    const gsp = uiCfg.globalSplitPages;
                    const gkc = uiCfg.globalKeySplitCount;
                    if (getEl('global-split-pages-input')) {
                        getEl('global-split-pages-input').value = (Number.isFinite(gsp) && gsp > 0) ? `${gsp}` : '';
                    }
                    if (getEl('global-key-split-count-input')) {
                        getEl('global-key-split-count-input').value = (Number.isFinite(gkc) && gkc > 0) ? `${gkc}` : '';
                    }
                    try {
                        if (uiCfg.pipelineConfig && typeof uiCfg.pipelineConfig === 'object') {
                            applyPipelineConfigToUi(uiCfg.pipelineConfig);
                            localStorage.setItem(EXP_CONFIG_STORAGE_KEY, JSON.stringify(uiCfg.pipelineConfig));
                        }
                    } catch { }

                    // Restore API Config
                    const apiCfg = state.apiConfig || {};
                    getEl('api-url-input').value = apiCfg.apiUrl || apiCfg.baseUrl || '';
                    getEl('api-key-list-input').value = apiCfg.apiKeyList || apiCfg.apiKey || '';
                    getEl('api-model-name-input').value = apiCfg.model || '';
                    getEl('enable-rate-limit-input').checked = !!apiCfg.rateLimitEnabled;
                    getEl('rpm-limit-input').value = apiCfg.rpmLimit || 30;
                    getEl('tpm-limit-input').value = apiCfg.tpmLimit || 15000;
                    if (getEl('inflight-limit-input')) getEl('inflight-limit-input').value = apiCfg.inflightLimitPerKey ?? 0;
                    saveApiConfig(); // Persist to localStorage

                    // Restore Prompts
                    if (!ocrOnly && state.prompts) {
                        // Backward-compat: old saves may include legacy <id:n> format or missing prompt keys.
                        currentPrompts = __normalizePrompts(state.prompts);
                        initializePromptEditor(); // repopulate textareas
                    }

                    // Restore Parameters
                    // rpm limit removed

                    // Restore File List UI (metadata only)
                    const fileListEl = getEl('file-list');
                    fileListEl.innerHTML = '';
                    const infos = Array.isArray(state.uploadedFilesInfo) ? state.uploadedFilesInfo : [];
                    infos.forEach(info => {
                        const li = document.createElement('li');
                        li.className = 'file-list-item';
                        li.innerHTML = `<span class="file-list-item-name" title="${info.name}">${info.name} (loaded from save)</span>`;
                        fileListEl.appendChild(li);
                    });

                    // Restore internal state
                    examPapers = Array.isArray(state.examPapers) ? state.examPapers : [];
                    // Backward compat: ensure each exam unit has a stable sourceFileName for grouping
                    try {
                        examPapers.forEach(p => {
                            if (!p || typeof p !== 'object') return;
                            if (!p.sourceFileName && p.fileName) {
                                p.sourceFileName = deriveSourceFileNameFromUnitName(p.fileName);
                            }
                        });
                    } catch (_) { }
                    activeProcess = ocrOnly ? null : (state.activeProcess || null);
                    successfulApiCallCount = ocrOnly ? 0 : (state.successfulApiCallCount || 0);
                    try {
                        if (ocrOnly) __callStats.reset();
                        else if (state.callStats) __callStats.importState(state.callStats);
                        else if (Number.isFinite(successfulApiCallCount) && successfulApiCallCount > 0) {
                            __callStats.importState({
                                okTotal: successfulApiCallCount,
                                okByPhase: { phase0: 0, phase1: 0, phase2: 0, phase3: 0, other: successfulApiCallCount },
                                okByStage: { other: successfulApiCallCount },
                            });
                        } else {
                            __callStats.reset();
                        }
                    } catch { }
                    try {
                        if (ocrOnly) __formatErrors.clear();
                        else if (state.formatErrors) __formatErrors.importState(state.formatErrors);
                        else __formatErrors.clear();
                    } catch { }
                    typeRerunState = normalizeTypeRerunState(state.typeRerunState);
                    refreshTypeRerunUI();

                    // Restore logs
                    try {
                        const __parseLogsHtmlToEntries = (html) => {
                            const out = [];
                            try {
                                const doc = new DOMParser().parseFromString(`<div>${String(html || '')}</div>`, 'text/html');
                                doc.querySelectorAll('.log-line').forEach(line => {
                                    const tsUi = (line.querySelector('.log-timestamp')?.textContent || '').trim();
                                    const level = (line.querySelector('.log-level')?.textContent || 'INFO').trim().toUpperCase();
                                    const ctxRaw = (line.querySelector('.log-context')?.textContent || '').trim();
                                    const context = ctxRaw.replace(/^\\[|\\]$/g, '').trim();
                                    const message = (line.querySelector('.log-content')?.textContent || '').trim();
                                    out.push({
                                        tsIso: new Date().toISOString(),
                                        tsUi,
                                        level,
                                        context,
                                        message,
                                    });
                                });
                            } catch { }
                            return out;
                        };
                        if (ocrOnly) {
                            logger.clear();
                        } else if (state.logState && typeof state.logState === 'object') {
                            logger.importState(state.logState);
                        } else if (Array.isArray(state.logEntries) && state.logEntries.length) {
                            // Backward-compat (older saves)
                            logger.importEntries(state.logEntries, { uiStartIndex: state.logUiStartIndex });
                        } else if (state.logsHtml) {
                            logger.importEntries(__parseLogsHtmlToEntries(state.logsHtml), { uiStartIndex: 0 });
                        } else {
                            logger.renderUi();
                        }
                        try { __refreshLogSessionSelect(); } catch { }
                    } catch {
                        // Fallback: keep legacy rendering
                        getEl('logs-container').innerHTML = ocrOnly ? '' : (state.logsHtml || '');
                    }
                    updateApiCallCounter();

                    if (activeProcess) {
                        // Normalize the loaded state so it can be resumed safely
                        activeProcess = migrateActiveProcessForResume(activeProcess);
                        processController.stop = false;

                        renderActiveProcess();
                        updateUIState(false);

                        const canResume = isProcessResumable();

                        // Load summary (helps debug "clusters/modules missing" reports)
                        try {
                            const ap = activeProcess;
                            const p1 = ap?.phase1_patterns || {};
                            const clustersN = Array.isArray(p1?.clusters) ? p1.clusters.length : 0;
                            const perQn = Array.isArray(p1?.perQuestion) ? p1.perQuestion.length : 0;
                            const stdN = Array.isArray(p1?.standardCreation?.finalStandard) ? p1.standardCreation.finalStandard.length : 0;
                            const mods = Array.isArray(ap?.phase2_modules) ? ap.phase2_modules : [];
                            const modsN = mods.length;
                            const modsDone = mods.filter(m => m?.status === 'completed').length;
                            const modsPending = mods.filter(m => m?.status === 'pending').length;
                            logger.info(
                                "Load",
                                `ë³µì› ìš”ì•½: examPapers=${Array.isArray(examPapers) ? examPapers.length : 0}, 1ë‹¨ê³„í‘œì¤€=${stdN}, clusters=${clustersN}, perQuestion=${perQn}, modules=${modsN} (ì™„ë£Œ ${modsDone}/ëŒ€ê¸° ${modsPending}), chunkTokens=${Number.isFinite(ap?.chunkTokens) ? ap.chunkTokens : 'N/A'}, OCRë§Œ=${ocrOnly ? 'on' : 'off'}`
                            );
                        } catch { }

                        updateStatus(
                            "ë¶ˆëŸ¬ì˜´",
                            `${file.name} ì§„í–‰ìƒíƒœë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.` +
                            (canResume ? " â€˜ë§¤ë‰´ì–¼ ì¬ê°œâ€™ë¥¼ ëˆŒëŸ¬ ê³„ì†í•˜ì„¸ìš”." : "")
                        );
                        logger.success("Load", "ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒíƒœ ë³µì› ì™„ë£Œ. ì¬ê°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
                    } else {
                        const hasOcr = Array.isArray(examPapers) && examPapers.length > 0;
                        updateStatus(
                            "ë¶ˆëŸ¬ì˜´",
                            ocrOnly
                                ? (hasOcr
                                    ? `${file.name}ì—ì„œ OCR ìºì‹œë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤. 0ë‹¨ê³„ë¶€í„° ì‹¤í–‰í•˜ë ¤ë©´ â€˜ë§¤ë‰´ì–¼ ìƒì„±â€™ì„ ëˆ„ë¥´ì„¸ìš”.`
                                    : `${file.name}ë¥¼ ë¶ˆëŸ¬ì™”ì§€ë§Œ OCR ìºì‹œ(examPapers)ê°€ ì—†ìŠµë‹ˆë‹¤.`)
                                : `${file.name}ì—ì„œ ì„¤ì •ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`
                        );
                        updateUIState(false);
                        logger.success("Load", ocrOnly ? "OCR ìºì‹œ ë¡œë”© ì™„ë£Œ. 0ë‹¨ê³„ë¶€í„° ì‹œì‘í•  ì¤€ë¹„ê°€ ëìŠµë‹ˆë‹¤." : "ì„¤ì • ë³µì› ì™„ë£Œ.");
                    }

                } catch (error) {
                    logger.error("Load", `ì§„í–‰ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${error.message}`);
                    alert("ì§„í–‰ìƒíƒœ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. íŒŒì¼ì´ ì†ìƒëì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.");
                } finally {
                    event.target.value = ''; // Reset input to allow re-load of same file
                }
            };
            reader.onerror = () => {
                logger.error("Load", "ì €ì¥íŒŒì¼ ì½ê¸° ì˜¤ë¥˜");
                alert("ì €ì¥íŒŒì¼ ì½ê¸° ì˜¤ë¥˜");
            };
            reader.readAsText(file);
        }

	        const getEl = (id) => document.getElementById(id);
	
	        // ===== GUI Language (simple i18n) =====
	        const GUI_LANG_STORAGE_KEY = 'mastery_manual_gui_lang_v1';
	        const GUI_I18N = {
	            en: {
		                appTitle: 'Hit Thunder Guide Maker',
	                guiLangLabel: 'GUI Language',
	                guiLangOptionEnglish: 'English',
	                guiLangOptionKorean: 'Korean',
	                apiCallCounterPrefix: 'API calls',
	                fileUploadLabel: '1. Upload exam papers (.pdf, .txt)',
	                fileUploadHint: 'Click here or drop PDF/TXT files',
	                answerFileUploadLabel: 'Answer/Solution files (optional)',
	                answerFileUploadHint: 'Click here or drop PDF/TXT answer files',
	                answerFileUploadHelp: 'Filenames do not need to match. After Phase 0 extraction, the app will auto-match and fill official answers.',
	                answerFileListRemoveFileTitle: 'Remove answer file',
	                fileListSplitEveryLabel: 'Split every',
	                fileListSplitPagesLabel: 'pages',
	                fileListRemoveFileTitle: 'Remove file',
	                globalSplitPagesLabel: 'Global PDF split pages (optional)',
	                globalSplitPagesPlaceholder: '(leave blank = per-file)',
	                globalSplitPagesHelp: 'If set, this value applies to PDFs whose per-file split is 0 (default).',
	                globalKeySplitCountLabel: 'Key split count (workers) (optional)',
	                globalKeySplitCountPlaceholder: '(leave blank = auto: use all keys)',
	                globalKeySplitCountHelp: 'Controls worker concurrency for phases 0â€“2. (Auto: use all keys)',
	                saveButtonTitle: 'Save state',
	                loadButtonTitle: 'Load state',
	                clearButtonTitle: 'Reset (delete all)',
	                loadOcrOnlyText: 'Load OCR cache only (ignore pipeline; restart from Phase 0)',
	                summaryApiSettings: 'API Settings',
	                summaryGenerationOptions: 'Generation Options',
	                summaryExperimentCost: 'Experiment / Cost Control',
	                summaryTypeGuideRegeneration: 'Regenerate Type Guides',
	                summaryIncremental: 'Add New Problems (coverage-only patch)',
	                summaryPromptsAdvanced: 'Prompts (Advanced)',
	                summaryApiMonitor: 'API Monitor',
	                summaryFormatErrors: 'Format Errors (Structured Output) â€” raw I/O',
	
	                apiMonitorColIndex: '#',
	                apiMonitorColKey: 'Key',
	                apiMonitorColContext: 'Context',
	                apiMonitorColStatus: 'Status',
	                apiMonitorRecentCallsTitle: 'Recent calls (50)',
		                apiMonitorTotalsInit: 'Calls 0 â€¢ waiting 0 â€¢ inflight 0 â€¢ ok 0 â€¢ fail 0',
		                apiMonitorTotalsFmt: 'Calls {total} â€¢ waiting {waiting} â€¢ inflight {inflight} â€¢ ok {ok} â€¢ fail {fail}',
		                apiMonitorBreakdownTitle: 'Call breakdown (OK)',
		                apiMonitorBreakdownResetButton: 'Reset',
		                callStatsSessionAll: 'All sessions',
		                callStatsSessionCurrentFmt: 'Current session ({id})',
		                callStatsSessionOtherFmt: 'Session {id}',
		                callStatsStatLineFmt: '[{session}] OK {ok} â€¢ Fail {fail} â€¢ Format {fmt}',
		                callStatsGlobalLineFmt: '(Total: OK {okTotal} / Global AvgLat {avgLat})',
		                callStatsPhaseLineFmt: 'P0 {p0} â€¢ P1 {p1} â€¢ P2 {p2} â€¢ P3 {p3}',
		                callStatsLastOkFmt: 'Last OK {time}',
		                callStatsNoOkYet: 'No successful calls yet.',
		                callStatsStageLineFmt: '{stage}: {n} (avgLat {avg})',
		                callStatsStageP0Extract: 'P0 Extract',
		                callStatsStageP1CreateTypes: 'P1A Type standard',
		                callStatsStageP1EvalTypes: 'P1A Verify',
		                callStatsStageP1Merge: 'P1 Merge',
		                callStatsStageP1ClassifyBatch: 'P1B Classify',
		                callStatsStageP1Subgroup: 'P1 Subgroup',
		                callStatsStageP2StdProblem: 'P2 Standard problem',
		                callStatsStageP2Explanation: 'P2 Explanation',
		                callStatsStageP2Auditor: 'P2 Auditor',
		                callStatsStageP2ReviseStdProblem: 'P2 Revise standard',
		                callStatsStageP2ReviseExplanationPatch: 'P2 Explanation patch',
		                callStatsStageP2CoverageVerify: 'P2 Coverage verify',
		                callStatsStageP2CoveragePatch: 'P2 Coverage patch',
		                callStatsStageOther: 'Other',
	
	                processLogTitle: 'Process log',
	                logUiMaxLinesLabel: 'Visible lines',
	                logUiMaxCharsLabel: 'Chars/line',
	                logFilterTypeLabel: 'Type',
	                logFilterTypeAll: 'All',
	                logFilterTypeApiInput: 'API input',
	                logFilterTypeApiOutput: 'API output',
	                logFilterTypeErrors: 'Warnings + errors',
	                logFilterTypeErrorsNoHttp: 'Warnings + errors (except HTTP 429/5xx)',
		                logFilterSessionLabel: 'Session',
		                logFilterSessionCurrent: 'Current session',
		                logFilterSessionAll: 'All sessions',
		                logFilterSessionCurrentFmt: 'Current session ({id})',
	                logFilterPhaseLabel: 'Phase',
	                logFilterPhaseAll: 'All',
	                logFilterPhase0: 'Phase 0 (Extraction)',
	                logFilterPhase1: 'Phase 1 (Type classification)',
	                logFilterPhase2: 'Phase 2 (Guides/Coverage)',
	                logFilterPhase3: 'Phase 3 (Final)',
	                logFilterPhaseOther: 'Other',
	                logFilterQueryPlaceholder: 'Search (context/message)',
	                logDownloadButton: 'Download (filtered)',
	                logClearButton: 'Clear view',
	                formatErrorsClearButton: 'Clear',
	                formatErrorsDownloadButton: 'Download (JSON)',
	                fullCaptureEnabledLabel: 'Full API capture (IndexedDB)',
	                fullCaptureExportButton: 'Export full log (JSONL)',
	                fullCaptureClearButton: 'Clear full log',
	                fullCaptureStatusDisabled: 'disabled',
	                fullCaptureStatusEnabledFmt: 'enabled â€¢ records {n} â€¢ pending {p}',
	                fullCaptureStatusErrorFmt: 'error: {error}',
	
	                finalGuideTitle: 'Final guide',
	                finalGuideNotReady: 'Not completed yet.',
	                finalGuideBuilding: 'Building final guide...',
	                finalGuideDownloadRendererSaveButton: 'Download renderer save (.json)',
	                finalGuideDownloadTxtButton: 'Download (.txt)',
	
	                exportNoTypeResultsError: 'No type classification results yet. (Run Phase 1 first.)',
	                exportNoFinalGuideAlert: 'No final guide yet. (Complete Phase 3 first.)',
	                exportFailedCheckLogsAlert: 'Export failed. Check the logs.',

	                p1ClustersTitle: 'Type classification results (clusters)',
	                p1PerChunkVerifyFmt: 'Per-chunk verification ({n})',
	                p1TypeBundleDownloadButton: 'Download types + original problems (.json)',
	                p1RunSubgroupingButton: 'Run subgrouping (experimental)',
	                p1SubgroupifySaveButton: 'Subgroupify existing save (.json)',
	                tabPostprocessSave: 'Save postprocessing',
	                ppLoadSaveButton: 'Load save (.json)',
	                ppResetWorkingButton: 'Reset working',
	                ppDownloadWorkingButton: 'Download working',
	                ppStopButton: 'Stop',
	                ppLoadedFileFmt: 'Loaded: {name}',
	                ppNoFileLoaded: 'No file loaded.',
	                ppSubgroupSectionTitle: 'Subgroupify (subgroup_tag)',
	                ppChunkTokensLabel: 'Chunk tokens (approx.)',
	                ppRunSubgroupButton: 'Run subgroupify',
	                ppFillSectionTitle: 'Fill answers/explanations',
	                ppFillAnswersLabel: 'Fill answers',
	                ppFillExplanationsLabel: 'Fill explanations',
	                ppOverwriteAnswersLabel: 'Overwrite answers',
	                ppOverwriteExplanationsLabel: 'Overwrite explanations',
	                ppIncludeTypeGuideLabel: 'Include type guide (fmm_source)',
	                ppTypeGuideMaxCharsLabel: 'Type guide max chars',
	                ppUseDuckDuckGoLabel: 'Use DuckDuckGo Instant Answer',
	                ppRunFillButton: 'Run fill',
	                ppRunBothButton: 'Run both',
	                ppFillHelpText: 'Fills official_answer / official_explanation. Also prepends an LLM provenance banner to official_explanation.',
	                ppStopRequested: 'Stop requested.',
	                ppRunningSubgroup: 'Running subgroupify...',
	                ppDoneSubgroupFmt: 'Done. Assigned {n} problems.',
	                ppRunningFill: 'Filling answers/explanations...',
	                ppDoneFillFmt: 'Done. Filled answers {a}, explanations {e}.',
	                ppRunningBoth: 'Running subgroupify + fill...',
	                ppProgressAfterSubgroupFmt: 'Subgroupify done. assigned={n} â†’ running fill...',
	                ppDoneBothFmt: 'Done. subgroup={sg}, answers={a}, explanations={e}.',

	                p2ProgressSummaryTitle: 'Progress summary',
	                p2ProgressTotalFmt: 'Total {n}',
	                p2ProgressPendingFmt: 'Pending {n}',
	                p2ProgressProcessingFmt: 'In progress {n}',
	                p2ProgressCompletedFmt: 'Done {n}',
	                p2ProgressErrorFmt: 'Error {n}',
	                p2ProgressDetailsSummary: 'View details',
	                p2ProgressTableType: 'Type',
	                p2ProgressTableStatus: 'Status',
	                p2ProgressTableCalls: 'Calls',
	                p2ProgressTableCoverage: 'Coverage',
	
	                apiKeysLabel: 'API keys (one per line)',
	                apiKeysPlaceholder: 'Enter keys\n(one per line)',
	                apiUrlLabel: 'API URL',
	                apiUrlHelpHtml: 'If you include <code>{model}</code>, it will be replaced with the model name. (OpenAI-compatible: <code>.../v1/chat/completions</code> or <code>.../v1beta/openai/chat/completions</code>; Upstage: <code>https://api.upstage.ai/v1</code>; Cloudflare Responses: <code>.../ai/v1/responses</code>)',
	                apiProxyUrlLabel: 'Proxy URL (optional)',
	                apiProxyUrlPlaceholder: 'https://your-proxy.example/forward or https://your-proxy.example/?url={url}',
	                apiProxyUrlHelpHtml: 'Use this for endpoints blocked by CORS (e.g., Cloudflare AI). If the URL contains <code>{url}</code>, the request is forwarded as-is; otherwise, it is sent via a JSON wrapper.',
	                apiModelLabel: 'Model name',
	                bypassSystemRoleLabel: 'System Role Bypass (merge into User)',
	                enableRateLimitLabel: 'Enable per-key rate limiting',
	                rpmLabel: 'RPM (calls/min)',
	                tpmLabel: 'TPM (tokens/min)',
	                inflightLabel: 'Per-key concurrent requests',
	                inflightPlaceholder: '0 = unlimited',
	                inflightHelp: 'Max number of in-flight requests per API key (0 = unlimited).',
	
		                stdProblemLangLabel: 'Guide language',
		                stdProblemLangPlaceholder: 'e.g., Korean / English',
	
		                statusTitleStopping: 'Stoppingâ€¦',
		                statusStoppingSubtext: 'Waiting for the current job to finishâ€¦',
		                statusReadyTitle: 'Ready',
		                statusReadySubtext: 'Upload a PDF or TXT exam paper to begin.',
	                statusReadyFilesLoadedFmt: '{n} file(s) loaded. Set split options, then click â€œBuild manualâ€.',
	                statusReadyOcrCacheLoadedFmt: 'OCR cache loaded ({n} units). To restart from Phase 0, click â€œBuild manualâ€.',
	                statusTitleCompleted: 'Done',
	                statusCompletedSubtext: 'Guide generation finished.',
	                statusTitlePaused: 'Paused',
	                statusPausedPendingModulesSubtext: 'Some modules stayed pending due to filters / max-module settings. Adjust settings and click â€œResume manualâ€.',
	                statusPausedStopAfterSubtext: 'Stopped at the configured phase. Adjust â€œStop after phaseâ€ and click â€œResume manualâ€.',
	                statusTitleStopped: 'Stopped',
	                statusStoppedSubtext: 'Stopped by user.',
	                statusTitleError: 'Error',
	                statusErrorSubtext: 'An error occurred. Check the logs.',
	                phase0ImageCropsLabel: 'Figure/Diagram Crops (optional)',
	                phase0ImageCropsTextHtml: 'For questions with figures/diagrams: prepend image crops to <code>question_text</code> as <code>![img](data:...)</code>',
	                phase0ImageCropsHelp: 'Default: off. Enabling can increase cost/file size.',
	                phase0MultimodalTransportLabel: 'Phase 0: Multimodal input transport',
	                phase0MultimodalTransportImages: 'Images + PDF text (current)',
	                phase0MultimodalTransportPdf: 'PDF + PDF text (experimental)',
	                phase0MultimodalTransportHelp: 'Default keeps the current image+rawText flow. â€œPDF + textâ€ attaches the PDF to the model (no local rendering).',
	                phase0SmartRouterLabel: 'Phase 0: Smart QID Router (experimental)',
	                phase0SmartRouterTextHtml: 'Attach PDF â†’ route <code>Pageâ†’QID</code> â†’ extract by QID batches (never splits atomic QID blocks)',
	                phase0SmartRouterHelp: 'Split pages is treated as â€œmax pages per requestâ€. If 0, it packs the entire file into 1 request (can be large).',
	                phase1SubgroupingLabel: 'Subgroups within types (experimental)',
	                phase1SubgroupingTextHtml: 'Within each type: group only the problems that share an identical one-sentence solving rule using <code>subgroup_tag</code> (affects renderer similarity groups)',
	                phase1SubgroupingHelp: 'Default: off. Enabling adds extra calls after Phase 3 (final export).',
	
	                runPlanLabel: 'Run plan',
	                runStartFromLabel: 'Restart point (applies once)',
	                runStartFromContinue: 'Continue (resume only pending phases)',
	                runStartFromPhase0: 'Restart from Phase 0 (Extraction)',
	                runStartFromPhase1: 'Restart from Phase 1 (Type classification)',
	                runStartFromPhase2: 'Restart from Phase 2 (Guides/Coverage)',
	                runStartFromPhase3: 'Restart Phase 3 only (Final merge)',
	                runStopAfterLabel: 'Stop after phase',
	                runStopAfterPhase3: 'Up to Phase 3 (full run)',
	                runStopAfterPhase2: 'Up to Phase 2 (guides/coverage only)',
	                runStopAfterPhase1: 'Up to Phase 1 (type classification only)',
	                runStopAfterPhase0: 'Up to Phase 0 (extraction only)',
	                resetCallCountersLabel: 'Reset call counter on start/resume',
	                runPlanHelp: 'After loading a saved file, choose a restart point and click â€œResume manualâ€ to rerun from that phase. (Restart applies once.)',
	                runPlanExamples: 'Examples: (1) save with OCR only â†’ Phase 0, (2) save up to type classification (clusters) â†’ Phase 2, (3) rebuild final merge only â†’ Phase 3 only',
	                chunkTokensLabel: 'Phase 1: Chunk tokens (approx.)',
	                chunkTokensHelp: 'Larger chunks reduce calls but increase prompt size.',
	                chunkTokens1bLabel: 'Phase 1B: Classification batch tokens (approx.)',
	                chunkTokens1bHelp: 'Applies only to Phase 1B (type classification) batching. (Separate from Phase 1A type standard generation/verification.)',
	                subgroupChunkTokensLabel: 'Phase 1: Subgrouping batch tokens (approx.)',
	                subgroupChunkTokensHelp: 'Applies only to Phase 1 subgrouping (within-type grouping) batching.',
	                phase0AnswerFillLabel: 'LLM fill (postprocess-equivalent) (optional)',
	                phase0AnswerFillTextHtml: 'Postprocess-equivalent: fill <code>official_answer</code> / <code>official_explanation</code> using LLM (warning: not official)',
	                phase0AnswerFillHelp: 'Default: off. Enabling adds extra calls after Phase 3 (final guide), so it can include the type guide.',
	                answerFillChunkTokensLabel: 'LLM fill batch tokens (approx.)',
	                answerFillChunkTokensHelp: 'Applies only to LLM answer/explanation filling batches.',
	                answerFillRefLabel: 'Reference sources (optional)',
	                answerFillDuckDuckGoLabel: 'Use DuckDuckGo Instant Answer (free, extra network requests)',
	                tokenizerModeLabel: 'Tokenizer mode',
	                tokenizerModeCharEstimate: 'Char estimate (lenÃ·4, fastest)',
	                tokenizerModeCharEstimate3: 'Char estimate (lenÃ·3, conservative)',
	                tokenizerModeCharEstimate25: 'Char estimate (lenÃ·2.5, very conservative)',
	                tokenizerModeSimpleSplit: 'Word/whitespace split (lightweight approx.)',
	                tokenizerModeGptTokenizer: 'gpt-tokenizer (accurate, slow first load)',
	                tokenizerModeHelp: 'Char estimate is fastest. gpt-tokenizer is accurate but requires loading a ~2MB library.',
	                chunkModeLabel: 'Phase 1: Chunking strategy',
	                chunkModeFileFirst: 'Group by file first (recommended)',
	                chunkModeSequential: 'Sequential (legacy)',
	                chunkModeHelp: 'Group by file first: keeps varied problems from one file together, reducing overly narrow classifications.',
	                maxTypesLabel: 'Phase 1: Max number of types',
	                maxTypesHelp: 'Limits final number of types when merging per-chunk types (default 25).',
	                phase1ArchTitle: 'Phase 1: Type classification architecture',
	                phase1ArchModeLabel: 'Mode',
	                phase1ArchP1Default: 'Default: aim for pass per chunk (max 2)',
	                phase1ArchP1NoEval: 'pass@1: one-shot (no verification/retry)',
	                phase1ArchP1UntilPass: 'Repeat until pass (unlimited; costâ†‘)',
	                phase1ArchP1CoverageStyle: 'Coverage: create types â†’ merge â†’ classify â†’ retry unclassified',
	                phase2ArchTitle: 'Phase 2: Guide/Coverage architecture',
	                phase2ArchModeLabel: 'Mode',
	                phase2ArchP2Default: 'Default: audit (1 feedback) + coverage patch',
	                phase2ArchP2PassToCoverage: 'pass@1: skip audit â†’ coverage patch',
	                phase2ArchP2AuditorOnly: 'Audit only: skip coverage',
	                phase2ArchP2AuditorUntilPassThenCoverage: 'Repeat audit until pass â†’ coverage patch',
	                phase2ArchP2Integrated: 'Integrated: skip audit â†’ coverage patcher improves pedagogy too',
	                phase2ArchP2IntegratedCreatorPatch: 'Integrated (explanation patch): skip audit â†’ coverage patch based on explanation creator',
	                phase2ArchP2DraftOnly: 'Ultra low cost: skip audit & coverage (draft only)',
	                phase2TargetLabel: 'Target types',
	                phase2TargetAll: 'All types',
	                phase2TargetSingle: 'Single type only (name contains / regex)',
	                phase2TargetQueryLabel: 'Type filter',
	                phase2TargetQueryPlaceholder: 'e.g., Linear function / /quadratic/i',
	                phase2MaxModulesLabel: 'Max modules (0 = unlimited)',
	                coverageSettingsLabel: 'Coverage patch settings (Phase 2)',
	                coverageMaxTokensLabel: 'Max tokens (per request)',
	                coverageMaxRoundsLabel: 'Max rounds',
	                coverageAutoAcceptLabel: 'If remaining â‰¤ N, patch once and accept (skip re-verify)',
	                coverageMaxTokensHelpHtml: '<code>Max tokens</code> applies to the full request (system+guide+problems). If exceeded, it auto-splits. (Separate from output <code>max_tokens</code>.)',
	                coverageAutoAcceptHelp: '<code>N=0</code> disables. If verifier finds â‰¤ N missing items, it patches once and stops. (Does not re-verify exact final coverage.)',
	                coverageVerifierOutputLabel: 'Verifier output',
	                coverageVerifierOutputFull: 'Full (covered+missing, with evidence)',
	                coverageVerifierOutputMissingOnly: 'Missing only (low cost)',
	                coverageVerifierMaxTriesLabel: 'Verifier retries (0 = unlimited)',
	                coverageFinalVerifyLabel: 'Final verification',
	                coverageFinalVerifyGlobal: 'Global (re-verify all problems)',
	                coverageFinalVerifyPerChunk: 'Per-chunk after completion (no global re-ask)',
	                coverageFinalVerifyNone: 'Skip (minimum cost)',
	                coverageOverflowModeLabel: 'When guide overflows',
	                coverageOverflowGuideMerge: 'Split/merge guides (recommended)',
	                coverageOverflowTypeSplit: 'Split types',
	                coverageOverflowError: 'Stop with error',
	                coverageOverflowThresholdLabel: 'Split threshold (error count)',
	                coverageOverflowHelpHtml: 'In â€œfullâ€ mode, it receives <code>covered</code>/<code>reason</code> for every problem and auto-retries if the item count mismatches.<br>â€œSplit/merge guidesâ€ generates guides for sub-splits and then merges them.',
	                phase0PdfInputModeLabel: 'Phase 0: Extraction (OCR) mode',
	                phase0PdfInputModeMultimodal: 'LLM multimodal (images + PDF text)',
	                phase0PdfInputModeRawTextOnly: 'Text only (PDF text only; no images)',
	                phase0PdfInputModeTesseractText: 'Tesseract OCR â†’ text only (no images)',
	                tesseractLangLabel: 'Tesseract language',
	                tesseractLangPlaceholder: 'e.g., kor+eng',
	                tesseractHelp: 'Tesseract downloads traineddata in the browser. First run may be slow.',
	                maxDataEnvelopeTriesLabel: 'Strict <data> format retry limit (0 = unlimited)',
	                maxDataEnvelopeTriesHelp: 'Prevents infinite retries when the model keeps breaking the XML format.',
	                structuredOutputStyleLabel: 'Structured output style',
	                structuredOutputStyleStructuredOnly: 'Structured only (default)',
	                structuredOutputStyleRationaleThenStructured: 'Rationale first â†’ structured output (last)',
	                structuredOutputStyleHelp: 'For structured-output steps (<data>, <patches>, etc.), prompts the model to output rationale first and put the structured block at the very end. (Includes experiment modes.)',
	                structuredOutputOverridesLabel: 'Rationale-first (per-phase override)',
	                structuredOutputPhase0Label: 'Phase 0 (Extraction)',
	                structuredOutputPhase1aLabel: 'Phase 1A (Type standard)',
	                structuredOutputPhase1bLabel: 'Phase 1B (Type classification)',
	                structuredOutputPhase2Label: 'Phase 2 (Modules/Coverage)',
	                structuredOutputOptionInherit: 'Inherit global',
	                structuredOutputOptionStructuredOnly: 'Structured only',
	                structuredOutputOptionRationaleThenStructured: 'Rationale first',
	                structuredOutputOverridesHelp: 'If you enable â€œRationale firstâ€ in Phase 1B, it automatically asks only for a short â€œmethodology summaryâ€ to prevent context explosion.',
	
	                typeGuideImportLabel: 'Import type guides (.txt/.md)',
	                typeGuideImportButton: 'Load',
	                typeGuideImportStatusEmpty: 'No guide loaded',
	                typeGuideStatusRegenerating: 'Regenerating type guides...',
	                typeGuideStatusRegenerationCompleteFmt: 'Regeneration complete Â· {n} type(s)',
	                typeGuideStatusResultsReadyFmt: 'Ready: {n} regenerated type result(s)',
	                typeGuideStatusImportLoadedFmt: 'Loaded: {titles}',
	                typeGuideStatusImportFailedFmt: 'Load failed: {error}',
	                unknownError: 'Unknown error',
	                typeGuideRerunButton: 'Regenerate guides',
	                typeGuideExportButton: 'Download patch (.json)',
	
	                incBaseImportLabel: 'Load existing guide/problem base (.json)',
	                incBaseImportButton: 'Load',
	                incBaseImportHelpHtml: 'Recommended: patch file created by the builder (<code>type_patch_*.json</code>).<br>If you only use â€œAdd as new type (unclassified)â€, you can run without a base.',
	                incNewFilesLabel: 'Upload new exam papers to add (.pdf, .txt)',
	                incNewFilesButton: 'Choose files',
	                incNewFilesStatusNone: 'No files selected',
	                incNewFilesStatusSelectedFmt: 'Selected {n}: {names}',
	                incOcrSplitLabel: 'OCR split (PDF pages per chunk)',
	                incOcrSplitHelp: '0 uses the global default (top setting). e.g., 5 â†’ create OCR/extraction units every 5 pages.',
	                incReuseExtractionCacheLabel: 'Reuse completed OCR/extraction results when re-running the same files',
	                incTypeModeLabel: 'Type batching mode',
	                incTypeModeDistribute: 'Distribute into existing types (requires classification standard)',
	                incTypeModeNewType: 'Add as a new type (unclassified)',
	                incTypeModeHelp: 'â€œDistribute into existing typesâ€ requires `classificationStandard` in the base file. If missing, use â€œnew typeâ€.',
	                incNewTypeTitleLabel: 'New type title',
	                incExperimentalOptionsLabel: 'Experimental options',
	                incExperimentalImageCropsLabel: 'For questions with figures/diagrams: prepend image crops to `question_text` as `![img](data:...)` (experimental)',
	                incRunButton: 'Build incremental patch',
	                incDownloadButton: 'Download patch (.json)',
	                incStatusIdle: 'Idle',
	                incAlertSelectNewFiles: 'Please choose new exam files.',
	                incAlertDistributeNeedsBaseTypes: 'â€œDistribute into existing typesâ€ requires a base file with types.',
	                incAlertDistributeNeedsClassificationStandard: 'â€œDistribute into existing typesâ€ requires `classificationStandard` in the base file.\\n\\nâ†’ (1) Use a builder patch file (type_patch_*.json)\\nâ†’ (2) Or switch mode to â€œAdd as a new type (unclassified)â€.',
	                incStatusBaseLoadedFmt: 'Base loaded: {typesN} types Â· classification standard {std}',
	                incStatusStdPresent: 'present',
	                incStatusStdMissing: 'missing',
	                incStatusBaseLoadFailedFmt: 'Base load failed: {error}',
	                incStatusProcessingNewTypeNoBase: 'Processing: creating new type (no base)...',
	                incStatusProcessingFileToOcr: 'Processing: files â†’ OCR units...',
	                incStatusProcessingCacheReuseFmt: 'Processing: reusing cacheâ€¦ ({n} problems)',
	                incStatusProcessingExtractFmt: 'Processing: extraction (OCR/LLM)â€¦ ({unitsN} units)',
	                incStatusProcessingImageCrops: 'Processing: image crops (experimental)â€¦',
	                incStatusProcessingCoveragePatchFmt: 'Processing: coverage patchâ€¦ ({n} problems)',
	                incStatusCompletedFmt: 'Done: added {n} problems Â· patched {patchedN} types',
	                incStatusFailedFmt: 'Failed: {error}',
	
	                promptsImportButton: 'Load',
	                promptsExportButton: 'Export',
	                promptsResetButton: 'Reset',
	                promptExtractorLabel: '1. Extraction (Extractor) prompt',
	                promptClassifierStandardLabel: '2a. Type standard creation prompt',
	                promptClassifierStandardVerifierLabel: '2a-Verify. Type standard evaluation prompt',
	                promptClassifierApplyLabel: '2b. Type classification apply prompt',
	                promptSubgroupCreatorLabel: '2c. Subgroup creation prompt (experimental)',
	                promptStandardProblemCreatorLabel: '3. Standard problem creation prompt',
	                promptExplanationCreatorLabel: '4. Explanation creation prompt',
	                promptExplanationFeedbackLabel: '5. Audit/feedback prompt',
	                promptCoverageVerifierLabel: '6. Coverage verification prompt',
	                promptCoveragePatcherLabel: '7. Coverage patch prompt',
	
	                startButtonCreate: 'Build manual',
	                startButtonResume: 'Resume manual',
	                startButtonStop: 'Stop',
	            },
	            ko: {
	                appTitle: 'íˆíŠ¸ì¬ë” ê°€ì´ë“œ ìƒì„±ê¸°',
	                guiLangLabel: 'GUI ì–¸ì–´',
	                guiLangOptionEnglish: 'ì˜ì–´',
	                guiLangOptionKorean: 'í•œêµ­ì–´',
	                apiCallCounterPrefix: 'API í˜¸ì¶œ',
	                fileUploadLabel: '1. ì‹œí—˜ì§€ ì—…ë¡œë“œ (.pdf, .txt)',
	                fileUploadHint: 'ì—¬ê¸°ë¥¼ í´ë¦­í•˜ê±°ë‚˜ PDF/TXT íŒŒì¼ì„ ë“œë¡­í•˜ì„¸ìš”',
	                answerFileUploadLabel: 'ì •ë‹µ/í•´ì„¤ íŒŒì¼ ì—…ë¡œë“œ (ì˜µì…˜)',
	                answerFileUploadHint: 'ì—¬ê¸°ë¥¼ í´ë¦­í•˜ê±°ë‚˜ PDF/TXT íŒŒì¼ì„ ë“œë¡­í•˜ì„¸ìš” (ì •ë‹µ/í•´ì„¤)',
	                answerFileUploadHelp: 'íŒŒì¼ëª…ì´ ì•ˆ ë§ì•„ë„ ë©ë‹ˆë‹¤. 0ë‹¨ê³„(ì¶”ì¶œ) ì´í›„ ë¬¸ì„œ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ ìë™ ë§¤ì¹­ í›„ ì •ë‹µë§Œ ì±„ì›ë‹ˆë‹¤.',
	                answerFileListRemoveFileTitle: 'ì •ë‹µ/í•´ì„¤ íŒŒì¼ ì œê±°',
	                fileListSplitEveryLabel: 'ë§¤',
	                fileListSplitPagesLabel: 'í˜ì´ì§€',
	                fileListRemoveFileTitle: 'íŒŒì¼ ì œê±°',
	                globalSplitPagesLabel: 'ì „ì—­ PDF ë¶„í•  í˜ì´ì§€ (ì˜µì…˜)',
	                globalSplitPagesPlaceholder: '(ë¹„ìš°ë©´ íŒŒì¼ë³„ ì„¤ì •)',
	                globalSplitPagesHelp: 'ê°’ì„ ë„£ìœ¼ë©´, ê°œë³„ PDF ë¶„í• ì´ 0(ê¸°ë³¸)ì¸ íŒŒì¼ì— ì „ì—­ ê°’ì´ ì ìš©ë©ë‹ˆë‹¤.',
	                globalKeySplitCountLabel: 'í‚¤ ë¶„í•  ê°œìˆ˜(ì›Œì»¤ ìˆ˜) (ì˜µì…˜)',
	                globalKeySplitCountPlaceholder: '(ë¹„ìš°ë©´ ìë™: ëª¨ë“  í‚¤ ì‚¬ìš©)',
	                globalKeySplitCountHelp: '0~2ë‹¨ê³„ ì›Œì»¤ ë™ì‹œì„±ì„ ì œì–´í•©ë‹ˆë‹¤. (ìë™: ëª¨ë“  í‚¤ ì‚¬ìš©)',
	                saveButtonTitle: 'ì €ì¥',
	                loadButtonTitle: 'ë¶ˆëŸ¬ì˜¤ê¸°',
	                clearButtonTitle: 'ì‹¤í—˜ ì´ˆê¸°í™” (ì „ì²´ ì‚­ì œ)',
	                loadOcrOnlyText: 'OCR ìºì‹œë§Œ ë¶ˆëŸ¬ì˜¤ê¸° (ê¸°ì¡´ íŒŒì´í”„ë¼ì¸ ë¬´ì‹œ, 0ë‹¨ê³„ë¶€í„° ì¬ì‹œì‘)',
	                summaryApiSettings: 'API ì„¤ì •',
	                summaryGenerationOptions: 'ìƒì„± ì˜µì…˜',
	                summaryExperimentCost: 'ì‹¤í—˜ / ë¹„ìš© ì œì–´',
	                summaryTypeGuideRegeneration: 'ìœ í˜• ê°€ì´ë“œ ì¬ìƒì„±',
	                summaryIncremental: 'ì‹ ê·œ ë¬¸ì œ ì¶”ê°€ (ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜ ì „ìš©)',
	                summaryPromptsAdvanced: 'í”„ë¡¬í”„íŠ¸(ê³ ê¸‰)',
	                summaryApiMonitor: 'API ëª¨ë‹ˆí„°',
	                summaryFormatErrors: 'í˜•ì‹ ì˜¤ë¥˜(êµ¬ì¡°í™” ì¶œë ¥) â€” raw I/O ëª¨ìŒ',
	
	                apiMonitorColIndex: '#',
	                apiMonitorColKey: 'í‚¤',
	                apiMonitorColContext: 'ì»¨í…ìŠ¤íŠ¸',
	                apiMonitorColStatus: 'ìƒíƒœ',
	                apiMonitorRecentCallsTitle: 'ìµœê·¼ í˜¸ì¶œ (50)',
		                apiMonitorTotalsInit: 'í˜¸ì¶œ 0 â€¢ waiting 0 â€¢ inflight 0 â€¢ ì„±ê³µ 0 â€¢ ì‹¤íŒ¨ 0',
		                apiMonitorTotalsFmt: 'í˜¸ì¶œ {total} â€¢ waiting {waiting} â€¢ inflight {inflight} â€¢ ì„±ê³µ {ok} â€¢ ì‹¤íŒ¨ {fail}',
		                apiMonitorBreakdownTitle: 'í˜¸ì¶œ ë¸Œë ˆì´í¬ë‹¤ìš´ (ì„±ê³µ)',
		                apiMonitorBreakdownResetButton: 'ì´ˆê¸°í™”',
		                callStatsSessionAll: 'ì „ì²´ ì„¸ì…˜',
		                callStatsSessionCurrentFmt: 'í˜„ì¬ ì„¸ì…˜ ({id})',
		                callStatsSessionOtherFmt: 'ì„¸ì…˜ {id}',
		                callStatsStatLineFmt: '[{session}] ì„±ê³µ {ok} â€¢ ì‹¤íŒ¨ {fail} â€¢ í˜•ì‹ì˜¤ë¥˜ {fmt}',
		                callStatsGlobalLineFmt: '(ì „ì²´ëˆ„ì : ì„±ê³µ {okTotal} / Global AvgLat {avgLat})',
		                callStatsPhaseLineFmt: '0ë‹¨ê³„ {p0} â€¢ 1ë‹¨ê³„ {p1} â€¢ 2ë‹¨ê³„ {p2} â€¢ 3ë‹¨ê³„ {p3}',
		                callStatsLastOkFmt: 'ë§ˆì§€ë§‰ ì„±ê³µ {time}',
		                callStatsNoOkYet: 'ì•„ì§ ì„±ê³µ í˜¸ì¶œì´ ì—†ìŠµë‹ˆë‹¤.',
		                callStatsStageLineFmt: '{stage}: {n} (avgLat {avg})',
		                callStatsStageP0Extract: '0ë‹¨ê³„ ì¶”ì¶œ',
		                callStatsStageP1CreateTypes: '1ë‹¨ê³„A ìœ í˜•í‘œì¤€',
		                callStatsStageP1EvalTypes: '1ë‹¨ê³„A ê²€ì¦',
		                callStatsStageP1Merge: '1ë‹¨ê³„ í†µí•©',
		                callStatsStageP1ClassifyBatch: '1ë‹¨ê³„B ë¶„ë¥˜',
		                callStatsStageP1Subgroup: '1ë‹¨ê³„ ì†Œê·¸ë£¹',
		                callStatsStageP2StdProblem: '2ë‹¨ê³„ í‘œì¤€ë¬¸ì œ',
		                callStatsStageP2Explanation: '2ë‹¨ê³„ í•´ì„¤',
		                callStatsStageP2Auditor: '2ë‹¨ê³„ ê°ì‚¬',
		                callStatsStageP2ReviseStdProblem: '2ë‹¨ê³„ í‘œì¤€ìˆ˜ì •',
		                callStatsStageP2ReviseExplanationPatch: '2ë‹¨ê³„ í•´ì„¤íŒ¨ì¹˜',
		                callStatsStageP2CoverageVerify: '2ë‹¨ê³„ ì»¤ë²„ê²€ì¦',
		                callStatsStageP2CoveragePatch: '2ë‹¨ê³„ ì»¤ë²„íŒ¨ì¹˜',
		                callStatsStageOther: 'ê¸°íƒ€',
	
	                processLogTitle: 'í”„ë¡œì„¸ìŠ¤ ë¡œê·¸',
	                logUiMaxLinesLabel: 'í‘œì‹œ ì¤„ìˆ˜',
	                logUiMaxCharsLabel: 'ì¤„ë‹¹ ê¸€ììˆ˜',
	                logFilterTypeLabel: 'íƒ€ì…',
	                logFilterTypeAll: 'ì „ì²´',
	                logFilterTypeApiInput: 'API ì…ë ¥',
	                logFilterTypeApiOutput: 'API ì¶œë ¥',
	                logFilterTypeErrors: 'ê²½ê³ +ì—ëŸ¬',
	                logFilterTypeErrorsNoHttp: 'ê²½ê³ +ì—ëŸ¬(HTTP 429/5xx ì œì™¸)',
		                logFilterSessionLabel: 'ì„¸ì…˜',
		                logFilterSessionCurrent: 'í˜„ì¬ ì„¸ì…˜',
		                logFilterSessionAll: 'ì „ì²´ ì„¸ì…˜',
		                logFilterSessionCurrentFmt: 'í˜„ì¬ ì„¸ì…˜ ({id})',
	                logFilterPhaseLabel: 'í˜ì´ì¦ˆ',
	                logFilterPhaseAll: 'ì „ì²´',
	                logFilterPhase0: '0ë‹¨ê³„ (ì¶”ì¶œ)',
	                logFilterPhase1: '1ë‹¨ê³„ (ìœ í˜•ë¶„ë¥˜)',
	                logFilterPhase2: '2ë‹¨ê³„ (ê°€ì´ë“œ/ì»¤ë²„ë¦¬ì§€)',
	                logFilterPhase3: '3ë‹¨ê³„ (ìµœì¢…)',
	                logFilterPhaseOther: 'ê¸°íƒ€',
	                logFilterQueryPlaceholder: 'ê²€ìƒ‰ (context/message)',
	                logDownloadButton: 'ë‹¤ìš´ë¡œë“œ(í•„í„°ë¨)',
	                logClearButton: 'í™”ë©´ ì§€ìš°ê¸°',
	                formatErrorsClearButton: 'ì´ˆê¸°í™”',
	                formatErrorsDownloadButton: 'ë‹¤ìš´ë¡œë“œ(JSON)',
	                fullCaptureEnabledLabel: 'ì „ì²´ API ë¡œê·¸ ìº¡ì²˜ (IndexedDB)',
	                fullCaptureExportButton: 'ì „ì²´ ë¡œê·¸ ë‚´ë³´ë‚´ê¸° (JSONL)',
	                fullCaptureClearButton: 'ì „ì²´ ë¡œê·¸ ì‚­ì œ',
	                fullCaptureStatusDisabled: 'êº¼ì§',
	                fullCaptureStatusEnabledFmt: 'ì¼œì§ â€¢ records {n} â€¢ pending {p}',
	                fullCaptureStatusErrorFmt: 'ì˜¤ë¥˜: {error}',
	
	                finalGuideTitle: 'ìµœì¢… ìš”ì•½ë³¸',
	                finalGuideNotReady: 'ì•„ì§ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
	                finalGuideBuilding: 'ìµœì¢… í•©ë³¸ ìƒì„± ì¤‘...',
	                finalGuideDownloadRendererSaveButton: 'ë Œë”ëŸ¬ ì €ì¥íŒŒì¼ ë‹¤ìš´ë¡œë“œ (.json)',
	                finalGuideDownloadTxtButton: 'ë‹¤ìš´ë¡œë“œ (.txt)',
	
	                exportNoTypeResultsError: 'ì•„ì§ ìœ í˜•ë¶„ë¥˜ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. (1ë‹¨ê³„ë¥¼ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”)',
	                exportNoFinalGuideAlert: 'ì•„ì§ ìµœì¢… ìš”ì•½ë³¸ì´ ì—†ìŠµë‹ˆë‹¤. (3ë‹¨ê³„ë¥¼ ì™„ë£Œí•˜ì„¸ìš”)',
	                exportFailedCheckLogsAlert: 'ë‚´ë³´ë‚´ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.',

	                p1ClustersTitle: 'ìœ í˜•ë¶„ë¥˜ ê²°ê³¼(í´ëŸ¬ìŠ¤í„°)',
	                p1PerChunkVerifyFmt: 'ì²­í¬ë³„ ê²€ì¦ ({n}ê°œ)',
	                p1TypeBundleDownloadButton: 'ìœ í˜•ë³„ ë¶„ë¥˜ ê²°ê³¼ + ë¬¸ì œ ì›ë¬¸ ë‹¤ìš´ë¡œë“œ (.json)',
	                p1RunSubgroupingButton: 'ì†Œê·¸ë£¹ ìƒì„± ì‹¤í–‰ (ì‹¤í—˜)',
	                p1SubgroupifySaveButton: 'ê¸°ì¡´ ì €ì¥íŒŒì¼ ì†Œê·¸ë£¹í™” (.json)',
	                tabPostprocessSave: 'ì €ì¥íŒŒì¼ í›„ì²˜ë¦¬',
	                ppLoadSaveButton: 'ì €ì¥íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° (.json)',
	                ppResetWorkingButton: 'ì‘ì—…ë³¸ ë¦¬ì…‹',
	                ppDownloadWorkingButton: 'ì‘ì—…ë³¸ ë‹¤ìš´ë¡œë“œ',
	                ppStopButton: 'ì¤‘ì§€',
	                ppLoadedFileFmt: 'ë¶ˆëŸ¬ì˜´: {name}',
	                ppNoFileLoaded: 'ë¶ˆëŸ¬ì˜¨ íŒŒì¼ ì—†ìŒ.',
	                ppSubgroupSectionTitle: 'ì†Œê·¸ë£¹ ìƒì„± (subgroup_tag)',
	                ppChunkTokensLabel: 'ë°°ì¹˜ í† í°(ëŒ€ëµ)',
	                ppRunSubgroupButton: 'ì†Œê·¸ë£¹ ìƒì„± ì‹¤í–‰',
	                ppFillSectionTitle: 'ì •ë‹µ/í•´ì„¤ ì±„ìš°ê¸°',
	                ppFillAnswersLabel: 'ì •ë‹µ ì±„ìš°ê¸°',
	                ppFillExplanationsLabel: 'í•´ì„¤ ì±„ìš°ê¸°',
	                ppOverwriteAnswersLabel: 'ì •ë‹µ ë®ì–´ì“°ê¸°',
	                ppOverwriteExplanationsLabel: 'í•´ì„¤ ë®ì–´ì“°ê¸°',
	                ppIncludeTypeGuideLabel: 'ìœ í˜• ê°€ì´ë“œ ì²¨ë¶€ (fmm_source)',
	                ppTypeGuideMaxCharsLabel: 'ìœ í˜• ê°€ì´ë“œ ìµœëŒ€ ê¸€ììˆ˜',
	                ppUseDuckDuckGoLabel: 'DuckDuckGo Instant Answer ì°¸ê³ ',
	                ppRunFillButton: 'ì±„ìš°ê¸° ì‹¤í–‰',
	                ppRunBothButton: 'ë‘˜ë‹¤ ì‹¤í–‰',
	                ppFillHelpText: 'official_answer / official_explanation ì±„ìš°ê¸°. LLM ìƒì„± ì—¬ë¶€ëŠ” official_explanation ìƒë‹¨ ë°°ë„ˆë¡œ í‘œì‹œë©ë‹ˆë‹¤.',
	                ppStopRequested: 'ì¤‘ì§€ ìš”ì²­ë¨.',
	                ppRunningSubgroup: 'ì†Œê·¸ë£¹ ìƒì„± ì¤‘...',
	                ppDoneSubgroupFmt: 'ì™„ë£Œ. {n}ë¬¸ì œì— subgroup_tagë¥¼ ë„£ì—ˆìŠµë‹ˆë‹¤.',
	                ppRunningFill: 'ì •ë‹µ/í•´ì„¤ ì±„ìš°ëŠ” ì¤‘...',
	                ppDoneFillFmt: 'ì™„ë£Œ. ì •ë‹µ {a}ê°œ, í•´ì„¤ {e}ê°œ ì±„ì›€.',
	                ppRunningBoth: 'ì†Œê·¸ë£¹+ì±„ìš°ê¸° ì‹¤í–‰ ì¤‘...',
	                ppProgressAfterSubgroupFmt: 'ì†Œê·¸ë£¹ ì™„ë£Œ(assigned={n}) â†’ ì±„ìš°ê¸° ì§„í–‰...',
	                ppDoneBothFmt: 'ì™„ë£Œ. subgroup={sg}, ì •ë‹µ={a}, í•´ì„¤={e}.',

	                p2ProgressSummaryTitle: 'ì§„í–‰ìƒí™© ìš”ì•½',
	                p2ProgressTotalFmt: 'ì „ì²´ {n}',
	                p2ProgressPendingFmt: 'ëŒ€ê¸° {n}',
	                p2ProgressProcessingFmt: 'ì§„í–‰ì¤‘ {n}',
	                p2ProgressCompletedFmt: 'ì™„ë£Œ {n}',
	                p2ProgressErrorFmt: 'ì˜¤ë¥˜ {n}',
	                p2ProgressDetailsSummary: 'ìƒì„¸ ëª©ë¡ ë³´ê¸°',
	                p2ProgressTableType: 'ìœ í˜•ëª…',
	                p2ProgressTableStatus: 'ìƒíƒœ',
	                p2ProgressTableCalls: 'Calls',
	                p2ProgressTableCoverage: 'ì»¤ë²„ë¦¬ì§€',
	
	                apiKeysLabel: 'API í‚¤ (ì¤„ë‹¹ 1ê°œ)',
	                apiKeysPlaceholder: 'í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”\n(ì¤„ë‹¹ 1ê°œ)',
	                apiUrlLabel: 'API URL',
	                apiUrlHelpHtml: '<code>{model}</code>ì„ ì“°ë©´ ëª¨ë¸ëª… ì…ë ¥ê°’ìœ¼ë¡œ ìë™ ì¹˜í™˜ë©ë‹ˆë‹¤. (OpenAI í˜¸í™˜: <code>.../v1/chat/completions</code> ë˜ëŠ” <code>.../v1beta/openai/chat/completions</code>; Upstage: <code>https://api.upstage.ai/v1</code>; Cloudflare Responses: <code>.../ai/v1/responses</code>)',
	                apiProxyUrlLabel: 'í”„ë¡ì‹œ URL (ì˜µì…˜)',
	                apiProxyUrlPlaceholder: 'https://your-proxy.example/forward ë˜ëŠ” https://your-proxy.example/?url={url}',
	                apiProxyUrlHelpHtml: 'CORSë¡œ ë§‰íŒ ì—”ë“œí¬ì¸íŠ¸(ì˜ˆ: Cloudflare AI)ì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤. URLì— <code>{url}</code>ì´ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ í¬ì›Œë”©í•˜ê³ , ì—†ìœ¼ë©´ JSON ë˜í¼ë¡œ ì „ì†¡í•©ë‹ˆë‹¤.',
	                apiModelLabel: 'ëª¨ë¸ëª…',
	                bypassSystemRoleLabel: 'System Role Bypass (Userë¡œ ë³‘í•©)',
	                enableRateLimitLabel: 'í‚¤ë³„ ì†ë„ ì œí•œ ì‚¬ìš©',
	                rpmLabel: 'RPM (í˜¸ì¶œ/ë¶„)',
	                tpmLabel: 'TPM (í† í°/ë¶„)',
	                inflightLabel: 'í‚¤ë³„ ë™ì‹œ ìš”ì²­ ì œí•œ',
	                inflightPlaceholder: '0 = ë¬´ì œí•œ',
	                inflightHelp: 'API í‚¤ë³„ ë™ì‹œ ì§„í–‰ ìš”ì²­ì˜ ìµœëŒ€ ê°œìˆ˜(0 = ë¬´ì œí•œ).',
	
		                stdProblemLangLabel: 'ê°€ì´ë“œ ì–¸ì–´',
		                stdProblemLangPlaceholder: 'ì˜ˆ) Korean / English',
	
		                statusTitleStopping: 'ì¤‘ë‹¨ ì¤‘...',
		                statusStoppingSubtext: 'í˜„ì¬ ì‘ì—…ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...',
		                statusReadyTitle: 'ì¤€ë¹„',
		                statusReadySubtext: 'ì‹œì‘í•˜ë ¤ë©´ PDF ë˜ëŠ” TXT ì‹œí—˜ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”.',
	                statusReadyFilesLoadedFmt: '{n}ê°œ íŒŒì¼ ë¡œë”©ë¨. ë¶„í•  ì„¤ì • í›„ â€˜ë§¤ë‰´ì–¼ ìƒì„±â€™ì„ ëˆ„ë¥´ì„¸ìš”.',
	                statusReadyOcrCacheLoadedFmt: 'OCR ìºì‹œ ë¡œë”©ë¨ ({n}ê°œ ë‹¨ìœ„). 0ë‹¨ê³„ë¶€í„° ì‹œì‘í•˜ë ¤ë©´ â€˜ë§¤ë‰´ì–¼ ìƒì„±â€™ì„ ëˆ„ë¥´ì„¸ìš”.',
	                statusTitleCompleted: 'ì™„ë£Œ',
	                statusCompletedSubtext: 'ê°€ì´ë“œ ìƒì„±ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.',
	                statusTitlePaused: 'ì¼ì‹œì •ì§€',
	                statusPausedPendingModulesSubtext: 'ëŒ€ìƒ í•„í„°/ìµœëŒ€ ëª¨ë“ˆ ìˆ˜ ì„¤ì • ë•Œë¬¸ì— ì¼ë¶€ ëª¨ë“ˆì´ pendingìœ¼ë¡œ ë‚¨ì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ ë°”ê¾¸ê³  â€˜ë§¤ë‰´ì–¼ ì¬ê°œâ€™ë¡œ ê³„ì†í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
	                statusPausedStopAfterSubtext: 'ì‹¤í–‰ ì¢…ë£Œ ë‹¨ê³„ ì„¤ì • ë•Œë¬¸ì— ì—¬ê¸°ì„œ ì¢…ë£Œí–ˆìŠµë‹ˆë‹¤. ì¢…ë£Œ ë‹¨ê³„ë¥¼ ì¡°ì •í•˜ê³  â€˜ë§¤ë‰´ì–¼ ì¬ê°œâ€™ë¡œ ê³„ì†í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
	                statusTitleStopped: 'ì¤‘ë‹¨ë¨',
	                statusStoppedSubtext: 'ì‚¬ìš©ìì— ì˜í•´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.',
	                statusTitleError: 'ì˜¤ë¥˜',
	                statusErrorSubtext: 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.',
	                phase0ImageCropsLabel: 'ê·¸ë¦¼/ë„í‘œ í¬ë¡­ (ì˜µì…˜)',
	                phase0ImageCropsTextHtml: 'ê·¸ë¦¼/ë„í‘œê°€ ìˆëŠ” ë¬¸ì œ: ì´ë¯¸ì§€ í¬ë¡­ì„ <code>question_text</code> ì•ì— <code>![img](data:...)</code>ë¡œ ì‚½ì…',
	                phase0ImageCropsHelp: 'ê¸°ë³¸ê°’: ì‚¬ìš© ì•ˆ í•¨. í™œì„±í™” ì‹œ ë¹„ìš©/ìš©ëŸ‰ì´ ì¦ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
	                phase0MultimodalTransportLabel: '0ë‹¨ê³„: ë©€í‹°ëª¨ë‹¬ ì…ë ¥ ì „ì†¡',
	                phase0MultimodalTransportImages: 'ì´ë¯¸ì§€ + PDF í…ìŠ¤íŠ¸ (ê¸°ì¡´)',
	                phase0MultimodalTransportPdf: 'PDF + PDF í…ìŠ¤íŠ¸ (ì‹¤í—˜)',
	                phase0MultimodalTransportHelp: 'ê¸°ë³¸ê°’ì€ ê¸°ì¡´ ì´ë¯¸ì§€+í…ìŠ¤íŠ¸ ë°©ì‹ì…ë‹ˆë‹¤. â€œPDF + í…ìŠ¤íŠ¸â€ëŠ” ë¡œì»¬ ë Œë”ë§ ì—†ì´ PDFë¥¼ ëª¨ë¸ì— ì²¨ë¶€í•©ë‹ˆë‹¤.',
	                phase0SmartRouterLabel: '0ë‹¨ê³„: Smart QID Router (ì‹¤í—˜)',
	                phase0SmartRouterTextHtml: 'PDF ì²¨ë¶€ â†’ <code>Pageâ†’QID</code> ë¼ìš°íŒ… â†’ QID ë¬¶ìŒ ë‹¨ìœ„ ì¶”ì¶œ(atomic blockì€ ì ˆëŒ€ ìë¥´ì§€ ì•ŠìŒ)',
	                phase0SmartRouterHelp: 'ë¶„í•  í˜ì´ì§€ ê°’ì€ â€œìš”ì²­ë‹¹ ìµœëŒ€ í˜ì´ì§€â€ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤. 0ì´ë©´ í•œ íŒŒì¼ì„ 1íšŒ ìš”ì²­ìœ¼ë¡œ ë¬¶ìŠµë‹ˆë‹¤(ì»¤ì§ˆ ìˆ˜ ìˆìŒ).',
	                phase1SubgroupingLabel: 'ìœ í˜• ë‚´ ì†Œê·¸ë£¹ (ì‹¤í—˜)',
	                phase1SubgroupingTextHtml: 'ìœ í˜• ë‚´ì—ì„œ â€œí•œ ë¬¸ì¥ìœ¼ë¡œ ê°™ì€ í’€ì´ê°€ ê°€ëŠ¥í•œâ€ ë¬¸ì œë§Œ <code>subgroup_tag</code>ë¡œ ë¬¶ê¸° (ë Œë”ëŸ¬ ìœ ì‚¬ë„ ê·¸ë£¹ì— ë°˜ì˜)',
	                phase1SubgroupingHelp: 'ê¸°ë³¸ê°’: ì‚¬ìš© ì•ˆ í•¨. í™œì„±í™” ì‹œ 3ë‹¨ê³„(ìµœì¢… ê°€ì´ë“œ) ì´í›„ ì¶”ê°€ í˜¸ì¶œì´ ë°œìƒí•©ë‹ˆë‹¤.',
	
	                runPlanLabel: 'ì‹¤í–‰ ê³„íš',
	                runStartFromLabel: 'ì¬ì‹œì‘ ì§€ì  (í•œ ë²ˆë§Œ ì ìš©)',
	                runStartFromContinue: 'ê³„ì† (ëŒ€ê¸°ì¤‘ ë‹¨ê³„ë§Œ ì´ì–´ì„œ)',
	                runStartFromPhase0: '0ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ (ì¶”ì¶œë¶€í„°)',
	                runStartFromPhase1: '1ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ (ìœ í˜•ë¶„ë¥˜ë¶€í„°)',
	                runStartFromPhase2: '2ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ (ê°€ì´ë“œë¶€í„°)',
	                runStartFromPhase3: '3ë‹¨ê³„ë§Œ ë‹¤ì‹œ (ìµœì¢… í•©ë³¸ë§Œ)',
	                runStopAfterLabel: 'ì‹¤í–‰ ì¢…ë£Œ ë‹¨ê³„',
	                runStopAfterPhase3: '3ë‹¨ê³„ê¹Œì§€ (ì „ì²´)',
	                runStopAfterPhase2: '2ë‹¨ê³„ê¹Œì§€ (ê°€ì´ë“œ/ì»¤ë²„ë¦¬ì§€ê¹Œì§€ë§Œ)',
	                runStopAfterPhase1: '1ë‹¨ê³„ê¹Œì§€ (ìœ í˜•ë¶„ë¥˜ê¹Œì§€ë§Œ)',
	                runStopAfterPhase0: '0ë‹¨ê³„ê¹Œì§€ (ì¶”ì¶œê¹Œì§€ë§Œ)',
	                resetCallCountersLabel: 'ì‹œì‘/ì¬ê°œ ì‹œ í˜¸ì¶œ ì¹´ìš´í„° ì´ˆê¸°í™”',
	                runPlanHelp: 'ì €ì¥íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¨ ë’¤ â€œì¬ì‹œì‘ ì§€ì â€ì„ ì„ íƒí•˜ê³  â€œë§¤ë‰´ì–¼ ì¬ê°œâ€ë¥¼ ëˆ„ë¥´ë©´ í•´ë‹¹ ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ ì‹¤í–‰í•©ë‹ˆë‹¤. (ì¬ì‹œì‘ì€ 1íšŒ ì ìš©)',
	                runPlanExamples: 'ì˜ˆ: (1) OCRë§Œ ìˆëŠ” ì €ì¥íŒŒì¼ â†’ 0ë‹¨ê³„ë¶€í„°, (2) ìœ í˜•ë¶„ë¥˜(í´ëŸ¬ìŠ¤í„°)ê¹Œì§€ ìˆëŠ” ì €ì¥íŒŒì¼ â†’ 2ë‹¨ê³„ë¶€í„°, (3) í•©ë³¸ë§Œ ë‹¤ì‹œ ë§Œë“¤ê¸° â†’ 3ë‹¨ê³„ë§Œ',
	                chunkTokensLabel: '1ë‹¨ê³„: ì²­í¬ í† í°(ëŒ€ëµ)',
	                chunkTokensHelp: 'ì²­í¬ í† í°ì„ í‚¤ìš°ë©´ í˜¸ì¶œ ìˆ˜ëŠ” ì¤„ì§€ë§Œ, í”„ë¡¬í”„íŠ¸ê°€ ì»¤ì§‘ë‹ˆë‹¤.',
	                chunkTokens1bLabel: '1ë‹¨ê³„B: ë¶„ë¥˜ ë°°ì¹˜ í† í°(ëŒ€ëµ)',
	                chunkTokens1bHelp: '1ë‹¨ê³„B(ìœ í˜•ë¶„ë¥˜) ë°°ì¹˜ ë¬¶ìŒì—ë§Œ ì ìš©ë©ë‹ˆë‹¤. (1ë‹¨ê³„A ìœ í˜•í‘œì¤€ ìƒì„±/ê²€ì¦ê³¼ ë¶„ë¦¬)',
	                subgroupChunkTokensLabel: '1ë‹¨ê³„: ì†Œê·¸ë£¹ ë°°ì¹˜ í† í°(ëŒ€ëµ)',
	                subgroupChunkTokensHelp: 'ì†Œê·¸ë£¹ ìƒì„±(ìœ í˜• ë‚´ ë¬¸ì œ ë¬¶ê¸°) ë°°ì¹˜ ë¬¶ìŒì—ë§Œ ì ìš©ë©ë‹ˆë‹¤.',
	                phase0AnswerFillLabel: 'ì •ë‹µ/í•´ì„¤ LLM ì±„ìš°ê¸° (í›„ì²˜ë¦¬ ë°©ì‹) (ì˜µì…˜)',
	                phase0AnswerFillTextHtml: 'ì €ì¥íŒŒì¼ í›„ì²˜ë¦¬ì™€ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ <code>official_answer</code> / <code>official_explanation</code> ì±„ìš°ê¸° (ì£¼ì˜: ê³µì‹ ì•„ë‹˜)',
	                phase0AnswerFillHelp: 'ê¸°ë³¸ê°’: ì‚¬ìš© ì•ˆ í•¨. í™œì„±í™” ì‹œ 3ë‹¨ê³„(ìµœì¢… ê°€ì´ë“œ) ì´í›„ ì¶”ê°€ í˜¸ì¶œì´ ë°œìƒí•©ë‹ˆë‹¤. (ìœ í˜• ê°€ì´ë“œ ì²¨ë¶€ ê°€ëŠ¥)',
	                answerFillChunkTokensLabel: 'LLM ì±„ìš°ê¸° ë°°ì¹˜ í† í°(ëŒ€ëµ)',
	                answerFillChunkTokensHelp: 'ë¯¸ì •ë‹µ ë¬¸ì œ ì •ë‹µ/í•´ì„¤ ìƒì„± ë°°ì¹˜ ë¬¶ìŒì—ë§Œ ì ìš©ë©ë‹ˆë‹¤.',
	                answerFillRefLabel: 'ì°¸ê³  ì†ŒìŠ¤ (ì˜µì…˜)',
	                answerFillDuckDuckGoLabel: 'DuckDuckGo Instant Answer ì°¸ê³  (ë¬´ë£Œ, ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ì¶”ê°€)',
	                tokenizerModeLabel: 'í† í¬ë‚˜ì´ì € ë°©ì‹',
	                tokenizerModeCharEstimate: 'ë¬¸ì ê¸°ë°˜ ì¶”ì • (lenÃ·4, ê°€ì¥ ë¹ ë¦„)',
	                tokenizerModeCharEstimate3: 'ë¬¸ì ê¸°ë°˜ ì¶”ì • (lenÃ·3, ë³´ìˆ˜ì )',
	                tokenizerModeCharEstimate25: 'ë¬¸ì ê¸°ë°˜ ì¶”ì • (lenÃ·2.5, ë§¤ìš° ë³´ìˆ˜ì )',
	                tokenizerModeSimpleSplit: 'ë‹¨ì–´/ê³µë°± ë¶„í•  (ê°€ë²¼ìš´ ê·¼ì‚¬)',
	                tokenizerModeGptTokenizer: 'gpt-tokenizer (ì •í™•, ì²« ë¡œë”© ëŠë¦¼)',
	                tokenizerModeHelp: 'ë¬¸ì ê¸°ë°˜ ì¶”ì •ì´ ê°€ì¥ ë¹ ë¦„. gpt-tokenizerëŠ” ì •í™•í•˜ì§€ë§Œ ~2MB ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë”© í•„ìš”.',
	                chunkModeLabel: '1ë‹¨ê³„: ì²­í¬ ìƒì„± ë°©ì‹',
	                chunkModeFileFirst: 'íŒŒì¼ë³„ ìš°ì„  ë¬¶ê¸° (ê¶Œì¥)',
	                chunkModeSequential: 'ìˆœì°¨ì  (ê¸°ì¡´)',
	                chunkModeHelp: 'íŒŒì¼ë³„ ìš°ì„  ë¬¶ê¸°: í•œ íŒŒì¼ì˜ ë‹¤ì–‘í•œ ìœ í˜•ì´ ê°™ì€ ì²­í¬ì— í¬í•¨ë˜ì–´ ì§€ì—½ì  ë¶„ë¥˜ ë°©ì§€.',
	                maxTypesLabel: '1ë‹¨ê³„: ìµœëŒ€ ìœ í˜• ê°œìˆ˜',
	                maxTypesHelp: 'ì²­í¬ë³„ ìœ í˜• ë³‘í•© ì‹œ ìµœì¢… ìœ í˜• ê°œìˆ˜ ì œí•œ (ê¸°ë³¸ 25).',
	                phase1ArchTitle: '1ë‹¨ê³„: ìœ í˜•ë¶„ë¥˜ ì•„í‚¤í…ì²˜',
	                phase1ArchModeLabel: 'ëª¨ë“œ',
	                phase1ArchP1Default: 'ê¸°ë³¸: ì²­í¬ë³„ pass ëª©í‘œ (ìµœëŒ€ 2íšŒ)',
	                phase1ArchP1NoEval: 'pass@1: ì›ìƒ·(ê²€ì¦/ì¬ì‹œë„ ì—†ìŒ)',
	                phase1ArchP1UntilPass: 'passê¹Œì§€ ë°˜ë³µ(ë¬´ì œí•œ; ë¹„ìš©â†‘)',
	                phase1ArchP1CoverageStyle: 'ì»¤ë²„ë¦¬ì§€: ìœ í˜• ìƒì„± â†’ ë³‘í•© â†’ ë¶„ë¥˜ â†’ ë¯¸ë¶„ë¥˜ ì¬ì‹œë„',
	                phase2ArchTitle: '2ë‹¨ê³„: ê°€ì´ë“œ/ì»¤ë²„ë¦¬ì§€ ì•„í‚¤í…ì²˜',
	                phase2ArchModeLabel: 'ëª¨ë“œ',
	                phase2ArchP2Default: 'ê¸°ë³¸: ê°ì‚¬(í”¼ë“œë°± 1íšŒ) + ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜',
	                phase2ArchP2PassToCoverage: 'pass@1: ê°ì‚¬ ìƒëµ â†’ ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜',
	                phase2ArchP2AuditorOnly: 'ê°ì‚¬ë§Œ: ì»¤ë²„ë¦¬ì§€ ìƒëµ',
	                phase2ArchP2AuditorUntilPassThenCoverage: 'ê°ì‚¬ passê¹Œì§€ ë°˜ë³µ â†’ ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜',
	                phase2ArchP2Integrated: 'í†µí•©: ê°ì‚¬ ìƒëµ â†’ ì»¤ë²„ë¦¬ì§€ íŒ¨ì²˜ê°€ êµìœ¡ì„±ê¹Œì§€ ê°œì„ ',
	                phase2ArchP2IntegratedCreatorPatch: 'í†µí•©(í•´ì„¤ Patch): ê°ì‚¬ ìƒëµ â†’ í•´ì„¤ìƒì„± ê¸°ë°˜ ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜',
	                phase2ArchP2DraftOnly: 'ì´ˆì €ë¹„ìš©: ê°ì‚¬/ì»¤ë²„ë¦¬ì§€ ëª¨ë‘ ìƒëµ (ì´ˆì•ˆë§Œ)',
	                phase2TargetLabel: 'ëŒ€ìƒ ìœ í˜•',
	                phase2TargetAll: 'ì „ì²´ ìœ í˜•',
	                phase2TargetSingle: 'í•œ ìœ í˜•ë§Œ (ì´ë¦„ í¬í•¨ / ì •ê·œì‹)',
	                phase2TargetQueryLabel: 'ìœ í˜• í•„í„°',
	                phase2TargetQueryPlaceholder: 'ì˜ˆ) 1ì°¨í•¨ìˆ˜ / /quadratic/i',
	                phase2MaxModulesLabel: 'ìµœëŒ€ ëª¨ë“ˆ ìˆ˜ (0 = ë¬´ì œí•œ)',
	                coverageSettingsLabel: 'ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜ ì„¤ì • (2ë‹¨ê³„)',
	                coverageMaxTokensLabel: 'ìµœëŒ€ í† í° (ìš”ì²­ë‹¹)',
	                coverageMaxRoundsLabel: 'ìµœëŒ€ ë¼ìš´ë“œ',
	                coverageAutoAcceptLabel: 'ë‚¨ì€ ë¬¸ì œ â‰¤ Nì´ë©´ 1íšŒ íŒ¨ì¹˜ í›„ í™•ì •(ì¬ê²€ì¦ ìƒëµ)',
	                coverageMaxTokensHelpHtml: '<code>ìµœëŒ€ í† í°</code>ì€ ìš”ì²­ ì „ì²´(system+guide+problems) ê¸°ì¤€ì´ë©°, ì´ˆê³¼ ì‹œ ìë™ ë¶„í• ë©ë‹ˆë‹¤. (ì¶œë ¥ <code>max_tokens</code>ì™€ ë³„ê°œ)',
	                coverageAutoAcceptHelp: '<code>N=0</code>ì´ë©´ ë¹„í™œì„±. ê²€ì¦ ê²°ê³¼ê°€ Nê°œ ì´í•˜ì¼ ë•Œ 1íšŒ íŒ¨ì¹˜ í›„ ë°”ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤. (ì •í™•í•œ ìµœì¢… ì»¤ë²„ë¦¬ì§€ëŠ” ì¬ê²€ì¦í•˜ì§€ ì•ŠìŒ)',
	                coverageVerifierOutputLabel: 'ê²€ì¦ ì¶œë ¥',
	                coverageVerifierOutputFull: 'ì „ì²´(ì¶©ì¡±+ë¯¸ì¶©ì¡±, ê·¼ê±° í¬í•¨)',
	                coverageVerifierOutputMissingOnly: 'ë¯¸ì¶©ì¡±ë§Œ(ì €ë¹„ìš©)',
	                coverageVerifierMaxTriesLabel: 'ê²€ì¦ ì¬ì‹œë„ (0 = ë¬´ì œí•œ)',
	                coverageFinalVerifyLabel: 'ìµœì¢… ê²€ì¦',
	                coverageFinalVerifyGlobal: 'ì „ì—­(ì „ì²´ ë¬¸ì œ ì¬ê²€ì¦)',
	                coverageFinalVerifyPerChunk: 'ì²­í¬ ì™„ë£Œ ì‹œ ì¬ê²€ì¦(ì „ì—­ ì¬ì§ˆë¬¸ ì—†ìŒ)',
	                coverageFinalVerifyNone: 'ìƒëµ(ìµœì†Œ ë¹„ìš©)',
	                coverageOverflowModeLabel: 'ê°€ì´ë“œ ì´ˆê³¼ ì‹œ',
	                coverageOverflowGuideMerge: 'ê°€ì´ë“œ ë¶„í•  ë³‘í•© (ê¶Œì¥)',
	                coverageOverflowTypeSplit: 'ìœ í˜• ë¶„í• ',
	                coverageOverflowError: 'ì˜¤ë¥˜ë¡œ ì¤‘ë‹¨',
	                coverageOverflowThresholdLabel: 'ë¶„í•  ì„ê³„ê°’ (ì˜¤ë¥˜ íšŸìˆ˜)',
	                coverageOverflowHelpHtml: 'â€œì „ì²´â€ ëª¨ë“œëŠ” ë¬¸ì œë³„ë¡œ <code>covered</code>/<code>reason</code>ë¥¼ ëª¨ë‘ ë°›ìœ¼ë©°, í•­ëª© ìˆ˜ê°€ ë§ì§€ ì•Šìœ¼ë©´ ìë™ ì¬ìš”ì²­í•©ë‹ˆë‹¤.<br>â€œê°€ì´ë“œ ë¶„í•  ë³‘í•©â€ì€ ë¬¸ì œë¥¼ ë‚˜ëˆ  ê°ê° ê°€ì´ë“œë¥¼ ìƒì„± í›„ ë³‘í•©í•©ë‹ˆë‹¤.',
	                phase0PdfInputModeLabel: '0ë‹¨ê³„: ì¶”ì¶œ(OCR) ëª¨ë“œ',
	                phase0PdfInputModeMultimodal: 'LLM ë©€í‹°ëª¨ë‹¬ (ì´ë¯¸ì§€ + PDF í…ìŠ¤íŠ¸)',
	                phase0PdfInputModeRawTextOnly: 'í…ìŠ¤íŠ¸ë§Œ (PDF í…ìŠ¤íŠ¸ë§Œ / ì´ë¯¸ì§€ ì—†ìŒ)',
	                phase0PdfInputModeTesseractText: 'Tesseract OCR â†’ í…ìŠ¤íŠ¸ë§Œ (ì´ë¯¸ì§€ ì—†ìŒ)',
	                tesseractLangLabel: 'Tesseract ì–¸ì–´',
	                tesseractLangPlaceholder: 'ì˜ˆ) kor+eng',
	                tesseractHelp: 'TesseractëŠ” ë¸Œë¼ìš°ì €ì—ì„œ traineddataë¥¼ ë‚´ë ¤ë°›ìŠµë‹ˆë‹¤. ì²« ì‹¤í–‰ì€ ëŠë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
	                maxDataEnvelopeTriesLabel: 'ì—„ê²© <data> í¬ë§· ì¬ì‹œë„ íšŸìˆ˜ (0 = ë¬´ì œí•œ)',
	                maxDataEnvelopeTriesHelp: 'ëª¨ë¸ì´ XML í¬ë§·ì„ ê³„ì† ê¹¨ëŠ” ê²½ìš° ë¬´í•œ ì¬ì‹œë„ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.',
	                structuredOutputStyleLabel: 'êµ¬ì¡°í™” ì¶œë ¥ ìŠ¤íƒ€ì¼',
	                structuredOutputStyleStructuredOnly: 'êµ¬ì¡°ë§Œ(ê¸°ë³¸)',
	                structuredOutputStyleRationaleThenStructured: 'ì´ìœ  ë¨¼ì € â†’ êµ¬ì¡°í™” ì¶œë ¥(ë§ˆì§€ë§‰)',
	                structuredOutputStyleHelp: '<data>/<patches> ë“± êµ¬ì¡°í™” ì¶œë ¥ ë‹¨ê³„ì—ì„œ â€œì´ìœ â€ë¥¼ ë¨¼ì € ì¶œë ¥í•˜ê³ , êµ¬ì¡°í™” ë¸”ë¡ì„ ë§ˆì§€ë§‰ì— ë‘ë„ë¡ ìœ ë„í•©ë‹ˆë‹¤. (ì‹¤í—˜ ëª¨ë“œ í¬í•¨)',
	                structuredOutputOverridesLabel: 'ì´ìœ  ë¨¼ì €(í˜ì´ì¦ˆë³„ ì˜¤ë²„ë¼ì´ë“œ)',
	                structuredOutputPhase0Label: '0ë‹¨ê³„(ì¶”ì¶œ)',
	                structuredOutputPhase1aLabel: '1A(ìœ í˜•í‘œì¤€)',
	                structuredOutputPhase1bLabel: '1B(ìœ í˜•ë¶„ë¥˜)',
	                structuredOutputPhase2Label: '2ë‹¨ê³„(ëª¨ë“ˆ/ì»¤ë²„ë¦¬ì§€)',
	                structuredOutputOptionInherit: 'ì „ì—­ ë”°ë¦„',
	                structuredOutputOptionStructuredOnly: 'êµ¬ì¡°ë§Œ',
	                structuredOutputOptionRationaleThenStructured: 'ì´ìœ  ë¨¼ì €',
	                structuredOutputOverridesHelp: '1Bì—ì„œ â€œì´ìœ  ë¨¼ì €â€ë¥¼ ì¼œë©´, ì»¨í…ìŠ¤íŠ¸ í­ë°œì„ ë§‰ê¸° ìœ„í•´ ìë™ìœ¼ë¡œ â€œë°©ë²•ë¡  ìš”ì•½(ì§§ê²Œ)â€ë§Œ ìš”êµ¬í•©ë‹ˆë‹¤.',
	
	                typeGuideImportLabel: 'ìœ í˜• TXT/MD ë¶ˆëŸ¬ì˜¤ê¸° (.txt/.md)',
	                typeGuideImportButton: 'ë¶ˆëŸ¬ì˜¤ê¸°',
	                typeGuideImportStatusEmpty: 'ê°€ì´ë“œ ë¯¸ë¡œë”©',
	                typeGuideStatusRegenerating: 'ê°€ì´ë“œ ì¬ìƒì„± ì¤‘...',
	                typeGuideStatusRegenerationCompleteFmt: 'ì¬ìƒì„± ì™„ë£Œ Â· {n}ê°œ ìœ í˜•',
	                typeGuideStatusResultsReadyFmt: 'ì™„ë£Œ: {n}ê°œ ìœ í˜• ì¬ìƒì„± ê²°ê³¼ ì¤€ë¹„ë¨',
	                typeGuideStatusImportLoadedFmt: 'ë¡œë”©ë¨: {titles}',
	                typeGuideStatusImportFailedFmt: 'ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {error}',
	                unknownError: 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜',
	                typeGuideRerunButton: 'ê°€ì´ë“œ ì¬ìƒì„±',
	                typeGuideExportButton: 'íŒ¨ì¹˜ ë‹¤ìš´ë¡œë“œ (.json)',
	
	                incBaseImportLabel: 'ê¸°ì¡´ ê°€ì´ë“œ/ë¬¸ì œ ë² ì´ìŠ¤ ë¶ˆëŸ¬ì˜¤ê¸° (.json)',
	                incBaseImportButton: 'ë¶ˆëŸ¬ì˜¤ê¸°',
	                incBaseImportHelpHtml: 'ê¶Œì¥: builderê°€ ë§Œë“  íŒ¨ì¹˜ íŒŒì¼(<code>type_patch_*.json</code>).<br>â€œìƒˆ ìœ í˜•(ë¯¸ë¶„ë¥˜)ë¡œ ì¶”ê°€â€ë§Œ í•  ê²½ìš° ë² ì´ìŠ¤ ì—†ì´ë„ ë™ì‘í•©ë‹ˆë‹¤.',
	                incNewFilesLabel: 'ì¶”ê°€í•  ìƒˆ ì‹œí—˜ì§€ ì—…ë¡œë“œ (.pdf, .txt)',
	                incNewFilesButton: 'íŒŒì¼ ì„ íƒ',
	                incNewFilesStatusNone: 'íŒŒì¼ ë¯¸ì„ íƒ',
	                incNewFilesStatusSelectedFmt: '{n}ê°œ ì„ íƒë¨: {names}',
	                incOcrSplitLabel: 'OCR ë¶„í•  (PDF í˜ì´ì§€ ë¬¶ìŒ)',
	                incOcrSplitHelp: '0ì´ë©´ ê¸°ë³¸ê°’(ìƒë‹¨ ì „ì—­ ì„¤ì •)ì„ ì‚¬ìš©. ì˜ˆ: 5 â†’ 5í˜ì´ì§€ì”© OCR/ì¶”ì¶œ ìœ ë‹› ìƒì„±.',
	                incReuseExtractionCacheLabel: 'ê°™ì€ íŒŒì¼ë¡œ ë‹¤ì‹œ ì‹¤í–‰ ì‹œ, ì™„ë£Œëœ OCR/ì¶”ì¶œ ê²°ê³¼ë¥¼ ì¬ì‚¬ìš©(ì´ì–´í•˜ê¸°)',
	                incTypeModeLabel: 'ìœ í˜• ë°°ì¹˜ ëª¨ë“œ',
	                incTypeModeDistribute: 'ê¸°ì¡´ ìœ í˜•ì— ë¶„ë°° (ë¶„ë¥˜í‘œì¤€ í•„ìš”)',
	                incTypeModeNewType: 'ìƒˆ ìœ í˜•(ë¯¸ë¶„ë¥˜)ë¡œ ì¶”ê°€',
	                incTypeModeHelp: 'â€œê¸°ì¡´ ìœ í˜•ì— ë¶„ë°°â€ëŠ” ë² ì´ìŠ¤ íŒŒì¼ì— `classificationStandard`ê°€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ì—†ìœ¼ë©´ â€œìƒˆ ìœ í˜•â€ì„ ì‚¬ìš©í•˜ì„¸ìš”.',
	                incNewTypeTitleLabel: 'ìƒˆ ìœ í˜• ì œëª©',
	                incExperimentalOptionsLabel: 'ì‹¤í—˜ ì˜µì…˜',
	                incExperimentalImageCropsLabel: 'ê·¸ë¦¼/ë„í‘œê°€ ìˆëŠ” ë¬¸ì œ: ì´ë¯¸ì§€ í¬ë¡­ì„ `question_text` ì•ì— `![img](data:...)`ë¡œ ì‚½ì… (ì‹¤í—˜)',
	                incRunButton: 'ì‹ ê·œë¬¸ì œ íŒ¨ì¹˜ ìƒì„±',
	                incDownloadButton: 'íŒ¨ì¹˜ ë‹¤ìš´ë¡œë“œ (.json)',
	                incStatusIdle: 'ëŒ€ê¸°',
	                incAlertSelectNewFiles: 'ìƒˆ ì‹œí—˜ì§€ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.',
	                incAlertDistributeNeedsBaseTypes: 'â€œê¸°ì¡´ ìœ í˜•ì— ë¶„ë°°â€ëŠ” ë² ì´ìŠ¤ íŒŒì¼(types)ì´ í•„ìš”í•©ë‹ˆë‹¤.',
	                incAlertDistributeNeedsClassificationStandard: 'â€œê¸°ì¡´ ìœ í˜•ì— ë¶„ë°°â€ëŠ” ë² ì´ìŠ¤ íŒŒì¼ì— classificationStandardê°€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.\\n\\nâ†’ (1) builder íŒ¨ì¹˜ íŒŒì¼(type_patch_*.json)ì„ ì‚¬ìš©í•˜ê±°ë‚˜\\nâ†’ (2) ëª¨ë“œë¥¼ â€œìƒˆ ìœ í˜•(ë¯¸ë¶„ë¥˜)ë¡œ ì¶”ê°€â€ë¡œ ë°”ê¾¸ì„¸ìš”.',
	                incStatusBaseLoadedFmt: 'ë² ì´ìŠ¤ ë¡œë”©ë¨: ìœ í˜• {typesN}ê°œ Â· ë¶„ë¥˜í‘œì¤€ {std}',
	                incStatusStdPresent: 'ìˆìŒ',
	                incStatusStdMissing: 'ì—†ìŒ',
	                incStatusBaseLoadFailedFmt: 'ë² ì´ìŠ¤ ë¡œë”© ì‹¤íŒ¨: {error}',
	                incStatusProcessingNewTypeNoBase: 'ì²˜ë¦¬ ì¤‘: (ë² ì´ìŠ¤ ì—†ìŒ) ì‹ ê·œ ìœ í˜• ìƒì„±...',
	                incStatusProcessingFileToOcr: 'ì²˜ë¦¬ ì¤‘: íŒŒì¼â†’OCR ìœ ë‹›...',
	                incStatusProcessingCacheReuseFmt: 'ì²˜ë¦¬ ì¤‘: ìºì‹œ ì¬ì‚¬ìš©(ì´ì–´í•˜ê¸°)... (ë¬¸ì œ {n}ê°œ)',
	                incStatusProcessingExtractFmt: 'ì²˜ë¦¬ ì¤‘: ì¶”ì¶œ(OCR/LLM)... (ìœ ë‹› {unitsN}ê°œ)',
	                incStatusProcessingImageCrops: 'ì²˜ë¦¬ ì¤‘: ì´ë¯¸ì§€ í¬ë¡­(ì‹¤í—˜)...',
	                incStatusProcessingCoveragePatchFmt: 'ì²˜ë¦¬ ì¤‘: ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜... (ë¬¸ì œ {n}ê°œ)',
	                incStatusCompletedFmt: 'ì™„ë£Œ: ë¬¸ì œ {n}ê°œ ì¶”ê°€ Â· íŒ¨ì¹˜ ìœ í˜• {patchedN}ê°œ',
	                incStatusFailedFmt: 'ì‹¤íŒ¨: {error}',
	
	                promptsImportButton: 'ë¶ˆëŸ¬ì˜¤ê¸°',
	                promptsExportButton: 'ë‚´ë³´ë‚´ê¸°',
	                promptsResetButton: 'ì´ˆê¸°í™”',
	                promptExtractorLabel: '1. ì¶”ì¶œ(Extractor) í”„ë¡¬í”„íŠ¸',
	                promptClassifierStandardLabel: '2a. ìœ í˜•í‘œì¤€ ìƒì„± í”„ë¡¬í”„íŠ¸',
	                promptClassifierStandardVerifierLabel: '2a-ê²€ì¦. ìœ í˜•í‘œì¤€ í‰ê°€ í”„ë¡¬í”„íŠ¸',
	                promptClassifierApplyLabel: '2b. ìœ í˜•ë¶„ë¥˜ ì ìš© í”„ë¡¬í”„íŠ¸',
	                promptSubgroupCreatorLabel: '2c. ì†Œê·¸ë£¹ ìƒì„± í”„ë¡¬í”„íŠ¸ (ì‹¤í—˜)',
	                promptStandardProblemCreatorLabel: '3. í‘œì¤€ë¬¸ì œ ìƒì„± í”„ë¡¬í”„íŠ¸',
	                promptExplanationCreatorLabel: '4. í•´ì„¤ ìƒì„± í”„ë¡¬í”„íŠ¸',
	                promptExplanationFeedbackLabel: '5. ê°ì‚¬/í”¼ë“œë°± í”„ë¡¬í”„íŠ¸',
	                promptCoverageVerifierLabel: '6. ì»¤ë²„ë¦¬ì§€ ê²€ì¦ í”„ë¡¬í”„íŠ¸',
	                promptCoveragePatcherLabel: '7. ì»¤ë²„ë¦¬ì§€ íŒ¨ì¹˜ í”„ë¡¬í”„íŠ¸',
	
	                startButtonCreate: 'ë§¤ë‰´ì–¼ ìƒì„±',
	                startButtonResume: 'ë§¤ë‰´ì–¼ ì¬ê°œ',
	                startButtonStop: 'ì¤‘ë‹¨',
	            }
	        };
	        let __guiLang = 'en';
	
	        function __detectDefaultGuiLang() {
	            try {
	                const lang = (navigator.languages && navigator.languages[0]) ? navigator.languages[0] : navigator.language;
	                return String(lang || '').toLowerCase().startsWith('ko') ? 'ko' : 'en';
	            } catch {
	                return 'en';
	            }
	        }
	
	        function __loadGuiLang() {
	            try {
	                const raw = localStorage.getItem(GUI_LANG_STORAGE_KEY);
	                if (raw === 'ko' || raw === 'en') return raw;
	            } catch { }
	            return __detectDefaultGuiLang();
	        }
	
	        function __saveGuiLang(lang) {
	            try { localStorage.setItem(GUI_LANG_STORAGE_KEY, lang); } catch { }
	        }
	
		        function __tGui(key) {
		            const dict = GUI_I18N[__guiLang] || GUI_I18N.en;
		            return dict?.[key] ?? GUI_I18N.en?.[key] ?? key;
		        }

		        function __tGuiFmt(key, vars = {}) {
		            const template = __tGui(key);
		            return String(template).replace(/\{([A-Za-z0-9_]+)\}/g, (m, k) => {
		                try {
		                    if (Object.prototype.hasOwnProperty.call(vars, k)) return String(vars[k]);
		                } catch { }
		                return m;
		            });
		        }
		
		        function __applyI18nToDocument() {
		            try { document.documentElement.lang = __guiLang; } catch { }
		
		            const applyText = (selector, attr) => {
		                document.querySelectorAll(selector).forEach(el => {
		                    const key = el.getAttribute(attr);
		                    if (!key) return;
		                    el.textContent = __tGui(key);
		                });
		            };
		            const applyHtml = (selector, attr) => {
		                document.querySelectorAll(selector).forEach(el => {
		                    const key = el.getAttribute(attr);
		                    if (!key) return;
		                    el.innerHTML = __tGui(key);
		                });
		            };
		            const applyAttr = (selector, attr, targetAttr) => {
		                document.querySelectorAll(selector).forEach(el => {
		                    const key = el.getAttribute(attr);
		                    if (!key) return;
		                    try { el.setAttribute(targetAttr, __tGui(key)); } catch { }
		                });
		            };
		
		            applyText('[data-i18n]', 'data-i18n');
		            applyHtml('[data-i18n-html]', 'data-i18n-html');
		            applyAttr('[data-i18n-placeholder]', 'data-i18n-placeholder', 'placeholder');
		            applyAttr('[data-i18n-title]', 'data-i18n-title', 'title');
		            applyAttr('[data-i18n-aria-label]', 'data-i18n-aria-label', 'aria-label');
		        }
	
	        function __getDefaultStdProblemLang(guiLang) {
	            return (guiLang === 'ko') ? 'Korean' : 'English';
	        }
	
		        function __applyGuiLanguage(lang) {
		            __guiLang = (lang === 'ko') ? 'ko' : 'en';
		            __applyI18nToDocument();
	            try { document.title = __tGui('appTitle'); } catch { }
		
		            const stdLangEl = getEl('std-problem-lang-input');
		            if (stdLangEl) {
		                const touched = stdLangEl.dataset?.userEdited === '1';
		                if (!touched) stdLangEl.value = __getDefaultStdProblemLang(__guiLang);
		            }
	
	            try { updateApiCallCounter(); } catch { }
	            try { updateUIState(false); } catch { }
	            // Dynamic UI elements (built via JS) must be re-rendered on language switch.
	            try { __refreshLogSessionSelect(); } catch { }
	            try { __callStats.render(); } catch { }
	            try { __apiMonitor.render(); } catch { }
	            try { renderFileList(); } catch { }
	            try { refreshTypeRerunUI(); } catch { }
	            try { refreshIncrementalUiText(); } catch { }
		        }
	
	        function initializeGuiLanguageUI() {
	            const sel = getEl('gui-lang-select');
	            if (!sel) return;
	
	            const stdLangEl = getEl('std-problem-lang-input');
	            if (stdLangEl && stdLangEl.dataset) {
	                if (stdLangEl.dataset.userEdited !== '1') stdLangEl.dataset.userEdited = '0';
	                stdLangEl.addEventListener('input', () => { try { stdLangEl.dataset.userEdited = '1'; } catch { } });
	            }
	
	            const initial = __loadGuiLang();
	            sel.value = initial;
	            __applyGuiLanguage(initial);
	            sel.addEventListener('change', () => {
	                const v = (sel.value === 'ko') ? 'ko' : 'en';
	                __saveGuiLang(v);
	                __applyGuiLanguage(v);
	            });
	        }

	        // Resume logic helpers
	        function isProcessResumable(ap = activeProcess) {
            if (!ap) return false;

            // Check if there's any meaningful data that warrants resuming
            const hasExamPapers = Array.isArray(examPapers) && examPapers.length > 0;
            const hasPhase1Data = ap.phase1_patterns && (
                Array.isArray(ap.phase1_patterns.clusters) && ap.phase1_patterns.clusters.length > 0 ||
                Array.isArray(ap.phase1_patterns.perQuestion) && ap.phase1_patterns.perQuestion.length > 0
            );
            const hasPhase2Data = Array.isArray(ap.phase2_modules) && ap.phase2_modules.length > 0;
            const hasMeaningfulData = hasExamPapers || hasPhase1Data || hasPhase2Data;

            // If there's meaningful data, always allow resume
            if (hasMeaningfulData) return true;

            // If no meaningful data but status is not completed, allow resume (in case of early-stage interruption)
            if (ap.status !== 'completed') return true;

            // Allow "resume" from a completed save only when an explicit rerun reset is requested.
            try {
                const startFrom = __normalizeStartFrom(getPipelineConfigFromUi()?.runPlan?.startFrom || 'continue');
                return startFrom !== 'continue';
            } catch {
                return false;
            }
        }

        function migrateActiveProcessForResume(ap) {
            if (!ap) return ap;

            // --- ì„¸ì´ë¸Œ í˜¸í™˜ ë³´ê°•: ì¤‘ì²© ìƒíƒœ ë³µì› ---
            // Phase 1 ìƒìœ„ ìƒíƒœ ë³µì›
            if (ap.phase1_patterns) {
                if (ap.phase1_patterns.status === 'processing')
                    ap.phase1_patterns.status = 'pending';
                const msg = (ap.phase1_patterns.error || '').toLowerCase();
                if (msg.includes('cancelled') || msg.includes('canceled'))
                    ap.phase1_patterns.status = 'pending';

                // í‘œì¤€ ìƒì„± ì„œë¸Œìƒíƒœ ë³µì›
                const sc = ap.phase1_patterns.standardCreation;
                if (sc) {
                    if (sc.status === 'processing' || sc.status === 'error') sc.status = 'pending';
                    if (!Array.isArray(sc.perChunk)) sc.perChunk = [];
                }
            }
            // --- New: migrate old saves that used 100k-token chunking to 10k ---
            // If chunkTokens is missing, assume legacy save and initialize to DEFAULT_CHUNK_TOKENS.
            // Do NOT override user-configured chunkTokens; those are now controlled via Experiment config.
            const hadChunkTokens = (typeof ap.chunkTokens === 'number') && Number.isFinite(ap.chunkTokens);
            if (!hadChunkTokens) {
                try {
                    logger.info(
                        "Migration",
                        `Legacy save detected (missing chunkTokens). Initializing chunk size to ${DEFAULT_CHUNK_TOKENS} tokens and resetting Phase 1~3.`
                    );
                } catch (_) { /* logger may not be initialized in some edge loads; safe to ignore */ }

                // Set new chunk size
                ap.chunkTokens = DEFAULT_CHUNK_TOKENS;
                ap.chunkTokensPhase1b = DEFAULT_CHUNK_TOKENS;

                // Reset Phase 1
                ap.phase1_patterns = {
                    status: 'pending',
                    standardCreation: {
                        status: 'pending',
                        // Ensure per-chunk list is cleared for fresh 10k-token chunking
                        perChunk: [],
                        finalStandard: null
                    },
                    perQuestion: [],
                    clusters: [],
                    error: null
                };

                // Reset Phase 2 and 3 because they depend on Phase 1 results
                ap.phase2_modules = [];
                ap.phase3_finalManual = {
                    status: 'pending',
                    content: null,
                    error: null
                };
            }

            // Helper to recover mid-run items
            const recoverListItems = (list) => {
                if (!Array.isArray(list)) return;
                list.forEach(item => {
                    if (item.status === 'processing') item.status = 'pending';
                    const msg = (item.error || '').toLowerCase();
                    if (item.status === 'error' && (msg.includes('cancelled') || msg.includes('canceled'))) {
                        item.status = 'pending';
                    }
                });
            };

            // phase0_extract: [{...}]
            recoverListItems(ap.phase0_extract);
            // NEW: also recover nested Phase 0 parts (grouped PDF chunks)
            try {
                if (Array.isArray(ap?.phase0_extract)) {
                    ap.phase0_extract.forEach(s => {
                        if (Array.isArray(s?.parts)) recoverListItems(s.parts);
                    });
                }
            } catch (_) { }

            // phase1_patterns (redundant with block above but safe)
            if (ap.phase1_patterns) {
                if (ap.phase1_patterns.status === 'processing')
                    ap.phase1_patterns.status = 'pending';
                const msg = (ap.phase1_patterns.error || '').toLowerCase();
                if (msg.includes('cancelled') || msg.includes('canceled')) {
                    ap.phase1_patterns.status = 'pending';
                }
            }

            // phase2_modules: [{...}]
            recoverListItems(ap.phase2_modules);

            if (ap.phase3_finalManual) {
                if (ap.phase3_finalManual.status === 'processing')
                    ap.phase3_finalManual.status = 'pending';
                const m3 = (ap.phase3_finalManual.error || '').toLowerCase();
                if (m3.includes('cancelled') || m3.includes('canceled')) {
                    ap.phase3_finalManual.status = 'pending';
                }
            }

            // Ensure activeTabId sane
            ap.activeTabId = ap.activeTabId || 'phase0-extract';

            // --- NEW: trim legacy long histories on resume (compat with old saves) ---
            // Ideological reason: Old saves may carry huge attempt logs; we keep only the last item to continue smoothly.
            try {
                // Phase 1 per-chunk attempts: keep only the last attempt for in-progress chunks
                const sc = ap?.phase1_patterns?.standardCreation;
                if (sc && Array.isArray(sc.perChunk)) {
                    sc.perChunk.forEach(slot => {
                        const isFinalized = Array.isArray(slot?.finalStandardChunk) && slot.finalStandardChunk.length > 0;
                        if (!isFinalized && Array.isArray(slot?.attempts) && slot.attempts.length > 1) {
                            slot.attempts = [slot.attempts[slot.attempts.length - 1]];
                        }
                    });
                }

                // Phase 2 refinement cycles: keep only the last cycle for modules not yet completed
                if (Array.isArray(ap?.phase2_modules)) {
                    ap.phase2_modules.forEach(m => {
                        if (m?.status !== 'completed' && Array.isArray(m?.refinementCycles) && m.refinementCycles.length > 1) {
                            m.refinementCycles = [m.refinementCycles[m.refinementCycles.length - 1]];
                        }
                    });
                }
            } catch (_) {
                // swallow trimming errors; better to continue than to block resume
            }

            return ap;
        }

        function getApiConfig() {
            return {
                apiUrl: getEl('api-url-input')?.value || '',
                proxyUrl: getEl('api-proxy-url-input')?.value || '',
                apiKeyList: getEl('api-key-list-input')?.value || '',
                model: getEl('api-model-name-input')?.value || '',
                rateLimitEnabled: !!getEl('enable-rate-limit-input')?.checked,
                rpmLimit: getEl('rpm-limit-input')?.value || '',
                tpmLimit: getEl('tpm-limit-input')?.value || '',
                inflightLimitPerKey: getEl('inflight-limit-input')?.value ?? 0,
            };
        }

        function saveApiConfig() {
            localStorage.setItem('apiConfig', JSON.stringify(getApiConfig()));
            try { __apiKeyLive.syncFromInput(); } catch { }
            try { __apiMonitor.render(); } catch { }
        }

	        function loadApiConfig() {
	            const config = JSON.parse(localStorage.getItem('apiConfig'));
	            if (config) {
	                const url = config.apiUrl || config.baseUrl || '';
	                const keys = config.apiKeyList || config.apiKey || '';
	                getEl('api-url-input').value = url;
	                getEl('api-proxy-url-input').value = config.proxyUrl || '';
	                getEl('api-key-list-input').value = keys;
	                getEl('api-model-name-input').value = config.model || '';
	                getEl('enable-rate-limit-input').checked = !!config.rateLimitEnabled;
	                getEl('rpm-limit-input').value = config.rpmLimit || 30;
	                getEl('tpm-limit-input').value = config.tpmLimit || 15000;
	                if (getEl('inflight-limit-input')) getEl('inflight-limit-input').value = config.inflightLimitPerKey ?? 0;
	            } else {
	                // Default values
	                getEl('api-url-input').value = '';
	                getEl('api-proxy-url-input').value = '';
	                getEl('api-key-list-input').value = '';
	                getEl('api-model-name-input').value = '';
	                getEl('enable-rate-limit-input').checked = false;
	                getEl('rpm-limit-input').value = 30;
	                getEl('tpm-limit-input').value = 15000;
	                if (getEl('inflight-limit-input')) getEl('inflight-limit-input').value = 0;
	            }
	        }

        function initializePromptEditor() {
            const promptTextareas = {
                extractor: getEl('prompt-extractor'),
                classifier_standard: getEl('prompt-classifier-standard'),
                classifier_standard_verifier: getEl('prompt-classifier-standard-verifier'),
                classifier_apply: getEl('prompt-classifier-apply'),
                subgroup_creator: getEl('prompt-subgroup-creator'),
                standard_problem_creator: getEl('prompt-standard-problem-creator'),
                explanation_creator: getEl('prompt-explanation-creator'),
                explanation_feedback: getEl('prompt-explanation-feedback'),
                coverage_verifier: getEl('prompt-coverage-verifier'),
                coverage_patcher: getEl('prompt-coverage-patcher'),
            };

            const populatePromptUI = () => {
                for (const key in promptTextareas) {
                    if (promptTextareas[key] && currentPrompts[key]) {
                        promptTextareas[key].value = currentPrompts[key].system;
                    }
                }
            };

            const exportPrompts = () => {
                try {
                    const jsonString = JSON.stringify(currentPrompts, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'mastery-manual-prompt-preset.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    logger.success("Prompts", "Prompt preset exported successfully.");
                } catch (error) {
                    logger.error("Prompts", `Failed to export prompts: ${error.message}`);
                    alert("Failed to export prompts. See logs for details.");
                }
            };

            const importPrompts = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);

                        // Basic validation
                        const requiredKeys = [
                            'extractor',
                            'classifier_standard',
                            'classifier_standard_verifier',
                            'classifier_apply',
                            'standard_problem_creator',
                            'explanation_creator',
                            'explanation_feedback',
                            'coverage_verifier',
                            'coverage_patcher',
                        ];
                        const isValid = requiredKeys.every((key) => typeof importedData?.[key]?.system === 'string');
                        if (!isValid) throw new Error("Imported file is missing required prompt keys or has an invalid format.");

                        currentPrompts = __normalizePrompts(importedData);
                        populatePromptUI();
                        logger.success("Prompts", `Successfully imported preset from ${file.name}.`);
                    } catch (error) {
                        logger.error("Prompts", `Failed to import preset: ${error.message}`);
                        alert(`Failed to import preset: ${error.message}`);
                    } finally {
                        event.target.value = ''; // Reset
                    }
                };
                reader.onerror = () => {
                    logger.error("Prompts", "Error reading the preset file.");
                    alert("Error reading the preset file.");
                };
                reader.readAsText(file);
            };

            const resetPrompts = () => {
                if (confirm("Are you sure you want to reset all prompts to their default values?")) {
                    currentPrompts = JSON.parse(JSON.stringify(DEFAULT_PROMPTS));
                    populatePromptUI();
                    logger.info("Prompts", "All prompts have been reset to default values.");
                }
            };

            for (const key in promptTextareas) {
                if (promptTextareas[key]) {
                    promptTextareas[key].addEventListener('input', (e) => {
                        if (currentPrompts[key]) currentPrompts[key].system = e.target.value;
                    });
                }
            }

            getEl('export-prompts-btn').addEventListener('click', exportPrompts);
            getEl('reset-prompts-btn').addEventListener('click', resetPrompts);

            const importBtn = getEl('import-prompts-btn');
            const importInput = getEl('import-prompts-input');
            importBtn.addEventListener('click', () => importInput.click());
            importInput.addEventListener('change', importPrompts);

            populatePromptUI();
            logger.info("UI_Init", "Custom prompt editor initialized.");
        }

	        function updateApiCallCounter() {
	            const counterEl = getEl('api-call-counter');
	            if (counterEl) counterEl.textContent = `(${__tGui('apiCallCounterPrefix')}: ${successfulApiCallCount})`;
	        }

	        function updateUIState(isProcessing) {
	            const startButton = getEl('start-button');
	
	            if (isProcessing) {
	                startButton.innerHTML =
	                    `<span class="material-symbols-outlined">stop</span>` +
	                    `<span class="button-text">${escapeHtmlForInnerHTML(__tGui('startButtonStop'))}</span>`;
	                startButton.style.backgroundColor = 'var(--error-color)';
	                processController.stop = false;
	            } else {
	                const isResumable = isProcessResumable();
	                const hasStartableInput = uploadedFiles.length > 0 || (Array.isArray(examPapers) && examPapers.length > 0);
	                const buttonText = isResumable ? __tGui('startButtonResume') : __tGui('startButtonCreate');
	                startButton.innerHTML =
	                    `<span class="material-symbols-outlined">play_arrow</span>` +
	                    `<span class="button-text">${escapeHtmlForInnerHTML(buttonText)}</span>`;
	                startButton.style.backgroundColor = '';
	                startButton.disabled = !isResumable && !hasStartableInput;
	            }

            try { __keepAlive.sync(isProcessing); } catch { }
            try { __apiMonitor.setRunning(true); } catch { }

            // Disable controls (except Start/Stop) while processing
            const apiHotIds = new Set([
                'api-key-list-input',
                'api-url-input',
                'api-proxy-url-input',
                'api-model-name-input',
                'enable-rate-limit-input',
                'rpm-limit-input',
                'tpm-limit-input',
                'inflight-limit-input',
            ]);
            document
                .querySelectorAll('#controls-sidebar input, #controls-sidebar select, #controls-sidebar textarea, #controls-sidebar button:not(#start-button)')
                .forEach(el => {
                    if (isProcessing && el?.id && apiHotIds.has(el.id)) {
                        el.disabled = false;
                        return;
                    }
                    el.disabled = isProcessing;
                });

            getEl('save-button').disabled = !activeProcess && !hasTypeRerunState();

            // Keep Start enabled during processing to serve as Stop
            if (isProcessing) startButton.disabled = false;
        }

        function updateStatus(text, subtext) {
            getEl('status-text').textContent = text;
            getEl('status-subtext').textContent = subtext;
        }

        function __inferLogPhase(context) {
            const c = String(context || '').toLowerCase();
            if (c.startsWith('extract-') || c.startsWith('phase0') || c.startsWith('fileprocessing')) return 'phase0';
            if (c.startsWith('phase1') || c.includes('createtypes') || c.includes('evaltypes') || c.includes('phase1a') || c.includes('phase1b') || c.includes('merge') || c.includes('classifybatch')) return 'phase1';
            if (c.startsWith('phase2') || c.startsWith('module-') || c.includes('coverage') || c.includes('revise') || c.includes('feedback')) return 'phase2';
            if (c.startsWith('phase3') || c.includes('final')) return 'phase3';
            return 'other';
        }

        function __logMatchesType(entry, type) {
            const t = String(type || 'all');
            const level = String(entry?.level || '').toUpperCase();
            const msg = String(entry?.messageFull ?? entry?.message ?? '');
            if (t === 'all') return true;
            if (t === 'api_input') return msg.startsWith('API Input (payload):');
            if (t === 'api_output') return msg.startsWith('API Raw Output:');
            if (t === 'errors') return level === 'WARN' || level === 'ERROR';
            if (t === 'errors_no_api_http') {
                if (!(level === 'WARN' || level === 'ERROR')) return false;
                const m = msg.match(/(?:HTTP\\s*|httpStatus=)(\\d{3})/i);
                const st = m ? parseInt(m[1], 10) : null;
                const isNoisyApiHttp = Number.isFinite(st) && (st === 429 || (st >= 500 && st < 600));
                return !isNoisyApiHttp;
            }
            return true;
        }

        function __logMatchesPhase(entry, phase) {
            const p = String(phase || 'all');
            if (p === 'all') return true;
            const context = String(entry?.context || '');
            return __inferLogPhase(context) === p;
        }

        function __logMatchesFilters(entry, { type = 'all', phase = 'all', query = '' } = {}) {
            if (!__logMatchesType(entry, type)) return false;
            if (!__logMatchesPhase(entry, phase)) return false;
            const q = String(query || '').trim().toLowerCase();
            if (!q) return true;
            const ctx = String(entry?.context || '').toLowerCase();
            const msg = String(entry?.messageFull ?? entry?.message ?? '').toLowerCase();
            return ctx.includes(q) || msg.includes(q);
        }

        function __getLogFiltersFromUi() {
            return {
                type: getEl('log-filter-type-select')?.value || 'all',
                session: getEl('log-filter-session-select')?.value || 'current',
                phase: getEl('log-filter-phase-select')?.value || 'all',
                query: getEl('log-filter-query-input')?.value || '',
            };
        }

        function __refreshFullCaptureUi() {
            const chk = getEl('full-capture-enabled-input');
            const exportBtn = getEl('full-capture-export-btn');
            const clearBtn = getEl('full-capture-clear-btn');
            const statusEl = getEl('full-capture-status');
            if (!chk && !exportBtn && !clearBtn && !statusEl) return;

            const st = (() => { try { return __fullApiCapture.getStatus(); } catch { return null; } })();
            const enabled = !!st?.enabled;
            const n = Number(st?.approxCount || 0) || 0;
            const p = Number(st?.pending || 0) || 0;
            const err = String(st?.lastError || '').trim();

            if (chk) chk.checked = enabled;
            if (exportBtn) exportBtn.disabled = (n + p) <= 0;
            if (clearBtn) clearBtn.disabled = (n + p) <= 0;
            if (statusEl) {
                if (!enabled) {
                    statusEl.textContent = __tGui('fullCaptureStatusDisabled') + (n ? ` â€¢ records ${n}` : '');
                } else {
                    statusEl.textContent = __tGuiFmt('fullCaptureStatusEnabledFmt', { n, p });
                }
                if (err) statusEl.textContent += ` â€¢ ${__tGuiFmt('fullCaptureStatusErrorFmt', { error: err })}`;
            }
        }

        function __downloadTextFile(filename, text) {
            const blob = new Blob([String(text || '')], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function downloadLogs() {
            const { type, session, phase, query } = __getLogFiltersFromUi();
            const entries = logger.getEntries();
            const filtered = entries
                .filter(e => {
                    const sid = String(e?.sessionId || '');
                    if (session === 'all') return true;
                    if (session === 'current') return sid && sid === (logger.getActiveSessionId() || '');
                    return sid === session;
                })
                .filter(e => __logMatchesFilters(e, { type, phase, query }));
            const text = filtered.map(e => {
                const header = `${e.tsIso}\t${e.level}\t[${e.context}]`;
                return `${header}\n${String(e.messageFull ?? e.message ?? '')}\n`;
            }).join('\n');
            const stamp = new Date().toISOString().replace(/[:.]/g, '-');
            __downloadTextFile(`logs-${type}-${session}-${phase}-${stamp}.txt`, text);
        }

	        function __refreshLogSessionSelect() {
	            const sel = getEl('log-filter-session-select');
	            if (!sel) return;
	            const sessions = (() => { try { return logger.getSessions(); } catch { return []; } })();
	            const activeId = (() => { try { return logger.getActiveSessionId(); } catch { return ''; } })();

            const prev = String(sel.value || 'current');
            const opts = [];

	            const currentLabel = activeId
	                ? __tGuiFmt('logFilterSessionCurrentFmt', { id: activeId })
	                : __tGui('logFilterSessionCurrent');
	            opts.push({ value: 'current', label: currentLabel });
	            opts.push({ value: 'all', label: __tGui('logFilterSessionAll') });
	            sessions.forEach(s => {
	                const id = String(s?.id || '').trim();
	                if (!id) return;
	                const label = String(s?.label || id).trim();
	                opts.push({ value: id, label: `${id} â€” ${label}` });
            });

            sel.innerHTML = opts.map(o => `<option value="${escapeHtmlForInnerHTML(o.value)}">${escapeHtmlForInnerHTML(o.label)}</option>`).join('');

            const values = new Set(opts.map(o => o.value));
	            if (values.has(prev)) sel.value = prev;
	            else sel.value = 'current';
	        }
        try { window.__refreshLogSessionSelect = __refreshLogSessionSelect; } catch { }

        function __rebuildCallStatsFromLogs() {
            try {
                const entries = logger.getEntries();
                try { __callStats.reset(); } catch { }
                let ok = 0;
                for (const e of entries) {
                    const level = String(e?.level || '').toUpperCase();
                    if (level !== 'SUCCESS') continue;
                    const msg = String(e?.messageFull ?? e?.message ?? '');
                    const ctx = String(e?.context || '');
                    if (!ctx) continue;

                    // Preferred new marker
                    if (msg.startsWith('API OK')) {
                        const est = (() => { const m = msg.match(/estTokens=(\\d+)/i); return m ? parseInt(m[1], 10) : null; })();
                        const act = (() => { const m = msg.match(/actualTokens=(\\d+)/i); return m ? parseInt(m[1], 10) : null; })();
                        const lat = (() => { const m = msg.match(/latencyMs=(\\d+)/i); return m ? parseInt(m[1], 10) : null; })();
                        try { __callStats.recordOkCall({ context: ctx, estTokens: est, actualTokens: act, latencyMs: lat }); } catch { }
                        ok++;
                        continue;
                    }

                    // Backward-compat success marker
                    if (/API call attempt\\s*#\\d+\\s*successful\\./i.test(msg)) {
                        try { __callStats.recordOkCall({ context: ctx }); } catch { }
                        ok++;
                        continue;
                    }
                }
                successfulApiCallCount = ok;
                updateApiCallCounter();
                try { __callStats.render(); } catch { }
            } catch { }
        }

	        function initializeUI() {
	            logger.info("UI_Init", "Initializing UI...");
	
	            loadApiConfig();
	            initializeGuiLanguageUI();
	            loadPipelineConfigFromStorage();
	            try { __formatErrors.initUi(); } catch { }
	            ['api-url-input', 'api-proxy-url-input', 'api-key-list-input', 'api-model-name-input', 'enable-rate-limit-input', 'rpm-limit-input', 'tpm-limit-input', 'inflight-limit-input'].forEach(id =>
	                getEl(id).addEventListener('change', saveApiConfig)
	            );
		            [
		                'run-start-from-select', 'run-stop-after-select', 'reset-call-counters-on-start-input',
		                'chunk-tokens-input', 'chunk-tokens-1b-input', 'phase1-subgrouping-input', 'subgrouping-chunk-tokens-input',
		                'phase1-arch-select',
		                'phase2-arch-select', 'phase2-target-select', 'phase2-target-query-input', 'phase2-max-modules-input',
		                'coverage-max-tokens-input', 'coverage-max-rounds-input', 'coverage-verifier-output-select', 'coverage-verifier-max-tries-input', 'coverage-final-verify-select',
		                'phase0-pdf-input-mode-select', 'tesseract-lang-input', 'phase0-image-crops-input',
		                'phase0-answer-fill-input',
		                'phase0-answer-fill-fill-answers-input', 'phase0-answer-fill-fill-explanations-input',
		                'phase0-answer-fill-overwrite-answers-input', 'phase0-answer-fill-overwrite-explanations-input',
		                'phase0-answer-fill-include-type-guide-input', 'phase0-answer-fill-type-guide-max-chars-input',
		                'answer-fill-chunk-tokens-input', 'answer-fill-duckduckgo-input',
		                'max-data-envelope-tries-input', 'structured-output-style-select',
		                'structured-output-phase0-select', 'structured-output-phase1a-select', 'structured-output-phase1b-select', 'structured-output-phase2-select',
		            ].forEach(id => {
	                getEl(id)?.addEventListener('change', savePipelineConfigToStorage);
	                getEl(id)?.addEventListener('input', savePipelineConfigToStorage);
            });
            getEl('run-start-from-select')?.addEventListener('change', () => {
                try { updateUIState(false); } catch { }
            });
            const syncPhase2TargetUi = () => {
                const mode = (getEl('phase2-target-select')?.value || 'all').toLowerCase();
                const wrap = getEl('phase2-target-query-wrap');
                if (wrap) wrap.style.display = (mode === 'single') ? 'block' : 'none';
            };
            syncPhase2TargetUi();
            getEl('phase2-target-select')?.addEventListener('change', syncPhase2TargetUi);

            // Log UI performance controls
            const applyLogLimits = () => {
                const maxLines = getEl('log-ui-max-lines-input')?.value;
                const maxChars = getEl('log-ui-max-chars-input')?.value;
                logger.setUiLimits({ maxLines, maxChars });
            };
            const applyLogFilters = () => {
                const { type, session, phase, query } = __getLogFiltersFromUi();
                logger.setFilters({ type, session, phase, query });
            };
            let logFilterTimer = null;
            applyLogLimits();
            try { __refreshLogSessionSelect(); } catch { }
            applyLogFilters();
            getEl('log-ui-max-lines-input')?.addEventListener('input', applyLogLimits);
            getEl('log-ui-max-chars-input')?.addEventListener('input', applyLogLimits);
            getEl('log-filter-type-select')?.addEventListener('change', applyLogFilters);
            getEl('log-filter-session-select')?.addEventListener('change', applyLogFilters);
            getEl('log-filter-phase-select')?.addEventListener('change', applyLogFilters);
            getEl('log-filter-query-input')?.addEventListener('input', () => {
                if (logFilterTimer) clearTimeout(logFilterTimer);
                logFilterTimer = setTimeout(applyLogFilters, 120);
            });
            getEl('download-logs-btn')?.addEventListener('click', downloadLogs);
            getEl('clear-logs-btn')?.addEventListener('click', () => logger.clearUi());
            // Full API capture (IndexedDB)
            try {
                const capEnabledInput = getEl('full-capture-enabled-input');
                const capExportBtn = getEl('full-capture-export-btn');
                const capClearBtn = getEl('full-capture-clear-btn');

                if (capEnabledInput) capEnabledInput.checked = __fullApiCapture?.isEnabled?.() === true;
                capEnabledInput?.addEventListener('change', async () => {
                    try { await __fullApiCapture.setEnabled(!!capEnabledInput.checked); } catch { }
                    try { __refreshFullCaptureUi(); } catch { }
                });
                capExportBtn?.addEventListener('click', async () => {
                    try {
                        await __fullApiCapture.exportJsonl();
                        logger.success('FullCapture', 'Exported full API capture.');
                    } catch (err) {
                        const msg = err?.message || String(err || '');
                        logger.error('FullCapture', `Export failed: ${msg}`);
                        alert(__tGui('exportFailedCheckLogsAlert'));
                    } finally {
                        try { __refreshFullCaptureUi(); } catch { }
                    }
                });
                capClearBtn?.addEventListener('click', async () => {
                    if (!confirm('ì „ì²´ API ìº¡ì²˜ ë¡œê·¸(IndexedDB)ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
                    try {
                        await __fullApiCapture.clear();
                        logger.success('FullCapture', 'Cleared full API capture.');
                    } catch (err) {
                        const msg = err?.message || String(err || '');
                        logger.error('FullCapture', `Clear failed: ${msg}`);
                        alert(__tGui('exportFailedCheckLogsAlert'));
                    } finally {
                        try { __refreshFullCaptureUi(); } catch { }
                    }
                });
                try { __fullApiCapture.refreshCount().then(() => __refreshFullCaptureUi()).catch(() => __refreshFullCaptureUi()); } catch { }
                try { __refreshFullCaptureUi(); } catch { }
            } catch { }
            getEl('reset-call-breakdown-btn')?.addEventListener('click', () => {
                successfulApiCallCount = 0;
                updateApiCallCounter();
                try { __callStats.reset(); } catch { }
                logger.info('API', 'Call stats reset.');
            });
            try { __callStats.render(); } catch { }

            initializePromptEditor();

            const startButton = getEl('start-button');
            const saveButton = getEl('save-button');
	            const loadButton = getEl('load-button');
	            const loadInput = getEl('load-progress-input');
	            const subgroupifySaveInput = getEl('subgroupify-save-input');
	            const postprocessSaveInput = getEl('postprocess-save-input');
	            const typeGuideImportBtn = getEl('type-guide-import-btn');
	            const typeGuideImportInput = getEl('type-guide-import-input');
	            const typeGuideImportStatus = getEl('type-guide-import-status');
	            const typeRerunBtn = getEl('type-rerun-btn');
	            const typeExportBtn = getEl('type-export-btn');

            saveButton.addEventListener('click', saveProgress);
            loadButton.addEventListener('click', () => loadInput.click());
            loadInput.addEventListener('change', loadProgress);
	            subgroupifySaveInput?.addEventListener('change', async (event) => {
	                const file = event.target.files?.[0];
	                if (!file) return;
	                try {
	                    const raw = await file.text();
	                    const obj = JSON.parse(raw);
	                    const res = await subgroupifyImportedSaveObject(obj);
	                    const stamp = new Date().toISOString().slice(0, 10);
	                    const base = file.name.replace(/\.[^.]+$/, '') || 'save';
	                    __downloadJsonFile(`${base}_subgroupified_${stamp}.json`, res.updated);
	                } catch (e) {
	                    const msg = e?.message || String(e || '');
	                    logger.error('SubgroupifySave', `Failed to subgroupify save: ${msg}`);
	                    alert(__tGui('exportFailedCheckLogsAlert'));
	                } finally {
	                    try { event.target.value = ''; } catch { }
	                }
	            });

	            postprocessSaveInput?.addEventListener('change', async (event) => {
	                const file = event.target.files?.[0];
	                if (!file) return;
	                try {
	                    const raw = await file.text();
	                    const obj = JSON.parse(raw);
	                    __postprocessSave.state.fileName = file.name;
	                    __postprocessSave.state.original = obj;
	                    __postprocessSave.state.loadedAt = new Date().toISOString();
	                    __postprocessSave.resetWorking();
	                    __uiTabId = 'postprocess-save';
	                    if (activeProcess) activeProcess.activeTabId = 'postprocess-save';
	                    renderActiveProcess();
	                    logger.success('Postprocess', `Loaded save for postprocessing: ${file.name}`);
	                } catch (e) {
	                    const msg = e?.message || String(e || '');
	                    logger.error('Postprocess', `Failed to load save: ${msg}`);
	                    alert(__tGui('exportFailedCheckLogsAlert'));
	                } finally {
	                    try { event.target.value = ''; } catch { }
	                }
	            });

            // Clear button - completely resets experiment state
            const clearButton = getEl('clear-button');
            clearButton?.addEventListener('click', () => {
                if (!confirm('ì‹¤í—˜ì„ ì™„ì „íˆ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n- ëª¨ë“  ì§„í–‰ ìƒí™©ì´ ì‚­ì œë©ë‹ˆë‹¤\n- ì—…ë¡œë“œëœ íŒŒì¼ ëª©ë¡ì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤\n- OCR ìºì‹œê°€ ì‚­ì œë©ë‹ˆë‹¤\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) {
                    return;
                }

                // Reset all state
                uploadedFiles.length = 0;
                uploadedAnswerFiles.length = 0;
                examPapers.length = 0;
                activeProcess = null;
                successfulApiCallCount = 0;

                // Clear UI
                logger.clear();
                try { __callStats.reset(); } catch { }
                updateApiCallCounter();
                renderFileList();
                renderAnswerFileList();
                renderActiveProcess();
                updateUIState(false);

                logger.success('ì´ˆê¸°í™”', 'ì‹¤í—˜ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì—¬ ì‹œì‘í•˜ì„¸ìš”.');
            });

            typeGuideImportBtn?.addEventListener('click', () => typeGuideImportInput?.click());
            typeGuideImportInput?.addEventListener('change', async (event) => {
                const file = event.target.files?.[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    const title = parseGuideTypeTitle(text) || file.name.replace(/\.[^.]+$/, '');
                    const problems = parseProblemsFromRawText(text);
                    if (!problems.length) throw new Error('Could not parse problems from the TXT.');
                    const usedNames = new Set([title]);
                    const types = splitTypeProblemsIfNeeded({ title, problems }, usedNames);
                    typeRerunState = { status: 'ready', types, results: [], error: null };
                    if (typeRerunBtn) typeRerunBtn.disabled = false;
                    if (typeExportBtn) typeExportBtn.disabled = true;
                    refreshTypeRerunUI();
                } catch (e) {
                    typeRerunState = { status: 'error', types: [], results: [], error: e.message };
                    if (typeRerunBtn) typeRerunBtn.disabled = true;
                    if (typeExportBtn) typeExportBtn.disabled = true;
                    logger.error('TypeRerun', `TXT import failed: ${e.message}`);
                    refreshTypeRerunUI();
                } finally {
                    event.target.value = '';
                }
            });

            typeRerunBtn?.addEventListener('click', async () => {
                await startTypeRegeneration();
            });

            typeExportBtn?.addEventListener('click', () => {
                const payload = buildTypePatchPayload(typeRerunState.results || []);
                const jsonString = JSON.stringify(payload, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const a = document.createElement('a');
                a.download = `type_patch_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                a.href = URL.createObjectURL(blob);
                a.click();
                URL.revokeObjectURL(a.href);
            });

            // --- Incremental: Add new problems via coverage-only patch ---
            const incBaseBtn = getEl('inc-base-import-btn');
            const incBaseInput = getEl('inc-base-import-input');
            const incNewFilesBtn = getEl('inc-new-files-btn');
            const incNewFilesInput = getEl('inc-new-files-input');
            const incNewFilesStatus = getEl('inc-new-files-status');

            const incSplitPagesInput = getEl('inc-split-pages-input');
            const incReuseCacheInput = getEl('inc-reuse-extraction-cache-input');            const incTypeModeSel = getEl('inc-type-mode-select');
            const incNewTypeWrap = getEl('inc-new-type-title-wrap');
            const incNewTypeTitleInput = getEl('inc-new-type-title-input');
            const incExperimentalCropsInput = getEl('inc-experimental-image-crops-input');
            const incRunBtn = getEl('inc-run-btn');
            const incDownloadBtn = getEl('inc-download-btn');
            const incStatusEl = getEl('inc-status');

            const __makeIncCacheKey = (files, options) => {
                try {
                    const parts = (files || []).map(f => `${f.name}::${f.size}::${f.lastModified}`).sort();
                    const opt = options || {};
                    const optParts = [
                        `mode=${opt.mode || ''}`,
                        `split=${opt.splitPages || 0}`,
                        `crops=${opt.experimentalImageCrops ? 1 : 0}`,
                        `pdfMode=${String(getPipelineConfigFromUi()?.phase0?.pdfInputMode || '')}`
                    ];
                    const raw = parts.join('|') + '||' + optParts.join('|');
                    // cheap hash
                    let h = 0;
                    for (let i = 0; i < raw.length; i++) h = ((h << 5) - h) + raw.charCodeAt(i) | 0;
                    return `inc:${h}:${parts.length}`;
                } catch {
                    return `inc:${Date.now()}`;
                }
            };

            const refreshIncUi = () => {
                const mode = String(incTypeModeSel?.value || 'distribute');
                const isNewType = mode === 'new_type';
                if (incNewTypeWrap) incNewTypeWrap.style.display = isNewType ? 'block' : 'none';
                const base = incrementalPatchState.basePayload;
                const hasBase = !!base;
                const hasFiles = Array.isArray(incrementalPatchState.newFiles) && incrementalPatchState.newFiles.length > 0;
                const baseHasStd = hasBase && Array.isArray(base?.classificationStandard) && base.classificationStandard.length > 0;
                const baseHasTypes = hasBase && Array.isArray(base?.types) && base.types.length > 0;
                const canRun =
                    hasFiles &&
                    (isNewType || (hasBase && baseHasTypes && baseHasStd)) &&
                    incrementalPatchState.status !== 'processing';
                if (incRunBtn) incRunBtn.disabled = !canRun;
                if (incDownloadBtn) incDownloadBtn.disabled = !incrementalPatchState.patchPayload || incrementalPatchState.status === 'processing';
                if (incStatusEl && incrementalPatchState.status === 'idle') incStatusEl.textContent = __tGui('incStatusIdle');
            };
            refreshIncUi();

            incTypeModeSel?.addEventListener('change', refreshIncUi);
            incNewFilesBtn?.addEventListener('click', () => incNewFilesInput?.click());
            incBaseBtn?.addEventListener('click', () => incBaseInput?.click());

            incBaseInput?.addEventListener('change', async (e) => {
                const file = e.target.files?.[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    const obj = JSON.parse(text);
                    const base = parseIncrementalBasePayload(obj);
                    incrementalPatchState.basePayload = base;
                    incrementalPatchState.baseFileName = file.name;
                    incrementalPatchState.status = 'ready';
                    incrementalPatchState.error = null;
                    if (incStatusEl) {
                        const hasStd = Array.isArray(base?.classificationStandard) && base.classificationStandard.length;
                        incStatusEl.textContent = __tGuiFmt('incStatusBaseLoadedFmt', {
                            typesN: base.types.length,
                            std: hasStd ? __tGui('incStatusStdPresent') : __tGui('incStatusStdMissing')
                        });
                    }
                } catch (err) {
                    incrementalPatchState.basePayload = null;
                    incrementalPatchState.baseFileName = null;
                    incrementalPatchState.status = 'error';
                    incrementalPatchState.error = err?.message || String(err);
                    if (incStatusEl) incStatusEl.textContent = __tGuiFmt('incStatusBaseLoadFailedFmt', { error: incrementalPatchState.error });
                } finally {
                    e.target.value = '';
                    refreshIncUi();
                }
            });

            incNewFilesInput?.addEventListener('change', (e) => {
                const files = Array.from(e.target.files || []).filter(Boolean);
                incrementalPatchState.newFiles = files;
                if (incNewFilesStatus) {
                    incNewFilesStatus.textContent = files.length
                        ? __tGuiFmt('incNewFilesStatusSelectedFmt', { n: files.length, names: files.map(f => f.name).join(', ') })
                        : __tGui('incNewFilesStatusNone');
                }
                refreshIncUi();
                e.target.value = '';
            });

            incRunBtn?.addEventListener('click', async () => {
                if (incrementalPatchState.status === 'processing') return;
                const baseRaw = incrementalPatchState.basePayload;
                const files = incrementalPatchState.newFiles || [];
                if (!files.length) {
                    alert(__tGui('incAlertSelectNewFiles'));
                    return;
                }
                const modeUi = String(incTypeModeSel?.value || 'distribute');
                const mode = (modeUi === 'new_type') ? 'new_type' : 'distribute';
                if (mode === 'distribute') {
                    if (!baseRaw || !Array.isArray(baseRaw.types) || baseRaw.types.length === 0) {
                        alert(__tGui('incAlertDistributeNeedsBaseTypes'));
                        return;
                    }
                    if (!(Array.isArray(baseRaw.classificationStandard) && baseRaw.classificationStandard.length)) {
                        alert(__tGui('incAlertDistributeNeedsClassificationStandard'));
                        return;
                    }
		                }
		                const base = baseRaw || { types: [], classificationStandard: null };
		                const newTypeTitle = String(incNewTypeTitleInput?.value || 'ğŸ†• ì‹ ê·œ ë¬¸ì œ (ë¯¸ë¶„ë¥˜)').trim();
		                const globalCrops = !!getPipelineConfigFromUi()?.phase0?.experimentalImageCrops;
		                const experimentalImageCrops = globalCrops || !!incExperimentalCropsInput?.checked;

                incrementalPatchState.status = 'processing';
                incrementalPatchState.patchPayload = null;
                incrementalPatchState.error = null;
                if (incStatusEl) {
                    incStatusEl.textContent = (mode === 'new_type' && !baseRaw)
                        ? __tGui('incStatusProcessingNewTypeNoBase')
                        : __tGui('incStatusProcessingFileToOcr');
                }
                refreshIncUi();

                try {
                    processController.stop = false;
                    const globalSplitPages = getGlobalSplitPagesOverride();
                    const localSplitPages = parseInt(incSplitPagesInput?.value, 10);
                    const effectiveSplitPages = (Number.isFinite(localSplitPages) && localSplitPages > 0) ? localSplitPages : globalSplitPages;

                    const cacheKey = __makeIncCacheKey(files, { mode, splitPages: effectiveSplitPages, experimentalImageCrops });
                    const reuseOk = !!incReuseCacheInput?.checked;

                    let questions = null;

                    if (reuseOk && incrementalPatchState.cacheKey === cacheKey && Array.isArray(incrementalPatchState.cachedQuestions) && incrementalPatchState.cachedQuestions.length) {
                        questions = incrementalPatchState.cachedQuestions.map(q => ({ ...(q || {}) }));
                        if (incStatusEl) incStatusEl.textContent = __tGuiFmt('incStatusProcessingCacheReuseFmt', { n: questions.length });
                    } else {
                        const wrappers = files.map(f => ({
                            file: f,
                            splitPages: (f.type === 'application/pdf' && Number.isFinite(effectiveSplitPages) && effectiveSplitPages > 0) ? effectiveSplitPages : 0
                        }));

                        const units = await processFileWrappersToExamUnits(wrappers, 'IncFileProcessing');
                        if (!units.length) throw new Error('ì²˜ë¦¬ëœ exam unitì´ ì—†ìŠµë‹ˆë‹¤.');
                        if (incStatusEl) incStatusEl.textContent = __tGuiFmt('incStatusProcessingExtractFmt', { unitsN: units.length });

                        questions = await incrementalExtractQuestions(units, { experimentalImageCrops });
                        questions = Array.isArray(questions) ? questions : [];
                        if (!questions.length) throw new Error('ì¶”ì¶œëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');

                        if (experimentalImageCrops) {
                            if (incStatusEl) incStatusEl.textContent = __tGui('incStatusProcessingImageCrops');
                            try { await incrementalLocateAndAttachImageCrops(questions, 'IncImageCrop'); } catch (e) {
                                logger.warn('IncImageCrop', `Experimental crop failed (continuing): ${e.message}`);
                            }
                        }

                        // cache extraction result (in-memory)
                        incrementalPatchState.cacheKey = cacheKey;
                        incrementalPatchState.cachedQuestions = questions.map(q => ({ ...(q || {}) }));
                        incrementalPatchState.cachedAt = new Date().toISOString();
                    }
                    // Remove internal fields from export payload
                    questions.forEach(q => { try { delete q.__unitImages; } catch { } });

                    if (incStatusEl) incStatusEl.textContent = __tGuiFmt('incStatusProcessingCoveragePatchFmt', { n: questions.length });
                    const res = await runIncrementalCoverageOnlyPatch({
                        base,
                        newQuestions: questions,
                        mode,
                        newTypeTitle,
                        experimentalImageCrops
                    });

                    incrementalPatchState.patchPayload = res.patchPayload;
                    incrementalPatchState.status = 'completed';
                    const patchedN = Array.isArray(res?.patchedTypes) ? res.patchedTypes.length : 0;
                    if (incStatusEl) incStatusEl.textContent = __tGuiFmt('incStatusCompletedFmt', { n: questions.length, patchedN });
                } catch (err) {
                    incrementalPatchState.status = 'error';
                    incrementalPatchState.error = err?.message || String(err);
                    if (incStatusEl) incStatusEl.textContent = __tGuiFmt('incStatusFailedFmt', { error: incrementalPatchState.error });
                    logger.error('Incremental', `Failed: ${incrementalPatchState.error}`);
                } finally {
                    refreshIncUi();
                }
            });

            incDownloadBtn?.addEventListener('click', () => {
                const payload = incrementalPatchState.patchPayload;
                if (!payload) return;
                const jsonString = JSON.stringify(payload, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const a = document.createElement('a');
                a.download = `incremental_patch_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                a.href = URL.createObjectURL(blob);
                a.click();
                URL.revokeObjectURL(a.href);
            });

	            startButton.addEventListener('click', () => {
	                const icon = (startButton.querySelector('.material-symbols-outlined')?.textContent || '').trim();
	                const isStopMode = icon === 'stop';
	                if (!isStopMode) {
	                    startGenerationProcess();
	                    return;
	                }
	                // Stop
	                processController.stop = true;
	                logger.warn("UI", "STOP ë²„íŠ¼ í´ë¦­");
	                updateStatus(__tGui('statusTitleStopping'), __tGui('statusStoppingSubtext'));
	                startButton.disabled = true;
	            });

            const uploadArea = getEl('file-upload-area');
            const uploadInput = getEl('file-upload-input');
            const ansUploadArea = getEl('answer-upload-area');
            const ansUploadInput = getEl('answer-upload-input');

            uploadArea.addEventListener('click', () => uploadInput.click());
            ansUploadArea?.addEventListener('click', () => ansUploadInput?.click());

            ['dragover', 'dragenter'].forEach(event =>
                uploadArea.addEventListener(event, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    uploadArea.classList.add('dragover');
                })
            );
            ['dragover', 'dragenter'].forEach(event =>
                ansUploadArea?.addEventListener(event, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    ansUploadArea.classList.add('dragover');
                })
            );

            ['dragleave', 'drop'].forEach(event =>
                uploadArea.addEventListener(event, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    uploadArea.classList.remove('dragover');
                })
            );
            ['dragleave', 'drop'].forEach(event =>
                ansUploadArea?.addEventListener(event, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    ansUploadArea.classList.remove('dragover');
                })
            );

            uploadArea.addEventListener('drop', (e) => addFilesToList(e.dataTransfer.files));
            uploadInput.addEventListener('change', (e) => addFilesToList(e.target.files));
            ansUploadArea?.addEventListener('drop', (e) => addAnswerFilesToList(e.dataTransfer.files));
            ansUploadInput?.addEventListener('change', (e) => addAnswerFilesToList(e.target.files));

            const globalSplitEl = getEl('global-split-pages-input');
            globalSplitEl?.addEventListener('change', () => {
                const g = getGlobalSplitPagesOverride();
                if (!Number.isFinite(g) || g <= 0) return;
                uploadedFiles.forEach(fw => {
                    try {
                        if (fw?.file?.type !== 'application/pdf') return;
                        const cur = parseInt(fw.splitPages, 10);
                        if (!Number.isFinite(cur) || cur === 0) fw.splitPages = g;
                    } catch { }
                });
                uploadedAnswerFiles.forEach(fw => {
                    try {
                        if (fw?.file?.type !== 'application/pdf') return;
                        const cur = parseInt(fw.splitPages, 10);
                        if (!Number.isFinite(cur) || cur === 0) fw.splitPages = g;
                    } catch { }
                });
                renderFileList();
                renderAnswerFileList();
            });

            // Start API monitor immediately so key status is visible even before processing
            try { __apiMonitor.setRunning(true); } catch { }

            // Ensure tabs render even when no activeProcess is loaded yet.
            try { renderActiveProcess(); } catch { }

            logger.success("UI_Init", "UI Initialized. Ready for operation.");
        }

        document.addEventListener('DOMContentLoaded', initializeUI);

        /* --- END OF EMBEDDED JAVASCRIPT --- */
    </script>
</body>

</html>
