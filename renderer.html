<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hit Thunder Renderer</title>
  <!-- ADD: Favicon (âœï¸)
       ideology: recognizable tab makes returning to study faster -->
  <link rel="icon"
    href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='48'>âœï¸</text></svg>">
  <!-- Marked (Markdown Renderer) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- DOMPurify (Sanitizer) -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.7/dist/purify.min.js"></script>
  <!-- Highlight.js (optional, for code blocks) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.9.0/styles/github.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  <!-- ADD: MathJax for LaTeX ($...$, $$...$$) -->
  <!-- ideology: faithful in-place math rendering reduces cognitive context switches -->
  <script>
	    window.MathJax = {
	      // Ensure TeX extensions (e.g. color) are actually loaded in slim builds.
	      loader: { load: ['[tex]/color'] },
	      tex: {
	        // Support both \(...\)/\[...\] and the double-escaped variants \\(...\\)/\\[...\\]
	        // (the latter can appear after markdown/escaping layers).
	        inlineMath: [['$', '$'], ['\\(', '\\)'], ['\\\\(', '\\\\)']],
	        displayMath: [['$$', '$$'], ['\\[', '\\]'], ['\\\\[', '\\\\]']],
	        processEscapes: true,
	        // FIX: allow \color{...}{...} (MathJax TeX color package)
	        packages: { '[+]': ['color'] },
	        // ADD: small quality-of-life macros for notes/tools
	        macros: {
	          // \test{...} -> inline text (render-time only)
	          test: ['\\text{#1}', 1],
	          // Common helpers for fast note-taking
	          abs: ['\\left|#1\\right|', 1],
	          paren: ['\\left(#1\\right)', 1],
	          bracket: ['\\left[#1\\right]', 1],
	          set: ['\\left\\{#1\\right\\}', 1],
	          ceil: ['\\left\\lceil#1\\right\\rceil', 1],
	          floor: ['\\left\\lfloor#1\\right\\rfloor', 1],
	          unit: ['\\,\\mathrm{#1}', 1],
	          dd: '\\,\\mathrm{d}'
	        }
	      },
      options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] },
      // FIX: ensure Korean in math uses UI font fallbacks
      // ideology: mixed-language formulas should read as one typographic voice
      chtml: {
        mtextInheritFont: true,
        matchFontHeight: true
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <style>
    /* FIX: avoid inline glyph collisions in math (e.g. Ï‰t)
     ideology: a touch of spacing is better than visually merged symbols */
    mjx-container[display="inline"] mjx-mi,
    mjx-container[display="inline"] mjx-mn {
      letter-spacing: 0.06em;
      margin-right: 0.08em;
      display: inline-block;
    }

    /* FIX: block display math should also have proper spacing */
    mjx-container mjx-mi+mjx-mi,
    mjx-container mjx-mi+mjx-mn,
    mjx-container mjx-mn+mjx-mi {
      margin-left: 0.08em;
    }

	    :root {
	      --bg: #0e1116;
	      --bg-elev: #111720;
	      --fg: #e6edf3;
	      --muted: #9aa4af;
	      --main-pad-x: 14px;
      --accent: #4cc2ff;
      --accent-2: #7ce38b;
      --danger: #ff6b6b;
      --border: #1f2632;
      --card: #0f141c;
      --shadow: 0 8px 30px rgba(0, 0, 0, 0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --radius: 12px;
      --radius-sm: 8px;
	      --radius-lg: 16px;
	      --header-h: 60px;
	      --header-visible-h: 60px;
	      --scroll-track: color-mix(in oklab, var(--bg) 88%, #000);
	      --scroll-thumb: color-mix(in oklab, var(--fg) 20%, var(--bg));
	    }

	    [data-theme="light"] {
	      --bg: #ffffff;
	      --bg-elev: #f6f8fa;
	      --fg: #0b1320;
      --muted: #49566a;
      --accent: #0a84ff;
      --accent-2: #0bab63;
      --danger: #d7263d;
	      --border: #e2e8f0;
	      --card: #ffffff;
	      --shadow: 0 8px 30px rgba(30, 41, 59, 0.15);
	      --scroll-track: color-mix(in oklab, var(--bg) 90%, #fff);
	      --scroll-thumb: color-mix(in oklab, var(--fg) 22%, var(--bg));
	    }

	    * {
	      box-sizing: border-box;
	      scrollbar-color: var(--scroll-thumb) var(--scroll-track);
	      scrollbar-width: thin;
	    }
	    *::-webkit-scrollbar {
	      width: 12px;
	      height: 12px;
	    }
	    *::-webkit-scrollbar-track {
	      background: var(--scroll-track);
	    }
	    *::-webkit-scrollbar-thumb {
	      background-color: var(--scroll-thumb);
	      border: 3px solid var(--scroll-track);
	      border-radius: 999px;
	    }
	    *::-webkit-scrollbar-thumb:hover {
	      background-color: color-mix(in oklab, var(--scroll-thumb) 70%, var(--fg));
	    }

	    html,
	    body {
	      height: 100%;
	    }
	    body {
	      color-scheme: dark;
	    }
	    body[data-theme="light"] {
	      color-scheme: light;
	    }

    html {
      scroll-padding-top: calc(var(--header-h) + 12px);
    }

    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      font: 15px/1.6 system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans KR", "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 50;
      background: linear-gradient(180deg, var(--bg-elev), rgba(0, 0, 0, 0));
      backdrop-filter: blur(6px);
      border-bottom: 1px solid var(--border);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }

    header.hidden {
      transform: translateY(-100%);
      opacity: 0;
      pointer-events: none;
    }

    /* Compensate for fixed header by adding padding to body */
    body {
      padding-top: var(--header-h);
    }

    .bar {
      max-width: min(1600px, 100%);
      margin: 0 auto;
      padding: 6px var(--main-pad-x);
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    /* Make the header brand compact (avoid 2-line title + pill stack) */
    .brand>div:last-child {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: nowrap;
    }
    .brand>div:last-child>div:first-child {
      font-size: 14px;
      line-height: 1.15;
      white-space: nowrap;
    }

    .brand .logo {
      width: 26px;
      height: 26px;
      border-radius: 7px;
      background: radial-gradient(120% 120% at 70% 10%, var(--accent), #6f42c1 70%, #1f2632);
      display: grid;
      place-items: center;
      color: #fff;
      box-shadow: var(--shadow);
      font-family: var(--mono);
      font-size: 13px;
    }

    .actions {
      display: flex;
      gap: 6px;
      align-items: center;
      flex: 1 1 auto;
      justify-content: flex-end;
      flex-wrap: wrap;
      row-gap: 6px;
    }

    /* RESCUE CENTER STYLE */
    #rescueDialog {
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 24px;
      max-width: 500px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }

    #rescueDialog::backdrop {
      background: rgba(0, 0, 0, 0.7);
    }

    #rescueDialog h2 {
      margin-top: 0;
    }

    .rescue-row {
      margin-bottom: 16px;
    }

    .rescue-row label {
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
      color: var(--muted);
    }

    .rescue-row input[type=file] {
      width: 100%;
      background: var(--bg-elev);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
    }

	    button,
	    .btn {
	      cursor: pointer;
	      border: 1px solid var(--border);
	      background: linear-gradient(180deg, var(--card), var(--bg-elev));
	      color: var(--fg);
	      padding: 5px 9px;
	      border-radius: 9px;
	      display: inline-flex;
	      align-items: center;
	      gap: 6px;
	      box-shadow: var(--shadow);
	      white-space: nowrap;
	    }
	    select.btn {
	      appearance: none;
	      -webkit-appearance: none;
	      padding-right: 20px;
	      background: var(--bg-elev) !important;
	      color: var(--fg) !important;
	      border-color: var(--border) !important;
	      box-shadow: var(--shadow);
	      outline: none;
	    }
	    select.btn option {
	      background: var(--bg-elev);
	      color: var(--fg);
	    }

    header button,
    header .btn {
      font-size: 13px;
      line-height: 1.1;
    }

    button:hover {
      border-color: color-mix(in oklab, var(--border), var(--accent) 30%);
    }

    .btn-primary {
      background: linear-gradient(180deg, color-mix(in oklab, var(--accent) 16%, var(--card)), var(--card));
      border-color: color-mix(in oklab, var(--accent) 30%, var(--border));
    }

    .btn-ghost {
      background: transparent;
      border-color: transparent;
      color: var(--muted);
    }

    .pill {
      border: 1px solid var(--border);
      background: var(--bg-elev);
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
    }

    header .pill {
      padding: 2px 8px;
      font-size: 11px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 420px;
    }
    @media (max-width: 1180px) {
      header .brand .pill {
        display: none;
      }
    }

    main {
      max-width: 1200px;
      margin: 14px auto 40px;
      padding: 0 var(--main-pad-x);
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
    }

    .row {
      display: flex;
      gap: 14px;
      align-items: stretch;
    }

    .row>* {
      flex: 1;
    }

    textarea {
      width: 100%;
      min-height: 200px;
      resize: vertical;
      background: var(--bg-elev);
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      font-family: var(--mono);
      font-size: 13px;
    }

    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      margin-top: 10px;
    }

    .toolbar .left,
    .toolbar .right {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .types-nav {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 16px 0 10px;
    }

    .types-nav a {
      text-decoration: none;
      color: var(--fg);
      border: 1px solid var(--border);
      background: var(--bg-elev);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 13px;
    }

    .types-nav a.active {
      border-color: var(--accent);
      color: var(--accent);
    }

    .type-card {
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      background: linear-gradient(180deg, var(--card), color-mix(in oklab, var(--card), var(--bg-elev) 30%));
      padding: 16px 16px 6px;
      margin-bottom: 18px;
      box-shadow: var(--shadow);
      scroll-margin-top: calc(var(--header-h) + 12px);
    }

    .type-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding-bottom: 10px;
      border-bottom: 1px dashed var(--border);
      margin-bottom: 16px;
    }

    .type-title {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .type-title h2 {
      margin: 0;
      font-size: 18px;
    }

    .type-idx {
      color: var(--muted);
      font-weight: 600;
    }

    .type-jump {
      display: flex;
      gap: 8px;
    }

    .cols {
      display: grid;
      gap: 14px;
      /* FIX: keep stable column widths across types (avoid min-content-driven shifts) */
      grid-template-columns: minmax(0, 1fr) minmax(0, 2fr);
    }

    .col {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg-elev);
      padding: 14px;
      min-width: 0;
      min-height: 120px;
    }

    .col h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
      color: var(--muted);
      border-bottom: 1px dashed var(--border);
      padding-bottom: 6px;
    }

    .problem .answer {
      margin: 10px 0 6px;
      padding: 10px 12px;
      border: 1px solid color-mix(in oklab, var(--danger), var(--border) 35%);
      background: color-mix(in oklab, var(--danger) 12%, var(--bg-elev));
      border-radius: 10px;
      font-weight: 600;
    }

    .problem .answer .badge {
      display: inline-block;
      margin-right: 8px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      background: var(--danger);
      color: #fff;
    }

    /* ADD: í‘œì¤€ë¬¸ì œ ê³ ì • ìŠ¤í¬ë¡¤ */
    .col.problem {
      position: sticky;
      top: calc(var(--header-h) + 13px);
      /* ìƒë‹¨ í—¤ë” ë†’ì´ ë³´ì • */
      align-self: start;
      max-height: calc(100vh - var(--header-h) - 35px);
      overflow: auto;
      /* í‘œì¤€ë¬¸ì œê°€ ê¸¸ë©´ ë‚´ë¶€ ìŠ¤í¬ë¡¤ */
    }

    @media (max-width: 980px) {
      .cols {
        grid-template-columns: 1fr;
      }

      /* ëª¨ë°”ì¼ì—ì„œëŠ” sticky í•´ì œ */
      .col.problem {
        position: static;
        max-height: none;
        overflow: visible;
      }
    }

    /* ADD: long commentary list stays usable */
    #problemDetail {
      max-height: 65vh;
      overflow: auto;
    }

    /* ideology: long content needs bounded scroll */

    .muted {
      color: var(--muted);
    }

    .hr {
      height: 1px;
      background: var(--border);
      margin: 10px 0;
    }

    .empty {
      color: var(--muted);
      font-style: italic;
    }

    /* markdown content tweaks */
    .md :is(h1, h2, h3) {
      margin: 12px 0 8px;
    }

    .md p {
      margin: 8px 0;
    }

	    /* memo preview font size (persisted) */
	    .memo-viewer,
	    .problem-memo-preview {
	      font-size: var(--memo-preview-font, 15px);
	    }
	    /* FIX: some fonts clip the first line; keep a bit more headroom in memo previews */
	    .problem-memo-preview {
	      padding-top: 10px !important;
	    }
	    .memo-viewer table,
	    .problem-memo-preview table {
	      font-size: inherit;
	    }

    /* FIX: Dark theme link contrast (markdown hyperlinks) */
    .md a {
      color: var(--accent);
      text-decoration: underline;
      text-underline-offset: 2px;
    }

    .md a:visited {
      color: #c3a6ff;
    }

    .md a:hover {
      color: var(--accent-2);
    }

    .md img {
      max-width: 100%;
      border-radius: 8px;
      border: 1px solid var(--border);
      cursor: zoom-in;
    }

    .md table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: 14px;
      overflow: auto;
      display: block;
    }

    .md table th,
    .md table td {
      border: 1px solid var(--border);
      padding: 8px;
      text-align: left;
      min-width: 60px;
      /* FIX: prevent extreme narrow columns */
    }

    /* FIX: last column can wrap to prevent horizontal overflow */
    .md table td:last-child,
    .md table th:last-child {
      word-break: break-word;
    }

    .md blockquote {
      margin: 8px 0;
      padding: 8px 12px;
      border-left: 3px solid var(--accent);
      background: color-mix(in oklab, var(--accent) 6%, var(--bg-elev));
      border-radius: 6px;
    }

	    .md pre {
	      background: #0b1017;
	      color: #dbe7ff;
	      border: 1px solid var(--border);
	      border-radius: 8px;
	      padding: 10px;
	      overflow: auto;
	      /* FIX: auto-wrap for indented problem text rendered as code blocks */
	      white-space: pre-wrap;
	      overflow-wrap: anywhere;
	      word-break: break-word;
	    }

    [data-theme="light"] .md pre {
      background: #f4f7fb;
      color: #0a1728;
    }

    .foot {
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      margin: 24px 0 36px;
    }

    .progress {
      position: fixed;
      inset: 0 0 auto 0;
      height: 4px;
      background: rgba(255, 255, 255, 0.18);
      z-index: 60;
      pointer-events: none;
    }
    [data-theme="light"] .progress {
      background: rgba(0, 0, 0, 0.14);
    }

    .progress .progress-bar {
      height: 4px;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      width: 0%;
      transition: width 0.2s ease;
      border-radius: 999px;
    }

    /* --- ADD: PDF ì¸ì‡„ìš© ìŠ¤íƒ€ì¼ --- */
    @media print {

      /* ê°•ì œë¡œ ë‹¤í¬ ëª¨ë“œ ë³€ìˆ˜ ì ìš© */
      :root {
        --bg: #0e1116;
        --bg-elev: #111720;
        --fg: #e6edf3;
        --muted: #9aa4af;
        --accent: #4cc2ff;
        --accent-2: #7ce38b;
        --danger: #ff6b6b;
        --border: #1f2632;
        --card: #0f141c;
        --shadow: none;
        /* ê·¸ë¦¼ì ì œê±° */
      }

      body {
        background: var(--bg) !important;
        color: var(--fg) !important;
        -webkit-print-color-adjust: exact !important;
        /* ë¸Œë¼ìš°ì €ê°€ ìƒ‰ìƒ ê°•ì œ ë³€ê²½í•˜ëŠ” ê²ƒ ë°©ì§€ */
        print-color-adjust: exact !important;
      }

      /* ë¶ˆí•„ìš”í•œ UI ìˆ¨ê¸°ê¸° */
      header,
      .panel,
      .types-nav,
      .foot,
      .progress,
      .type-jump,
      #globalAside,
      #typeAside,
      #leftAside,
      #chatWindow {
        display: none !important;
      }

      /* ë³¸ë¬¸ ì˜ì—­ë§Œ ë³´ì´ë„ë¡ ì„¤ì • */
      main {
        margin: 0 !important;
        padding: 0 !important;
        max-width: 100% !important;
      }

      #output {
        padding: 20px;
      }

      /* ë ˆì´ì•„ì›ƒ ë³€ê²½: 2ë‹¨ -> 1ë‹¨, sticky í•´ì œ */
      .cols {
        display: block !important;
      }

      .col.problem {
        position: static !important;
        max-height: none !important;
        overflow: visible !important;
        margin-bottom: 16px;
      }

      /* ì¸ì‡„ ì‹œ í˜ì´ì§€ ë‚˜ë‰¨ ë°©ì§€ ë° ìŠ¤íƒ€ì¼ ì •ë¦¬ */
      .type-card {
        page-break-inside: avoid;
        border: 1px solid var(--border) !important;
        box-shadow: none !important;
        padding: 16px !important;
        margin-bottom: 24px;
        background: var(--card) !important;
      }

      .col {
        border: none !important;
        padding: 0 !important;
        background: transparent !important;
      }

      .type-head {
        border-bottom: 1px solid var(--border) !important;
      }
    }

	    /* === ADD: sidebars & floating windows for memos / problems / chat === */
	    .aside {
	      position: fixed;
	      top: calc(var(--header-h) + 13px);
	      height: calc(100vh - var(--header-h) - 25px);
	      width: 320px;
	      z-index: 40;
	      display: flex;
	      flex-direction: column;
	      gap: 10px;
	      /* Allow users to adjust memo window size directly (fix: resizing disabled/buggy) */
	      resize: both;
	      overflow: hidden;
	      min-width: 260px;
	      min-height: 220px;
	    }

    .aside.right {
      right: 12px;
    }

    .aside.left {
      left: 12px;
    }

	    .sidebar-panel {
	      background: var(--card);
	      border: 1px solid var(--border);
	      border-radius: var(--radius);
	      box-shadow: var(--shadow);
	      display: flex;
	      flex-direction: column;
	      /* resize happens on .aside (persisted); panel just fills */
	      resize: none;
	      overflow: hidden;
	      min-height: 140px;
	    }
		    /* FIX: ensure asides fill their fixed height on first load
		       so overflow/scrollbars are correct without a manual resize */
		    .aside .sidebar-panel {
		      /* In a column flex container, flexing on the main axis prevents vertical resize.
		         Default-fill via height:100%, but allow user resize to override. */
		      flex: 1;
		      height: 100%;
		      width: 100%;
		      min-height: 140px;
		    }

    .sidebar-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px dashed var(--border);
    }

		    .sidebar-body {
		      padding: 10px;
		      overflow: auto;
		      flex: 1;
		      min-height: 0;
		    }
		    /* FIX: Global/Type memo should not leave a long empty area below the textarea. */
		    #globalMemoPanel .sidebar-body,
		    #typeMemoPanel .sidebar-body {
		      display: flex;
		      flex-direction: column;
		      gap: 8px;
		    }
		    #globalMemo,
		    #typeMemo {
		      flex: 0 0 auto;
		      min-height: 120px;
		      height: 240px;
		      resize: vertical;
		    }

	    .sidebar-panel.min .sidebar-body {
	      display: none;
	    }
	    .sidebar-panel.min .sidebar-head strong,
	    .sidebar-panel.min .sidebar-head button:not([data-action="min"]) {
	      display: none;
	    }
	    .sidebar-panel.min .sidebar-head {
	      justify-content: flex-end;
	    }

	    /* minimize */
	    .sidebar-panel.min {
	      flex: 0 0 auto !important;
	      height: auto !important;
	      min-height: 0 !important;
	      resize: none;
	    }
		    .aside.min {
		      height: auto !important;
		      min-height: 0 !important;
		      resize: none;
		      overflow: visible;
		    }
		    .aside.min {
		      width: 56px !important;
		      min-width: 0 !important;
		    }

    .memo-textarea {
      width: 100%;
      min-height: 100px;
      background: var(--bg-elev);
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 8px;
      font-family: var(--mono);
    }

    .memo-anchor {
      border-bottom: 2px dotted color-mix(in oklab, var(--accent) 40%, var(--border));
      cursor: help;
    }

    .memo-pop {
      position: absolute;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--shadow);
      padding: 10px;
      max-width: 360px;
      z-index: 70;
    }

    .memo-thumb {
      font-size: 12px;
      color: var(--muted);
      white-space: pre-wrap;
      /* FIX: show long phrases nicely */
      overflow-wrap: anywhere;
      /* FIX: break long tokens instead of overflowing */
      max-height: 240px;
      overflow: auto;
      /* FIX: allow large notes without flicker */
      pointer-events: none;
      /* FIX: tooltip shouldn't steal hover; keep anchor active */
    }

    /* Larger editor surface for memo editing preview
       ideology: bigger canvas reduces cognitive friction while writing */
    .memo-pop.memo-editor {
      max-width: 560px;
      min-width: 380px;
    }

    .window {
      position: fixed;
      bottom: 14px;
      right: 350px;
      width: 420px;
      height: 360px;
      z-index: 45;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      resize: both;
      overflow: hidden;
      display: none;
    }

    .window.active {
      display: flex;
      flex-direction: column;
    }

    .window-head {
      padding: 8px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px dashed var(--border);
    }

    .window-body {
      flex: 1;
      overflow: auto;
      padding: 10px;
    }

    .window-foot {
      padding: 8px;
      border-top: 1px dashed var(--border);
      display: flex;
      gap: 8px;
    }

    .chat-msg {
      margin: 8px 0;
    }

    .chat-msg.you {
      text-align: right;
    }

    .chat-msg .bubble {
      display: inline-block;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--bg-elev);
      max-width: 85%;
    }

    .chat-msg.you .bubble {
      background: color-mix(in oklab, var(--accent) 12%, var(--bg-elev));
    }

    .chat-controls {
      display: flex;
      gap: 8px;
    }

    .chat-input {
      flex: 1;
    }

    .problems-list {
      max-height: 200px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    .problems-item {
      display: block;
      padding: 8px 10px;
      border-bottom: 1px dashed var(--border);
      cursor: pointer;
    }

    .problems-item:hover {
      background: color-mix(in oklab, var(--accent) 6%, var(--card));
    }

    @keyframes fmmFlash {
      0% {
        background: color-mix(in oklab, var(--accent) 18%, var(--card));
        outline: 2px solid color-mix(in oklab, var(--accent) 55%, transparent);
        outline-offset: 2px;
      }
      100% {
        background: transparent;
        outline: 2px solid transparent;
        outline-offset: 2px;
      }
    }
    .problems-item.flash {
      animation: fmmFlash 1.2s ease-out;
    }
    .sidebar-panel.flash,
    .memo-textarea.flash {
      animation: fmmFlash 1.2s ease-out;
    }

    @media (max-width: 980px) {

      .aside.left,
      .aside.right,
      #globalAside,
      #typeAside {
        position: static;
        width: auto;
        height: auto;
      }

      .window {
        position: fixed;
        right: 12px;
        left: 12px;
        width: auto;
      }
    }

    /* === ADD: movable/resizable asides & chat window ===========================
       Ideology: ì´ˆê¸° ë ˆì´ì•„ì›ƒì€ CSSê°€ ì±…ì„ â€” JSëŠ” 'ì‚¬ìš©ì ì¡°ì‘'ë§Œ ê¸°ì–µ */
		    .aside {
		      /* ë³µì›ëœ ê¸°ë³¸ ìœ„ì¹˜/í¬ê¸° (JS ë¹„ì˜ì¡´ ì´ˆê¸° ìƒíƒœ) */
		      position: fixed;
		      top: calc(var(--header-h) + 13px);
		      height: calc(100vh - var(--header-h) - 25px);
		      width: 320px;
		      z-index: 40;
		      display: flex;
		      flex-direction: column;
		      gap: 10px;
	
		      /* ì‚¬ìš©ì ì¡°ì‘ í—ˆìš© */
		      resize: both;
		      overflow: hidden;
		      min-width: 260px;
		      min-height: 220px;
		    }

    .aside.dragging,
    .window.dragging {
      user-select: none;
      cursor: grabbing;
    }

    .sidebar-head,
    .window-head {
      cursor: grab;
    }

    /* Make headers the draggable handle */

    /* Make word-memo anchors feel like hyperlinks (keeps your dotted style) */
    .memo-anchor {
      text-decoration: underline;
    }

    /* === FIX: chat actions readability & markdown rendering ======================
       Ideology: controls must be legible in dark mode; chat content should render
       like the rest of the app (markdown + math), with minimal cognitive friction */
    .chat-actions a,
    .chat-actions button {
      color: var(--fg) !important;
      /* override default blue */
      text-decoration: none;
      border: 1px solid var(--border);
      background: var(--bg-elev);
      border-radius: 8px;
      padding: 2px 8px;
      font-size: 12px;
      opacity: 0.95;
    }

    .chat-actions a:hover,
    .chat-actions button:hover {
      opacity: 1;
    }

    .chat-msg .bubble.md {
      white-space: normal;
    }

    /* allow markdown to flow */
    .chat-edit {
      margin-top: 8px;
    }

    .chat-edit .memo-textarea {
      min-height: 120px;
    }

    /* collapse toggle for chat */
    .window.collapsed .window-body,
    .window.collapsed .window-foot {
      display: none;
    }

    /* ADD: floating edit bar for explanations
       ideology: controls should remain reachable while reading */
	    .explanation .editbar {
	      position: sticky;
	      top: calc(var(--header-visible-h) + 10px);
	      z-index: 3;
      display: inline-flex;
      width: fit-content;
      max-width: 100%;
      background: transparent;
      border: none;
      border-radius: 8px;
	      padding: 0;
	    }

	    /* Render-edit mode: click rendered blocks to edit small chunks (without opening full raw editor) */
	    .fmm-render-edit-on .fmm-rend-block {
	      border-radius: 8px;
	      /* Avoid layout/scroll jumps when toggling render-edit mode. */
	      padding: 0;
	    }
	    .fmm-render-edit-on .fmm-rend-block:hover {
	      outline: 1px dashed var(--accent);
	      outline-offset: 2px;
	      cursor: pointer;
	    }

	    /* Simple modal (used by render-edit) */
	    .fmm-modal-overlay {
	      position: fixed;
	      inset: 0;
	      display: none;
	      align-items: center;
	      justify-content: center;
	      padding: 18px;
	      background: rgba(0, 0, 0, 0.55);
	      z-index: 10000;
	    }
	    .fmm-modal {
	      width: min(980px, 96vw);
	      max-height: 92vh;
	      overflow: hidden;
	      background: var(--card);
	      border: 1px solid var(--border);
	      border-radius: 14px;
	      box-shadow: 0 14px 42px rgba(0, 0, 0, 0.45);
	      display: flex;
	      flex-direction: column;
	    }
	    .fmm-modal-head {
	      display: flex;
	      align-items: center;
	      justify-content: space-between;
	      gap: 10px;
	      padding: 10px 12px;
	      border-bottom: 1px dashed var(--border);
	    }
	    .fmm-modal-body {
	      padding: 12px;
	      overflow: auto;
	    }
	    .fmm-modal-preview {
	      margin-top: 10px;
	      padding: 10px;
	      border: 1px dashed var(--border);
	      border-radius: 12px;
	      background: var(--bg-elev);
	    }

	    /* --- PATCH START: Split memo asides & selection highlight --- */
	    /* split memo asides: default offsets so both are visible
	       ideology: sensible defaults reduce friction before any drag/persist */
	    #globalAside {
      right: 12px;
    }

    #typeAside {
      right: 344px;
    }

    /* ~320px width + 12px gap */
    /* show which memo is selected for editing */
    .category-memo-btn.selected {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* --- PATCH END --- */

    /* FIX: Korean (and other text) inside \text{...} should match the guide font */
    mjx-container mjx-mtext,
    mjx-container mjx-mtext mjx-c {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans KR", "Apple Color Emoji", "Segoe UI Emoji" !important;
    }

    /* ADD: error banner for chat API failures
       ideology: visible, transient failures beat silent confusion */
    .error-banner {
      display: none;
      margin: 6px 0;
      padding: 8px 10px;
      border-radius: 8px;
      background: color-mix(in oklab, var(--danger) 30%, var(--bg-elev));
      border: 1px solid color-mix(in oklab, var(--danger), var(--border) 40%);
      color: #fff;
    }

    [data-theme="light"] .error-banner {
      color: #0b1320;
    }

    /* ADD: hide textarea/toolbar when guide is collapsed
       ideology: maximize reading space; raw stays accessible for search/edit */
    .panel.collapsed textarea,
    .panel.collapsed .toolbar {
      display: none !important;
    }

    /* ADD: mark highlighting for search results
       ideology: low-contrast highlights keep focus without visual shouting */
    mark {
      background: color-mix(in oklab, var(--accent) 35%, transparent);
      color: inherit;
      border-radius: 3px;
      padding: 0 2px;
    }

	    .search-hit.selected {
	      outline: 2px solid var(--accent);
	    }

	    /* ADD: highlight math containers for LaTeX search hits */
	    mjx-container.math-search-hit {
	      outline: 2px solid var(--accent);
	      outline-offset: 4px;
	      border-radius: 6px;
	      background: color-mix(in oklab, var(--accent) 14%, transparent);
	    }

    /* overlay panels inside chat window
       ideology: menus should appear where you're reading, not force a scroll reset */
    #chatWindow .chat-overlay {
      position: absolute;
      left: 8px;
      right: 8px;
      top: 40px;
      /* just below the chat header */
      max-height: calc(100% - 80px);
      /* keep the footer visible */
      overflow: auto;
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
      z-index: 5;
    }

    /* --- NEW: solving window & controls --- */
	    .window.solve-window {
	      left: 12px;
	      right: auto;
	      width: 480px;
	      max-height: calc(100vh - var(--header-h) - 24px);
	      bottom: 14px;
	      font-size: var(--solve-font, 15px);
	    }

    .solve-setup,
    .solve-play,
    .solve-review {
      display: none;
      gap: 8px;
      flex-direction: column;
    }

    .solve-setup.active,
    .solve-play.active,
    .solve-review.active {
      display: flex;
    }

    .choice-btn {
      width: 100%;
      text-align: left;
      border: 1px solid var(--border);
      background: var(--bg-elev);
      border-radius: 10px;
      padding: 10px;
      display: flex;
      gap: 10px;
      align-items: flex-start;
    }

    .choice-btn.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent) 30%, transparent);
    }

    .choice-btn.revealed {
      background: color-mix(in oklab, var(--accent-2) 12%, var(--bg-elev));
    }

    .choice-mark {
      font-weight: 700;
      line-height: 1.2;
      min-width: 24px;
      display: inline-flex;
      align-items: flex-start;
      justify-content: center;
    }

    .choice-text {
      flex: 1;
      line-height: 1.5;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    .tag-chip {
      border: 1px solid var(--border);
      background: var(--bg-elev);
      padding: 4px 8px;
      border-radius: 8px;
      cursor: pointer;
    }

	    .tag-chip.active {
	      border-color: var(--accent);
	      color: var(--accent);
	    }

	    .tag-checks {
	      display: inline-flex;
	      gap: 6px;
	      flex-wrap: wrap;
	      align-items: center;
	      margin-left: 6px;
	    }
	    .tag-checks .tag-check {
	      display: inline-flex;
	      gap: 4px;
	      align-items: center;
	      cursor: pointer;
	      user-select: none;
	    }
	    .tag-checks .tag-check input[type="checkbox"] {
	      margin: 0;
	      accent-color: var(--accent);
	    }
	    .tag-checks .tag-check-chip {
	      border: 1px solid var(--border);
	      background: var(--bg-elev);
	      padding: 2px 8px;
	      border-radius: 999px;
	      line-height: 1.2;
	    }
	    .tag-checks .tag-check input[type="checkbox"]:checked + .tag-check-chip {
	      border-color: var(--accent);
	      color: var(--accent);
	    }

	    .problems-item .tag-badge {
	      margin-right: 6px;
	    }

    .solve-progress {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .solve-memo-list button {
      width: 100%;
      text-align: left;
    }

	    .solve-badges {
	      display: flex;
	      gap: 6px;
	      flex-wrap: wrap;
	    }
	    .solve-type-pill {
	      cursor: pointer;
	    }
	    .solve-type-pill:hover {
	      border-color: var(--accent);
	      color: var(--accent);
	    }

    .solve-review-list {
      max-height: 200px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
    }

	    .solve-review-list .item {
	      display: flex;
	      gap: 8px;
	      align-items: flex-start;
	      padding: 6px 8px;
	      border-bottom: 1px dashed var(--border);
	      cursor: pointer;
	    }
	    .solve-review-list .item .review-sel {
	      margin-top: 2px;
	      flex: 0 0 auto;
	    }
	    .solve-review-list .item .review-line {
	      flex: 1;
	      min-width: 0;
	    }

	    .solve-review-list .item:last-child {
	      border-bottom: none;
	    }

	    /* --- NEW: solve quick-tap panel (memo share / navigation) --- */
	    .solve-quicktap {
	      display: flex;
	      gap: 6px;
	      flex-wrap: wrap;
	      align-items: flex-start;
	    }
	    .solve-quicktap .quick-item {
	      display: flex;
	      gap: 4px;
	      align-items: center;
	    }
	    .solve-quicktap .quick-qbtn {
	      min-width: 40px;
	      padding: 6px 8px;
	      text-align: center;
	      position: relative;
	      font-variant-numeric: tabular-nums;
	    }
	    .solve-quicktap .quick-linkbtn,
	    .solve-quicktap .quick-unlinkbtn {
	      min-width: 34px;
	      padding: 6px 8px;
	      text-align: center;
	      font-variant-numeric: tabular-nums;
	    }
	    .solve-quicktap .quick-linkbtn.selected {
	      border-color: var(--danger);
	      box-shadow: 0 0 0 2px color-mix(in oklab, var(--danger) 25%, transparent);
	    }
	    .solve-quicktap .quick-qbtn.selected {
	      border-color: var(--danger);
	      box-shadow: 0 0 0 2px color-mix(in oklab, var(--danger) 25%, transparent);
	    }
	    .solve-quicktap .quick-qbtn.shared-here {
	      border-color: var(--accent-2);
	      background: color-mix(in oklab, var(--accent-2) 14%, var(--bg-elev));
	    }
	    .solve-quicktap .quick-qbtn.shared-else {
	      border-color: var(--accent);
	      background: color-mix(in oklab, var(--accent) 12%, var(--bg-elev));
	    }
	    .solve-quicktap .quick-qbtn.current {
	      box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent-2) 18%, transparent);
	    }
	    .solve-quicktap .quick-qbtn.answered::after {
	      content: "âœ“";
	      position: absolute;
	      top: -6px;
	      right: -6px;
	      width: 16px;
	      height: 16px;
	      border-radius: 999px;
	      display: grid;
	      place-items: center;
	      font-size: 11px;
	      background: color-mix(in oklab, var(--accent-2) 45%, var(--bg-elev));
	      border: 1px solid var(--border);
	      color: var(--fg);
	    }

	    /* --- NEW: memo share group manager (visual, solve-order) --- */
	    .share-manager {
	      display: grid;
	      grid-template-columns: 1.2fr 0.8fr;
	      gap: 10px;
	      min-height: 520px;
	      max-height: 70vh;
	    }
	    .share-manager-col {
	      border: 1px solid var(--border);
	      border-radius: 12px;
	      background: var(--card);
	      min-height: 0;
	      display: flex;
	      flex-direction: column;
	    }
	    .share-manager-head {
	      display: flex;
	      justify-content: space-between;
	      align-items: center;
	      gap: 8px;
	      padding: 8px 10px;
	      border-bottom: 1px dashed var(--border);
	    }
	    .share-manager-list {
	      padding: 10px;
	      overflow: auto;
	      display: flex;
	      flex-direction: column;
	      gap: 10px;
	      min-height: 0;
	    }
	    .share-card {
	      border: 1px solid var(--border);
	      border-radius: 12px;
	      background: var(--bg-elev);
	      padding: 10px;
	    }
		    .share-card.selected {
		      border-color: var(--danger);
		      box-shadow: 0 0 0 2px color-mix(in oklab, var(--danger) 20%, transparent);
		    }
		    .share-card.current {
		      border-color: var(--accent-2);
		      background: color-mix(in oklab, var(--accent-2) 10%, var(--bg-elev));
		      box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent-2) 18%, transparent);
		    }
		    .share-card.selected.current {
		      border-color: color-mix(in oklab, var(--danger) 60%, var(--accent-2));
		    }
		    .share-snippet {
		      margin-top: 6px;
		      white-space: pre-wrap;
		      overflow-wrap: anywhere;
		      word-break: break-word;
	      font-size: 13px;
	      line-height: 1.45;
	      color: color-mix(in oklab, var(--fg) 90%, var(--muted));
	      max-height: 180px;
	      overflow: auto;
	      border: 1px dashed var(--border);
	      border-radius: 10px;
	      padding: 8px;
	      background: color-mix(in oklab, var(--bg) 75%, var(--bg-elev));
	    }
	    .share-mini {
	      font-size: 12px;
	      color: var(--muted);
	      overflow-wrap: anywhere;
	    }

	    .memo-pop.problem-hover-preview {
	      max-width: 520px;
	      max-height: 320px;
	      overflow: auto;
	      pointer-events: none;
	    }

	    .category-list {
	      max-height: 260px;
	      min-height: 0;
	      overflow: auto;
	      flex: 0 0 auto;
	    }

    /* collapse windows should shrink to header size */
    .window.collapsed {
      height: auto !important;
      min-height: 0 !important;
      max-height: none !important;
      overflow: visible;
      resize: none;
    }

    /* --- NEW: auto-hide header reveal zone (visual only, logicì€ mousemoveë¡œ ì²˜ë¦¬) --- */
    #hoverRevealZone {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 10vh;
      min-height: 40px;
      z-index: 70;
      pointer-events: none;
      /* ì‹¤ì œ í˜¸ë²„ ê°ì§€ëŠ” document mousemove ë¡œ ì²˜ë¦¬ */
    }

    header.hidden {
      transform: translateY(-100%);
      opacity: 0;
      pointer-events: none;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

    header {
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

	    /* --- NEW: MathJax selection/copy friendliness --- */
	    mjx-container,
	    mjx-container * {
	      user-select: text !important;
	    }
	    /* FIX: make MathJax follow surrounding font-size controls (memo AÂ±, UI font +/-) */
	    mjx-container {
	      font-size: inherit !important;
	    }
	    /* FIX: long LaTeX on mobile should not overflow the guide panel */
	    mjx-container {
	      max-width: 100%;
	      overflow-x: auto;
	      overflow-y: hidden;
	    }
	    mjx-container[display="true"],
	    mjx-container[display="block"] {
	      display: block;
	    }
	    mjx-container[display="false"],
	    mjx-container[display="inline"] {
	      display: inline-block;
	    }

    /* --- NEW: image helpers for memos --- */
    .image-tools {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin: 6px 0;
    }

    .image-tools .btn {
      padding: 4px 8px;
    }

    /* modal for enlarged images */
    #imgModal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 90;
    }

    #imgModal img {
      max-width: 90vw;
      max-height: 90vh;
      border: 4px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      background: var(--card);
    }
  </style>
</head>

<body>
  <div class="progress">
    <div class="progress-bar" id="progressBar"></div>
  </div>
  <div id="hoverRevealZone"></div>

  <header>
    <div class="bar">
      <div class="brand">
        <div class="logo">HT</div>
        <div>
          <div id="appBrandTitle">Hit Thunder Renderer</div>
          <div class="pill" id="appBrandPill">Guide viewer Â· practice mode Â· type tabs</div>
        </div>
      </div>
      <div class="actions">
        <!-- ADD: Guide file loader -->
        <button class="btn" id="guideLoadBtn" title="ê°€ì´ë“œ ë¶ˆëŸ¬ì˜¤ê¸°">ğŸ“‘ ê°€ì´ë“œ</button>
        <button class="btn" id="guideMergeBtn" title="ê°€ì´ë“œ íŒ¨ì¹˜ ë³‘í•©">ğŸ§© ë³‘í•©</button>
        <button class="btn" id="guideMergeBundleBtn" title="ì €ì¥íŒŒì¼(fmm_export.json)+íŒ¨ì¹˜ ë³‘í•© â†’ ìƒˆ ì €ì¥íŒŒì¼ ë‹¤ìš´ë¡œë“œ">ğŸ§© ì €ì¥ë³‘í•©</button>
        <!-- ADD: Guide panel open/close toggle -->
        <button class="btn" id="guideToggleBtn" title="ê°€ì´ë“œ ì…ë ¥ í¼ì¹˜ê¸°/ì ‘ê¸°">âœï¸ í¸ì§‘</button>
        <input type="file" id="guideFile" accept=".txt,.md,.markdown,text/plain" hidden>
        <input type="file" id="guideMergeFile" accept="application/json" hidden>
        <input type="file" id="guideMergeBundleFile" accept="application/json" hidden>
        <input type="file" id="guideMergeBundlePatchFile" accept="application/json" hidden>
        <!-- ADD: Problems load / Problems viewer / Chat / Export-Import -->
        <button class="btn" id="problemsLoadBtn" title="ë¬¸ì œ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°">ğŸ“‚ ë¬¸ì œ</button>
        <button class="btn" id="problemsToggleBtn" title="ìœ í˜• ë¬¸ì œ ë³´ê¸°">ğŸ—‚ ìœ í˜• ë¬¸ì œ</button>
        <button class="btn" id="solveToggleBtn" title="ë¬¸ì œ í’€ì´">ğŸ§© í’€ì´</button>
	        <button class="btn" id="statsToggleBtn" title="í†µê³„ / LLM í˜„í™©">ğŸ“Š í†µê³„</button>
	        <button class="btn" id="llmFillToggleBtn" title="LLMìœ¼ë¡œ ì •ë‹µ ì±„ìš°ê¸°">ğŸ¤– ì±„ìš°ê¸°</button>
	        <button class="btn" id="chatToggleBtn" title="LLM ì±„íŒ…">ğŸ’¬ ì±„íŒ…</button>
	        <!-- ADD: Search window toggle -->
	        <button class="btn" id="searchToggleBtn" title="ê²€ìƒ‰">ğŸ” ê²€ìƒ‰</button>
	        <button class="btn" id="latexToolToggleBtn" title="LaTeX ë„êµ¬">âˆ‘ LaTeX</button>
	        <button class="btn" id="exportBtn" title="ëª¨ë“  ë°ì´í„° ë‚´ë³´ë‚´ê¸°">â­³ Export</button>
	        <button class="btn" id="txtExportBtn" title="ë¬¸ì œ/ì •ë‹µ/í•´ì„¤/ë©”ëª¨ TXT ë‹¤ìš´ë¡œë“œ">â­³ TXT</button>
	        <button class="btn" id="importBtn" title="ê°€ì ¸ì˜¤ê¸°">â­± Import</button>
	        <button class="btn" id="saveManagerToggleBtn" title="ì„¸ì´ë¸Œ ìŠ¬ë¡¯(ì„œë¡œ ì„ì´ì§€ ì•Šê²Œ) ê´€ë¦¬">ğŸ’¾ ì„¸ì´ë¸Œ</button>
	        <button class="btn" id="hardClearBtn" title="ì €ì¥ëœ ëª¨ë“  ë°ì´í„°(ë¬¸ì œë©”ëª¨/ì‹œí—˜ì§€/ê¸°ë¡/ì±„íŒ… ë“±)ë¥¼ ì™„ì „íˆ ì‚­ì œ"
	          style="border-color:var(--danger); color:var(--danger)">ğŸ§¹ Clear</button>
        <!-- ADD: Rescue Center Button -->
        <button class="btn" onclick="openRescueCenter()" title="ë°ì´í„° ë³µêµ¬ ì„¼í„°"
          style="border-color:var(--danger); color:var(--danger)">ğŸš‘ ë³µêµ¬</button>
	        <!-- ADD: Font size and width controls (persisted) -->
	        <button class="btn" id="fontMinus" title="ê¸€ì ì‘ê²Œ">Aâˆ’</button>
	        <button class="btn" id="fontPlus" title="ê¸€ì í¬ê²Œ">A+</button>
	        <button class="btn" id="memoFontMinus" title="ì „ì²´ ë©”ëª¨ ë¯¸ë¦¬ë³´ê¸° ê¸€ì ì‘ê²Œ">Mâˆ’</button>
	        <button class="btn" id="memoFontPlus" title="ì „ì²´ ë©”ëª¨ ë¯¸ë¦¬ë³´ê¸° ê¸€ì í¬ê²Œ">M+</button>
	        <button class="btn" id="widthNarrow" title="ì§€ë©´ ì¢ê²Œ">â†”ï¸âˆ’</button>
	        <button class="btn" id="widthWiden" title="ì§€ë©´ ë„“ê²Œ">â†”ï¸+</button>
        <input type="file" id="problemsFile" accept="application/json" hidden>
        <input type="file" id="importFile" accept="application/json" hidden>
        <!-- ADD: PDF ì €ì¥ ë²„íŠ¼ ì¶”ê°€ -->
	        <button class="btn" id="pdfBtn" title="PDFë¡œ ì €ì¥">ğŸ“„ PDF ì €ì¥</button>
	        <select class="btn" id="langSelect" title="UI language">
	          <option value="en">EN</option>
	          <option value="ko">í•œêµ­ì–´</option>
	        </select>
	        <button class="btn" id="themeToggle" title="í…Œë§ˆ ì „í™˜">ğŸŒ“ í…Œë§ˆ</button>
	        <a class="btn btn-ghost" href="#" id="scrollTop">ë§¨ ìœ„ë¡œ â†‘</a>
      </div>
    </div>
  </header>

  <main>
    <section class="panel">
	      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
	        <div id="guidePanelTitle" style="font-weight:700;">ê°€ì´ë“œ ì…ë ¥</div>
	        <div id="guidePanelHint" class="muted" style="font-size:13px;">êµ¬ë¶„ì ì¤„(=â€¦=)ë¡œ ìœ í˜• ë¶„ë¦¬, ê° ìœ í˜•ì˜ â€œ## Standard Problemâ€ ~ ì²« â€œ---â€ ê¹Œì§€ë¥¼ ë¬¸ì œë¡œ ì¸ì‹
	        </div>
	      </div>
	      <textarea id="source" placeholder="ì—¬ê¸°ì— ê°€ì´ë“œë¥¼ ë¶™ì—¬ë„£ì€ í›„, ì•„ë˜ â€˜ë Œë”ë§â€™ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”."></textarea>
	      <div class="image-tools" style="margin-top:6px;">
	        <button class="btn" id="guideImgUrl">ğŸ–¼ URL</button>
	        <span class="muted" id="guideImgHint">ìŠ¤í¬ë¦°ìƒ· ë¶™ì—¬ë„£ê¸° ì§€ì›</span>
	      </div>
      <div class="toolbar">
        <div class="left">
          <button class="btn-primary" id="renderBtn">ğŸš€ ë Œë”ë§</button>
          <button class="btn" id="clearBtn">ì§€ìš°ê¸°</button>
        </div>
        <div class="right">
          <span class="pill" id="status">ëŒ€ê¸° ì¤‘</span>
        </div>
      </div>
    </section>

    <nav class="types-nav" id="typesNav" style="display:none;"></nav>

    <section id="output"></section>

	    <div class="foot" id="footerText">Made for streamlined study â€¢ Markdown rendered with Marked + sanitized by DOMPurify</div>
  </main>

  <!-- PATCH START: Split Right Sidebar into two separate asides -->
  <aside class="aside right" id="globalAside">
    <div class="sidebar-panel" id="globalMemoPanel">
      <div class="sidebar-head">
        <strong>ğŸ—’ï¸ ê¸€ë¡œë²Œ ë©”ëª¨</strong>
        <div>
          <button class="btn" data-action="min" data-target="#globalMemoPanel">â€”</button>
          <button class="btn" id="globalMemoSave">ì €ì¥</button>
          <button class="btn" id="globalMemoDelete">ì‚­ì œ</button>
        </div>
      </div>
      <div class="sidebar-body">
        <textarea class="memo-textarea" id="globalMemo"></textarea>
      </div>
    </div>
  </aside>

  <aside class="aside right" id="typeAside">
    <div class="sidebar-panel" id="typeMemoPanel">
      <div class="sidebar-head">
        <strong>ğŸ“Œ ìœ í˜• ë©”ëª¨ <span id="typeMemoTitle" class="muted"></span></strong>
        <div>
          <button class="btn" data-action="min" data-target="#typeMemoPanel">â€”</button>
          <button class="btn" id="typeMemoSave">ì €ì¥</button>
          <button class="btn" id="typeMemoDelete">ì‚­ì œ</button>
        </div>
      </div>
      <div class="sidebar-body">
        <textarea class="memo-textarea" id="typeMemo"></textarea>
      </div>
    </div>
  </aside>
  <!-- PATCH END -->

  <!-- ADD: Left Sidebar (Problems for current type) -->
  <aside class="aside left" id="leftAside" style="display:none;">
    <div class="sidebar-panel" id="problemsPanel">
      <div class="sidebar-head">
        <strong>ğŸ—‚ ìœ í˜• ë¬¸ì œ</strong>
        <div>
          <button class="btn" data-action="min" data-target="#problemsPanel">â€”</button>
        </div>
      </div>
      <div class="sidebar-body">
        <div class="muted" id="problemsMeta"></div>
        <div class="problems-list" id="problemsList"></div>
        <div class="hr"></div>
        <div id="problemDetail" class="md"></div>
      </div>
    </div>
  </aside>

  <!-- ADD: Floating Chat window -->
  <div class="window" id="chatWindow" aria-label="LLM Chat">
    <div class="window-head">
      <strong>ğŸ’¬ LLM ì±„íŒ…</strong>
      <div>
        <button class="btn" id="chatRoomsBtn">ë°©</button>
        <button class="btn" id="chatSettingsBtn">ì„¤ì •</button>
        <!-- ADD: raw editor toggle -->
        <button class="btn" id="chatRawBtn">Raw</button>
        <button class="btn" data-action="close" data-target="#chatWindow">âœ•</button>
      </div>
    </div>
    <div class="window-body">
      <div id="chatError" class="error-banner" style="display:none;"></div>
      <!-- ideology: failures should be explicit & vanish on success -->
      <div id="chatMessages"></div>
    </div>
    <div class="window-foot">
      <input class="memo-textarea chat-input" id="chatInput"
        placeholder="ë©”ì‹œì§€ ì…ë ¥â€¦ (<problem>, <standard_problem>, <explanation> ì§€ì›)">
      <button class="btn-primary" id="chatSend">ë³´ë‚´ê¸°</button>
    </div>
  </div>

	  <!-- ADD: Floating Search window -->
	  <div class="window" id="searchWindow" aria-label="Search">
	    <div class="window-head">
	      <strong>ğŸ” ê²€ìƒ‰</strong>
	      <div>
	        <button class="btn" data-action="close" data-target="#searchWindow">âœ•</button>
	      </div>
	    </div>
	    <div class="window-body">
	      <div class="chat-actions" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px;">
	        <input class="memo-textarea" id="searchInput" placeholder="ê²€ìƒ‰ì–´ ì…ë ¥â€¦" style="min-height:36px;flex:2">
	        <button class="btn-primary" id="searchRun">ì°¾ê¸°</button>
	      </div>
		      <div class="chat-actions" style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:8px;">
		        <label><input type="radio" name="searchScope" value="type" checked> í˜„ì¬ ìœ í˜•</label>
		        <label><input type="radio" name="searchScope" value="problems"> í˜„ì¬ ìœ í˜• ë¬¸ì œ</label>
		        <label><input type="radio" name="searchScope" value="allProblems"> ì „ì²´ ë¬¸ì œ(QIDÂ·ë³¸ë¬¸)</label>
		        <label><input type="radio" name="searchScope" value="commentary"> ì „ì²´ í•´ì„¤</label>
		        <label><input type="radio" name="searchScope" value="global"> ì „ì²´(ë©”ëª¨Â·ì±„íŒ…Â·í•´ì„¤Â·ê°€ì´ë“œ)</label>
		      </div>
	      <div class="hr"></div>
	      <div id="searchResults" class="md"></div>
	    </div>
	  </div>

	  <!-- ADD: Floating Similar window -->
	  <div class="window" id="similarWindow" aria-label="Similar Problems" style="display:none;">
	    <div class="window-head">
	      <strong>ğŸ§² ìœ ì‚¬ ë¬¸ì œ</strong>
	      <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
	        <label class="muted" style="display:flex;gap:6px;align-items:center;" title="ìœ ì‚¬ë„ ì„ê³„ì¹˜(ë¬¸ì œ í…ìŠ¤íŠ¸ ê¸°ì¤€ Jaccard)">
	          <span>ì„ê³„ì¹˜</span>
	          <input id="similarThreshold" type="range" min="0.60" max="0.95" step="0.01" value="0.78">
	          <span id="similarThresholdLabel" class="pill">0.78</span>
	        </label>
	        <button class="btn" id="similarRefreshBtn" title="í˜„ì¬ ë¬¸ì œ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ì‹œ ê³„ì‚°">ìƒˆë¡œê³ ì¹¨</button>
	        <button class="btn" id="similarRebuildBtn" title="ì „ì²´ ë¬¸ì œ ìœ ì‚¬ë„ ê·¸ë£¹ì„ ì¬ê³„ì‚°í•˜ê³  ìë™ ê³µìœ ë¥¼ ë‹¤ì‹œ ì ìš©">ìœ ì‚¬ë„ ì¬ê³„ì‚°</button>
	        <button class="btn" data-action="close" data-target="#similarWindow">âœ•</button>
	      </div>
	    </div>
	    <div class="window-body">
	      <div class="muted" id="similarMeta"></div>
	      <div class="panel" style="padding:8px; margin:8px 0;">
	        <div class="muted">ìë™ ê³µìœ (ìœ ì‚¬ë„ ê·¸ë£¹)</div>
	        <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:6px;">
	          <button class="btn" id="similarAutoMemoOn">ë©”ëª¨ ê³µìœ  ON</button>
	          <button class="btn" id="similarAutoMemoOff">ë©”ëª¨ ê³µìœ  OFF</button>
	          <button class="btn" id="similarAutoTagOn">íƒœê·¸ ê³µìœ  ON</button>
	          <button class="btn" id="similarAutoTagOff">íƒœê·¸ ê³µìœ  OFF</button>
	        </div>
	        <div class="muted" style="margin-top:6px;">
	          ë©”ëª¨ ëŒ€í‘œ: <span id="similarMemoOwner"></span> Â· íƒœê·¸ ëŒ€í‘œ: <span id="similarTagOwner"></span>
	        </div>
	      </div>
	      <div class="problems-list" id="similarList" style="max-height:260px;"></div>
	      <div class="hr"></div>
	      <div class="muted">ìœ ì‚¬ ë¬¸ì œ ëª¨ì•„ë³´ê¸°</div>
	      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;">
	        <button class="btn" id="similarCollectBtn">ì´ ìœ ì‚¬êµ° ëª¨ì•„ë³´ê¸°(ë³µê¸°)</button>
	      </div>
	    </div>
	  </div>

	  <!-- ADD: Floating LaTeX tools window -->
	  <div class="window" id="latexToolWindow" aria-label="LaTeX Tools">
	    <div class="window-head">
	      <strong>âˆ‘ LaTeX ë„êµ¬</strong>
	      <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
	        <label class="muted" style="display:flex;gap:6px;align-items:center;" title="ì €ì¥ëœ ë©”ëª¨ í…ìŠ¤íŠ¸ëŠ” ë°”ê¾¸ì§€ ì•Šê³ , í‘œì‹œí•  ë•Œë§Œ 2/3 â†’ \\frac{2}{3} ì²˜ëŸ¼ LaTeXë¡œ ê°ì‹¸ ë Œë”ë§í•©ë‹ˆë‹¤. (ì‚¬ìš©ì ë©”ëª¨/ì±„íŒ…/ë¬¸ì œë©”ëª¨ì—ë§Œ ì ìš©)">
	          <input type="checkbox" id="autoAsciiMathToggle">ë©”ëª¨ ìë™ë³€í™˜(í‘œì‹œ)
	        </label>
	        <button class="btn" id="latexToolConvertSelection" title="ì„ íƒ ë¬¸ìì—´ì„ LaTeXë¡œ ë³€í™˜í•˜ì—¬ ì¹˜í™˜">ì„ íƒ ë³€í™˜</button>
	        <button class="btn" data-action="close" data-target="#latexToolWindow">âœ•</button>
	      </div>
	    </div>
	    <div class="window-body">
	      <div class="chat-actions" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
	        <select class="memo-textarea" id="latexToolDelimiter" style="min-height:36px;max-width:170px;">
	          <option value="$">$...$</option>
	          <option value="\\(">\(...\)</option>
	          <option value="$$">$$...$$</option>
	          <option value="\\[">\[...\]</option>
	        </select>
	        <button class="btn-primary" id="latexToolInsert">ì‚½ì…</button>
	        <button class="btn" id="latexToolClear">ë¹„ìš°ê¸°</button>
	      </div>
	      <textarea class="memo-textarea" id="latexToolInput" placeholder="LaTeX ì…ë ¥"
	        style="min-height:120px; margin-top:8px;"></textarea>
	      <div id="latexToolButtons" class="chat-actions" style="display:flex;gap:6px;flex-wrap:wrap;margin-top:8px;"></div>
	      <div class="hr"></div>
	      <div class="muted">ë¯¸ë¦¬ë³´ê¸°</div>
	      <div id="latexToolPreview" class="md"
	        style="margin-top:6px; padding:8px; border:1px dashed var(--border); border-radius:8px;"></div>
	      <div class="hr"></div>
	      <div class="muted">ê°„ë‹¨ ë³€í™˜ê¸° (ì˜ˆ: 3*3, 4/3, a=sqrt(3))</div>
	      <div class="chat-actions" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;align-items:center;">
	        <input class="memo-textarea" id="asciiMathInput" placeholder="ì‹ ì…ë ¥" style="min-height:36px;flex:2">
	        <button class="btn" id="asciiMathConvert">LaTeXë¡œ</button>
	        <button class="btn-primary" id="asciiMathInsert">ì‚½ì…</button>
	      </div>
	      <div class="muted" id="asciiMathOutput" style="margin-top:6px; word-break:break-all;"></div>
	    </div>
	  </div>

	  <!-- Image modal -->
	  <div id="imgModal"><img alt="í™•ëŒ€ ì´ë¯¸ì§€"></div>

	  <!-- NEW: Problem Solving window -->
	  <div class="window solve-window" id="solveWindow" aria-label="ë¬¸ì œ í’€ì´" style="display:none;">
	    <div class="window-head">
	      <strong>ğŸ§© ë¬¸ì œí’€ì´</strong>
	      <div>
	        <button class="btn" id="solveFontMinus" title="í’€ì´ ê¸€ì ì‘ê²Œ">Aâˆ’</button>
	        <button class="btn" id="solveFontPlus" title="í’€ì´ ê¸€ì í¬ê²Œ">A+</button>
	        <button class="btn" id="solveSessionsBtn" title="ì§„í–‰ì¤‘ ì„¸ì…˜/ì´ì–´í’€ê¸°">ì„¸ì…˜</button>
	        <button class="btn" id="solvePopoutBtn" title="í˜„ì¬ í’€ì´ë¥¼ ìƒˆ ì°½ìœ¼ë¡œ">ìƒˆ ì°½</button>
	        <button class="btn" id="solveCollapseBtn">ì ‘ê¸°</button>
	        <button class="btn" data-action="close" data-target="#solveWindow">âœ•</button>
	      </div>
	    </div>
	    <div class="window-body">
	      <div id="solveSessionsPanel" class="panel" style="padding:8px; margin-bottom:8px; display:none;">
	        <div style="display:flex; justify-content:space-between; align-items:center;">
	          <div class="muted">ì§„í–‰ì¤‘ ì„¸ì…˜</div>
	          <button class="btn" id="solveSessionsClose">ë‹«ê¸°</button>
	        </div>
	        <div id="solveSessionsList" class="problems-list" style="margin-top:6px; max-height:200px;"></div>
	        <div class="muted" style="margin-top:6px;">ì„¸ì…˜ì„ ì—´ì–´ë„ ê¸°ì¡´ í’€ì´ê°€ ì‚¬ë¼ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>
	      </div>
	      <div id="solveSetup" class="solve-setup active">
	        <div id="solveMeta" class="muted"></div>
	        <div class="hr"></div>
	        <div style="display:grid; gap:8px;">
          <label>í’€ ë¬¸ì œ ìˆ˜ <input class="memo-textarea" id="solveCount" type="number" min="1" value="10"
              style="min-height:36px;"></label>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <label><input type="radio" name="solveMode" value="any" checked> ì „ì²´ ëœë¤</label>
            <label><input type="radio" name="solveMode" value="unsolved"> ì•ˆí‘¼ë¬¸ì œ ëœë¤</label>
            <label><input type="radio" name="solveMode" value="after"> ì—°ë„ ì´í›„ ëœë¤</label>
            <label><input type="radio" name="solveMode" value="latest"> ìµœì‹ ìˆœ</label>
            <label><input type="radio" name="solveMode" value="manual"> ì§ì ‘ ì„ íƒ</label>
            <label><input type="radio" name="solveMode" value="tag"> í‘œì‹œëœ ë¬¸ì œ</label>
            <label><input type="radio" name="solveMode" value="wrongHist"> ëˆ„ì  ì˜¤ë‹µ</label>
          </div>
          <div id="solveYearWrap"><input class="memo-textarea" id="solveYear" placeholder="ì˜ˆ: 2018 (ì´í›„ í¬í•¨)"
              style="min-height:36px;"></div>
          <div id="solveTagWrap" style="display:none;">
	            <select class="memo-textarea" id="solveTagSelect" style="min-height:36px;">
	              <option value="ğŸ”’">ğŸ”’ ì ê¸ˆ/ë¯¸ë¶„ë¥˜</option>
	              <option value="âŒ">âŒ í¬ê¸°/ë„ˆë¬´ ì–´ë ¤ì›€</option>
	              <option value="â€¼ï¸">â€¼ï¸ í‹€ë¦° ë¬¸ì œ</option>
	              <option value="â“">â“ ì „í˜€ ëª¨ë¦„</option>
	              <option value="â—">â— ì• ë§¤í•¨</option>
	              <option value="â—">â— ë³´ë¥˜/ì¬ê²€í† </option>
	              <option value="âœ…">âœ… ìˆ™ë‹¬</option>
	            </select>
          </div>
          <div id="solveWrongWrap" style="display:none;">
            <div class="muted">ëˆ„ì  ì˜¤ë‹µ ê¸°ì¤€</div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <select class="memo-textarea" id="solveWrongOp" style="min-height:36px; max-width:110px;">
                <option value=">=">ì´ìƒ</option>
                <option value="==">ì •í™•íˆ</option>
                <option value="<=">ì´í•˜</option>
              </select>
              <input class="memo-textarea" id="solveWrongCount" type="number" min="1" value="1"
                style="min-height:36px; max-width:80px;">
              <span class="muted">ë²ˆ í‹€ë¦° ë¬¸ì œë§Œ</span>
            </div>
          </div>
          <div id="solveManualWrap" style="display:none;">
            <div class="muted">ì²´í¬í•œ ë¬¸ì œë§Œ í’‰ë‹ˆë‹¤.</div>
            <div id="solveManualList" class="problems-list" style="max-height:150px;"></div>
          </div>
          <div class="chat-actions" style="display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn-primary" id="solveStartBtn">ì‹œì‘</button>
            <button class="btn" id="solveFillBtn">LLMìœ¼ë¡œ ì •ë‹µ ì±„ìš°ê¸°</button>
          </div>
        </div>
      </div>

	      <div id="solvePlay" class="solve-play">
		        <div class="solve-progress">
		          <span id="solveProgress"></span>
		          <div class="solve-badges" id="solveBadges"></div>
		          <button class="btn" id="solveCopyUid" title="í˜„ì¬ ë¬¸ì œ UID ë³µì‚¬">UID ë³µì‚¬</button>
		          <button class="btn" id="solveSimilarBtn" title="í˜„ì¬ ë¬¸ì œì™€ ìœ ì‚¬í•œ ë¬¸ì œ ë³´ê¸°">ìœ ì‚¬</button>
		          <button class="btn" id="solveMarkBtn" title="ì´ í…ŒìŠ¤íŠ¸ì—ì„œ ì°ì€ ë¬¸ì œ(ë¶ë§ˆí¬) í† ê¸€">ğŸ“Œ ì°ê¸°</button>
		        </div>
	        <div class="chat-actions" style="display:flex; gap:6px; flex-wrap:wrap;">
	          <span class="muted" id="solveQid"></span>
	          <button class="btn" id="solvePrev">â† ì´ì „</button>
	          <button class="btn" id="solveNext">ë‹¤ìŒ â†’</button>
          <button class="btn" id="solveRevealAll">ì •ë‹µ/í•´ì„¤ ë³´ê¸°</button>
          <button class="btn" id="solveLlmFillOne" title="í˜„ì¬ ë¬¸ì œì˜ ê³µì‹ í•´ì„¤ì„ LLMìœ¼ë¡œ ìƒì„±/ë®ì–´ì“°ê¸°">LLM í•´ì„¤ ì±„ìš°ê¸°</button>
          <button class="btn" id="solveGrade">ìë™ì±„ì </button>
        </div>
	        <div class="chat-actions" style="display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
	          <button class="btn" id="solveTagToggle" title="ë¬¸ì œ í’€ì´ ì¤‘ íƒœê·¸(íŒíŠ¸)ë¥¼ ìˆ¨ê¹ë‹ˆë‹¤.">íƒœê·¸ ë³´ê¸°</button>
	          <div id="solveTagChips" style="display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
	            <span class="muted">íƒœê·¸:</span>
	            <button class="tag-chip" data-tag="ğŸ”’">ğŸ”’</button>
	            <button class="tag-chip" data-tag="âŒ">âŒ</button>
	            <button class="tag-chip" data-tag="â€¼ï¸">â€¼ï¸</button>
	            <button class="tag-chip" data-tag="â“">â“</button>
	            <button class="tag-chip" data-tag="â—">â—</button>
	            <button class="tag-chip" data-tag="â—">â—</button>
	            <button class="tag-chip" data-tag="âœ…">âœ…</button>
	          </div>
	        </div>
		        <div id="solveQuestion" class="md"
		          style="border:1px solid var(--border); border-radius:10px; padding:10px;">
		        </div>
        <div id="solveChoices"></div>
        <div class="panel" style="padding:8px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div>ë¬¸ì œ ë©”ëª¨</div>
            <div class="image-tools">
              <button class="btn" id="solveImgUrl">ğŸ–¼ URL</button>
            </div>
          </div>
          <textarea class="memo-textarea" id="solveMemoArea" placeholder="í’€ì´ ë©”ëª¨ (ì €ì¥ ì „ê¹Œì§€ ì„ì‹œ ì…ë ¥)"></textarea>
          <div class="chat-actions" style="display:flex; gap:6px; margin-top:6px;">
            <button class="btn-primary" id="solveMemoSave">ìƒˆë¡œ ì €ì¥</button>
            <button class="btn" id="solveMemoUpdate">ìˆ˜ì • ì €ì¥</button>
            <button class="btn" id="solveMemoClear">ë¹„ìš°ê¸°</button>
          </div>
          <div class="solve-memo-list" id="solveMemoList"></div>
          <div class="panel" style="padding:8px; margin-top:8px;">
            <div class="muted">ë©”ëª¨ ê³µìœ  (ì‚¬ì‹¤ìƒ ê°™ì€ ë¬¸ì œë¼ë¦¬ ë©”ëª¨ ë™ê¸°í™”)</div>
            <div class="chat-actions" style="display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
              <input class="memo-textarea" id="solveMemoLinkQid" placeholder="ê³µìœ í•  ê¸°ì¤€ ë¬¸ì œ GLOBAL_QID ì…ë ¥"
                style="min-height:32px; flex:1;">
              <button class="btn" id="solveMemoLinkApply">ì´ ë¬¸ì œë¥¼ í•´ë‹¹ ë¬¸ì œì™€ ë©”ëª¨ ê³µìœ </button>
              <button class="btn" id="solveMemoLinkReset">ê³µìœ  í•´ì œ</button>
	            </div>
	            <div class="muted" style="margin-top:4px;">í˜„ì¬ ë©”ëª¨ ê³µìœ  ê¸°ì¤€: <span id="solveMemoLinkCurrent"></span></div>
	            <div class="chat-actions" style="display:flex; gap:6px; flex-wrap:wrap; align-items:center; margin-top:6px;">
	              <button class="btn" id="solveMemoSharePickerToggle" title="í˜„ì¬ ì„¸ì…˜ ë¬¸ì œ ë²ˆí˜¸ íŒ¨ë„ ì—´ê¸°/ë‹«ê¸°">ë²ˆí˜¸ íŒ¨ë„</button>
	              <button class="btn" id="solveMemoShareManagerToggle" title="ë¬¸ì œ ëª©ë¡/ê³µìœ ê·¸ë£¹ íŒ¨ë„ ì—´ê¸°">ê·¸ë£¹ íŒ¨ë„</button>
	              <button class="btn" id="solveMemoSharePickerApply" title="ì„ íƒí•œ ë¬¸ì œë“¤ì„ í•œ ê·¸ë£¹ìœ¼ë¡œ ë©”ëª¨ ê³µìœ (ê²°ì†) ì²˜ë¦¬">ê²°ì†</button>
	              <button class="btn" id="solveMemoSharePickerClear" title="ì„ íƒ í•´ì œ">ì„ íƒ í•´ì œ</button>
	              <span class="muted" style="font-size:12px;">(Q: ì´ë™ / ğŸ”—: ê²°ì† ëŒ€ìƒ ì„ íƒ / â†©: ê³µìœ  í•´ì œ / í˜¸ë²„: ë¯¸ë¦¬ë³´ê¸°)</span>
	            </div>
	            <div id="solveMemoSharePicker" class="solve-quicktap" style="display:none; margin-top:6px;"></div>
	          </div>
		        </div>
	        <div class="panel" id="solveProblemEditPanel" style="padding:8px; margin-top:8px;">
	          <div style="display:flex; justify-content:space-between; align-items:center;">
	            <div class="muted">ë¬¸ì œ ìˆ˜ì •</div>
	            <button class="btn" id="solveProblemEditToggle">âœï¸ ë¬¸ì œ ìˆ˜ì •</button>
	          </div>
	          <div id="solveProblemEditBox" style="display:none;"></div>
	        </div>
	        <div id="solveOfficialWrap" class="panel" style="padding:8px; display:none;">
          <div class="muted">ê³µì‹ ì •ë‹µ/í•´ì„¤ (ì—†ìœ¼ë©´ ì…ë ¥)</div>
          <div id="solveRevealPanel" class="panel" style="padding:8px; display:none;">
            <div class="answer" id="solveRevealAnswer" style="margin-top:0;"></div>
            <div class="md" id="solveRevealExpBox" style="margin-top:8px;"></div>
          </div>
          <input class="memo-textarea" id="solveOfficialAnswer" placeholder="ì˜ˆ: â‘¢ ë˜ëŠ” 3 ë˜ëŠ” A" style="min-height:36px;">
          <textarea class="memo-textarea" id="solveOfficialExplanation" placeholder="ê³µì‹ í•´ì„¤ (ì„ íƒ)"></textarea>
          <div class="chat-actions" style="display:flex; gap:6px;">
            <button class="btn" id="solveSaveOfficial">ê³µì‹ ì •ë‹µ ì €ì¥</button>
          </div>
        </div>
      </div>

      <div id="solveReview" class="solve-review">
        <div id="solveReviewSummary" class="muted"></div>
	        <div class="chat-actions" style="display:flex; gap:8px; flex-wrap:wrap;">
	          <button class="btn" id="solveReviewAll">ì „ì²´ ë¬¸ì œ ë³´ê¸°</button>
	          <button class="btn" id="solveReviewWrong">í‹€ë¦° ë¬¸ì œ ë³´ê¸°</button>
	          <button class="btn" id="solveReviewCorrect">ë§ì€ ë¬¸ì œ ë³´ê¸°</button>
	          <button class="btn" id="solveReviewSimilarBtn">ìœ ì‚¬ ë³´ê¸°</button>
	          <label style="display:flex;align-items:center;gap:4px;" title="ë§ì€ ë¬¸ì œ ì¤‘ âœ…(ìˆ™ë‹¬) íƒœê·¸ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì œì™¸í•©ë‹ˆë‹¤.">
	            <input type="checkbox" id="solveReviewExcludeMastered" checked>
	            <span>ë§ì€ ë¬¸ì œì—ì„œ âœ… ì œì™¸</span>
	          </label>
	          <button class="btn" id="solveRetakeWrong">ì˜¤ë‹µë§Œ ë‹¤ì‹œ í’€ê¸°</button>
	          <button class="btn" id="solveReviewRestore" style="display:none;" title="ì¬ì±„ì (ê°€ìƒ) ê²°ê³¼ë¥¼ ì·¨ì†Œí•˜ê³ , ì²˜ìŒ ì±„ì  ìƒíƒœë¡œ ë˜ëŒë¦½ë‹ˆë‹¤.">ì±„ì  ë˜ëŒì•„ê°€ê¸°</button>
	          <label style="display:flex;align-items:center;gap:4px;">
	            <input type="checkbox" id="solveReviewMarkedOnly">
	            <span>ì°ì€ ë¬¸ì œë§Œ</span>
	          </label>
		          <select class="memo-textarea" id="solveReviewTagFilter" style="min-height:36px; max-width:180px;">
		            <option value="">íƒœê·¸ ì „ì²´</option>
		            <option value="ğŸ”’">ğŸ”’ ë§Œ</option>
		            <option value="âŒ">âŒ ë§Œ</option>
		            <option value="â€¼ï¸">â€¼ï¸ ë§Œ</option>
		            <option value="â“">â“ ë§Œ</option>
		            <option value="â—">â— ë§Œ</option>
		            <option value="â—">â— ë§Œ</option>
		            <option value="âœ…">âœ… ë§Œ</option>
	          </select>
	          <select class="memo-textarea" id="solveBulkTagWrong" style="min-height:36px; flex:1;">
	            <option value="">í‹€ë¦° ë¬¸ì œ íƒœê·¸ ì¼ê´„ ë³€ê²½</option>
	            <option value="ğŸ”’">ğŸ”’</option>
	            <option value="âŒ">âŒ</option>
	            <option value="â€¼ï¸">â€¼ï¸</option>
	            <option value="â“">â“</option>
	            <option value="â—">â—</option>
	            <option value="â—">â—</option>
	            <option value="âœ…">âœ…</option>
	          </select>
		          <select class="memo-textarea" id="solveBulkTagCorrect" style="min-height:36px; flex:1;">
		            <option value="">ë§ì€ ë¬¸ì œ íƒœê·¸ ì¼ê´„ ë³€ê²½</option>
		            <option value="ğŸ”’">ğŸ”’</option>
		            <option value="âŒ">âŒ</option>
		            <option value="â€¼ï¸">â€¼ï¸</option>
		            <option value="â“">â“</option>
		            <option value="â—">â—</option>
		            <option value="â—">â—</option>
		            <option value="âœ…">âœ…</option>
		          </select>
		          <span class="pill" id="solveReviewSelCount">ì„ íƒ 0</span>
		          <button class="btn" id="solveReviewSelectAll">ì„ íƒ ì „ì²´</button>
		          <button class="btn" id="solveReviewSelectNone">ì„ íƒ í•´ì œ</button>
		          <select class="memo-textarea" id="solveReviewBulkTagSelected" style="min-height:36px; max-width:180px;">
		            <option value="">ì„ íƒ ë¬¸ì œ íƒœê·¸ ë³€ê²½</option>
		            <option value="ğŸ”’">ğŸ”’</option>
		            <option value="âŒ">âŒ</option>
		            <option value="â€¼ï¸">â€¼ï¸</option>
		            <option value="â“">â“</option>
		            <option value="â—">â—</option>
		            <option value="â—">â—</option>
		            <option value="âœ…">âœ…</option>
		          </select>
		          <button class="btn" id="solveReviewFixWrongToCorrect" title="ì„ íƒëœ ë¬¸í•­ì„ ì •ë‹µ ì²˜ë¦¬í•˜ì—¬ ëˆ„ì  ì˜¤ë‹µ ì§‘ê³„ì—ì„œ ì œì™¸">ì˜¤ë‹µâ†’ì •ë‹µ</button>
	        </div>
	        <div class="solve-review-list" id="solveReviewList"></div>
	      </div>
    </div>
  </div>

  <!-- NEW: Memo-share manager window (solve-order list + group list) -->
  <div class="window" id="memoShareManagerWindow" aria-label="ë©”ëª¨ ê³µìœ  ê·¸ë£¹" style="display:none;">
    <div class="window-head">
      <strong>ğŸ”— ë©”ëª¨ ê³µìœ  ê·¸ë£¹ í¸ì§‘</strong>
      <div>
        <button class="btn" id="memoShareManagerRefresh">ìƒˆë¡œê³ ì¹¨</button>
        <button class="btn" id="memoShareManagerMakeGroup" title="ì„ íƒí•œ ë¬¸ì œë“¤ì„ í•œ ê·¸ë£¹ìœ¼ë¡œ ê²°ì†(ê¸°ì¤€: ì„ íƒ ì¤‘ ì²« ë¬¸ì œ)">ì„ íƒâ†’ìƒˆ ê·¸ë£¹</button>
        <button class="btn" id="memoShareManagerUnlinkSelected" title="ì„ íƒí•œ ë¬¸ì œë“¤ì˜ ë©”ëª¨ ê³µìœ ë¥¼ í•´ì œ">ì„ íƒ ê³µìœ  í•´ì œ</button>
        <button class="btn" data-action="close" data-target="#memoShareManagerWindow">âœ•</button>
      </div>
    </div>
    <div class="window-body">
      <div class="share-manager">
        <div class="share-manager-col">
          <div class="share-manager-head">
            <strong>ë¬¸ì œ(í’€ì´ ìˆœ)</strong>
            <div class="solve-progress" style="gap:6px;">
              <span class="pill" id="memoShareManagerSelCount">ì„ íƒ 0</span>
              <button class="btn" id="memoShareManagerSelectAll">ì „ì²´</button>
              <button class="btn" id="memoShareManagerSelectNone">í•´ì œ</button>
            </div>
          </div>
          <div class="share-manager-list" id="memoShareManagerProblemList"></div>
        </div>
        <div class="share-manager-col">
          <div class="share-manager-head">
            <strong>ê³µìœ  ê·¸ë£¹</strong>
            <div class="muted" style="font-size:12px;">ê·¸ë£¹ ì¹´ë“œì—ì„œ â€œì„ íƒâ†’ì´ ê·¸ë£¹â€</div>
          </div>
          <div class="share-manager-list" id="memoShareManagerGroupList"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- NEW: Stats window (type overview & LLM ëŒ€ìƒ ì„ íƒ) -->
  <div class="window" id="statsWindow" aria-label="í†µê³„" style="display:none;">
    <div class="window-head">
      <strong>ğŸ“Š í†µê³„ / LLM í˜„í™©</strong>
      <div>
        <button class="btn" id="statsRefreshBtn">ìƒˆë¡œê³ ì¹¨</button>
        <button class="btn" data-action="close" data-target="#statsWindow">âœ•</button>
      </div>
    </div>
    <div class="window-body">
      <div class="chat-actions" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:6px;">
        <label>ìœ í˜• ì •ë ¬
          <select class="memo-textarea" id="statsTypeOrder" style="min-height:32px;max-width:180px;">
            <option value="guide">ê°€ì´ë“œ ìˆœ</option>
            <option value="wrongDesc">ì˜¤ë‹µ ê²½í—˜ ë§ì€ ìˆœ</option>
          </select>
        </label>
      </div>
      <div id="statsOverview" class="md"></div>
	      <div class="hr"></div>
	      <div class="chat-actions" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
	        <label>ìœ í˜•
	          <select class="memo-textarea" id="statsTypeSelect" style="min-height:32px;max-width:220px;"></select>
	        </label>
	        <label title="ì—¬ëŸ¬ í•„í„° ì¡°ê±´ì„ AND/ORë¡œ ê²°í•©í•©ë‹ˆë‹¤. (ê¸°ë³¸: AND)">
	          ê²°í•©
	          <select class="memo-textarea" id="statsJoinMode" style="min-height:32px;max-width:160px;">
	            <option value="and" selected>AND (ëª¨ë‘)</option>
	            <option value="or">OR (í•˜ë‚˜ë¼ë„)</option>
	          </select>
	        </label>
	        <label title="ì„ íƒí•œ íƒœê·¸ëŠ” ORë¡œ ë¬¶ì…ë‹ˆë‹¤.">
	          íƒœê·¸
	          <span style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
	            <select class="memo-textarea" id="statsTagMode" style="min-height:32px;max-width:110px;">
	              <option value="include" selected>í¬í•¨</option>
	              <option value="exclude">ì œì™¸</option>
	            </select>
	            <span id="statsTagChecks" class="tag-checks"></span>
	          </span>
	        </label>
	        <label title="í’€ì´ ê¸°ë¡ ê¸°ë°˜: í•œ ë²ˆì´ë¼ë„ í’€ì–´ë³¸ ê²½í—˜">
	          í’€ì´ ê²½í—˜
	          <select class="memo-textarea" id="statsAttemptedMode" style="min-height:32px;max-width:160px;">
	            <option value="">ì „ì²´</option>
	            <option value="none">í’€ì´ ê²½í—˜ ì—†ìŒ</option>
	            <option value="has">í’€ì´ ê²½í—˜ ìˆìŒ</option>
	          </select>
	        </label>
		        <label title="í’€ì´ ê¸°ë¡ ê¸°ë°˜: ì •ë‹µ ê²½í—˜(ëˆ„ì  ì •ë‹µ íšŸìˆ˜)">
		          ì •ë‹µ ê²½í—˜
		          <select class="memo-textarea" id="statsCorrectMode" style="min-height:32px;max-width:160px;">
		            <option value="">ì „ì²´</option>
		            <option value="none">ì •ë‹µ ê²½í—˜ ì—†ìŒ</option>
		            <option value="has">ì •ë‹µ ê²½í—˜ ìˆìŒ</option>
		          </select>
		        </label>
	        <label>ì—°ë„
	          <span style="display:flex;gap:6px;align-items:center;">
	            <select class="memo-textarea" id="statsYearOp" style="min-height:32px;max-width:110px;">
	              <option value=">=" selected>ì´ìƒ(â‰¥)</option>
              <option value="<=">ì´í•˜(â‰¤)</option>
              <option value="==">í•´ë‹¹ ì—°ë„ë§Œ(=)</option>
            </select>
            <input class="memo-textarea" id="statsYearFilter" placeholder="ì˜ˆ: 2024"
              style="min-height:32px;max-width:90px;">
          </span>
        </label>
        <label>ëˆ„ì  ì˜¤ë‹µ
          <span style="display:flex;gap:6px;align-items:center;">
            <select class="memo-textarea" id="statsWrongOp" style="min-height:32px;max-width:110px;">
              <option value=">=" selected>ì´ìƒ(â‰¥)</option>
              <option value="<=">ì´í•˜(â‰¤)</option>
              <option value="==">ê°™ìŒ(=)</option>
            </select>
            <input class="memo-textarea" id="statsWrongCount" type="number" min="1" placeholder="N"
              style="min-height:32px;max-width:90px;">
          </span>
        </label>
        <label title="í’€ì´ ê¸°ë¡ì—ì„œ â€˜ì°ìŒâ€™ìœ¼ë¡œ í‘œì‹œí•œ íšŸìˆ˜ ê¸°ì¤€">
          ì°ìŒ íšŸìˆ˜
          <span style="display:flex;gap:6px;align-items:center;">
            <select class="memo-textarea" id="statsMarkedOp" style="min-height:32px;max-width:110px;">
              <option value=">=" selected>ì´ìƒ(â‰¥)</option>
              <option value="<=">ì´í•˜(â‰¤)</option>
              <option value="==">ê°™ìŒ(=)</option>
            </select>
            <input class="memo-textarea" id="statsMarkedCount" type="number" min="1" placeholder="N"
              style="min-height:32px;max-width:90px;">
          </span>
        </label>
	        <label>ì›ë³¸ ì‹œí—˜ì§€
	          <select class="memo-textarea" id="statsPaperSelect" style="min-height:32px;max-width:260px;"></select>
	        </label>
	        <button class="btn" id="paperManagerBtn">ì›ë³¸ì‹œí—˜ì§€ ê´€ë¦¬</button>
		        <label style="display:flex;align-items:center;gap:4px;" title="ìœ ì‚¬í•œ ë¬¸ì œ(ë¬¸ì œ í…ìŠ¤íŠ¸ ê¸°ì¤€)ë¥¼ ê°™ì€ ë©ì–´ë¦¬ë¡œ ë¶™ì—¬ì„œ ë³´ì—¬ì¤ë‹ˆë‹¤.">
		          <input type="checkbox" id="statsClusterSimilar" checked>
		          <span>ìœ ì‚¬ë„ ë¬¶ê¸°</span>
		        </label>
	        <button class="btn" id="statsFilterMissing">ë¯¸ì •ë‹µë§Œ</button>
	        <button class="btn" id="statsSelectAllMissing">ì „ì²´ ì„ íƒ</button>
	        <button class="btn" id="statsClearSelection">ì„ íƒ í•´ì œ</button>
	        <button class="btn" id="statsLlmSettings">LLM ì„¤ì •</button>
		        <button class="btn" id="statsCollectFiltered" title="í˜„ì¬ í•„í„° ì¡°ê±´ì˜ ë¬¸ì œë“¤ì„ ëª¨ì•„ í’€ì´ ì„¸ì…˜ìœ¼ë¡œ ì—½ë‹ˆë‹¤.">í•„í„° ëª¨ì•„ë³´ê¸°</button>
	        <button class="btn-primary" id="statsFillSelected">ì„ íƒ LLM ì±„ìš°ê¸°</button>
	      </div>
      <div class="problems-list" id="statsMissingList" style="margin-top:8px; max-height:220px;"></div>
      <div class="hr" style="margin-top:12px;"></div>
      <div class="chat-actions" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:4px;">
        <label>ì‹œí—˜ì§€
          <select class="memo-textarea" id="sheetSelect" style="min-height:32px;max-width:220px;"></select>
        </label>
        <button class="btn" id="sheetNewBtn">ìƒˆ ì‹œí—˜ì§€</button>
        <button class="btn" id="sheetRenameBtn">ì´ë¦„ ë³€ê²½</button>
        <button class="btn" id="sheetDeleteBtn">ì‹œí—˜ì§€ ì‚­ì œ</button>
        <button class="btn" id="sheetAddSelected">ì„ íƒ ë¬¸ì œ ì¶”ê°€</button>
        <button class="btn" id="sheetRemoveSelected">ì„ íƒ ë¬¸ì œ ì œê±°</button>
        <label>í’€ì´ ìˆœì„œ
          <select class="memo-textarea" id="sheetSolveOrder" style="min-height:32px;max-width:190px;">
            <option value="similar" selected>ìœ ì‚¬ë„ ë¬¶ê¸°</option>
            <option value="uid">UID/Që²ˆí˜¸ ìˆœ</option>
            <option value="sheet">ì‹œí—˜ì§€ ì €ì¥ ìˆœ</option>
          </select>
        </label>
        <button class="btn" id="sheetApplyOrderBtn" title="ì„ íƒí•œ í’€ì´ ìˆœì„œë¥¼ ì‹œí—˜ì§€ ìì²´ì— ì ìš©(ì •ë ¬ì„ ì €ì¥)í•©ë‹ˆë‹¤.">ì •ë ¬ ì ìš©</button>
        <button class="btn" id="sheetStartSolve">ì´ ì‹œí—˜ì§€ë§Œ í’€ê¸°</button>
        <label title="ì‹œí—˜ì§€ì—ì„œ ëœë¤ìœ¼ë¡œ Në¬¸í•­ë§Œ ë½‘ì•„ í’‰ë‹ˆë‹¤.">
          ëœë¤ N
          <input class="memo-textarea" id="sheetRandomCount" type="number" min="1" placeholder="N" style="min-height:32px;max-width:90px;">
        </label>
        <button class="btn" id="sheetStartSolveRandom">ëœë¤ N í’€ê¸°</button>
        <label style="display:flex;align-items:center;gap:4px;">
          <input type="checkbox" id="sheetWrongOnly">
          <span>í‹€ë¦° ë¬¸ì œë§Œ</span>
        </label>
      </div>
	      <div id="sheetInfo" class="muted" style="margin-top:4px;"></div>
	      <div class="problems-list" id="sheetProblemList" style="margin-top:4px; max-height:150px;"></div>
	      <div class="panel" id="sheetProblemHistoryPanel" style="margin-top:8px; display:none; max-height:180px; overflow:auto;">
	        <div class="muted" id="sheetProblemHistoryTitle">ë¬¸ì œ í’€ì´ ê¸°ë¡</div>
	        <div id="sheetProblemHistoryList" style="margin-top:6px;"></div>
	      </div>
	      <div class="panel" id="sheetHistoryPanel" style="margin-top:8px; max-height:140px; overflow:auto;">
	        <div class="muted" id="sheetHistoryEmpty">ì´ ì‹œí—˜ì§€ë¡œ í‘¼ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>
	        <div id="sheetHistoryList"></div>
	      </div>
    </div>
  </div>

  <!-- NEW: LLM fill window (detached from stats) -->
  <div class="window" id="llmFillWindow" aria-label="LLM ì •ë‹µ ì±„ìš°ê¸°" style="display:none;">
    <div class="window-head">
      <strong>ğŸ¤– LLM ì •ë‹µ ì±„ìš°ê¸°</strong>
      <div>
        <button class="btn" id="llmFillCloseBtn">âœ•</button>
      </div>
    </div>
    <div class="window-body">
      <div class="panel" id="llmFillSelectPanel" style="margin-bottom:8px;">
        <div class="muted" style="margin-bottom:6px;">LLM ëŒ€ìƒ ì„ íƒ</div>
        <div class="chat-actions" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
          <label>ëŒ€ìƒ
            <select class="memo-textarea" id="llmFillMode" style="min-height:32px;max-width:180px;">
              <option value="solve">í˜„ì¬ í’€ì´ ì„¸ì…˜</option>
              <option value="sheet">ì‹œí—˜ì§€</option>
              <option value="all">ì „ì²´ ë¬¸ì œ</option>
            </select>
          </label>
          <label id="llmFillSheetWrap" style="display:none;">ì‹œí—˜ì§€
            <select class="memo-textarea" id="llmFillSheetSelect" style="min-height:32px;max-width:220px;"></select>
          </label>
          <label id="llmFillTypeWrap" style="display:none;">ìœ í˜•
            <select class="memo-textarea" id="llmFillTypeSelect" style="min-height:32px;max-width:220px;"></select>
          </label>
          <label id="llmFillTagWrap" style="display:none;">íƒœê·¸
	            <select class="memo-textarea" id="llmFillTagFilter" style="min-height:32px;max-width:200px;">
	              <option value="">íƒœê·¸ ì „ì²´</option>
	              <option value="ğŸ”’">ğŸ”’ ì ê¸ˆ/ë¯¸ë¶„ë¥˜</option>
	              <option value="âŒ">âŒ í¬ê¸°/ë„ˆë¬´ ì–´ë ¤ì›€</option>
	              <option value="â€¼ï¸">â€¼ï¸ í‹€ë¦° ë¬¸ì œ</option>
	              <option value="â“">â“ ì „í˜€ ëª¨ë¦„</option>
	              <option value="â—">â— ì• ë§¤í•¨</option>
	              <option value="â—">â— ë³´ë¥˜/ì¬ê²€í† </option>
	              <option value="âœ…">âœ… ìˆ™ë‹¬</option>
	            </select>
          </label>
          <label id="llmFillYearWrap" style="display:none;">ì—°ë„
            <span style="display:flex;gap:6px;align-items:center;">
              <select class="memo-textarea" id="llmFillYearOp" style="min-height:32px;max-width:110px;">
                <option value=">=" selected>ì´ìƒ(â‰¥)</option>
                <option value="<=">ì´í•˜(â‰¤)</option>
                <option value="==">í•´ë‹¹ ì—°ë„ë§Œ(=)</option>
              </select>
              <input class="memo-textarea" id="llmFillYearFilter" placeholder="ì˜ˆ: 2024"
                style="min-height:32px;max-width:90px;">
            </span>
          </label>
          <label id="llmFillPaperWrap" style="display:none;">ì›ë³¸ ì‹œí—˜ì§€
            <select class="memo-textarea" id="llmFillPaperSelect" style="min-height:32px;max-width:260px;"></select>
          </label>
          <button class="btn" id="llmFillFilterMissing">ë¯¸ì •ë‹µë§Œ</button>
          <button class="btn" id="llmFillSelectAll">ì „ì²´ ì„ íƒ</button>
          <button class="btn" id="llmFillClearSelection">ì„ íƒ í•´ì œ</button>
        </div>
        <div class="problems-list" id="llmFillList" style="margin-top:8px; max-height:220px;"></div>
      </div>
	      <div id="solveLLMPanel" class="panel">
	        <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;"><strong>LLM ì •ë‹µ ì±„ìš°ê¸° ì„¤ì •</strong></div>
	        <div style="display:grid;gap:6px;">
	          <input class="memo-textarea" id="ansEndpoint" placeholder="Endpoint URL">
	          <input class="memo-textarea" id="ansProxyUrl" placeholder="Proxy URL (ì˜µì…˜) â€” cf_proxy.py ê°™ì€ CORS í”„ë¡ì‹œ">
	          <textarea class="memo-textarea" id="ansApiKey" placeholder="API Keys (ì˜µì…˜) â€” í•œ ì¤„ì— 1ê°œ ë˜ëŠ” ì‰¼í‘œë¡œ êµ¬ë¶„"></textarea>
	          <input class="memo-textarea" id="ansModel" placeholder="Model (ì˜µì…˜)">
	          <input class="memo-textarea" id="ansBatch" placeholder="í•œ í˜¸ì¶œë‹¹ ë¬¸ì œ ìˆ˜" value="3">
		          <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
		            <label style="display:flex;gap:6px;align-items:center;"><input type="checkbox" id="ansUseTypeGuide" checked>ìœ í˜• ê°€ì´ë“œ ì²¨ë¶€</label>
		            <label style="display:flex;gap:6px;align-items:center;"><input type="checkbox" id="ansUseProblemMemos">ë¬¸ì œ ë©”ëª¨ ì²¨ë¶€</label>
		            <label style="display:flex;gap:6px;align-items:center;"><input type="checkbox" id="ansMemoEval">ë©”ëª¨ í‰ê°€ ì¶”ê°€</label>
		            <label style="display:flex;gap:6px;align-items:center;" title="system ì—­í• ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ì—”ë“œí¬ì¸íŠ¸(í”„ë¡ì‹œ/í˜¸í™˜ API)ìš©: system ë©”ì‹œì§€ë¥¼ ì²« user ë©”ì‹œì§€ë¡œ í•©ì¹©ë‹ˆë‹¤."><input type="checkbox" id="ansBypassSystemRole">system bypass</label>
		          </div>
	          <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
	            <label style="display:flex;gap:6px;align-items:center;">ë©”ëª¨í‰ê°€ ëª¨ë“œ
	              <select class="memo-textarea" id="ansMemoEvalMode" style="min-height:32px;max-width:220px;">
	                <option value="repOrLatest">ëŒ€í‘œ(ì—†ìœ¼ë©´ ìµœê·¼)</option>
	                <option value="rep">ëŒ€í‘œ ë©”ëª¨ë§Œ</option>
	                <option value="latest">ìµœê·¼ ë©”ëª¨ë§Œ</option>
	                <option value="session">ì´ë²ˆ ì‹œí–‰ ë©”ëª¨ë§Œ</option>
	                <option value="all">ëª¨ë“  ë©”ëª¨</option>
	              </select>
	            </label>
	            <label style="display:flex;gap:6px;align-items:center;"><input type="checkbox" id="ansOverwriteExplanation">ê¸°ì¡´ í•´ì„¤ ë®ì–´ì“°ê¸°</label>
	          </div>
	          <div style="display:flex;gap:8px;flex-wrap:wrap;">
	            <button class="btn-primary" id="ansSave">ì €ì¥</button>
	            <button class="btn" id="ansRun">ì´ ì„¤ì •ìœ¼ë¡œ ì±„ìš°ê¸°</button>
	            <button class="btn" id="ansStop">ì¤‘ë‹¨</button>
	            <button class="btn" id="ansClose">ë‹«ê¸°</button>
          </div>
          <div class="muted" id="ansStatus"></div>
          <div class="muted" id="ansProgress" style="margin-top:4px;"></div>
          <div id="ansLogBox" class="panel" style="margin-top:4px;max-height:160px;overflow:auto;font-size:12px;"></div>
        </div>
      </div>
    </div>
	  </div>

	  <!-- NEW: Paper manager window -->
	  <div class="window" id="paperManagerWindow" aria-label="ì›ë³¸ ì‹œí—˜ì§€ ê´€ë¦¬" style="display:none;">
	    <div class="window-head">
	      <strong>ğŸ“„ ì›ë³¸ ì‹œí—˜ì§€ ê´€ë¦¬</strong>
	      <div>
	        <button class="btn" id="paperManagerCloseBtn">âœ•</button>
	      </div>
	    </div>
	    <div class="window-body">
	      <div class="muted" style="margin-bottom:6px;">
	        ì„œë¡œ ë‹¤ë¥¸ íŒŒì¼ëª…ìœ¼ë¡œ ë“¤ì–´ì˜¨ ë¬¸ì œë„ ë‚´ë¶€ ì›ë³¸ì‹œí—˜ì§€ IDë¡œ ë¬¶ì–´ ê´€ë¦¬í•©ë‹ˆë‹¤. (í–¥í›„ Import/ë³‘í•©ì—ì„œë„ ì¬ë¶„ë¦¬ ë°©ì§€)
	      </div>
	      <div class="chat-actions" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px;">
	        <button class="btn" id="paperManagerRefreshBtn">ìƒˆë¡œê³ ì¹¨</button>
	        <button class="btn" id="paperManagerRenameBtn">ì´ë¦„ ì¬ì •ì˜</button>
	        <button class="btn" id="paperManagerMergeBtn">ì„ íƒ ë³‘í•©</button>
	        <button class="btn" id="paperManagerSplitBtn">ì„ íƒ ë¶„ë¦¬</button>
	      </div>
	      <div class="panel" style="padding:8px; margin-bottom:8px;">
	        <div class="muted">ì›ë³¸ ì‹œí—˜ì§€ ëª©ë¡</div>
	        <div class="problems-list" id="paperManagerList" style="margin-top:6px; max-height:240px;"></div>
	      </div>
	      <div class="panel" style="padding:8px;">
	        <div class="muted">ì„ íƒí•œ ì‹œí—˜ì§€ì˜ ì›ë³¸/ë³„ì¹­ (ë¶„ë¦¬ ì‹œ ì„ íƒ)</div>
	        <div id="paperManagerAliasList" style="margin-top:6px;"></div>
	      </div>
	    </div>
	  </div>

	  <!-- NEW: Save manager window (multi-save slots, isolated) -->
	  <div class="window" id="saveManagerWindow" aria-label="ì„¸ì´ë¸Œ ìŠ¬ë¡¯" style="display:none;">
	    <div class="window-head">
	      <strong>ğŸ’¾ ì„¸ì´ë¸Œ ìŠ¬ë¡¯</strong>
	      <div>
	        <button class="btn" id="saveManagerCloseBtn">âœ•</button>
	      </div>
	    </div>
	    <div class="window-body">
	      <div class="muted" id="saveManagerMeta"></div>
	      <div class="chat-actions" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin:8px 0;">
	        <button class="btn" id="saveSlotNewBtn">ìƒˆ ìŠ¬ë¡¯</button>
	        <button class="btn" id="saveSlotSaveBtn" title="í˜„ì¬ ìƒíƒœë¥¼ ì„ íƒëœ ìŠ¬ë¡¯ì— ì €ì¥">í˜„ì¬ ì €ì¥</button>
	        <button class="btn" id="saveSlotSwitchBtn" title="ì„ íƒëœ ìŠ¬ë¡¯ìœ¼ë¡œ ì „í™˜ (í˜„ì¬ ë°ì´í„°ëŠ” ë®ì–´ì¨ì§‘ë‹ˆë‹¤)">ì „í™˜</button>
	        <button class="btn" id="saveSlotRenameBtn">ì´ë¦„ ë³€ê²½</button>
	        <button class="btn" id="saveSlotDeleteBtn" style="border-color:var(--danger); color:var(--danger)">ìŠ¬ë¡¯ ì‚­ì œ</button>
	      </div>
	      <div class="problems-list" id="saveManagerList" style="max-height:260px;"></div>
	      <div class="muted" style="margin-top:8px;">
	        - ìŠ¬ë¡¯ ì „í™˜ ì‹œ, í˜„ì¬ ë¸Œë¼ìš°ì € ì €ì¥ì†Œì˜ `fmm_*` ë°ì´í„°ëŠ” ê¹¨ë—ì´ ë¹„ìš´ ë’¤ ì„ íƒ ìŠ¬ë¡¯ì„ ë¡œë“œí•©ë‹ˆë‹¤. (ì„ì„ ë°©ì§€)<br>
	        - ë‚´ë³´ë‚´ê¸°(Export)ëŠ” í˜„ì¬ ë¡œë“œëœ ìŠ¬ë¡¯ë§Œ ëŒ€ìƒìœ¼ë¡œ í•©ë‹ˆë‹¤.
	      </div>
	    </div>
	  </div>

		  <script>
		    // ADD: LaTeX Sanitization (Request #17)
		    // Only touches content inside math delimiters and never re-escapes already-escaped commands.
		    // ADD: Wrap Korean text inside math with \text{...} (render-time only)
	    // Ideology: keep saved source intact; fix typography at render time.
	    // Wrap human-language labels used as subscripts/superscripts (render-time only).
	    // Examples:
	    // - L_{ê°€ë™} -> L_{\text{ê°€ë™}}
	    // - x_{ref}  -> x_{\text{ref}}
	    function wrapTextLabelsInSubSupMathText(content) {
	      const s = String(content || '');
	      if (!s) return s;
	      if (s.indexOf('_') === -1 && s.indexOf('^') === -1) return s;
	
	      const isEscapedAt = (idx) => {
	        let n = 0;
	        for (let j = idx - 1; j >= 0 && s[j] === '\\'; j--) n++;
	        return (n % 2) === 1;
	      };
	      const readBalanced = (startIdx) => {
	        if (s[startIdx] !== '{' || isEscapedAt(startIdx)) return null;
	        let depth = 1;
	        let i = startIdx + 1;
	        while (i < s.length) {
	          const ch = s[i];
	          if (ch === '{' && !isEscapedAt(i)) depth++;
	          else if (ch === '}' && !isEscapedAt(i)) depth--;
	          if (depth === 0) {
	            return { inner: s.slice(startIdx + 1, i), end: i };
	          }
	          i++;
	        }
	        return null;
	      };
	      const containsCjkOrHangul = (t) => /[\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]/.test(t);
	      const shouldWrap = (inner) => {
	        const t = String(inner || '').trim();
	        if (!t) return false;
	        if (/^\\text\s*\{/.test(t)) return false;
	        if (t.includes('\\')) return false; // avoid touching commands/macros
	        if (/^\d+$/.test(t)) return false;
	        if (containsCjkOrHangul(t)) return true;
	        // Latin label heuristic: avoid wrapping a single-letter index like i/j/k.
	        if (/[A-Za-z]/.test(t) && t.length > 1) return true;
	        return false;
	      };
	
	      let out = '';
	      let i = 0;
	      while (i < s.length) {
	        const ch = s[i];
	        if ((ch === '_' || ch === '^') && !isEscapedAt(i)) {
	          out += ch;
	          i++;
	          if (i >= s.length) break;
	          if (s[i] === '{' && !isEscapedAt(i)) {
	            const parsed = readBalanced(i);
	            if (!parsed) { out += '{'; continue; }
	            const inner = parsed.inner ?? '';
	            if (shouldWrap(inner)) {
	              const trimmed = String(inner).trim();
	              out += `{\\text{${trimmed}}}`;
	            } else {
	              out += `{${inner}}`;
	            }
	            i = parsed.end + 1;
	            continue;
	          }
	          // single-token sub/sup (leave as-is)
	          out += s[i];
	          i++;
	          continue;
	        }
	        out += ch;
	        i++;
	      }
	      return out;
	    }
	
	    function wrapTextLabelsInMathDelimiters(text) {
	      if (!text || typeof text !== 'string') return text || '';
	      // quick checks
	      if (text.indexOf('_') === -1 && text.indexOf('^') === -1) return text;
	      if (text.indexOf('$') === -1 && text.indexOf('\\(') === -1 && text.indexOf('\\[') === -1) return text;
	      let out = String(text);
	      out = out.replace(/\$\$([\s\S]*?)\$\$/g, (m, c) => `$$${wrapTextLabelsInSubSupMathText(c)}$$`);
	      out = out.replace(/(?<!\$)\$([^$]+?)\$(?!\$)/g, (m, c) => `$${wrapTextLabelsInSubSupMathText(c)}$`);
	      out = out.replace(/\\\[([\s\S]*?)\\\]/g, (m, c) => `\\[${wrapTextLabelsInSubSupMathText(c)}\\]`);
	      out = out.replace(/\\\(([\s\S]*?)\\\)/g, (m, c) => `\\(${wrapTextLabelsInSubSupMathText(c)}\\)`);
	      return out;
	    }

		    function wrapKoreanInMathText(content) {
		      const s = String(content || '');
		      if (!s) return s;
	      // Fast path (Hangul + CJK + Kana)
	      const LOCALE_RE = /[\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]/;
	      if (!LOCALE_RE.test(s)) return s;
	
	      const isLocaleChar = (ch) => LOCALE_RE.test(ch);
	      const isEscapedAt = (idx) => {
	        // true if char at idx is escaped by an odd number of backslashes immediately before it
	        let n = 0;
	        for (let j = idx - 1; j >= 0 && s[j] === '\\'; j--) n++;
        return (n % 2) === 1;
      };

      let out = '';
      let i = 0;
      let braceDepth = 0;
      const textDepthStack = [];
      const inText = () => textDepthStack.length > 0;

      while (i < s.length) {
        const ch = s[i];

	        // Detect \text{...} or \\text{...} to avoid double-wrapping inside it.
	        if (ch === '\\') {
	          let j = i;
	          while (j < s.length && s[j] === '\\') j++;
	          let k = j;
          while (k < s.length && /[A-Za-z]/.test(s[k])) k++;
          const cmd = s.slice(j, k);
          out += s.slice(i, k);
          i = k;

          if (cmd === 'text') {
            while (i < s.length && /\s/.test(s[i])) { out += s[i]; i++; }
            if (s[i] === '{' && !isEscapedAt(i)) {
              out += '{';
              braceDepth++;
              textDepthStack.push(braceDepth);
              i++;
            }
          }
          continue;
        }

        if (ch === '{' && !isEscapedAt(i)) {
          braceDepth++;
          out += ch;
          i++;
          continue;
        }
        if (ch === '}' && !isEscapedAt(i)) {
          braceDepth--;
          out += ch;
          i++;
          while (textDepthStack.length && braceDepth < textDepthStack[textDepthStack.length - 1]) {
            textDepthStack.pop();
          }
          continue;
	        }
	
	        if (!inText() && isLocaleChar(ch)) {
	          let j = i;
	          let run = '';
	          while (j < s.length && isLocaleChar(s[j])) { run += s[j]; j++; }
	          out += `\\text{${run}}`;
	          i = j;
	          continue;
	        }

        out += ch;
        i++;
      }

      return out;
    }

	    // Wrap Korean only inside math delimiters, without adding extra escaping.
	    // This is used right before MathJax typesets HTML text nodes (markdown may not be involved).
	    function wrapKoreanInMathDelimiters(text) {
	      if (!text || typeof text !== 'string') return text || '';
	      const LOCALE_RE = /[\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]/;
	      if (!LOCALE_RE.test(text)) return text;
	      // quick delimiter check
	      if (text.indexOf('$') === -1 && text.indexOf('\\(') === -1 && text.indexOf('\\[') === -1) return text;

      let out = String(text);
      // $$...$$ (display)
      out = out.replace(/\$\$([\s\S]*?)\$\$/g, (m, c) => `$$${wrapKoreanInMathText(c)}$$`);
      // $...$ (inline) - avoid matching $$ blocks
      out = out.replace(/(?<!\$)\$([^$]+?)\$(?!\$)/g, (m, c) => `$${wrapKoreanInMathText(c)}$`);
      // \[...\] (display)
      out = out.replace(/\\\[([\s\S]*?)\\\]/g, (m, c) => `\\[${wrapKoreanInMathText(c)}\\]`);
      // \(...\) (inline)
      out = out.replace(/\\\(([\s\S]*?)\\\)/g, (m, c) => `\\(${wrapKoreanInMathText(c)}\\)`);
      return out;
    }

		    function escapeLatexContent(content) {
		      let out = String(content || '');
		      // First: wrap human-language labels used in sub/superscripts with \text{...} (render-time only).
		      out = wrapTextLabelsInSubSupMathText(out);
		      // First: wrap Hangul inside math with \text{...} so MathJax uses mtext (better Korean fonts).
		      out = wrapKoreanInMathText(out);
		      // Preserve LaTeX commands for markdown: \cmd or \% -> \\cmd / \\%
		      out = out.replace(/(?<!\\)\\([a-zA-Z]+|[%{}&#_|])/g, '\\\\$1');
	      // Pipe conflict inside markdown tables: | -> \| (escape for table parsing; keeps TeX as | after markdown)
	      out = out.replace(/(?<!\\)\|/g, '\\|');
	      return out;
	    }

		    function sanitizeLatex(text) {
		      if (!text || typeof text !== 'string') return text || '';
		      let out = String(text);
		      // $$...$$ (display)
		      out = out.replace(/\$\$([\s\S]*?)\$\$/g, (m, c) => `$$${escapeLatexContent(c)}$$`);
	      // $...$ (inline) - avoid matching $$ blocks
	      out = out.replace(/(?<!\$)\$([^$]+?)\$(?!\$)/g, (m, c) => `$${escapeLatexContent(c)}$`);
	      // \[...\] (display)
	      // NOTE: delimiters must survive markdown parsing; escape the delimiter backslashes too.
	      out = out.replace(/\\\[([\s\S]*?)\\\]/g, (m, c) => `\\\\[${escapeLatexContent(c)}\\\\]`);
	      // \(...\) (inline)
	      out = out.replace(/\\\(([\s\S]*?)\\\)/g, (m, c) => `\\\\(${escapeLatexContent(c)}\\\\)`);
		      return out;
		    }

	    // FIX: Markdown tables should not break on literal pipes (e.g. |r| absolute value) inside cells.
	    // Render-only: this runs right before markdown parsing and does not mutate stored raw text.
	    function escapePipesInMarkdownTables(text) {
	      if (!text || typeof text !== 'string') return text || '';
	      if (text.indexOf('|') === -1) return text;

	      const lines = String(text).split('\n');
	      const out = [];
	      let inFence = false;
	      let fenceMarker = '';

	      const fenceRe = /^\s*(```+|~~~+)/;
	      const isTableSepLine = (line) => /^\s*\|?\s*:?-+:?\s*(\|\s*:?-+:?\s*)+\|?\s*$/.test(String(line || ''));
	      const tableColCount = (sepLine) => {
	        const s = String(sepLine || '').trim().replace(/^\|/, '').replace(/\|$/, '');
	        const parts = s.split('|').map(p => p.trim());
	        let count = 0;
	        parts.forEach(p => { if (p && /^:?-+:?$/.test(p)) count++; });
	        return count;
	      };

	      function unescapedPipePositions(line) {
	        const pos = [];
	        for (let i = 0; i < line.length; i++) {
	          if (line[i] !== '|') continue;
	          if (i > 0 && line[i - 1] === '\\') continue;
	          pos.push(i);
	        }
	        return pos;
	      }

	      function pipeScore(line, pos) {
	        const before = pos > 0 ? line[pos - 1] : '';
	        const after = pos < line.length - 1 ? line[pos + 1] : '';
	        const beforeWs = !before || /\s/.test(before);
	        const afterWs = !after || /\s/.test(after);
	        let score = 0;
	        if (beforeWs) score += 1;
	        if (afterWs) score += 1;
	        if (line.slice(0, pos).trim() === '') score += 4;
	        if (line.slice(pos + 1).trim() === '') score += 4;
	        if (!beforeWs && !afterWs) score -= 1;
	        return score;
	      }

	      function selectKeepIndices(scores, keepCount, forced) {
	        const m = scores.length;
	        const forcedSet = new Set(forced || []);
	        if (forcedSet.size > keepCount) return null;
	        const need = keepCount - forcedSet.size;
	        if (need <= 0) return forcedSet;
	        const cand = [];
	        for (let i = 0; i < m; i++) if (!forcedSet.has(i)) cand.push(i);
	        if (cand.length < need) return null;

	        const dp = Array.from({ length: cand.length + 1 }, () => new Array(need + 1).fill(-1e15));
	        const choice = Array.from({ length: cand.length + 1 }, () => new Array(need + 1).fill(false));
	        dp[0][0] = 0;
	        for (let i = 0; i < cand.length; i++) {
	          const idx = cand[i];
	          const sc = scores[idx];
	          for (let j = 0; j <= need; j++) {
	            // skip
	            if (dp[i][j] > dp[i + 1][j]) {
	              dp[i + 1][j] = dp[i][j];
	              choice[i + 1][j] = false;
	            }
	            // take
	            if (j > 0 && dp[i][j - 1] + sc > dp[i + 1][j]) {
	              dp[i + 1][j] = dp[i][j - 1] + sc;
	              choice[i + 1][j] = true;
	            }
	          }
	        }
	        if (dp[cand.length][need] <= -1e14) return null;
	        let j = need;
	        for (let i = cand.length; i >= 1; i--) {
	          if (choice[i][j]) {
	            forcedSet.add(cand[i - 1]);
	            j--;
	          }
	        }
	        return forcedSet;
	      }

	      function escapeRowPipes(line, colCount) {
	        if (!line || line.indexOf('|') === -1) return line;
	        const rowLeading = /^\s*\|/.test(line);
	        const rowTrailing = /\|\s*$/.test(line);
	        const expected = (rowLeading ? 1 : 0) + (rowTrailing ? 1 : 0) + Math.max(0, colCount - 1);
	        const pipePos = unescapedPipePositions(line);
	        if (pipePos.length <= expected) return line;

	        const scores = pipePos.map(p => pipeScore(line, p));
	        const forced = [];
	        if (rowLeading) forced.push(0);
	        if (rowTrailing) forced.push(pipePos.length - 1);
	        const keep = selectKeepIndices(scores, expected, forced);
	        if (!keep) return line;

	        let outLine = '';
	        let pIdx = 0;
	        for (let i = 0; i < line.length; i++) {
	          const ch = line[i];
	          if (ch === '|' && !(i > 0 && line[i - 1] === '\\')) {
	            outLine += keep.has(pIdx) ? '|' : '\\|';
	            pIdx++;
	          } else {
	            outLine += ch;
	          }
	        }
	        return outLine;
	      }

	      for (let i = 0; i < lines.length; i++) {
	        const line = lines[i];
	        const fm = line.match(fenceRe);
	        if (fm) {
	          const marker = fm[1];
	          if (!inFence) { inFence = true; fenceMarker = marker[0]; }
	          else if (marker[0] === fenceMarker) { inFence = false; fenceMarker = ''; }
	          out.push(line);
	          continue;
	        }
	        if (inFence) { out.push(line); continue; }

	        const sep = (i + 1 < lines.length) ? lines[i + 1] : '';
	        if (line.indexOf('|') !== -1 && sep && isTableSepLine(sep)) {
	          const cols = tableColCount(sep);
	          if (!cols) { out.push(line); continue; }
	          out.push(escapeRowPipes(line, cols));
	          out.push(sep);
	          i += 1;
	          // body rows
	          while (i + 1 < lines.length) {
	            const row = lines[i + 1];
	            if (!row || /^\s*$/.test(row)) break;
	            if (row.match(fenceRe)) break;
	            if (row.indexOf('|') === -1) break;
	            out.push(escapeRowPipes(row, cols));
	            i += 1;
	          }
	          continue;
	        }
	        out.push(line);
	      }
	      return out.join('\n');
	    }

	    // FIX: CommonMark flanking rule â€” bold ending with punctuation fails when followed by a word char.
		    // Example: **(í…ŒìŠ¤íŠ¸)**ì…ë‹ˆë‹¤ -> **(í…ŒìŠ¤íŠ¸)** ì…ë‹ˆë‹¤
		    // NOTE: Render-time fix only (raw source stays unchanged).
    function fixCommonMarkBoldFlanking(text) {
      if (!text || typeof text !== 'string') return text || '';
      if (text.indexOf('**') === -1 && text.indexOf('__') === -1) return text;
      // Fast path: ensure a space after any bold span when followed by a word char.
      text = text
        .replace(/(^|[^0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_*_])\*\*(?=\S)((?:(?!\*\*)[^\n])*?)\*\*(?=[0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_])/g, '$1**$2** ')
        .replace(/(^|[^0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_*_])__(?=\S)((?:(?!__)[^\n])*?)__(?=[0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_])/g, '$1__$2__ ');
      // Only touch intended bold spans that end with punctuation and are immediately followed by a letter/number.
      try {
        return text
          .replace(/(^|[^\p{L}\p{N}_*_])\*\*(?=\S)((?:(?!\*\*)[^\n])*?[\p{P}\p{S}])\*\*(?=[\p{L}\p{N}_])/gu, '$1**$2** ')
          .replace(/(^|[^\p{L}\p{N}_*_])__(?=\S)((?:(?!__)[^\n])*?[\p{P}\p{S}])__(?=[\p{L}\p{N}_])/gu, '$1__$2__ ')
          .replace(/(^|[^\p{L}\p{N}_*_])\*\*(?=\S)((?:(?!\*\*)[^\n])*?)\*\*(?=[\p{L}\p{N}_])/gu, '$1**$2** ')
          .replace(/(^|[^\p{L}\p{N}_*_])__(?=\S)((?:(?!__)[^\n])*?)__(?=[\p{L}\p{N}_])/gu, '$1__$2__ ');
      } catch {
        // Fallback for engines without Unicode property escapes.
        return text
          .replace(/(^|[^0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_*_])\*\*(?=\S)((?:(?!\*\*)[^\n])*?[\)\]\}\.,!?:;â€¦Â·%+\-=\<>])\*\*(?=[0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_])/g, '$1**$2** ')
          .replace(/(^|[^0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_*_])__(?=\S)((?:(?!__)[^\n])*?[\)\]\}\.,!?:;â€¦Â·%+\-=\<>])__(?=[0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_])/g, '$1__$2__ ')
          .replace(/(^|[^0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_*_])\*\*(?=\S)((?:(?!\*\*)[^\n])*?)\*\*(?=[0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_])/g, '$1**$2** ')
          .replace(/(^|[^0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_*_])__(?=\S)((?:(?!__)[^\n])*?)__(?=[0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_])/g, '$1__$2__ ');
      }
    }

		    // FIX: Convert "space-looking" Unicode spaces after **/__ into a real ASCII space.
		    // This avoids CommonMark emphasis edge-cases caused by NBSP/ideographic spaces, without mutating stored raw text.
		    function normalizeFakeSpacesAfterBoldMarkers(text) {
		      if (!text || typeof text !== 'string') return text || '';
		      if (text.indexOf('**') === -1 && text.indexOf('__') === -1) return text;
		      const toSpaces = (s) => ' '.repeat(String(s || '').length);
		      // Only normalize when they appear right after a bold marker.
		      return text
		        .replace(/\*\*([\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]+)/g, (m, sp) => `**${toSpaces(sp)}`)
		        .replace(/__([\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]+)/g, (m, sp) => `__${toSpaces(sp)}`);
		    }

		    // FIX: Ensure a literal space after **/__ when followed by a word char.
		    function enforceSpaceAfterBold(text) {
		      if (!text || typeof text !== 'string') return text || '';
		      if (text.indexOf('**') === -1 && text.indexOf('__') === -1) return text;
		      const isWord = (ch) => /[0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_]/.test(ch || '');
		      let out = '';
		      let i = 0;
		      let inFence = false;
		      let fence = '';
		      let inInline = false;
		      let inlineTicks = 0;
		      const isLineStart = (idx) => idx === 0 || text[idx - 1] === '\n';
		      while (i < text.length) {
		        if (!inInline && isLineStart(i)) {
		          const fenceMatch = text.slice(i).match(/^(?:```+|~~~+)/);
		          if (fenceMatch) {
		            const marker = fenceMatch[0];
		            if (!inFence) { inFence = true; fence = marker; }
		            else if (marker.startsWith(fence)) { inFence = false; fence = ''; }
		            out += marker;
		            i += marker.length;
		            continue;
		          }
		        }
		        if (!inFence && text[i] === '`') {
		          const run = text.slice(i).match(/^`+/);
		          const len = run ? run[0].length : 1;
		          if (!inInline) { inInline = true; inlineTicks = len; }
		          else if (len === inlineTicks) { inInline = false; inlineTicks = 0; }
		          out += '`'.repeat(len);
		          i += len;
		          continue;
		        }
		        if (!inFence && !inInline) {
		          if (text[i] === '*' && text[i + 1] === '*' && text[i + 2] !== '*') {
		            const close = text.indexOf('**', i + 2);
		            if (close !== -1) {
		              out += text.slice(i, close + 2);
		              const next = text[close + 2];
		              if (isWord(next)) out += ' ';
		              i = close + 2;
		              continue;
		            }
		          }
		          if (text[i] === '_' && text[i + 1] === '_' && text[i + 2] !== '_') {
		            const close = text.indexOf('__', i + 2);
		            if (close !== -1) {
		              out += text.slice(i, close + 2);
		              const next = text[close + 2];
		              if (isWord(next)) out += ' ';
		              i = close + 2;
		              continue;
		            }
		          }
		        }
		        out += text[i];
		        i += 1;
		      }
		      return out;
		    }

		    // Markdown setup
			    const originalMarkedParse = marked.parse;
			    // FIX: prevent CommonMark indented-codeblocks caused by leading spaces in plain text (render-time only).
			    // (Users often paste explanations with visual indentation; CommonMark treats 4+ spaces as a code block.)
				    function normalizeLeadingIndentForMarkdown(text) {
				      if (!text || typeof text !== 'string') return text || '';
				      if (!/^(?: {4,}|\t+)/m.test(text)) return text;
				      const NBSP = '\u00A0';
				      const ZWSP = '\u200B'; // breaks code-block indentation without visible glyph
				      const lines = String(text).replace(/\r\n/g, '\n').split('\n');
				      let inFence = false;
				      let fence = '';
				      for (let i = 0; i < lines.length; i++) {
			        const line = lines[i] || '';
			        const fenceMatch = line.match(/^(?:```+|~~~+)/);
			        if (fenceMatch) {
			          const marker = fenceMatch[0];
			          if (!inFence) { inFence = true; fence = marker; }
			          else if (marker.startsWith(fence)) { inFence = false; fence = ''; }
			          continue;
			        }
			        if (inFence) continue;
				        const m = line.match(/^( {4,}|\t+)/);
				        if (!m) continue;
				        const prefix = m[0];
				        const n = prefix[0] === '\t' ? (prefix.length * 4) : prefix.length;
				        lines[i] = ZWSP + NBSP.repeat(n) + line.slice(prefix.length);
				      }
				      return lines.join('\n');
				    }
			    marked.parse = function (src, opt) {
			      // Hook: sanitize LaTeX before markdown parsing
			      // This protects \command from being swallowed by markdown backslash escaping
			      const safe = normalizeLeadingIndentForMarkdown(enforceSpaceAfterBold(
			        fixCommonMarkBoldFlanking(
			          normalizeFakeSpacesAfterBoldMarkers(
			            escapePipesInMarkdownTables(sanitizeLatex(src))
			          )
			        )
			      ));
			      return originalMarkedParse(safe, opt);
			    };

    marked.setOptions({
      gfm: true,
      breaks: false,
      headerIds: true,
      mangle: false,
      smartLists: true,
      smartypants: false,
      // ì·¨ì†Œì„ (~ ~) ê¸°ëŠ¥ì€ ë”: í•œê¸€ì—ì„œ ~ë¥¼ ìì£¼ ì“°ê¸° ë•Œë¬¸ì— ì˜ë„ì¹˜ ì•Šê²Œ ì·¨ì†Œì„ ì´ ìƒê¹€
      renderer: (() => {
        const r = new marked.Renderer();
        r.del = (text) => text; // ~í…ìŠ¤íŠ¸~ ë¥¼ ê·¸ëƒ¥ ì¼ë°˜ í…ìŠ¤íŠ¸ë¡œ ë Œë”ë§
        return r;
      })(),
      highlight: function (code, lang) {
        try { return hljs.highlightAuto(code, lang ? [lang] : undefined).value; }
        catch (e) { return code; }
      }
    });

    const $ = (sel, el = document) => el.querySelector(sel);
    const $$ = (sel, el = document) => Array.from(el.querySelectorAll(sel));

    const sourceEl = $('#source');
    const outputEl = $('#output');
    const typesNavEl = $('#typesNav');
    const statusEl = $('#status');
    const renderBtn = $('#renderBtn');
	    const clearBtn = $('#clearBtn');
	    const hardClearBtn = $('#hardClearBtn');
	    const themeToggle = $('#themeToggle');
	    const langSelect = $('#langSelect');
	    const scrollTopBtn = $('#scrollTop');
	    const progressBar = $('#progressBar');
    const headerEl = document.querySelector('header');
    const hoverRevealZone = $('#hoverRevealZone');
    let mouseNearTop = false;
    let lastScrollY = window.scrollY || 0;
    const pdfBtn = $('#pdfBtn'); // ADD: PDF ë²„íŠ¼ ì°¸ì¡°

    // Keep content/anchors below the fixed header (responsive header height).
    (function initHeaderHeightVar() {
      if (!headerEl) return;
      const root = document.documentElement;
      const sync = () => {
        const h = Math.ceil(headerEl.getBoundingClientRect().height);
        root.style.setProperty('--header-h', `${h}px`);
      };
      sync();
      if ('ResizeObserver' in window) {
        new ResizeObserver(sync).observe(headerEl);
      } else {
        window.addEventListener('resize', sync, { passive: true });
      }
    })();

    // === RESCUE/IMPORT SUPPORT: Initialize problems from storage if available ===
    // ideology: User data (rescued/imported) takes precedence over hardcoded/default data
    (function initProblemsFromStorage() {
      try {
        const stored = localStorage.getItem('fmm_problems_json');
        if (stored) {
          const parsed = JSON.parse(stored);
          window.problems = { json: parsed };
          window.fmm_problems_json = parsed; // keep reference if needed
          console.log("Loaded problems from storage (" + Object.keys(parsed.types || {}).length + " types)");
        } else {
          // Ensure window.problems exists to prevent errors if not defined elsewhere
          window.problems = window.problems || { json: { types: {} } };
        }
      } catch (e) {
        console.error("Failed to load problems from storage", e);
        window.problems = window.problems || { json: { types: {} } };
      }
    })();

    // Single-session store (in-memory) + IndexedDB snapshot for durability
    const store = (() => {
      const data = {};
      const isPersistentKey = (k) => String(k || '').startsWith('fmm_');
      const readLocal = (k) => {
        try { return window.localStorage ? window.localStorage.getItem(k) : null; } catch { return null; }
      };
      const readSession = (k) => {
        try { return window.sessionStorage ? window.sessionStorage.getItem(k) : null; } catch { return null; }
      };
      const writeLocal = (k, v) => {
        try { if (window.localStorage && isPersistentKey(k)) window.localStorage.setItem(k, v); } catch { }
      };
      const writeSession = (k, v) => {
        try { if (window.sessionStorage && isPersistentKey(k)) window.sessionStorage.setItem(k, v); } catch { }
      };
      const removeLocal = (k) => {
        try { if (window.localStorage && isPersistentKey(k)) window.localStorage.removeItem(k); } catch { }
      };
      const removeSession = (k) => {
        try { if (window.sessionStorage && isPersistentKey(k)) window.sessionStorage.removeItem(k); } catch { }
      };
      const listLocalKeys = () => {
        const keys = [];
        try {
          if (window.localStorage) {
            for (let i = 0; i < window.localStorage.length; i++) {
              const k = window.localStorage.key(i);
              if (k && isPersistentKey(k)) keys.push(k);
            }
          }
        } catch { }
        return keys;
      };
	      const listSessionKeys = () => {
	        const keys = [];
	        try {
	          if (window.sessionStorage) {
            for (let i = 0; i < window.sessionStorage.length; i++) {
              const k = window.sessionStorage.key(i);
              if (k && isPersistentKey(k)) keys.push(k);
            }
          }
	        } catch { }
	        return keys;
	      };
	      // Prevent accidental "[object Object]" persistence by coercing any value into safe plain text.
	      // (Core fix: block object-stringification at the storage boundary.)
	      const toSafeStorageString = (value) => {
	        const isPlausibleYearToken = (s) => {
	          const m = String(s || '').match(/^(\d{3,4}|\?)/);
	          if (!m) return null;
	          const t = m[1];
	          if (t === '?') return '?';
	          const n = parseInt(t, 10);
	          if (!Number.isFinite(n)) return null;
	          return (n >= 500 && n <= 2100) ? t : null;
	        };
	        const lastPlausibleYearIn = (s) => {
	          const m = String(s || '').match(/(\d{3,4}|\?)$/);
	          if (!m) return null;
	          const t = m[1];
	          if (t === '?') return '?';
	          const n = parseInt(t, 10);
	          if (!Number.isFinite(n)) return null;
	          return (n >= 500 && n <= 2100) ? t : null;
	        };
	        const rec = (v) => {
	          if (v == null) return '';
	          if (typeof v === 'string') return v;
	          if (typeof v === 'number' || typeof v === 'boolean') return String(v);
		          if (Array.isArray(v)) {
		            const parts = v.map(x => ({ raw: x, text: rec(x) }));
		            let out = '';
		            for (let i = 0; i < parts.length; i++) {
		              const t = parts[i].text || '';
		              if (t) { out += t; continue; }
		              const raw = parts[i].raw;
		              const isObjToken = raw && typeof raw === 'object';
		              if (!isObjToken) continue;
		              const prevY = lastPlausibleYearIn(out);
		              const nextText = parts[i + 1]?.text || '';
		              const nextY = isPlausibleYearToken(nextText);
		              const prevCh = out.slice(-1);
		              const nextCh = nextText[0] || '';
		              const prevNonSpace = !!(prevCh && !/\s/.test(prevCh));
		              const nextNonSpace = !!(nextCh && !/\s/.test(nextCh));
		              out += (prevY && nextY) ? '~' : ((prevNonSpace && nextNonSpace) ? '~' : ' ');
		            }
		            return out;
		          }
		          if (typeof v === 'object') {
		            if (typeof v.text === 'string') return v.text;
		            if (typeof v.t === 'string') return v.t;
		            if (typeof v.value === 'string') return v.value;
		            if (typeof v.content === 'string') return v.content;
		            if (Array.isArray(v.parts)) return v.parts.map(rec).join('');
		            if (Array.isArray(v.content)) return v.content.map(rec).join('');
		            if (typeof v.textContent === 'string') return v.textContent;
		            // Numeric-indexed objects (rare): {0:"...",1:"..."}
		            try {
		              const keys = Object.keys(v).filter(k => /^\d+$/.test(k)).sort((a, b) => Number(a) - Number(b));
		              if (keys.length) return keys.map(k => rec(v[k])).join('');
		            } catch { }
		            try {
		              const s = String(v);
		              if (s && s !== '[object Object]') return s;
		            } catch { }
		            // Last resort (capped): store JSON rather than dropping content.
		            try {
		              const json = JSON.stringify(v);
		              if (json && json !== '{}' && json.length <= 4000) return json;
		            } catch { }
		            return '';
		          }
		          try { return String(v); } catch { return ''; }
		        };
		        let out = rec(value);
		        // Best-effort restoration: common year-range corruption "1158[object Object]1210" -> "1158~1210".
		        // Keep whitespace tight (spaces/tabs/NBSP only) so we don't destroy markdown structure.
		        try {
		          if (out && typeof out === 'string' && out.indexOf('[object Object]') !== -1) {
		            out = out.replace(/(\d{1,4}|\?)[\u00A0 \t]*\[object Object\][\u00A0 \t]*(\d{1,4}|\?)/g, '$1~$2');
		            out = out.replace(/(\S)[\u00A0 \t]*\[object Object\][\u00A0 \t]*(?=\S)/g, '$1~');
		            out = out.replace(/\[object Object\]/g, '~');
		          }
		        } catch { }
		        return out;
		      };
	      const api = {
        getItem: (k) => {
          if (isPersistentKey(k)) {
            if (Object.prototype.hasOwnProperty.call(data, k)) return data[k];
            const raw = readLocal(k);
            if (raw != null) {
              data[k] = raw;
              return raw;
            }
            const sess = readSession(k);
            if (sess != null) {
              data[k] = sess;
              return sess;
            }
            return null;
          }
          if (Object.prototype.hasOwnProperty.call(data, k)) return data[k];
          const raw = readLocal(k);
          if (raw != null) data[k] = raw;
          const sess = readSession(k);
          if (sess != null) data[k] = sess;
          return raw != null ? raw : (sess != null ? sess : null);
	        },
	        setItem: (k, v) => {
	          data[k] = toSafeStorageString(v);
	          writeLocal(k, data[k]);
	          writeSession(k, data[k]);
	        },
        removeItem: (k) => {
          delete data[k];
          removeLocal(k);
          removeSession(k);
        },
        key: (i) => {
          const keys = new Set(Object.keys(data));
          listLocalKeys().forEach(k => keys.add(k));
          listSessionKeys().forEach(k => keys.add(k));
          return Array.from(keys)[i] || null;
        },
        clear: () => {
          Object.keys(data).forEach(k => delete data[k]);
          listLocalKeys().forEach(k => removeLocal(k));
          listSessionKeys().forEach(k => removeSession(k));
        },
        get length() {
          const keys = new Set(Object.keys(data));
          listLocalKeys().forEach(k => keys.add(k));
          listSessionKeys().forEach(k => keys.add(k));
          return keys.size;
        },
        dump: () => {
          const out = { ...data };
          listLocalKeys().forEach(k => {
            if (Object.prototype.hasOwnProperty.call(out, k)) return;
            const raw = readLocal(k);
            if (raw != null) out[k] = raw;
          });
          listSessionKeys().forEach(k => {
            if (Object.prototype.hasOwnProperty.call(out, k)) return;
            const raw = readSession(k);
            if (raw != null) out[k] = raw;
          });
          return out;
        },
        import: (obj) => {
          Object.keys(obj || {}).forEach(k => {
            data[k] = obj[k];
            writeLocal(k, data[k]);
            writeSession(k, data[k]);
          });
        }
      };
      return api;
    })();

    // NEW: IndexedDB + localStorage snapshot of all fmm_* data
    // ideology: never lose work on refresh; keep export/import format as the single source of truth
    const snapshotDB = (() => {
      const LS_KEY = 'fmm_snapshot_bundle';
      const DB_NAME = 'fmm_snapshot_db';
      const STORE_NAME = 'snapshots';
      let db = null;
      let saveTimer = null;

      function openDb() {
        return new Promise(resolve => {
          try {
            if (!('indexedDB' in window)) { resolve(null); return; }
            const req = indexedDB.open(DB_NAME, 1);
            req.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME);
              }
            };
            req.onsuccess = () => { db = req.result; resolve(db); };
            req.onerror = () => { console.warn('IndexedDB open error, falling back to localStorage'); resolve(null); };
          } catch {
            resolve(null);
          }
        });
      }

      const dbReady = openDb();

      function saveToIdb(bundle) {
        dbReady.then(dbInst => {
          if (!dbInst) return;
          try {
            const tx = dbInst.transaction(STORE_NAME, 'readwrite');
            tx.objectStore(STORE_NAME).put(bundle, 'current');
          } catch {
            // ignore; localStorage fallback already handled
          }
        });
      }

      function loadFromIdb() {
        return dbReady.then(dbInst => new Promise(resolve => {
          if (!dbInst) { resolve(null); return; }
          try {
            const tx = dbInst.transaction(STORE_NAME, 'readonly');
            const req = tx.objectStore(STORE_NAME).get('current');
            req.onsuccess = () => resolve(req.result || null);
            req.onerror = () => resolve(null);
          } catch {
            resolve(null);
          }
        }));
      }

      function buildBundle() {
        const snapshot = store.dump();
        return {
          __fmm_bundle__: 1,
          savedAt: new Date().toISOString(),
          data: snapshot,
          // keep unmasked raw for durability; editor view is masked separately
          source: unmaskDataImages(sourceEl.value || '', sourceEl) || ''
        };
      }

      function scheduleSave() {
        if (saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
          const bundle = buildBundle();
          try {
            if (window.localStorage) {
              window.localStorage.setItem(LS_KEY, JSON.stringify(bundle));
            }
          } catch {
            // ignore quota errors; IndexedDB may still succeed
          }
          try {
            if (window.sessionStorage) {
              window.sessionStorage.setItem(LS_KEY, JSON.stringify(bundle));
            }
          } catch { }
          saveToIdb(bundle);
        }, 300);
      }
      function saveNow() {
        const bundle = buildBundle();
        try {
          if (window.localStorage) {
            window.localStorage.setItem(LS_KEY, JSON.stringify(bundle));
          }
        } catch {
          // ignore quota errors; IndexedDB may still succeed
        }
        try {
          if (window.sessionStorage) {
            window.sessionStorage.setItem(LS_KEY, JSON.stringify(bundle));
          }
        } catch { }
        saveToIdb(bundle);
      }

      async function init() {
        // 1) Try IndexedDB
        let bundle = await loadFromIdb();
        // 2) Fallback to localStorage
        if (!bundle) {
          try {
            if (window.localStorage) {
              const raw = window.localStorage.getItem(LS_KEY);
              if (raw) bundle = JSON.parse(raw);
            }
          } catch {
            bundle = null;
          }
        }
        // 3) Fallback to sessionStorage
        if (!bundle) {
          try {
            if (window.sessionStorage) {
              const raw = window.sessionStorage.getItem(LS_KEY);
              if (raw) bundle = JSON.parse(raw);
            }
          } catch {
            bundle = null;
          }
        }
        if (!bundle || bundle.__fmm_bundle__ !== 1 || !bundle.data) return;

        // Hydrate in-memory store
        store.clear();
        store.import(bundle.data);

        // Guide text (mask for editor; raw kept in store/bundle)
        if (!sourceEl.value) {
          const rawGuide = store.getItem('fmm_source') || bundle.source || '';
          if (rawGuide) sourceEl.value = maskDataImages(rawGuide, sourceEl);
        }

        // Delegate full UI rehydration to shared import path if available
        try {
          if (typeof window.rehydrateAfterImport === 'function') {
            window.rehydrateAfterImport();
          } else {
            // Minimal fallback: theme + render
            const savedTheme = store.getItem('fmm_theme') || 'dark';
            document.body.dataset.theme = savedTheme;
            if (typeof updateThemeLabel === 'function') updateThemeLabel();
            if ((sourceEl.value || '').trim()) {
              try { render(); } catch { }
            }
          }
        } catch {
          // ignore hydration errors; user can manually re-render
        }
      }

      return { init, scheduleSave, saveNow };
    })();

    // Patch store mutators to autosave snapshots
    (function patchStoreForSnapshots() {
      const origSet = store.setItem;
      const origRemove = store.removeItem;
      const origClear = store.clear;
      store.setItem = (k, v) => { origSet(k, v); snapshotDB.scheduleSave(); };
      store.removeItem = (k) => { origRemove(k); snapshotDB.scheduleSave(); };
      store.clear = () => { origClear(); snapshotDB.scheduleSave(); };
    })();
	    // UI controls for font/width
	    const fontMinus = $('#fontMinus');
	    const fontPlus = $('#fontPlus');
	    const solveFontMinus = $('#solveFontMinus');
	    const solveFontPlus = $('#solveFontPlus');
	    const memoFontMinus = $('#memoFontMinus');
	    const memoFontPlus = $('#memoFontPlus');
	    const widthNarrow = $('#widthNarrow');
	    const widthWiden = $('#widthWiden');

    // === ADD: guide file loader ===================================================
    // ideology: reduce frictionâ€”users shouldn't have to copy/paste long guides
    const guideLoadBtn = $('#guideLoadBtn');
    const guideToggleBtn = $('#guideToggleBtn');
    const guideFile = $('#guideFile');
    const guideMergeBtn = $('#guideMergeBtn');
    const guideMergeFile = $('#guideMergeFile');
    const guideMergeBundleBtn = $('#guideMergeBundleBtn');
    const guideMergeBundleFile = $('#guideMergeBundleFile');
    const guideMergeBundlePatchFile = $('#guideMergeBundlePatchFile');

    // NEW: when a completely new guide is loaded, drop old per-guide state
    function resetGuideStateForNewGuide() {
      const snapshot = store.dump();
      const keep = {};
	      const keepKeys = new Set([
	        'fmm_theme',
	        'fmm_ui_fontSize',
	        'fmm_ui_memoPreviewFont',
	        'fmm_ui_autoAsciiMath',
	        'fmm_ui_mainWidth',
	        'fmm_llm_settings',
	        'fmm_answer_api_settings',
	        'fmm_guide_collapsed',
        'fmm_ui_globalAside',
        'fmm_ui_typeAside',
        'fmm_ui_leftAside',
        'fmm_ui_chatWindow',
        'fmm_ui_searchWindow',
        'fmm_ui_solveWindow',
        'fmm_ui_llmFillWindow'
      ]);
      Object.keys(snapshot).forEach(k => {
        if (keepKeys.has(k)) keep[k] = snapshot[k];
      });
      store.clear();
      store.import(keep);
      if (outputEl) outputEl.innerHTML = '';
      if (typesNavEl) typesNavEl.style.display = 'none';
    }

		    guideLoadBtn.addEventListener('click', () => guideFile.click());
		    guideFile.addEventListener('change', async (e) => {
		      const f = e.target.files?.[0]; if (!f) return;
		      const text = await f.text();
		      try { store.setItem('fmm_example_dismissed', '1'); } catch { }
		      try {
		        store.removeItem('fmm_example_autoloaded');
		        store.removeItem('fmm_example_lang');
		        store.removeItem('fmm_example_hash');
		      } catch { }
		      // ë°ì´í„° ìœ ì‹¤ ë°©ì§€: ê°€ì´ë“œ ë¡œë“œ ì‹œ ê¸°ì¡´ ìƒíƒœë¥¼ "ìë™" ì‚­ì œí•˜ì§€ ì•ŠëŠ”ë‹¤.
		      // (í•„ìš”í•˜ë©´ ì‚¬ìš©ìê°€ ì„ íƒì ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ë„ë¡ ìœ ë„)
		      const keepExisting = confirm(
		        (currentLang === 'ko')
		          ? 'ìƒˆ ê°€ì´ë“œ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.\n\nê¸°ì¡´ ë°ì´í„°(ë¬¸ì œë©”ëª¨/í’€ì´ ê¸°ë¡/ë©”ëª¨/ì±„íŒ… ë“±)ë¥¼ ìœ ì§€í• ê¹Œìš”?\n\n[í™•ì¸]=ìœ ì§€ / [ì·¨ì†Œ]=ë¶ˆëŸ¬ì˜¤ê¸° ì·¨ì†Œ'
		          : 'Load a new guide file.\n\nKeep existing data (memos, solve history, chat, sheets, etc.)?\n\n[OK]=Keep / [Cancel]=Cancel loading'
		      );
	      if (!keepExisting) {
	        const doReset = confirm(
	          (currentLang === 'ko')
	            ? 'ê¸°ì¡´ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•œ ë’¤ ê°€ì´ë“œë¥¼ ë¶ˆëŸ¬ì˜¬ê¹Œìš”?\n\n[í™•ì¸]=ì´ˆê¸°í™” í›„ ë¶ˆëŸ¬ì˜¤ê¸° / [ì·¨ì†Œ]=ë¶ˆëŸ¬ì˜¤ê¸° ì·¨ì†Œ'
	            : 'Reset existing data and then load the guide?\n\n[OK]=Reset & load / [Cancel]=Cancel loading'
	        );
	        if (!doReset) { e.target.value = ''; return; }
	        resetGuideStateForNewGuide();
	      }
      sourceEl.value = maskDataImages(text, sourceEl);
      store.setItem('fmm_source', text);
      render();                          // show it right away
      // Collapse guide input â€” ideology: keep focus on reading pane after load
      const guidePanel = sourceEl.closest('.panel');
      if (guidePanel) guidePanel.classList.add('collapsed');
      store.setItem('fmm_guide_collapsed', '1');
		      statusEl.textContent = (currentLang === 'ko') ? 'ê°€ì´ë“œ íŒŒì¼ ë¡œë“œë¨' : 'Guide loaded';
		      e.target.value = '';               // allow reselecting same file
		    });

		    // Example guide files (autoloaded only when there's no saved guide yet)
		    const EXAMPLE_GUIDE_FILES = {
		      en: 'example_en.txt',
		      ko: 'example_ko.txt',
		      fallback: 'example_en.txt'
		    };

		    function fnv1a32(str) {
		      let h = 2166136261;
		      const s = String(str || '');
		      for (let i = 0; i < s.length; i++) {
		        h ^= s.charCodeAt(i);
		        h = Math.imul(h, 16777619);
		      }
		      return (h >>> 0).toString(16);
		    }

		    async function fetchTextFile(path) {
		      try {
		        const res = await fetch(path, { cache: 'no-store' });
		        if (!res.ok) throw new Error(`HTTP ${res.status}`);
		        const text = await res.text();
		        return String(text || '');
		      } catch (e) {
		        console.warn('failed to load text file:', path, e);
		        return '';
		      }
		    }

		    async function fetchExampleGuide(lang) {
		      const primary = (lang === 'ko') ? EXAMPLE_GUIDE_FILES.ko : EXAMPLE_GUIDE_FILES.en;
		      let text = await fetchTextFile(primary);
		      if (!text.trim()) text = await fetchTextFile(EXAMPLE_GUIDE_FILES.fallback);
		      return text;
		    }

		    async function maybeLoadExampleGuide() {
		      try {
		        // If user explicitly dismissed the example guide, never auto-load.
		        if ((store.getItem('fmm_example_dismissed') || '0') === '1') return;

		        const existing = (store.getItem('fmm_source') || '').trim() || (sourceEl.value || '').trim();
		        if (existing) return;

		        // Only when there's no guide AND no problems loaded.
		        const hasProblems = !!(store.getItem('fmm_problems_json') || '').trim();
		        if (hasProblems) return;

		        const text = await fetchExampleGuide(currentLang);
		        if (!text || !text.trim()) return;

		        sourceEl.value = maskDataImages(text, sourceEl);
		        store.setItem('fmm_source', text);
		        try {
		          store.setItem('fmm_example_autoloaded', '1');
		          store.setItem('fmm_example_lang', currentLang);
		          store.setItem('fmm_example_hash', fnv1a32(text));
		        } catch { }
		        try {
		          const guidePanel = sourceEl.closest('.panel');
		          if (guidePanel) guidePanel.classList.add('collapsed');
		          store.setItem('fmm_guide_collapsed', '1');
		        } catch { }
		        try { render(); } catch { }
		      } catch (e) {
		        console.warn('example guide load failed:', e);
		      }
		    }

    function normalizePatchTypes(payload) {
      if (!payload || typeof payload !== 'object') return [];
      const coerceProblems = (value) => {
        if (Array.isArray(value)) return value;
        if (typeof value === 'string') {
          try {
            const parsed = JSON.parse(value);
            if (Array.isArray(parsed)) return parsed;
            if (parsed && Array.isArray(parsed.items)) return parsed.items;
            if (parsed && Array.isArray(parsed.list)) return parsed.list;
          } catch { }
          return [];
        }
        if (value && typeof value === 'object') {
          if (Array.isArray(value.items)) return value.items;
          if (Array.isArray(value.list)) return value.list;
          if (Array.isArray(value.problems)) return value.problems;
          const vals = Object.values(value);
          if (vals.length && vals.every(v => v && typeof v === 'object')) return vals;
        }
        return [];
      };
      if (Array.isArray(payload.types)) {
        return payload.types.map(t => ({
          title: t?.title || t?.type_title || t?.typeName || '',
          standardMarkdown: coerceText(t?.standardMarkdown ?? t?.standard ?? ''),
          explanationMarkdown: coerceText(t?.explanationMarkdown ?? t?.explanation ?? ''),
          problems: coerceProblems(t?.problems)
        })).filter(t => t.title);
      }
      if (typeof payload.guideMarkdown === 'string' && payload.guideMarkdown.trim()) {
        return parseGuide(payload.guideMarkdown).map(t => ({
          title: t.title,
          standardMarkdown: t.standardMarkdown || '',
          explanationMarkdown: t.explanationMarkdown || '',
          problems: []
        }));
      }
      return [];
    }

    function buildGuideMarkdownFromTypes(types) {
      const buildTypeRaw = (typeof buildTypeGuideRawMarkdown === 'function')
        ? buildTypeGuideRawMarkdown
        : (t => {
            const title = String(t?.title || '').trim();
            const std = coerceText(t?.standardMarkdown).trim();
            const exp = coerceText(t?.explanationMarkdown).trim();
            return `# ${title}\n\n${std}\n\n---\n\n${exp}`.trim();
          });
      const blocks = (types || []).map(t => buildTypeRaw(t).replace(/\n$/, '').trim());
      return blocks.join('\n\n========================================\n\n').trim() + '\n';
    }

    function findProblemTypeMatch(patchIds, problemTypeSets) {
      const setsEqualSafe = (typeof setsEqual === 'function')
        ? setsEqual
        : ((a, b) => {
            if (!a || !b || a.size !== b.size) return false;
            for (const v of a) if (!b.has(v)) return false;
            return true;
          });
      const isSubsetSafe = (typeof isSubset === 'function')
        ? isSubset
        : ((a, b) => {
            if (!a || !b) return false;
            for (const v of a) if (!b.has(v)) return false;
            return true;
          });
      let exact = null;
      let superset = null;
      let supersetSize = Infinity;
      (problemTypeSets || []).forEach(entry => {
        if (setsEqualSafe(entry.ids, patchIds)) exact = entry.title;
        else if (patchIds.size && isSubsetSafe(patchIds, entry.ids)) {
          if (entry.ids.size < supersetSize) {
            superset = entry.title;
            supersetSize = entry.ids.size;
          }
        }
      });
      return exact || superset || null;
    }

    function normalizePatchTitle(title) {
      let t = String(title || '').trim();
      if (!t) return t;
      t = t.replace(/^fmm_problems[_\s-]*/i, '');
      t = t.replace(/[_\s-]?20\d{2}[._-]\d{2}[._-]\d{2}\b/g, '');
      t = t.replace(/_+/g, ' ').replace(/\s+/g, ' ').trim();
      t = t.replace(/\s+\(/g, ' (');
      return t.trim();
    }

    function hasIndexSuffix(title) {
      return /\(\s*\d+\s*\)$/.test(String(title || '').trim());
    }
    function stripIndexSuffix(title) {
      return String(title || '').replace(/\s*\(\s*\d+\s*\)\s*$/, '').trim();
    }

    function mergeGuidePatch(payload) {
      const patchTypesRaw = normalizePatchTypes(payload);
      if (!patchTypesRaw.length) {
        alert('íŒ¨ì¹˜ íŒŒì¼ì—ì„œ ë³‘í•©í•  ìœ í˜• ë°ì´í„°ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
        return;
      }
      // Persist classification standard if provided (used by builder incremental mode via renderer export).
      try {
        const cs = payload && typeof payload === 'object' ? payload.classificationStandard : null;
        if (Array.isArray(cs) && cs.length) {
          const raw = JSON.stringify(cs);
          store.setItem('fmm_classification_standard', raw);
          try { window.localStorage && window.localStorage.setItem('fmm_classification_standard', raw); } catch { }
        }
      } catch { }
      const payloadProblemsMap = (payload && typeof payload === 'object' && payload.problems && typeof payload.problems === 'object')
        ? payload.problems
        : null;

      const guideTypesRaw = Array.isArray(window.fmm_types) ? window.fmm_types : parseGuide(sourceEl.value || '');
      const guideTypes = [];
      const guideSeen = new Set();
      guideTypesRaw.forEach(t => {
        const cleanTitle = normalizePatchTitle(t.title);
        const norm = normalizeTitle(cleanTitle);
        if (guideSeen.has(norm)) return;
        guideSeen.add(norm);
        guideTypes.push({ ...t, title: cleanTitle });
      });
      const problemTypesRaw = problems.json?.types || {};
      const normalizedProblemTypes = {};
      Object.keys(problemTypesRaw).forEach(k => {
        const clean = normalizePatchTitle(k);
        normalizedProblemTypes[clean] = (normalizedProblemTypes[clean] || []).concat(problemTypesRaw[k] || []);
      });
      const problemTypes = normalizedProblemTypes;
      const buildIds = (typeof buildProblemIdSet === 'function')
        ? buildProblemIdSet
        : (list => {
            const set = new Set();
            (list || []).forEach(p => {
              const id = p?.qid || p?.id || p?.global_qid || p?.problem_id || '';
              if (id) set.add(id);
            });
            return set;
          });
      const problemTypeSets = Object.keys(problemTypes).map(title => ({
        title,
        ids: buildIds(problemTypes[title] || [])
      }));

      const groupByBaseNorm = new Map();
      const directByTitleNorm = new Map();
      const patchEntries = [];
      patchTypesRaw.forEach(pt => {
        const cleanTitle = normalizePatchTitle(pt.title);
        if (payloadProblemsMap && (!pt.problems || pt.problems.length === 0)) {
          const direct = payloadProblemsMap[pt.title] || payloadProblemsMap[cleanTitle];
          if (Array.isArray(direct)) pt.problems = direct;
        }
        const ids = buildIds(pt.problems || []);
        const baseTitle = (!hasIndexSuffix(cleanTitle) && ids.size)
          ? findProblemTypeMatch(ids, problemTypeSets)
          : null;
        const entry = { ...pt, title: cleanTitle, _baseTitle: baseTitle ? normalizePatchTitle(baseTitle) : null };
        patchEntries.push(entry);
        const norm = normalizeTitle(cleanTitle);
        if (!directByTitleNorm.has(norm)) directByTitleNorm.set(norm, []);
        directByTitleNorm.get(norm).push(entry);
        if (entry._baseTitle) {
          const baseNorm = normalizeTitle(entry._baseTitle);
          if (!groupByBaseNorm.has(baseNorm)) groupByBaseNorm.set(baseNorm, []);
          groupByBaseNorm.get(baseNorm).push(entry);
        }
      });

      const nextGuide = [];
      const usedPatchNorms = new Set();
      const nextGuideNorms = new Set();
      guideTypes.forEach(t => {
        const norm = normalizeTitle(t.title);
        let group = null;
        if (directByTitleNorm.has(norm)) {
          group = directByTitleNorm.get(norm);
          directByTitleNorm.delete(norm);
        } else if (groupByBaseNorm.has(norm)) {
          group = groupByBaseNorm.get(norm);
          groupByBaseNorm.delete(norm);
        }
        if (group) {
          let added = false;
          group.forEach(pt => {
            const ptNorm = normalizeTitle(pt.title);
            if (usedPatchNorms.has(ptNorm)) return;
            usedPatchNorms.add(ptNorm);
            nextGuide.push({
              title: pt.title,
              standardMarkdown: coerceText(pt.standardMarkdown || t.standardMarkdown || ''),
              explanationMarkdown: coerceText(pt.explanationMarkdown || '')
            });
            nextGuideNorms.add(ptNorm);
            added = true;
          });
          if (!added) {
            nextGuide.push(t);
            nextGuideNorms.add(norm);
          }
        } else {
          nextGuide.push(t);
          nextGuideNorms.add(norm);
        }
      });

      patchEntries.forEach(pt => {
        const norm = normalizeTitle(pt.title);
        if (usedPatchNorms.has(norm) || nextGuideNorms.has(norm)) return;
        usedPatchNorms.add(norm);
        nextGuide.push({
          title: pt.title,
          standardMarkdown: coerceText(pt.standardMarkdown || ''),
          explanationMarkdown: coerceText(pt.explanationMarkdown || '')
        });
        nextGuideNorms.add(norm);
      });

      const cleanedGuide = [];
      const cleanedNorms = new Set();
      nextGuide.forEach(t => {
        const cleanTitle = normalizePatchTitle(t.title);
        const norm = normalizeTitle(cleanTitle);
        if (cleanedNorms.has(norm)) return;
        cleanedNorms.add(norm);
        cleanedGuide.push({ ...t, title: cleanTitle });
      });

      let problemsChanged = false;
      const problemsByNorm = {};
      const problemsByTitle = {};
      Object.keys(problemTypes || {}).forEach(k => {
        const norm = normalizeTitle(normalizePatchTitle(k));
        if (!problemsByNorm[norm]) problemsByNorm[norm] = [];
        problemsByNorm[norm] = problemsByNorm[norm].concat(problemTypes[k] || []);
      });
      patchEntries.forEach(pt => {
        if (!Array.isArray(pt.problems) || pt.problems.length === 0) return;
        const cleanTitle = normalizePatchTitle(pt.title);
        const norm = normalizeTitle(cleanTitle);
        problemsByNorm[norm] = pt.problems.map(p => ({ ...p }));
        problemsByTitle[cleanTitle] = pt.problems.map(p => ({ ...p }));
        problemsChanged = true;
      });
      problems.json = problems.json || { types: {} };
      problems.json.types = {};
      // 1) Always apply patch problems by their cleaned titles.
      Object.keys(problemsByTitle).forEach(title => {
        problems.json.types[title] = problemsByTitle[title].map(p => ({ ...p }));
      });
      window.fmm_patch_problems = { ...problemsByTitle };
      // 2) Fill remaining guide titles from normalized cache if available.
      cleanedGuide.forEach(t => {
        if (problems.json.types[t.title]?.length) return;
        const norm = normalizeTitle(t.title);
        let fallback = problemsByNorm[norm];
        if ((!fallback || !fallback.length) && hasIndexSuffix(t.title)) {
          const baseNorm = normalizeTitle(stripIndexSuffix(t.title));
          fallback = problemsByNorm[baseNorm];
        }
        if (fallback && fallback.length) {
          problems.json.types[t.title] = fallback.map(p => ({ ...p }));
        }
      });
      problemsChanged = true;
      if (problemsChanged) {
        const rebuildFullIndex = () => {
          scrubProblemsJsonPlaceholderAnswers();
          try { normalizeProblemsPaperNamesInPlace(problems.json); } catch { }
          try { migratePartSuffixQids(); } catch { }
          try { repairObjectArtifactsInAllData(); } catch { }

          const src = problems.json?.types || {};
          problems.norm = {};
          problems.byQid = {};
          problems.qidType = {};
          Object.keys(src).forEach(k => {
            const key = normalizeTitle(k);
            problems.norm[key] = src[k] || [];
            (src[k] || []).forEach(p => {
              const qid = String(p?.qid || '');
              if (!qid) return;
              problems.qidType[qid] = k;
              problems.byQid[qid] = { ...p, __typeTitle: k };
            });
          });
          try { window.fmm_patch_problems = { ...(problems.json?.types || {}) }; } catch { }
          try { LS.set('fmm_problems_json', problems.json); } catch { }
          try { store.setItem('fmm_problems_json', JSON.stringify(problems.json)); } catch { }
        };
        rebuildFullIndex();
      }

	      cleanedGuide.forEach(t => {
	        const slug = String(t.title || '').toLowerCase().replace(/\s+/g, '_');
	        if (t.standardMarkdown) store.setItem(`fmm_standard_${slug}`, coerceText(t.standardMarkdown));
	        if (t.explanationMarkdown) store.setItem(`fmm_explanation_${slug}`, coerceText(t.explanationMarkdown));
	      });

      const mergedText = buildGuideMarkdownFromTypes(cleanedGuide);
      sourceEl.value = maskDataImages(mergedText, sourceEl);
      store.setItem('fmm_source', mergedText);
      render();
	      if (problems.json?.types && Object.keys(problems.json.types || {}).length) {
	        const aside = document.getElementById('leftAside');
	        if (aside) aside.style.display = '';
	        if (typeof renderProblemsForCurrentType === 'function') {
	          renderProblemsForCurrentType();
	        }
	      }
	      statusEl.textContent = `ê°€ì´ë“œ ë³‘í•© ì™„ë£Œ Â· ${patchEntries.length}ê±´`;
	      // If a multi-save slot is active, persist patch-merged state back into the current slot.
	      // ideology: patch should update "the save I'm looking at" without extra manual steps.
	      try {
	        const act = (typeof activeSlotId === 'function') ? activeSlotId() : '';
	        if (act && typeof saveCurrentToSlot === 'function') {
	          saveCurrentToSlot(act).catch(() => { });
	        }
	      } catch { }
	    }

    guideMergeBtn?.addEventListener('click', () => guideMergeFile?.click());
    guideMergeFile?.addEventListener('change', async (e) => {
      const f = e.target.files?.[0]; if (!f) return;
      try {
        const text = await f.text();
        const payload = JSON.parse(text);
        mergeGuidePatch(payload);
      } catch (err) {
        alert('íŒ¨ì¹˜ íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: ' + (err?.message || err));
      } finally {
        e.target.value = '';
      }
    });

    // NEW: Offline "bundle + patch" merge (does not touch current local state)
    function mergeGuidePatchIntoBundle(bundle, patchPayload) {
      if (!bundle || bundle.__fmm_bundle__ !== 1 || !bundle.items) throw new Error('Invalid FMM bundle (expected __fmm_bundle__:1)');
      const patchTypesRaw = normalizePatchTypes(patchPayload);
      if (!patchTypesRaw.length) throw new Error('Patchì— ë³‘í•©í•  ìœ í˜• ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');

      const next = (typeof structuredClone === 'function')
        ? structuredClone(bundle)
        : JSON.parse(JSON.stringify(bundle));

      const items = next.items || (next.items = {});
      const readItem = (k) => {
        const it = items[k];
        if (!it) return null;
        const kind = String(it.kind || '').toLowerCase();
        if (kind === 'raw') return String(it.value ?? '');
        return it.value ?? null;
      };
      const writeRaw = (k, v) => { items[k] = { kind: 'raw', value: String(v ?? '') }; };
      const writeJson = (k, v) => { items[k] = { kind: 'json', value: v ?? null }; };

      // Persist classification standard (optional)
      try {
        const cs = patchPayload && typeof patchPayload === 'object' ? patchPayload.classificationStandard : null;
        if (Array.isArray(cs) && cs.length) writeJson('fmm_classification_standard', cs);
      } catch { }

      const baseGuideText = coerceText(readItem('fmm_source') || '');
      const baseProblemsRaw = readItem('fmm_problems_json') || readItem('fmm_problems') || null;
      const baseProblemsJson = (() => {
        if (baseProblemsRaw && typeof baseProblemsRaw === 'object') {
          const typesObj = baseProblemsRaw.types && typeof baseProblemsRaw.types === 'object'
            ? baseProblemsRaw.types
            : baseProblemsRaw;
          return { types: typesObj && typeof typesObj === 'object' ? typesObj : {} };
        }
        if (typeof baseProblemsRaw === 'string' && baseProblemsRaw.trim()) {
          try {
            const parsed = JSON.parse(baseProblemsRaw);
            const typesObj = parsed.types && typeof parsed.types === 'object' ? parsed.types : parsed;
            return { types: typesObj && typeof typesObj === 'object' ? typesObj : {} };
          } catch { }
        }
        return { types: {} };
      })();

      const payloadProblemsMap = (patchPayload && typeof patchPayload === 'object' && patchPayload.problems && typeof patchPayload.problems === 'object')
        ? patchPayload.problems
        : null;

      const guideTypesRaw = parseGuide(baseGuideText || '');
      const guideTypes = [];
      const guideSeen = new Set();
      guideTypesRaw.forEach(t => {
        const cleanTitle = normalizePatchTitle(t.title);
        const norm = normalizeTitle(cleanTitle);
        if (guideSeen.has(norm)) return;
        guideSeen.add(norm);
        guideTypes.push({ ...t, title: cleanTitle });
      });

      const problemTypesRaw = baseProblemsJson?.types || {};
      const normalizedProblemTypes = {};
      Object.keys(problemTypesRaw).forEach(k => {
        const clean = normalizePatchTitle(k);
        normalizedProblemTypes[clean] = (normalizedProblemTypes[clean] || []).concat(problemTypesRaw[k] || []);
      });
      const problemTypes = normalizedProblemTypes;

      const buildIds = (typeof buildProblemIdSet === 'function')
        ? buildProblemIdSet
        : (list => {
            const set = new Set();
            (list || []).forEach(p => {
              const id = p?.qid || p?.id || p?.global_qid || p?.problem_id || '';
              if (id) set.add(id);
            });
            return set;
          });
      const problemTypeSets = Object.keys(problemTypes).map(title => ({
        title,
        ids: buildIds(problemTypes[title] || [])
      }));

      const groupByBaseNorm = new Map();
      const directByTitleNorm = new Map();
      const patchEntries = [];
      patchTypesRaw.forEach(pt0 => {
        const pt = { ...pt0 };
        const cleanTitle = normalizePatchTitle(pt.title);
        if (payloadProblemsMap && (!pt.problems || pt.problems.length === 0)) {
          const direct = payloadProblemsMap[pt.title] || payloadProblemsMap[cleanTitle];
          if (Array.isArray(direct)) pt.problems = direct;
        }
        const ids = buildIds(pt.problems || []);
        const baseTitle = (!hasIndexSuffix(cleanTitle) && ids.size)
          ? findProblemTypeMatch(ids, problemTypeSets)
          : null;
        const entry = { ...pt, title: cleanTitle, _baseTitle: baseTitle ? normalizePatchTitle(baseTitle) : null };
        patchEntries.push(entry);
        const norm = normalizeTitle(cleanTitle);
        if (!directByTitleNorm.has(norm)) directByTitleNorm.set(norm, []);
        directByTitleNorm.get(norm).push(entry);
        if (entry._baseTitle) {
          const baseNorm = normalizeTitle(entry._baseTitle);
          if (!groupByBaseNorm.has(baseNorm)) groupByBaseNorm.set(baseNorm, []);
          groupByBaseNorm.get(baseNorm).push(entry);
        }
      });

      const nextGuide = [];
      const usedPatchNorms = new Set();
      const nextGuideNorms = new Set();
      guideTypes.forEach(t => {
        const norm = normalizeTitle(t.title);
        let group = null;
        if (directByTitleNorm.has(norm)) {
          group = directByTitleNorm.get(norm);
          directByTitleNorm.delete(norm);
        } else if (groupByBaseNorm.has(norm)) {
          group = groupByBaseNorm.get(norm);
          groupByBaseNorm.delete(norm);
        }
        if (group) {
          let added = false;
          group.forEach(pt => {
            const ptNorm = normalizeTitle(pt.title);
            if (usedPatchNorms.has(ptNorm)) return;
            usedPatchNorms.add(ptNorm);
            nextGuide.push({
              title: pt.title,
              standardMarkdown: coerceText(pt.standardMarkdown || t.standardMarkdown || ''),
              explanationMarkdown: coerceText(pt.explanationMarkdown || '')
            });
            nextGuideNorms.add(ptNorm);
            added = true;
          });
          if (!added) {
            nextGuide.push(t);
            nextGuideNorms.add(norm);
          }
        } else {
          nextGuide.push(t);
          nextGuideNorms.add(norm);
        }
      });

      patchEntries.forEach(pt => {
        const norm = normalizeTitle(pt.title);
        if (usedPatchNorms.has(norm) || nextGuideNorms.has(norm)) return;
        usedPatchNorms.add(norm);
        nextGuide.push({
          title: pt.title,
          standardMarkdown: coerceText(pt.standardMarkdown || ''),
          explanationMarkdown: coerceText(pt.explanationMarkdown || '')
        });
        nextGuideNorms.add(norm);
      });

      const cleanedGuide = [];
      const cleanedNorms = new Set();
      nextGuide.forEach(t => {
        const cleanTitle = normalizePatchTitle(t.title);
        const norm = normalizeTitle(cleanTitle);
        if (cleanedNorms.has(norm)) return;
        cleanedNorms.add(norm);
        cleanedGuide.push({ ...t, title: cleanTitle });
      });

      // Problems merge
      const problemsByNorm = {};
      const problemsByTitle = {};
      Object.keys(problemTypes || {}).forEach(k => {
        const norm = normalizeTitle(normalizePatchTitle(k));
        if (!problemsByNorm[norm]) problemsByNorm[norm] = [];
        problemsByNorm[norm] = problemsByNorm[norm].concat(problemTypes[k] || []);
      });
      patchEntries.forEach(pt => {
        if (!Array.isArray(pt.problems) || pt.problems.length === 0) return;
        const cleanTitle = normalizePatchTitle(pt.title);
        const norm = normalizeTitle(cleanTitle);
        problemsByNorm[norm] = pt.problems.map(p => ({ ...p }));
        problemsByTitle[cleanTitle] = pt.problems.map(p => ({ ...p }));
      });
      const mergedProblemsJson = { types: {} };
      Object.keys(problemsByTitle).forEach(title => {
        mergedProblemsJson.types[title] = problemsByTitle[title].map(p => ({ ...p }));
      });
      cleanedGuide.forEach(t => {
        if (mergedProblemsJson.types[t.title]?.length) return;
        const norm = normalizeTitle(t.title);
        let fallback = problemsByNorm[norm];
        if ((!fallback || !fallback.length) && hasIndexSuffix(t.title)) {
          const baseNorm = normalizeTitle(stripIndexSuffix(t.title));
          fallback = problemsByNorm[baseNorm];
        }
        if (fallback && fallback.length) {
          mergedProblemsJson.types[t.title] = fallback.map(p => ({ ...p }));
        }
      });

      // Update bundle items
      cleanedGuide.forEach(t => {
        const slug = String(t.title || '').toLowerCase().replace(/\s+/g, '_');
        if (t.standardMarkdown) writeRaw(`fmm_standard_${slug}`, t.standardMarkdown);
        if (t.explanationMarkdown) writeRaw(`fmm_explanation_${slug}`, t.explanationMarkdown);
      });
      const mergedText = buildGuideMarkdownFromTypes(cleanedGuide);
      writeRaw('fmm_source', mergedText);
      writeJson('fmm_problems_json', mergedProblemsJson);

      return next;
    }

    let __pendingBundleForMerge = null;
    guideMergeBundleBtn?.addEventListener('click', () => guideMergeBundleFile?.click());
    guideMergeBundleFile?.addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      try {
        const text = await f.text();
        const bundle = JSON.parse(text);
        if (!bundle || bundle.__fmm_bundle__ !== 1 || !bundle.items) throw new Error('fmm_export.json í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.');
        __pendingBundleForMerge = bundle;
        guideMergeBundlePatchFile?.click();
      } catch (err) {
        __pendingBundleForMerge = null;
        alert('ì €ì¥íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: ' + (err?.message || err));
      } finally {
        e.target.value = '';
      }
    });
    guideMergeBundlePatchFile?.addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      try {
        if (!__pendingBundleForMerge) throw new Error('ë¨¼ì € ì €ì¥íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.');
        const text = await f.text();
        const patch = JSON.parse(text);
        const mergedBundle = mergeGuidePatchIntoBundle(__pendingBundleForMerge, patch);
        const blob = new Blob([JSON.stringify(mergedBundle, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'fmm_export_merged_' + new Date().toISOString().slice(0, 10) + '.json';
        a.click();
        URL.revokeObjectURL(url);
        statusEl.textContent = 'ì €ì¥íŒŒì¼ ë³‘í•© ì™„ë£Œ Â· ë‹¤ìš´ë¡œë“œë¨';
      } catch (err) {
        alert('ì €ì¥íŒŒì¼ ë³‘í•© ì‹¤íŒ¨: ' + (err?.message || err));
      } finally {
        __pendingBundleForMerge = null;
        e.target.value = '';
      }
    });

    // ADD: Guide panel open/close toggle + persistence
    guideToggleBtn?.addEventListener('click', () => {
      const gp = sourceEl.closest('.panel'); if (!gp) return;
      gp.classList.toggle('collapsed');
      const isCollapsed = gp.classList.contains('collapsed');
      store.setItem('fmm_guide_collapsed', isCollapsed ? '1' : '0');
    });

    // ADD: font size and main width persistence
	    const UI = {
	      font: Number(store.getItem('fmm_ui_fontSize') || 15),
	      solveFont: Number(store.getItem('fmm_ui_solveFontSize') || store.getItem('fmm_ui_fontSize') || 15),
	      memoPreviewFont: Number(store.getItem('fmm_ui_memoPreviewFont') || store.getItem('fmm_ui_fontSize') || 15),
	      autoAsciiMath: (store.getItem('fmm_ui_autoAsciiMath') || '0') === '1',
	      pad: Number(store.getItem('fmm_ui_mainPadX') || 14),
	      width: Number(store.getItem('fmm_ui_mainWidth') || 1200),
	      apply() {
	        const out = document.getElementById('output');
	        const mainEl = document.querySelector('main');
	        document.documentElement.style.setProperty('--memo-preview-font', this.memoPreviewFont + 'px');
	        document.documentElement.style.setProperty('--solve-font', this.solveFont + 'px');
	        document.documentElement.style.setProperty('--main-pad-x', this.pad + 'px');
	        if (out) out.style.fontSize = this.font + 'px';
	        if (mainEl) mainEl.style.maxWidth = this.width + 'px';
	      },
	      save() {
	        store.setItem('fmm_ui_fontSize', String(this.font));
	        store.setItem('fmm_ui_solveFontSize', String(this.solveFont));
	        store.setItem('fmm_ui_memoPreviewFont', String(this.memoPreviewFont));
	        store.setItem('fmm_ui_autoAsciiMath', this.autoAsciiMath ? '1' : '0');
	        store.setItem('fmm_ui_mainPadX', String(this.pad));
	        store.setItem('fmm_ui_mainWidth', String(this.width));
	      }
	    };
    UI.apply(); // apply at startup

	    function clamp(n, min, max) { return Math.min(max, Math.max(min, n)); }
	    fontMinus && fontMinus.addEventListener('click', () => { UI.font = clamp(UI.font - 1, 12, 22); UI.apply(); UI.save(); });
	    fontPlus && fontPlus.addEventListener('click', () => { UI.font = clamp(UI.font + 1, 12, 22); UI.apply(); UI.save(); });
	    solveFontMinus && solveFontMinus.addEventListener('click', () => { UI.solveFont = clamp(UI.solveFont - 1, 12, 26); UI.apply(); UI.save(); });
	    solveFontPlus && solveFontPlus.addEventListener('click', () => { UI.solveFont = clamp(UI.solveFont + 1, 12, 26); UI.apply(); UI.save(); });
	    memoFontMinus && memoFontMinus.addEventListener('click', () => { UI.memoPreviewFont = clamp(UI.memoPreviewFont - 1, 12, 32); UI.apply(); UI.save(); });
	    memoFontPlus && memoFontPlus.addEventListener('click', () => { UI.memoPreviewFont = clamp(UI.memoPreviewFont + 1, 12, 32); UI.apply(); UI.save(); });
		    widthNarrow && widthNarrow.addEventListener('click', () => {
		      if (window.matchMedia && window.matchMedia('(max-width: 900px)').matches) {
		        UI.pad = clamp(UI.pad + 4, 8, 24);
		      } else {
		        UI.width = clamp(UI.width - 60, 820, 1600);
		      }
		      UI.apply(); UI.save();
		    });
		    widthWiden && widthWiden.addEventListener('click', () => {
		      if (window.matchMedia && window.matchMedia('(max-width: 900px)').matches) {
		        UI.pad = clamp(UI.pad - 4, 8, 24);
		      } else {
		        UI.width = clamp(UI.width + 60, 820, 1600);
		      }
		      UI.apply(); UI.save();
		    });

	    // === I18N (UI language) =======================================================
	    const I18N = {
	      en: {
	        doc_title: 'Hit Thunder Renderer',
	        ui_language: 'UI language',
	        app_brand_title: 'Hit Thunder Renderer',
	        app_brand_pill: 'Guide viewer Â· practice mode Â· type tabs',
	        // Header / toolbar
	        btn_guide: 'ğŸ“‘ Guide',
	        title_guide_load: 'Load guide file',
	        btn_patch_merge: 'ğŸ§© Merge',
	        title_patch_merge: 'Merge guide patch',
	        btn_bundle_merge: 'ğŸ§© Merge+Save',
	        title_bundle_merge: 'Merge export (fmm_export.json) + patch, then download a new export',
	        btn_edit: 'âœï¸ Edit',
	        title_guide_toggle: 'Show/hide guide input',
	        btn_problems: 'ğŸ“‚ Problems',
	        title_problems_load: 'Load problems file',
	        btn_type_problems: 'ğŸ—‚ Types',
	        title_type_problems: 'Show type problems',
	        btn_solve: 'ğŸ§© Solve',
	        title_solve: 'Solve mode',
	        btn_stats: 'ğŸ“Š Stats',
	        title_stats: 'Stats / LLM status',
	        btn_llm_fill: 'ğŸ¤– Fill',
	        title_llm_fill: 'Fill answers with LLM',
	        btn_chat: 'ğŸ’¬ Chat',
	        title_chat: 'LLM chat',
	        btn_search: 'ğŸ” Search',
	        title_search: 'Search',
	        btn_latex: 'âˆ‘ LaTeX',
	        title_latex: 'LaTeX tools',
	        title_export: 'Export all data',
	        title_import: 'Import',
	        btn_saves: 'ğŸ’¾ Saves',
	        title_saves: 'Manage save slots',
	        btn_clear_all: 'ğŸ§¹ Clear',
	        title_clear_all: 'Delete all saved data (problems, memos, sessions, chat, settings)',
	        btn_rescue: 'ğŸš‘ Rescue',
	        title_rescue: 'Rescue Center',
	        title_font_minus: 'Smaller text',
	        title_font_plus: 'Larger text',
	        title_memo_font_minus: 'Smaller memo preview',
	        title_memo_font_plus: 'Larger memo preview',
	        title_width_narrow: 'Narrower layout',
	        title_width_widen: 'Wider layout',
	        btn_pdf: 'ğŸ“„ Save PDF',
	        title_pdf: 'Save as PDF',
	        title_theme: 'Toggle theme',
	        btn_top: 'Top â†‘',
	        // Guide panel
	        panel_guide_input: 'Guide input',
	        panel_guide_hint: 'Split types by a separator line (=â€¦=). In each type, â€œ## Standard Problemâ€ â†’ first â€œ---â€ is treated as one problem.',
	        placeholder_guide: 'Paste your guide here, then click â€œRenderâ€.',
	        img_hint: 'Paste screenshot supported',
	        btn_render: 'ğŸš€ Render',
	        btn_clear: 'Clear',
	        status_idle: 'Idle',
	        status_cleared: 'Cleared',
	        // Theme labels
	        theme_light: 'ğŸŒ Light',
	        theme_dark: 'ğŸŒ“ Dark'
	      },
	      ko: {
	        doc_title: 'íˆíŠ¸ì¬ë” ë Œë”ëŸ¬',
	        ui_language: 'UI ì–¸ì–´',
	        app_brand_title: 'íˆíŠ¸ì¬ë” ë Œë”ëŸ¬',
	        app_brand_pill: 'ê°€ì´ë“œ ë·°ì–´ Â· ë¬¸ì œí’€ì´ Â· ìœ í˜• íƒ­',
	        // Header / toolbar
	        btn_guide: 'ğŸ“‘ ê°€ì´ë“œ',
	        title_guide_load: 'ê°€ì´ë“œ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°',
	        btn_patch_merge: 'ğŸ§© ë³‘í•©',
	        title_patch_merge: 'ê°€ì´ë“œ íŒ¨ì¹˜ ë³‘í•©',
	        btn_bundle_merge: 'ğŸ§© ì €ì¥ë³‘í•©',
	        title_bundle_merge: 'ì €ì¥íŒŒì¼(fmm_export.json)+íŒ¨ì¹˜ ë³‘í•© â†’ ìƒˆ ì €ì¥íŒŒì¼ ë‹¤ìš´ë¡œë“œ',
	        btn_edit: 'âœï¸ í¸ì§‘',
	        title_guide_toggle: 'ê°€ì´ë“œ ì…ë ¥ í¼ì¹˜ê¸°/ì ‘ê¸°',
	        btn_problems: 'ğŸ“‚ ë¬¸ì œ',
	        title_problems_load: 'ë¬¸ì œ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°',
	        btn_type_problems: 'ğŸ—‚ ìœ í˜• ë¬¸ì œ',
	        title_type_problems: 'ìœ í˜• ë¬¸ì œ ë³´ê¸°',
	        btn_solve: 'ğŸ§© í’€ì´',
	        title_solve: 'ë¬¸ì œ í’€ì´',
	        btn_stats: 'ğŸ“Š í†µê³„',
	        title_stats: 'í†µê³„ / LLM í˜„í™©',
	        btn_llm_fill: 'ğŸ¤– ì±„ìš°ê¸°',
	        title_llm_fill: 'LLMìœ¼ë¡œ ì •ë‹µ ì±„ìš°ê¸°',
	        btn_chat: 'ğŸ’¬ ì±„íŒ…',
	        title_chat: 'LLM ì±„íŒ…',
	        btn_search: 'ğŸ” ê²€ìƒ‰',
	        title_search: 'ê²€ìƒ‰',
	        btn_latex: 'âˆ‘ LaTeX',
	        title_latex: 'LaTeX ë„êµ¬',
	        title_export: 'ëª¨ë“  ë°ì´í„° ë‚´ë³´ë‚´ê¸°',
	        title_import: 'ê°€ì ¸ì˜¤ê¸°',
	        btn_saves: 'ğŸ’¾ ì„¸ì´ë¸Œ',
	        title_saves: 'ì„¸ì´ë¸Œ ìŠ¬ë¡¯(ì„œë¡œ ì„ì´ì§€ ì•Šê²Œ) ê´€ë¦¬',
	        btn_clear_all: 'ğŸ§¹ Clear',
	        title_clear_all: 'ì €ì¥ëœ ëª¨ë“  ë°ì´í„°(ë¬¸ì œë©”ëª¨/ì‹œí—˜ì§€/ê¸°ë¡/ì±„íŒ… ë“±)ë¥¼ ì™„ì „íˆ ì‚­ì œ',
	        btn_rescue: 'ğŸš‘ ë³µêµ¬',
	        title_rescue: 'ë°ì´í„° ë³µêµ¬ ì„¼í„°',
	        title_font_minus: 'ê¸€ì ì‘ê²Œ',
	        title_font_plus: 'ê¸€ì í¬ê²Œ',
	        title_memo_font_minus: 'ì „ì²´ ë©”ëª¨ ë¯¸ë¦¬ë³´ê¸° ê¸€ì ì‘ê²Œ',
	        title_memo_font_plus: 'ì „ì²´ ë©”ëª¨ ë¯¸ë¦¬ë³´ê¸° ê¸€ì í¬ê²Œ',
	        title_width_narrow: 'ì§€ë©´ ì¢ê²Œ',
	        title_width_widen: 'ì§€ë©´ ë„“ê²Œ',
	        btn_pdf: 'ğŸ“„ PDF ì €ì¥',
	        title_pdf: 'PDFë¡œ ì €ì¥',
	        title_theme: 'í…Œë§ˆ ì „í™˜',
	        btn_top: 'ë§¨ ìœ„ë¡œ â†‘',
	        // Guide panel
	        panel_guide_input: 'ê°€ì´ë“œ ì…ë ¥',
	        panel_guide_hint: 'êµ¬ë¶„ì ì¤„(=â€¦=)ë¡œ ìœ í˜• ë¶„ë¦¬, ê° ìœ í˜•ì˜ â€œ## Standard Problemâ€ ~ ì²« â€œ---â€ ê¹Œì§€ë¥¼ ë¬¸ì œë¡œ ì¸ì‹',
	        placeholder_guide: 'ì—¬ê¸°ì— ê°€ì´ë“œë¥¼ ë¶™ì—¬ë„£ì€ í›„, ì•„ë˜ â€˜ë Œë”ë§â€™ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.',
	        img_hint: 'ìŠ¤í¬ë¦°ìƒ· ë¶™ì—¬ë„£ê¸° ì§€ì›',
	        btn_render: 'ğŸš€ ë Œë”ë§',
	        btn_clear: 'ì§€ìš°ê¸°',
	        status_idle: 'ëŒ€ê¸° ì¤‘',
	        status_cleared: 'ì´ˆê¸°í™”ë¨',
	        // Theme labels
	        theme_light: 'ğŸŒ ë¼ì´íŠ¸',
	        theme_dark: 'ğŸŒ“ ë‹¤í¬'
	      }
	    };
	
	    let currentLang = 'en';
	    function detectDefaultLang() {
	      try {
	        const nav = (navigator.languages && navigator.languages[0]) || navigator.language || '';
	        return /^ko\\b/i.test(nav) ? 'ko' : 'en';
	      } catch {
	        return 'en';
	      }
	    }
		    function t(key) {
		      const langTable = I18N[currentLang] || I18N.en;
		      return (langTable && Object.prototype.hasOwnProperty.call(langTable, key))
		        ? langTable[key]
		        : (I18N.en[key] || key);
		    }

		    const UI_KO_TO_EN = {
		      // Common actions
		      'ì €ì¥': 'Save',
		      'ì‚­ì œ': 'Delete',
		      'ë‹«ê¸°': 'Close',
		      'ì—´ê¸°': 'Open',
		      'ìƒˆë¡œê³ ì¹¨': 'Refresh',
		      'ë¹„ìš°ê¸°': 'Clear',
		      'ë³µì‚¬': 'Copy',
		      'ë‹¤ìš´ë¡œë“œ': 'Download',
		      'ì‹œì‘': 'Start',
		      'ì„¤ì •': 'Settings',
		      'ìŠ¤í¬ë¦°ìƒ· ë¶™ì—¬ë„£ê¸° ì§€ì›': 'Paste screenshot supported',
		      'ëª©ë¡ ë³´ê¸°': 'Show list',
		      'ì¹´í…Œê³ ë¦¬ ê²½ë¡œ (ì˜ˆ: Study/PE)': 'Category path (e.g. Study/PE)',
		      'ë©”ëª¨ ì œëª©': 'Memo title',
		      'ìƒˆ ë©”ëª¨ ì‘ì„±': 'New memo',
		      'í˜„ì¬ ë‚´ìš©ì„ ìƒˆ ë©”ëª¨ë¡œ ì €ì¥': 'Save as new memo',
		      'ì¹´í…Œê³ ë¦¬ ë©”ëª¨ ì—…ë°ì´íŠ¸ë¨': 'Category memo updated',
		      'ì¹´í…Œê³ ë¦¬ ë©”ëª¨ ìƒˆë¡œ ì €ì¥ë¨': 'Category memo saved',
		      'ìˆ˜ì •í•  ë©”ëª¨ë¥¼ ëª©ë¡ì—ì„œ ì„ íƒí•˜ì„¸ìš”.': 'Select a memo from the list to edit.',
		      'ì´ ë©”ëª¨ë¥¼ ì¹´í…Œê³ ë¦¬ì—ì„œ ì™„ì „íˆ ì‚­ì œí• ê¹Œìš”?': 'Delete this memo from categories?',
		      'ì „ì²´': 'All',
		      'í¬í•¨': 'Include',
		      'ì œì™¸': 'Exclude',
		      'í’€ì´ ê²½í—˜': 'Attempted',
		      'í’€ì´ ê²½í—˜ ì—†ìŒ': 'Not attempted',
		      'í’€ì´ ê²½í—˜ ìˆìŒ': 'Attempted',
		      'ì„ íƒí•œ íƒœê·¸ëŠ” ORë¡œ ë¬¶ì…ë‹ˆë‹¤.': 'Selected tags are OR-ed.',
		      // Sidebars
		      'ğŸ—’ï¸ ê¸€ë¡œë²Œ ë©”ëª¨': 'ğŸ—’ï¸ Global memo',
		      'ğŸ“Œ ìœ í˜• ë©”ëª¨': 'ğŸ“Œ Type memo',
		      'ğŸ—‚ ìœ í˜• ë¬¸ì œ': 'ğŸ—‚ Type problems',
		      // Chat / search
		      'ğŸ’¬ LLM ì±„íŒ…': 'ğŸ’¬ LLM Chat',
		      'ë°©': 'Rooms',
			      'ë³´ë‚´ê¸°': 'Send',
			      'ë©”ì‹œì§€ ì…ë ¥â€¦ (<problem>, <standard_problem>, <explanation> ì§€ì›)': 'Type a messageâ€¦ (<problem>, <standard_problem>, <explanation> supported)',
			      'ğŸ” ê²€ìƒ‰': 'ğŸ” Search',
			      'ì°¾ê¸°': 'Find',
			      'ê²€ìƒ‰ì–´ ì…ë ¥â€¦': 'Enter a queryâ€¦',
		      'í˜„ì¬ ìœ í˜•': 'This type',
		      'í˜„ì¬ ìœ í˜• ë¬¸ì œ': 'This typeâ€™s problems',
		      'ì „ì²´ ë¬¸ì œ(QIDÂ·ë³¸ë¬¸)': 'All problems (QID + text)',
		      'ì „ì²´ í•´ì„¤': 'All explanations',
		      'ì „ì²´(ë©”ëª¨Â·ì±„íŒ…Â·í•´ì„¤Â·ê°€ì´ë“œ)': 'Everything (memos, chat, explanations, guide)',
		      // Similar
		      'ğŸ§² ìœ ì‚¬ ë¬¸ì œ': 'ğŸ§² Similar problems',
		      'ì„ê³„ì¹˜': 'Threshold',
		      'ìœ ì‚¬ë„ ì¬ê³„ì‚°': 'Rebuild similarity',
		      'ìë™ ê³µìœ (ìœ ì‚¬ë„ ê·¸ë£¹)': 'Auto-share (similarity cluster)',
		      'ë©”ëª¨ ê³µìœ  ON': 'Memo share ON',
		      'ë©”ëª¨ ê³µìœ  OFF': 'Memo share OFF',
		      'íƒœê·¸ ê³µìœ  ON': 'Tag share ON',
		      'íƒœê·¸ ê³µìœ  OFF': 'Tag share OFF',
		      'ìœ ì‚¬ ë¬¸ì œ ëª¨ì•„ë³´ê¸°': 'Collect similar',
		      'ì´ ìœ ì‚¬êµ° ëª¨ì•„ë³´ê¸°(ë³µê¸°)': 'Collect this cluster (review)',
		      // LaTeX tools
		      'âˆ‘ LaTeX ë„êµ¬': 'âˆ‘ LaTeX tools',
		      'ë©”ëª¨ ìë™ë³€í™˜(í‘œì‹œ)': 'Auto convert memos (display)',
		      'ì„ íƒ ë³€í™˜': 'Convert selection',
		      'LaTeX ì…ë ¥': 'Enter LaTeX',
		      'ë¯¸ë¦¬ë³´ê¸°': 'Preview',
		      'ê°„ë‹¨ ë³€í™˜ê¸° (ì˜ˆ: 3*3, 4/3, a=sqrt(3))': 'Quick converter (e.g. 3*3, 4/3, a=sqrt(3))',
		      'ì‹ ì…ë ¥': 'Expression',
		      'LaTeXë¡œ': 'To LaTeX',
		      // Solve
		      'ğŸ§© ë¬¸ì œí’€ì´': 'ğŸ§© Solve',
		      'ì„¸ì…˜': 'Sessions',
		      'ìƒˆ ì°½': 'Popout',
		      'ì ‘ê¸°': 'Collapse',
		      'ì§„í–‰ì¤‘ ì„¸ì…˜': 'Active sessions',
		      'ì„¸ì…˜ì„ ì—´ì–´ë„ ê¸°ì¡´ í’€ì´ê°€ ì‚¬ë¼ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.': 'Opening a session does not delete your previous progress.',
		      'í’€ ë¬¸ì œ ìˆ˜': 'Questions',
		      'UID ë³µì‚¬': 'Copy UID',
		      'ìœ ì‚¬': 'Similar',
		      'â† ì´ì „': 'â† Prev',
		      'ë‹¤ìŒ â†’': 'Next â†’',
		      'ì •ë‹µ/í•´ì„¤ ë³´ê¸°': 'Show answer/explanation',
		      'LLM í•´ì„¤ ì±„ìš°ê¸°': 'Fill explanation (LLM)',
		      'ìë™ì±„ì ': 'Auto-grade',
		      'íƒœê·¸ ë³´ê¸°': 'Show tags',
		      'íƒœê·¸:': 'Tags:',
		      'ë¬¸ì œ ë©”ëª¨': 'Problem memo',
		      'ìƒˆë¡œ ì €ì¥': 'Save new',
		      'ìˆ˜ì • ì €ì¥': 'Save edit',
		      'ë¬¸ì œ ìˆ˜ì •': 'Edit problem',
		      'âœï¸ ë¬¸ì œ ìˆ˜ì •': 'âœï¸ Edit problem',
			      'ê³µì‹ ì •ë‹µ/í•´ì„¤ (ì—†ìœ¼ë©´ ì…ë ¥)': 'Official answer/explanation (optional)',
			      // Export/Rescue (titles)
			      'ë¬¸ì œ/ì •ë‹µ/í•´ì„¤/ë©”ëª¨ TXT ë‹¤ìš´ë¡œë“œ': 'Download TXT (problems/answers/explanations/memos)',
			      'ë°ì´í„° ë³µêµ¬ ì„¼í„°': 'Rescue Center',
			      // Stats
			      'ğŸ“Š í†µê³„ / LLM í˜„í™©': 'ğŸ“Š Stats / LLM status',
			      'ìœ í˜• ì •ë ¬': 'Type order',
			      'ê°€ì´ë“œ ìˆœ': 'Guide order',
			      'ì˜¤ë‹µ ê²½í—˜ ë§ì€ ìˆœ': 'Most wrong',
			      'ìœ í˜•': 'Type',
			      'ê²°í•©': 'Join',
			      'íƒœê·¸': 'Tags',
			      'íƒœê·¸ ì œì™¸': 'Exclude tags',
			      'í¬í•¨(OR)': 'Include (OR)',
			      'ì œì™¸(OR)': 'Exclude (OR)',
			      'ì •ë‹µ ê²½í—˜': 'Correct history',
			      'ë¯¸ì •ë‹µë§Œ': 'Unanswered only',
			      'ì „ì²´ ì„ íƒ': 'Select all',
			      'ì„ íƒ í•´ì œ': 'Clear selection',
			      'LLM ì„¤ì •': 'LLM settings',
			      'ì„ íƒ LLM ì±„ìš°ê¸°': 'Fill selected (LLM)',
			      'ì‹œí—˜ì§€': 'Sheet',
			      'ìƒˆ ì‹œí—˜ì§€': 'New sheet',
			      'ì´ë¦„ ë³€ê²½': 'Rename',
			      'ì‹œí—˜ì§€ ì‚­ì œ': 'Delete sheet',
			      'ì„ íƒ ë¬¸ì œ ì¶”ê°€': 'Add selected',
			      'ì„ íƒ ë¬¸ì œ ì œê±°': 'Remove selected',
			      'UID ì •ë ¬': 'Sort by UID',
			      'í’€ì´ ìˆœì„œ': 'Solve order',
			      'ìœ ì‚¬ë„ ë¬¶ê¸°': 'Group by similarity',
			      'UID/Që²ˆí˜¸ ìˆœ': 'UID/Q order',
			      'ì‹œí—˜ì§€ ì €ì¥ ìˆœ': 'Sheet order',
			      'ì •ë ¬ ì ìš©': 'Apply order',
			      'ì´ ì‹œí—˜ì§€ë§Œ í’€ê¸°': 'Solve this sheet',
			      'ëœë¤ N': 'Random N',
			      'ëœë¤ N í’€ê¸°': 'Solve random N',
			      'í‹€ë¦° ë¬¸ì œë§Œ': 'Wrong only',
			      'ë¬¸ì œ í’€ì´ ê¸°ë¡': 'Problem history',
			      'ì´ ì‹œí—˜ì§€ë¡œ í‘¼ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.': 'No history for this sheet.',
			      'í•„í„° ëª¨ì•„ë³´ê¸°': 'Collect filtered',
			      // Memo share manager
			      'ğŸ”— ë©”ëª¨ ê³µìœ  ê·¸ë£¹ í¸ì§‘': 'ğŸ”— Memo share groups',
			      'ê³µìœ  ê·¸ë£¹': 'Groups',
			      'ê·¸ë£¹ íŒ¨ë„': 'Groups',
			      'ë²ˆí˜¸ íŒ¨ë„': 'Numbers',
			      'ê²°ì†': 'Bind',
			      'ê³µìœ  í•´ì œ': 'Unlink',
			      'ì„ íƒâ†’ìƒˆ ê·¸ë£¹': 'Selection â†’ new group',
			      'ì„ íƒ ê³µìœ  í•´ì œ': 'Unlink selection'
			    };
		    const UI_EN_TO_KO = (() => {
		      const out = {};
		      Object.keys(UI_KO_TO_EN).forEach(k => { out[UI_KO_TO_EN[k]] = k; });
		      return out;
		    })();

		    function translateUiChrome(root) {
		      const base = root || document.body;
		      if (!base || !document?.createTreeWalker) return;
		      const map = (currentLang === 'ko') ? UI_EN_TO_KO : UI_KO_TO_EN;
		      if (!map || typeof map !== 'object') return;
		
		      const isInSkipForText = (el) => {
		        try {
		          if (!el || !el.closest) return false;
		          // Never translate user content areas.
		          if (el.closest('#output, #source, .fmm-modal-preview')) return true;
		          if (el.closest('pre, code, mjx-container')) return true;
		          if (el.closest('textarea, input')) return true;
		          // Problem/markdown content containers (these can contain user text).
		          if (el.closest('.md, #chatMessages, #searchResults, #problemDetail, #solveQuestion')) return true;
		          // Lists and memo bodies can contain arbitrary user text; do not translate there.
		          if (el.closest('.problems-list, .solve-memo-list, .solve-review-list, .share-manager-list')) return true;
		          if (el.closest('#sheetHistoryList, #sheetProblemList, #sheetProblemHistoryList')) return true;
		          return false;
		        } catch {
		          return false;
		        }
		      };
		      const isInUiChrome = (el) => {
		        try {
		          return !!(el && el.closest && el.closest('header, aside, .window, dialog'));
		        } catch {
		          return false;
		        }
		      };
		
		      // Text nodes (buttons/labels/headings/etc.)
		      const walker = document.createTreeWalker(base, NodeFilter.SHOW_TEXT, null);
		      const nodes = [];
		      while (walker.nextNode()) {
		        const node = walker.currentNode;
		        const parent = node?.parentElement;
		        if (!parent) continue;
		        if (!isInUiChrome(parent)) continue;
		        if (isInSkipForText(parent)) continue;
		        const raw = node.nodeValue || '';
		        const trimmed = raw.trim();
		        if (!trimmed) continue;
		        if (!Object.prototype.hasOwnProperty.call(map, trimmed)) continue;
		        nodes.push(node);
		      }
		      nodes.forEach(node => {
		        const raw = node.nodeValue || '';
		        const trimmed = raw.trim();
		        const mapped = map[trimmed];
		        if (!mapped) return;
		        const lead = raw.match(/^\s*/)?.[0] ?? '';
		        const tail = raw.match(/\s*$/)?.[0] ?? '';
		        node.nodeValue = lead + mapped + tail;
		      });
		
		      // Attribute translation (title/aria-label/placeholder)
		      const isInSkipForAttr = (el) => {
		        try {
		          if (!el || !el.closest) return false;
		          if (el.closest('#output, #source, .fmm-modal-preview')) return true;
		          return false;
		        } catch {
		          return false;
		        }
		      };
		      const els = base.querySelectorAll('[title],[aria-label],input[placeholder],textarea[placeholder]');
		      els.forEach(el => {
		        if (!isInUiChrome(el)) return;
		        if (isInSkipForAttr(el)) return;
		        const translateAttr = (attr) => {
		          const v = el.getAttribute(attr);
		          if (!v) return;
		          const key = String(v).trim();
		          if (!Object.prototype.hasOwnProperty.call(map, key)) return;
		          el.setAttribute(attr, map[key]);
		        };
		        translateAttr('title');
		        translateAttr('aria-label');
		        if (el.matches('input[placeholder],textarea[placeholder]')) translateAttr('placeholder');
		      });
		    }
		    function applyI18n() {
		      try { document.documentElement.lang = currentLang; } catch { }
		      try { document.title = t('doc_title'); } catch { }
		      if (langSelect) langSelect.title = t('ui_language');
	
	      // Header brand
	      const brandTitle = document.getElementById('appBrandTitle');
	      if (brandTitle) brandTitle.textContent = t('app_brand_title');
	      const brandPill = document.getElementById('appBrandPill');
	      if (brandPill) brandPill.textContent = t('app_brand_pill');
	
	      // Header buttons
	      if (guideLoadBtn) { guideLoadBtn.textContent = t('btn_guide'); guideLoadBtn.title = t('title_guide_load'); }
	      if (guideMergeBtn) { guideMergeBtn.textContent = t('btn_patch_merge'); guideMergeBtn.title = t('title_patch_merge'); }
	      if (guideMergeBundleBtn) { guideMergeBundleBtn.textContent = t('btn_bundle_merge'); guideMergeBundleBtn.title = t('title_bundle_merge'); }
	      if (guideToggleBtn) { guideToggleBtn.textContent = t('btn_edit'); guideToggleBtn.title = t('title_guide_toggle'); }
	      if (problemsLoadBtn) { problemsLoadBtn.textContent = t('btn_problems'); problemsLoadBtn.title = t('title_problems_load'); }
	      if (problemsToggleBtn) { problemsToggleBtn.textContent = t('btn_type_problems'); problemsToggleBtn.title = t('title_type_problems'); }
	      if (solveToggleBtn) { solveToggleBtn.textContent = t('btn_solve'); solveToggleBtn.title = t('title_solve'); }
	      if (statsToggleBtn) { statsToggleBtn.textContent = t('btn_stats'); statsToggleBtn.title = t('title_stats'); }
	      if (llmFillToggleBtn) { llmFillToggleBtn.textContent = t('btn_llm_fill'); llmFillToggleBtn.title = t('title_llm_fill'); }
	      if (chatToggleBtn) { chatToggleBtn.textContent = t('btn_chat'); chatToggleBtn.title = t('title_chat'); }
	      if (searchToggleBtn) { searchToggleBtn.textContent = t('btn_search'); searchToggleBtn.title = t('title_search'); }
	      if (latexToolToggleBtn) { latexToolToggleBtn.textContent = t('btn_latex'); latexToolToggleBtn.title = t('title_latex'); }
	      if (exportBtn) exportBtn.title = t('title_export');
	      if (importBtn) importBtn.title = t('title_import');
	      if (saveManagerToggleBtn) { saveManagerToggleBtn.textContent = t('btn_saves'); saveManagerToggleBtn.title = t('title_saves'); }
	      if (hardClearBtn) { hardClearBtn.textContent = t('btn_clear_all'); hardClearBtn.title = t('title_clear_all'); }
	      if (pdfBtn) { pdfBtn.textContent = t('btn_pdf'); pdfBtn.title = t('title_pdf'); }
	      if (themeToggle) themeToggle.title = t('title_theme');
	      if (scrollTopBtn) scrollTopBtn.textContent = t('btn_top');
	
	      // Small guide panel header
	      const gpTitle = document.getElementById('guidePanelTitle');
	      if (gpTitle) gpTitle.textContent = t('panel_guide_input');
	      const gpHint = document.getElementById('guidePanelHint');
	      if (gpHint) gpHint.textContent = t('panel_guide_hint');
	      if (sourceEl) sourceEl.placeholder = t('placeholder_guide');
	      const imgHint = document.getElementById('guideImgHint');
	      if (imgHint) imgHint.textContent = t('img_hint');
	      if (renderBtn) renderBtn.textContent = t('btn_render');
	      if (clearBtn) clearBtn.textContent = t('btn_clear');
	
	      // Status pill: only translate known idle/cleared states (avoid clobbering dynamic messages)
	      if (statusEl) {
	        const s = String(statusEl.textContent || '').trim();
	        if (s === 'ëŒ€ê¸° ì¤‘' || s === 'Idle') statusEl.textContent = t('status_idle');
	        if (s === 'ì´ˆê¸°í™”ë¨' || s === 'Cleared') statusEl.textContent = t('status_cleared');
		      }
		
		      // Theme label depends on language
		      try { if (typeof updateThemeLabel === 'function') updateThemeLabel(); } catch { }
		      // Best-effort: translate remaining static chrome strings (buttons/labels) without touching user content.
		      try { translateUiChrome(document.body); } catch { }
		    }
		    (function initLang() {
		      let lang = store.getItem('fmm_ui_lang');
		      if (!lang) lang = detectDefaultLang();
		      if (lang !== 'ko' && lang !== 'en') lang = 'en';
		      currentLang = lang;
		      if (langSelect) langSelect.value = lang;
		      applyI18n();
		      langSelect?.addEventListener('change', async () => {
		        const next = (langSelect.value === 'ko') ? 'ko' : 'en';
		        if (next === currentLang) return;
		        const prev = currentLang;
		        currentLang = next;
		        store.setItem('fmm_ui_lang', next);
		        applyI18n();
		        // If the current guide is still the untouched auto-loaded example, swap it to the selected language.
		        try {
		          const isExample = (store.getItem('fmm_example_autoloaded') || '0') === '1';
		          if (!isExample) return;
		          const expectedHash = String(store.getItem('fmm_example_hash') || '');
		          if (!expectedHash) return;
		          const raw = String(store.getItem('fmm_source') || '');
		          if (!raw || !raw.trim()) return;
		          if (fnv1a32(raw) !== expectedHash) return; // user edited -> do not overwrite
		
		          const nextText = await fetchExampleGuide(currentLang);
		          if (!nextText || !nextText.trim()) return;
		          sourceEl.value = maskDataImages(nextText, sourceEl);
		          store.setItem('fmm_source', nextText);
		          store.setItem('fmm_example_lang', currentLang);
		          store.setItem('fmm_example_hash', fnv1a32(nextText));
		          try { render(); } catch { }
		        } catch { }
		      });
		    })();

	    // ADD: keep raw guide text in session store (export/import handles durability)
	    // NOTE: textarea displays a masked version for ergonomics; storage keeps full data URIs.
	    sourceEl.value = maskDataImages(store.getItem('fmm_source') || '', sourceEl);
    // Respect persisted user preference; default to collapsed if guide exists
    (function initGuidePanelCollapsed() {
      const gp = sourceEl.closest('.panel'); if (!gp) return;
      const pref = store.getItem('fmm_guide_collapsed');
      const hasGuide = !!(sourceEl.value || '').trim();
      const shouldCollapse = (pref === '1') || (pref === null && hasGuide);
      gp.classList.toggle('collapsed', !!shouldCollapse);
    })();
    sourceEl.addEventListener('input', () => store.setItem('fmm_source', unmaskDataImages(sourceEl.value, sourceEl)));

    // Theme
    (function initTheme() {
      const saved = store.getItem('fmm_theme') || 'dark';
      document.body.dataset.theme = saved;
      updateThemeLabel();
    })();
	    function updateThemeLabel() {
	      const isLight = document.body.dataset.theme === 'light';
	      themeToggle.textContent = isLight ? t('theme_light') : t('theme_dark');
	    }
    themeToggle.addEventListener('click', () => {
      document.body.dataset.theme = document.body.dataset.theme === 'light' ? 'dark' : 'light';
      store.setItem('fmm_theme', document.body.dataset.theme);
      updateThemeLabel();
    });
    scrollTopBtn.addEventListener('click', (e) => { e.preventDefault(); window.scrollTo({ top: 0, behavior: 'smooth' }); });

    // Auto-hide header: handled by initHeaderHover IIFE
    // (Unified to avoid duplicate event handlers)

    // Progress bar
    function updateProgressBar() {
      const h = document.documentElement;
      const denom = Math.max(1, (h.scrollHeight - h.clientHeight));
      const perc = (h.scrollTop) / denom * 100;
      if (progressBar) progressBar.style.width = `${Math.max(0, Math.min(100, perc))}%`;
    }
    document.addEventListener('scroll', updateProgressBar, { passive: true });
    window.addEventListener('resize', updateProgressBar, { passive: true });
    updateProgressBar();

    // Helpers
    // Allow pasted screenshot images (data:image/...;base64,...) to survive sanitization.
    // NOTE: Restrict to common raster formats (exclude SVG for safety).
    (function initPurifyAllowDataImages() {
      try {
        if (!window.DOMPurify || DOMPurify._fmmDataImgHook) return;
        DOMPurify._fmmDataImgHook = true;
        DOMPurify.addHook('uponSanitizeAttribute', (node, data) => {
          if (!node || !data) return;
          if (data.attrName !== 'src') return;
          const tag = (node.tagName || '').toUpperCase();
          if (tag !== 'IMG') return;
          const v = String(data.attrValue || '');
          if (/^data:image\/(?:png|gif|jpe?g|webp|bmp);base64,/i.test(v)) {
            data.keepAttr = true;
          }
        });
      } catch { }
    })();
    function fixStrongCloseSpacingInHtml(html) {
      if (!html || typeof html !== 'string') return html || '';
      try {
        return html.replace(/<\/(strong|b)>(?=[\p{L}\p{N}_])/gu, '</$1> ');
      } catch {
        return html.replace(/<\/(strong|b)>(?=[0-9A-Za-z\uAC00-\uD7A3_])/g, '</$1> ');
      }
    }

    function ensureSpaceAfterStrong(root) {
      if (!root || !root.querySelectorAll) return;
      const isWord = (ch) => /[0-9A-Za-z\uAC00-\uD7A3\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFF10-\uFF5A_]/.test(ch || '');
      root.querySelectorAll('strong,b').forEach(el => {
        const next = el.nextSibling;
        if (!next) return;
        if (next.nodeType === Node.TEXT_NODE) {
          const t = next.nodeValue || '';
          if (t[0] && !/^\s/.test(t) && isWord(t[0])) {
            el.after(document.createTextNode(' '));
          }
          return;
        }
        if (next.nodeType === Node.ELEMENT_NODE) {
          const fc = next.firstChild;
          if (fc && fc.nodeType === Node.TEXT_NODE) {
            const t = fc.nodeValue || '';
            if (t[0] && !/^\s/.test(t) && isWord(t[0])) {
              el.after(document.createTextNode(' '));
            }
          }
        }
      });
    }

	    function applyInlineBoldMarkers(root) {
	      if (!root || !root.querySelectorAll || !document?.createTreeWalker) return;
	      const nodes = [];
	      const walker = document.createTreeWalker(
	        root,
	        NodeFilter.SHOW_TEXT,
	        {
	          acceptNode(node) {
	            const text = node.nodeValue || '';
	            if (text.indexOf('**') === -1 && text.indexOf('__') === -1) return NodeFilter.FILTER_SKIP;
	            const p = node.parentElement;
	            if (!p) return NodeFilter.FILTER_SKIP;
	            const tag = p.tagName;
	            if (tag === 'CODE' || tag === 'PRE' || tag === 'TEXTAREA' || tag === 'SCRIPT' || tag === 'STYLE') {
	              return NodeFilter.FILTER_SKIP;
	            }
	            if (p.closest && p.closest('mjx-container')) return NodeFilter.FILTER_SKIP;
	            return NodeFilter.FILTER_ACCEPT;
	          }
	        }
	      );
	      let n;
	      while ((n = walker.nextNode())) nodes.push(n);

	      function buildInlineBoldFragment(text) {
	        const s = String(text || '');
	        const frag = document.createDocumentFragment();
	        let i = 0;
	        while (i < s.length) {
	          const nextStar = s.indexOf('**', i);
	          const nextUnd = s.indexOf('__', i);
	          let next = -1;
	          let marker = '';
	          if (nextStar !== -1 && (nextUnd === -1 || nextStar < nextUnd)) { next = nextStar; marker = '**'; }
	          else if (nextUnd !== -1) { next = nextUnd; marker = '__'; }
	          if (next === -1) {
	            if (i < s.length) frag.appendChild(document.createTextNode(s.slice(i)));
	            break;
	          }
	          if (next > i) frag.appendChild(document.createTextNode(s.slice(i, next)));
	          const contentStart = next + 2;
	          const first = s[contentStart] || '';
	          if (!first || /^\s$/.test(first)) {
	            frag.appendChild(document.createTextNode(marker));
	            i = contentStart;
	            continue;
	          }
	          const close = s.indexOf(marker, contentStart);
	          if (close === -1) {
	            frag.appendChild(document.createTextNode(s.slice(next)));
	            break;
	          }
	          const inner = s.slice(contentStart, close);
	          const strong = document.createElement('strong');
	          strong.textContent = inner;
	          frag.appendChild(strong);
	          i = close + 2;
	        }
	        return frag;
	      }

	      nodes.forEach(node => {
	        const text = node.nodeValue || '';
	        const frag = buildInlineBoldFragment(text);
	        if (
	          frag.childNodes.length === 1 &&
	          frag.firstChild.nodeType === Node.TEXT_NODE &&
	          frag.firstChild.nodeValue === text
	        ) return;
	        node.replaceWith(...frag.childNodes);
	      });
	    }

    function sanitize(html) {
      const clean = DOMPurify.sanitize(html, { ADD_ATTR: ['target'] });
      return fixStrongCloseSpacingInHtml(clean);
    }
    function escapeHtml(s) {
      return String(s || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

			    // Lossless repair: never "deletes" unknown tokens from stored/raw text.
			    // It only performs safe restorations (e.g., year ranges).
				    function repairObjectObjectArtifactsInText(text) {
				      let s = String(text || '');
				      if (!s) return s;
				      if (s.indexOf('[object Object]') === -1) return s;
			      // Common corruption: date ranges where "~" got stringified from an object.
			      // Examples:
			      // - "1055[object Object]1101"  -> "1055~1101"
			      // - "?[object Object]679"      -> "?~679"
			      // - "1158[object Object]?"     -> "1158~?"
				      // NOTE: avoid swallowing newlines (can break markdown structure like lists).
				      s = s.replace(/(\d{1,4}|\?)[\u00A0 \t]*\[object Object\][\u00A0 \t]*(\d{1,4}|\?)/g, '$1~$2');
	
			      // More general: if it sits between two non-space chars, treat it as a tilde.
			      // This prevents lossy deletions that cause concatenation and "missing" text.
			      s = s.replace(/(\S)[\u00A0 \t]*\[object Object\][\u00A0 \t]*(?=\S)/g, '$1~');
	
			      // Final fallback: preserve a separator instead of showing the token.
			      s = s.replace(/\[object Object\]/g, '~');
				      return s;
				    }
	
			    // Display-only sanitization: ensure the UI never shows "[object Object]".
			    // If we can't confidently restore the original token, preserve a separator so text isn't merged.
				    function sanitizeObjectArtifactsForDisplay(text) {
				      let s = repairObjectObjectArtifactsInText(text);
				      if (!s) return s;
	
		      // Heuristic: if a year range token was already lost (e.g., "13521409"), restore "~" for plausible year ranges.
		      // Guard: both parts must be plausible years and the span must be reasonable.
		      s = s.replace(/(\d{4})(\d{4})/g, (m, a, b) => {
		        const ya = parseInt(a, 10);
		        const yb = parseInt(b, 10);
		        if (!Number.isFinite(ya) || !Number.isFinite(yb)) return m;
		        if (ya < 500 || ya > 2100) return m;
		        if (yb < 500 || yb > 2100) return m;
		        if (yb < ya) return m;
		        if ((yb - ya) > 250) return m;
		        return `${a}~${b}`;
		      });
	
				      if (s.indexOf('[object Object]') === -1) return s;
				      // Final safety: don't delete (lossy), but prevent token from appearing.
				      // Keep surrounding whitespace as-is to avoid breaking markdown structure.
				      return s.replace(/\[object Object\]/g, '~');
				    }

	    // Robust text coercion: prevents "[object Object]" rendering when inputs are
	    // content-part arrays/objects (LLM outputs, imported JSON variants, etc).
		    function coerceText(value) {
		      if (value == null) return '';
		      if (typeof value === 'string') return repairObjectObjectArtifactsInText(value);
		      if (Array.isArray(value)) {
		        const parts = value.map(v => ({ raw: v, text: coerceText(v) }));
		        const isPlausibleYearStr = (s) => {
		          const m = String(s || '').match(/^(\d{3,4}|\?)/);
		          if (!m) return null;
		          const t = m[1];
		          if (t === '?') return '?';
		          const n = parseInt(t, 10);
		          if (!Number.isFinite(n)) return null;
		          return (n >= 500 && n <= 2100) ? t : null;
		        };
		        const lastPlausibleYearIn = (s) => {
		          const m = String(s || '').match(/(\d{3,4}|\?)$/);
		          if (!m) return null;
		          const t = m[1];
		          if (t === '?') return '?';
		          const n = parseInt(t, 10);
		          if (!Number.isFinite(n)) return null;
		          return (n >= 500 && n <= 2100) ? t : null;
		        };
		        let out = '';
		        for (let i = 0; i < parts.length; i++) {
		          const t = parts[i].text || '';
		          if (t) { out += t; continue; }
		          const raw = parts[i].raw;
		          const isObjToken = raw && typeof raw === 'object';
		          if (!isObjToken) continue;
		          const prevY = lastPlausibleYearIn(out);
		          const nextY = isPlausibleYearStr(parts[i + 1]?.text || '');
		          if (prevY && nextY) out += '~';
		          else out += ' ';
		        }
		        return repairObjectObjectArtifactsInText(out);
		      }
		      if (typeof value === 'object') {
		        if (typeof value.text === 'string') return repairObjectObjectArtifactsInText(value.text);
		        if (typeof value.t === 'string') return repairObjectObjectArtifactsInText(value.t);
		        if (typeof value.content === 'string') return repairObjectObjectArtifactsInText(value.content);
	        if (typeof value.value === 'string') return repairObjectObjectArtifactsInText(value.value);
	        if (Array.isArray(value.parts)) return value.parts.map(coerceText).join('');
	        if (Array.isArray(value.content)) return value.content.map(coerceText).join('');
	        if (typeof value.textContent === 'string') return repairObjectObjectArtifactsInText(value.textContent);
        // Numeric-indexed objects (rare): {0:"...",1:"..."}
        try {
          const keys = Object.keys(value).filter(k => /^\d+$/.test(k)).sort((a, b) => Number(a) - Number(b));
          if (keys.length) return keys.map(k => coerceText(value[k])).join('');
        } catch { }
        try {
          const s = String(value);
          if (s && s !== '[object Object]') return s;
        } catch { }
        // Last resort (capped): show JSON instead of dropping content.
        try {
          const json = JSON.stringify(value);
          if (json && json !== '{}' && json.length <= 4000) return json;
        } catch { }
        return '';
      }
		      return String(value);
		    }

			    // Last-resort UI guard: if any "[object Object]" survived upstream, repair it in the DOM
			    // right before MathJax runs (prevents broken visible output without mutating stored text).
			    function repairObjectArtifactsInDom(root) {
		      const base = root || document.body;
		      if (!base || !document?.createTreeWalker) return;
		      const nodes = [];
		      const walker = document.createTreeWalker(base, NodeFilter.SHOW_TEXT, null);
		      while (walker.nextNode()) {
		        const node = walker.currentNode;
		        const txt = node?.nodeValue || '';
		        if (!txt || txt.indexOf('[object Object]') === -1) continue;
		        const el = node.parentElement;
		        if (!el) continue;
		        const tag = el.tagName;
		        if (tag === 'SCRIPT' || tag === 'STYLE' || tag === 'TEXTAREA' || tag === 'PRE' || tag === 'CODE') continue;
		        if (el.closest && el.closest('script, style, textarea, pre, code, mjx-container')) continue;
		        nodes.push(node);
		      }
		      nodes.forEach(node => {
		        const before = node.nodeValue || '';
		        const after = sanitizeObjectArtifactsForDisplay(before);
		        if (after !== before) node.nodeValue = after;
		      });
			    }

	    function escapeTildeForDisplay(src) {
	      // Display-only: prevent markdown extensions / parsers from interpreting '~'.
	      // Do NOT mutate stored raw text; this is render-time only.
	      return String(src || '').replace(/~/g, '&#126;');
	    }

				    // Centralized markdown rendering with explicit order to avoid behavioral drift.
				    function renderMarkdown(text, markedOpts, mode) {
				      let src = coerceText(text);
				      if (!src) return '';
				      // Never show "[object Object]" artifacts in the UI (display-only).
				      try { src = sanitizeObjectArtifactsForDisplay(src); } catch { }
		      // Optional: render-time ASCIIâ†’LaTeX conversion for memos (does not mutate saved text).
		      try {
		        if (markedOpts && markedOpts.autoAsciiMath && typeof UI !== 'undefined' && UI.autoAsciiMath) {
		          src = autoAsciiMathTransform(src);
			        }
		      } catch { }
		      // Security: always parse markdown first, then sanitize the produced HTML.
		      // (sanitizeâ†’parse can miss HTML-creating markdown vectors like javascript: links)
		      src = escapeTildeForDisplay(src);
		      return sanitize(marked.parse(src, markedOpts));
		    }

    // NOTE: sanitizeLatex/escapeLatexContent are defined once (near Markdown setup).

    const mjxTexMap = new WeakMap();
    const mjxDisplayMap = new WeakMap();

    function normalizeMathForTypeset(text) {
      let out = String(text || '');
      if (!out) return out;
      // FIX: common double-wrapping mistakes (e.g., \[\[...\]\]) should still render.
      out = out.replace(/\\\[\\\[/g, '\\[').replace(/\\\]\\\]/g, '\\]');
      out = out.replace(/\\\(\\\(/g, '\\(').replace(/\\\)\\\)/g, '\\)');

      // FIX: some pipelines end up with double-escaped commands inside math (\frac -> \\frac).
      // Normalize at render-time only so MathJax receives valid TeX.
      const hasMathDelim =
        out.indexOf('$') !== -1 ||
        out.indexOf('\\(') !== -1 ||
        out.indexOf('\\[') !== -1 ||
        out.indexOf('\\\\(') !== -1 ||
        out.indexOf('\\\\[') !== -1;
      if (hasMathDelim && out.indexOf('\\\\') !== -1) {
        // Only collapse when it clearly starts a TeX command name.
        out = out.replace(/\\\\(?=[A-Za-z])/g, '\\');
      }
      return out;
    }

	    function preprocessMathForTypeset(root) {
	      const base = root || document.body;
	      if (!base || !document?.createTreeWalker) return;
	      // Hangul + CJK + Kana: treat as natural-language labels inside math
	      const LOCALE_RE = /[\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3\uA960-\uA97F\uD7B0-\uD7FF\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]/;
	      const nodes = [];
	      const walker = document.createTreeWalker(base, NodeFilter.SHOW_TEXT, null);
	      while (walker.nextNode()) {
	        const node = walker.currentNode;
	        const txt = node?.nodeValue || '';
        if (!txt) continue;
        const hasMathSignal =
          txt.indexOf('$') !== -1 ||
          txt.indexOf('\\(') !== -1 ||
          txt.indexOf('\\[') !== -1 ||
          txt.indexOf('\\\\(') !== -1 ||
          txt.indexOf('\\\\[') !== -1;
        const hasEscapedCommand = /\\\\[A-Za-z]/.test(txt);
        const hasDoubleWrappedDelim =
          txt.indexOf('\\[\\[') !== -1 ||
          txt.indexOf('\\]\\]') !== -1 ||
          txt.indexOf('\\(\\(') !== -1 ||
          txt.indexOf('\\)\\)') !== -1;
	        if (!hasMathSignal && !hasEscapedCommand && !hasDoubleWrappedDelim) continue;
	
	        // Fast path: if nothing to do, skip.
	        if (!LOCALE_RE.test(txt) && !hasEscapedCommand && !hasDoubleWrappedDelim) continue;
	        const el = node.parentElement;
	        if (!el) continue;
	        const tag = el.tagName;
        if (tag === 'SCRIPT' || tag === 'STYLE' || tag === 'TEXTAREA' || tag === 'PRE' || tag === 'CODE') continue;
        if (el.closest && el.closest('script, style, textarea, pre, code, mjx-container')) continue;
        nodes.push(node);
      }
	      nodes.forEach(node => {
	        const before = node.nodeValue || '';
	        let after = before;
	        // 1) Text labels inside sub/sup -> \text{...}
	        try { after = wrapTextLabelsInMathDelimiters(after); } catch { }
	        // 2) Korean inside math -> \text{...}
	        try { after = wrapKoreanInMathDelimiters(after); } catch { }
	        // 3) Normalize common escaping mistakes so MathJax can render.
	        try { after = normalizeMathForTypeset(after); } catch { }
	        if (after !== before) node.nodeValue = after;
	      });
    }

	    function typesetMath(root) {
	      // ideology: render math right where users read & edit; no reloads, no separate views
	      const run = () => {
	        if (window.MathJax && typeof MathJax.typesetPromise === 'function') {
	          // Safety net: prevent any lingering "[object Object]" artifacts from reaching the UI.
	          try { repairObjectArtifactsInDom(root); } catch { }
	          // Ensure Korean inside math gets wrapped as \text{...} even when markdown parsing is not involved.
	          // (Example: ë³´ê¸°/ë²„íŠ¼ ë‚´ë¶€ í…ìŠ¤íŠ¸ ë“±)
	          try { preprocessMathForTypeset(root); } catch { }
	          MathJax.typesetPromise(root ? [root] : undefined).then(() => {
	            // annotate rendered math so copy â†’ ì›ë³¸ TeX
            try {
              const doc = MathJax.startup?.document;
              const items = (doc && typeof doc.getMathItemsWithin === 'function')
                ? doc.getMathItemsWithin(root || document.body)
                : (doc?.math || []);
              (items || []).forEach(mi => {
                const base = mi?.typesetRoot;
                if (!base) return;
                const container = (base.closest && base.closest('mjx-container')) ? base.closest('mjx-container') : base;
                const tex = mi?.math || '';
                if (!tex) return;
                try {
                  container.setAttribute('data-tex', tex);
                  container.setAttribute('data-display', mi.display ? 'block' : 'inline');
                  mjxTexMap.set(container, tex);
                  mjxDisplayMap.set(container, !!mi.display);
                  // affordance
                  if (container.style) container.style.cursor = 'copy';
                } catch { }
              });
            } catch { }
          }).catch(() => { });
        }
      };
      setTimeout(run, 0);
    }

    // LaTeX copy helper: click rendered math â†’ copy raw TeX
    function copyPlainText(text) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text);
        } else {
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.style.position = 'fixed';
          ta.style.opacity = '0';
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          ta.remove();
        }
      } catch {
        // ignore copy failures
      }
    }
    function getTexForMjx(mjx) {
      if (!mjx) return '';
      const texAttr = mjx.getAttribute('data-tex') || '';
      const texMapVal = mjxTexMap.get ? (mjxTexMap.get(mjx) || '') : '';
      let tex = texAttr || texMapVal;
      if (tex) return tex;
      // Fallback: query MathJax document for this container
      try {
        const doc = MathJax?.startup?.document;
        if (doc && typeof doc.getMathItemsWithin === 'function') {
          const items = doc.getMathItemsWithin(mjx) || [];
          const mi = items[0];
          tex = mi?.math || '';
          if (tex) {
            mjx.setAttribute('data-tex', tex);
            mjxTexMap.set(mjx, tex);
          }
        }
      } catch { }
      return tex || '';
    }
    document.addEventListener('click', (e) => {
      // FIX: Request #10 - Click-to-Copy without Alt key (user preference)
      const mjx = e.target.closest('mjx-container');
      if (!mjx) return;
      // Do not hijack clicks meant for interactive UI (e.g. choice selection).
      if (mjx.closest('button, a, input, textarea, select, label, .choice-btn')) return;
      const tex = getTexForMjx(mjx);
      if (!tex) return;

      // If clicking inside a text selection, do not trigger (let browser handle selection)
      const sel = window.getSelection();
      if (sel && sel.toString().length > 0) return;

      e.preventDefault();
      e.stopPropagation(); // prevent bubbling to other handlers
      const displayAttr = String(mjx.getAttribute('data-display') || mjx.getAttribute('display') || '').toLowerCase();
      const isDisplay = displayAttr === 'block' || displayAttr === 'true' || displayAttr === '1' || (mjxDisplayMap.get ? !!mjxDisplayMap.get(mjx) : false);
      const wrapped = isDisplay ? `$$${tex}$$` : `$${tex}$`;
      copyPlainText(wrapped);
      if (statusEl) statusEl.textContent = 'LaTeX ì›ë¬¸ì´ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.';
    });

    // === ADD: safe title normalization (handles "&amp;" vs "&", spaces, case) ==
    function decodeEntities(s) {
      const ta = document.createElement('textarea'); ta.innerHTML = String(s || '');
      return ta.value;
    }
    function normalizeTitle(s) {
      return decodeEntities(String(s || ''))
        .replace(/\s+/g, ' ')
        .trim()
        .toLowerCase();
    }

    function formatAnswerInProblem(htmlStr) {
      // Try to wrap the "Answer:" (or â€œì •ë‹µâ€) paragraph with .answer box
      // Pattern 1: <p><strong>Answer:</strong> ...</p>
      htmlStr = htmlStr.replace(
        /<p>\s*(?:<strong>\s*Answer:\s*<\/strong>|Answer:)\s*([^<]+?)\s*<\/p>/i,
        (_m, ans) => `<div class="answer"><span class="badge">ì •ë‹µ</span><span class="ans-text">${ans.trim()}</span></div>`
      );
      // Variant with Korean "Answer" remains as-is; most inputs have English "Answer:"
      return htmlStr;
    }

    // ADD: ë³´ê¸°(â‘ ~â‘³) ì•ì— ì¤„ë°”ê¿ˆ ì¶”ê°€ (Answer ë°•ìŠ¤ ì œì™¸)
	    function insertBreaksBeforeCircled(root) {
	      const circledRe = /([â‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨â‘©â‘ªâ‘«â‘¬â‘­â‘®â‘¯â‘°â‘±â‘²â‘³â€ââ‚âƒâ„â…â†â‡âˆâ‰âŠâ‹âŒâââââ‘â’â“])/g;

	      const walker = document.createTreeWalker(
	        root,
	        NodeFilter.SHOW_TEXT,
	        {
	          acceptNode(node) {
	            if (!node.nodeValue) return NodeFilter.FILTER_SKIP;
	            // ì •ë‹µ ë°•ìŠ¤ ë‚´ë¶€ëŠ” ê±´ë„ˆëœ€
	            if (node.parentElement && node.parentElement.closest('.answer')) return NodeFilter.FILTER_SKIP;
	            // í’€ì´ ë³´ê¸° ë²„íŠ¼ ë‚´ë¶€ëŠ” ì›í˜• ìˆ«ìë¥¼ ê·¸ëŒ€ë¡œ ë‘”ë‹¤
	            if (node.parentElement && node.parentElement.closest('.choice-btn')) return NodeFilter.FILTER_SKIP;
	            // MathJax ê²°ê³¼ë¬¼ì€ ê±´ë“œë¦¬ì§€ ì•ŠìŒ
	            if (node.parentElement && node.parentElement.closest('mjx-container')) return NodeFilter.FILTER_SKIP;
	            // ì½”ë“œ/í”„ë¦¬ í¬ë§·ì€ ê±´ë„ˆëœ€
	            const tag = node.parentElement && node.parentElement.tagName;
	            if (tag === 'CODE' || tag === 'PRE') return NodeFilter.FILTER_SKIP;

	            circledRe.lastIndex = 0;
	            return circledRe.test(node.nodeValue) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
	          }
	        }
	      );

      const nodes = [];
      let n;
      while ((n = walker.nextNode())) nodes.push(n);

	      nodes.forEach(node => {
	        const text = String(node.nodeValue || '');
	        circledRe.lastIndex = 0;
	        let m;
	        let last = 0;
	        const frag = document.createDocumentFragment();
	        while ((m = circledRe.exec(text))) {
	          const idx = m.index;
	          if (idx > last) frag.appendChild(document.createTextNode(text.slice(last, idx)));
	          frag.appendChild(document.createElement('br'));
	          frag.appendChild(document.createTextNode(m[1] || m[0]));
	          last = idx + (m[0] || '').length;
	        }
	        if (last === 0) return;
	        if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
	        node.replaceWith(...frag.childNodes);
	      });
	    }

	    function stripAnswerEmphasis(text) {
	      // Remove bold markers only when they wrap a choice marker (e.g., **â‘¢ 240**, **3) 240**)
	      return coerceText(text).replace(
	        /\*\*(\s*(?:[â‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨â‘©â‘ªâ‘«â‘¬â‘­â‘®â‘¯â‘°â‘±â‘²â‘³â€ââ‚âƒâ„â…â†â‡âˆâ‰âŠâ‹âŒâââââ‘â’â“]|(?:[1-9]|1\d|20)[\).])\s*[^*]+?)\*\*/g,
	        '$1'
	      );
		    }

	    function splitAnswerChoiceBlock(text) {
	      const t = coerceText(text).replace(/\r\n/g, '\n');
	      const ENC = ['â‘ ', 'â‘¡', 'â‘¢', 'â‘£', 'â‘¤', 'â‘¥', 'â‘¦', 'â‘§', 'â‘¨', 'â‘©', 'â‘ª', 'â‘«', 'â‘¬', 'â‘­', 'â‘®', 'â‘¯', 'â‘°', 'â‘±', 'â‘²', 'â‘³'];
	      const CIRCLED = 'â‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨â‘©â‘ªâ‘«â‘¬â‘­â‘®â‘¯â‘°â‘±â‘²â‘³â€ââ‚âƒâ„â…â†â‡âˆâ‰âŠâ‹âŒâââââ‘â’â“';
	      const markerRe = new RegExp(`([${CIRCLED}])|(^|[^\\dÂ·ã†])([1-9]|1\\d|20)[\\). ]`, 'gm');
	      const prevNonSpaceIndex = (s, fromExclusive) => {
	        let i = fromExclusive - 1;
	        while (i >= 0) {
	          const ch = s[i];
	          if (ch && !/\s/.test(ch)) return i;
	          i--;
	        }
	        return -1;
	      };
	      const isMiddleDotNumberContext = (s, markerStart) => {
	        const dotIdx = prevNonSpaceIndex(s, markerStart);
	        if (dotIdx < 0) return false;
	        const dot = s[dotIdx];
	        if (dot !== 'Â·' && dot !== 'ã†') return false;
	        const numIdx = prevNonSpaceIndex(s, dotIdx);
	        if (numIdx < 0) return false;
	        return /[0-9ï¼-ï¼™]/.test(s[numIdx] || '');
	      };

	      const markers = [];
	      let m;
	      while ((m = markerRe.exec(t))) {
	        if (m[1]) {
	          if (isMiddleDotNumberContext(t, m.index)) continue;
	          markers.push({ start: m.index, end: m.index + m[1].length, mark: m[1] });
	          continue;
	        }
	        const prefix = m[2] || '';
	        const n = parseInt(m[3], 10);
	        const start = m.index + prefix.length;
	        const end = m.index + m[0].length;
	        if (isMiddleDotNumberContext(t, start)) continue;
	        const mark = (n >= 1 && n <= ENC.length) ? ENC[n - 1] : String(n);
	        markers.push({ start, end, mark });
	      }

	      markers.sort((a, b) => (a.start - b.start) || (a.end - b.end));
	      const uniq = [];
	      markers.forEach(mk => {
	        const prev = uniq[uniq.length - 1];
	        if (prev && mk.start === prev.start) {
	          // Prefer longer token (e.g., "1) " over "1)")
	          if (mk.end > prev.end) uniq[uniq.length - 1] = mk;
	          return;
	        }
	        if (prev && mk.start < prev.end) return; // overlap
	        uniq.push(mk);
	      });

	      if (!uniq.length) return { prefix: '', items: [], hasMarkers: false };
	      const prefix = t.slice(0, uniq[0].start).trim();
	      const items = uniq.map((mk, idx) => {
	        const next = uniq[idx + 1];
	        const raw = t.slice(mk.end, next ? next.start : t.length);
	        return { mark: mk.mark, text: raw.trim() };
	      });
	      return { prefix, items, hasMarkers: true };
	    }

	    function normalizeQuestionAndChoices(questionText, answerChoices) {
	      const q0 = coerceText(questionText);
	      const a0 = coerceText(answerChoices);
	      const aStrip = stripAnswerEmphasis(a0).trim();
	      if (!aStrip) return { question_text: q0, answer_choices: a0, changed: false };

	      const parsed = splitAnswerChoiceBlock(aStrip);
	      if (!parsed || !parsed.hasMarkers || !Array.isArray(parsed.items) || parsed.items.length === 0) {
	        return { question_text: q0, answer_choices: a0, changed: false };
	      }

	      const prefix = coerceText(parsed.prefix).trim();
	      const rebuiltChoices = (parsed.items || [])
	        .map(it => {
	          const mark = String(it?.mark || '').trim();
	          const txt = String(it?.text || '').trim();
	          if (mark && txt) return `${mark} ${txt}`.trim();
	          return (mark || txt).trim();
	        })
	        .filter(Boolean)
	        .join('\n')
	        .trim();

	      let q = q0;
	      let a = rebuiltChoices || a0;
	      let changed = false;

	      if (prefix) {
	        const qNorm = q.replace(/\s+/g, ' ').trim();
	        const preNorm = prefix.replace(/\s+/g, ' ').trim();
	        if (!qNorm || !preNorm || !qNorm.includes(preNorm)) {
	          q = (q ? q.trimEnd() + '\n\n' : '') + prefix;
	          changed = true;
	        }
	      }
	      if (rebuiltChoices && rebuiltChoices.trim() !== a0.trim()) changed = true;
	      if (a0 && a !== a0) changed = true;

	      return { question_text: q, answer_choices: a, changed };
	    }
		    function getOfficialAnswerText(raw) {
		      const text = stripAnswerEmphasis(raw).trim();
		      if (!text || text === '(ì—†ìŒ)' || text === 'ì—†ìŒ') return '';
		      return text;
		    }
    function hasOfficialAnswer(raw) {
      return !!getOfficialAnswerText(raw);
    }
	    function displayOfficialAnswerValue(raw) {
	      return hasOfficialAnswer(raw) ? coerceText(raw).trim() : '';
	    }
	    function normalizeOfficialAnswerValue(raw) {
	      const rawText = coerceText(raw).trim();
	      const stripped = stripAnswerEmphasis(rawText).trim();
	      if (!stripped || stripped === '(ì—†ìŒ)' || stripped === 'ì—†ìŒ') return undefined;
	      return rawText;
	    }
    function scrubPlaceholderOfficialAnswersInList(list) {
      let changed = false;
      (list || []).forEach(p => {
        if (!p || !Object.prototype.hasOwnProperty.call(p, 'official_answer')) return;
        if (!hasOfficialAnswer(p.official_answer)) {
          delete p.official_answer;
          changed = true;
        }
      });
      return changed;
    }

	    function extractYearFromQid(qid) {
	      const m = String(qid || '').match(/(20\d{2}|19\d{2})/g);
	      if (!m || !m.length) return null;
	      return parseInt(m[m.length - 1], 10);
	    }

			    function extractPaperFromQid(qid) {
			      const s = String(qid || '');
			      const idx = s.indexOf('::');
			      const m = (idx <= 0) ? s.match(/^(.*?):\s*(Q\d+[a-z]?(?:@[-_0-9A-Za-zê°€-í£]+)?)$/i) : null;
			      const paper = idx > 0 ? s.slice(0, idx) : (m ? m[1] : '');
			      return canonicalizePaperName(paper);
			    }
		    function extractQuestionNumberFromQid(qid) {
		      const s = String(qid || '');
		      // Prefer explicit Q-number patterns (e.g., Q21, q_021, ...).
		      const mq = s.match(/(?:^|[^A-Za-z0-9])Q\s*0*(\d{1,3})(?:[^0-9]|$)/i);
		      if (mq) return parseInt(mq[1], 10);
		      // Fallback: last non-year number in the string.
		      const nums = (s.match(/\d+/g) || []).map(v => parseInt(v, 10)).filter(n => Number.isFinite(n));
		      const nonYears = nums.filter(n => n < 1900 || n > 2100);
		      if (nonYears.length) return nonYears[nonYears.length - 1];
		      return nums.length ? nums[nums.length - 1] : null;
		    }
		    const PAPER_REGISTRY_KEY = 'fmm_paper_registry';
			    function canonicalizePaperName(paperName) {
			      let s = String(paperName || '');
			      try { s = s.normalize('NFKC'); } catch { }
			      s = s.trim();
			      if (!s) return '';

			      // 1) Strip common split-part suffixes in parentheses.
			      // Examples:
			      // - "xxx.pdf (Part 1, p1-3)" -> "xxx.pdf"
			      // - "xxx (Part 2)"          -> "xxx"
			      s = s.replace(/\s*[\(\[]\s*Part\s*\d{1,3}(?=$|[^0-9])[^)\]]*[\)\]]\s*$/ig, '').trim();
			      // Also handle broken/missing closing bracket cases (e.g., "xxx.pdf (Part 4, p10-12").
			      s = s.replace(/\s*[\(\[]\s*Part\s*\d{1,3}(?=$|[^0-9])[\s\S]*$/ig, '').trim();

		      // 2) Strip "_Part_4..." after an extension.
		      s = s.replace(/(\.(?:pdf|txt))\s*(?:[_\s-]*Part[_\s-]*\d{1,3})(?=$|[^0-9])[\s\S]*$/i, '$1').trim();

		      // 3) Strip "Part 4" before an extension (keep extension).
		      s = s.replace(/^(.*?)(?:[_\s-]*Part[_\s-]*\d{1,3})(?=$|[^0-9])[\s\S]*?(\.(?:pdf|txt))$/i, (_m, pre, ext) => `${String(pre || '').trim()}${String(ext || '')}`).trim();

		      // 4) Strip "Part 4" without an extension.
		      s = s.replace(/^(.*?)(?:[_\s-]*Part[_\s-]*\d{1,3})(?=$|[^0-9])[\s\S]*$/i, (_m, pre) => String(pre || '').trim()).trim();

		      return s;
		    }
			    function normalizePaperNameDisplay(paperName) {
			      let s = canonicalizePaperName(paperName);
			      if (!s) return '';
			      s = s.replace(/^(\d+)\._\s*/, '$1. ');
			      s = s.replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
			      s = s.replace(/ í™ˆí˜ì´ì§€ ê²Œì‹œìš©$/, ' (í™ˆí˜ì´ì§€ ê²Œì‹œìš©)');
			      // Fix legacy corruption like "file.pdf (.pdf" (duplicate extension fragment).
			      s = s.replace(/(\.(?:pdf|txt))\s*\(\s*\.(?:pdf|txt)\s*\)?\s*$/i, '$1').trim();
			      // Guard: remove stray opening brackets that break extension detection (e.g., "file.pdf (").
			      s = s.replace(/[\(\[]\s*$/, '').trim();
			      const m = s.match(/\.(pdf|txt)$/i);
			      if (m) return s.replace(/\.(pdf|txt)$/i, `.${String(m[1]).toLowerCase()}`);
			      return `${s}.pdf`;
			    }
		    function normalizePaperNameKey(paperName) {
		      let s = normalizePaperNameDisplay(paperName);
		      if (!s) return '';
		      s = s.replace(/[(),]/g, ' ');
		      s = s.replace(/\s+/g, ' ').trim();
		      s = s.replace(/\s+\.(pdf|txt)$/i, '.$1');
		      return s.toLowerCase();
		    }
		    function paperNameQualityScore(name) {
		      const s = String(name || '');
		      let score = 0;
		      if (/[()]/.test(s)) score += 5;
		      score += Math.min(s.length, 160) / 20;
		      return score;
		    }
		    function preferBetterPaperName(current, candidate) {
		      const a = String(current || '').trim();
		      const b = String(candidate || '').trim();
		      if (!a) return b;
		      if (!b) return a;
		      return paperNameQualityScore(b) > paperNameQualityScore(a) ? b : a;
		    }
		    function readStoreJson(key, fallback) {
		      try { return JSON.parse(store.getItem(key) || 'null') ?? fallback; } catch { return fallback; }
		    }
		    function writeStoreJson(key, value) {
		      try { store.setItem(key, JSON.stringify(value ?? null)); } catch { }
		    }
		    function makePaperId() {
		      return 'paper_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8);
		    }
		    function ensurePaperRegistry() {
		      const reg = readStoreJson(PAPER_REGISTRY_KEY, null);
		      const base = (reg && typeof reg === 'object') ? reg : {};
		      if (!base.version) base.version = 1;
		      if (!base.papers || typeof base.papers !== 'object') base.papers = {};
		      if (!base.aliasToId || typeof base.aliasToId !== 'object') base.aliasToId = {};
		      return base;
		    }
		    function savePaperRegistry(reg) {
		      writeStoreJson(PAPER_REGISTRY_KEY, reg || null);
		    }
		    function normalizeProblemsPaperNamesInPlace(problemsJson) {
		      const src = problemsJson?.types;
		      if (!src || typeof src !== 'object') return false;
			      const reg = ensurePaperRegistry();
			      let changed = false;
			      let registryChanged = false;
			      const canonicalIdByKey = new Map();
			      const mergedPaperIds = new Set();
		
		      function findExistingPaperIdByKey(sourceKey) {
		        const key = String(sourceKey || '').trim().toLowerCase();
		        if (!key) return '';
		        try {
		          const entries = Object.entries(reg.papers || {});
		          let best = '';
		          let bestCreated = Infinity;
		          for (const [pid, paper] of entries) {
		            const paperKey = normalizePaperNameKey(paper?.name || '');
		            if (!paperKey || paperKey !== key) continue;
		            if (paper && paper.nameLocked) return pid;
		            const created = Number(paper?.createdAt || Infinity);
		            if (created < bestCreated) { best = pid; bestCreated = created; }
		          }
		          if (best) return best;
		        } catch { }
		        return '';
		      }
		
		      function ensurePaper(paperId, name) {
		        if (reg.papers[paperId]) return reg.papers[paperId];
		        const now = Date.now();
		        reg.papers[paperId] = { id: paperId, name: name || '', nameLocked: false, aliasKeys: [], aliasNames: {}, createdAt: now, updatedAt: now };
		        registryChanged = true;
		        return reg.papers[paperId];
		      }
			      function addAlias(paperId, aliasKey, aliasName) {
			        const pid = String(paperId || '');
			        const k = String(aliasKey || '').trim();
			        if (!pid || !k) return;
		        const paper = ensurePaper(pid, aliasName);
		        if (!paper.aliasNames || typeof paper.aliasNames !== 'object') paper.aliasNames = {};
		        if (!Array.isArray(paper.aliasKeys)) paper.aliasKeys = [];
		        if (!paper.aliasKeys.includes(k)) {
		          paper.aliasKeys.push(k);
		          registryChanged = true;
		        }
		        const prevAliasName = paper.aliasNames[k] || '';
		        const nextAliasName = preferBetterPaperName(prevAliasName, aliasName);
		        if (nextAliasName && nextAliasName !== prevAliasName) {
		          paper.aliasNames[k] = nextAliasName;
		          registryChanged = true;
		        }
		        if (reg.aliasToId[k] !== pid) {
		          reg.aliasToId[k] = pid;
		          registryChanged = true;
		        }
			        paper.updatedAt = Date.now();
			      }
			
			      function mergePaperAliases(fromId, toId) {
			        const from = reg.papers?.[fromId];
			        const to = reg.papers?.[toId];
			        if (!from || !to || String(fromId) === String(toId)) return;
			        const keys = Array.isArray(from.aliasKeys) ? from.aliasKeys.slice() : [];
			        keys.forEach(k => {
			          if (!k) return;
			          if (!Array.isArray(to.aliasKeys)) to.aliasKeys = [];
			          if (!to.aliasKeys.includes(k)) {
			            to.aliasKeys.push(k);
			            registryChanged = true;
			          }
			          if (!to.aliasNames || typeof to.aliasNames !== 'object') to.aliasNames = {};
			          const fromName = (from.aliasNames && typeof from.aliasNames === 'object') ? (from.aliasNames[k] || '') : '';
			          if (fromName) {
			            const prev = to.aliasNames[k] || '';
			            const better = preferBetterPaperName(prev, fromName);
			            if (better && better !== prev) {
			              to.aliasNames[k] = better;
			              registryChanged = true;
			            }
			          }
			          if (reg.aliasToId[k] !== String(toId)) {
			            reg.aliasToId[k] = String(toId);
			            registryChanged = true;
			          }
			        });
			      }
		
			      Object.keys(src).forEach(title => {
			        const list = src[title];
			        if (!Array.isArray(list)) return;
			        list.forEach(p => {
			          if (!p || typeof p !== 'object') return;
			          const rawFromFields = String(p.paperSourceName || p.paperName || '').trim();
			          const qidStr = String(p.qid || '');
			          const qIdx = qidStr.indexOf('::');
			          const rawFromQid = qIdx > 0 ? qidStr.slice(0, qIdx) : '';
			          const raw = rawFromFields || rawFromQid || extractPaperFromQid(p.qid);
			          const sourceName = normalizePaperNameDisplay(raw);
			          const sourceKey = normalizePaperNameKey(sourceName);
			          if (!sourceKey) return;
			          const prevPaperId = String(p.paperId || '').trim();
			          const rawDetect = rawFromFields || rawFromQid || '';
				          const isPartSplit = /(?:^|[_\s-]+)Part[_\s-]*\d+(?=$|[^0-9])/i.test(String(rawDetect));
		
		          if (p.paperSourceName !== sourceName) {
		            p.paperSourceName = sourceName;
		            changed = true;
		          }
		          if (p.paperSourceKey !== sourceKey) {
		            p.paperSourceKey = sourceKey;
		            changed = true;
		          }
		
			          let paperId = '';
			          if (canonicalIdByKey.has(sourceKey)) {
			            paperId = canonicalIdByKey.get(sourceKey) || '';
			          }
			          if (!paperId) {
			            paperId =
			              (reg.aliasToId[sourceKey] || '') ||
			              findExistingPaperIdByKey(sourceKey) ||
			              (((p.paperId && reg.papers[p.paperId]) ? p.paperId : '')) ||
			              '';
			          }
			          if (!paperId) {
			            paperId = makePaperId();
			            ensurePaper(paperId, sourceName);
			          }
			          canonicalIdByKey.set(sourceKey, paperId);
			          const paper = ensurePaper(paperId, sourceName);
			          addAlias(paperId, sourceKey, sourceName);
		
		          const betterName = preferBetterPaperName(paper.name, sourceName);
		          if (!paper.nameLocked && betterName && betterName !== paper.name) {
		            paper.name = betterName;
		            paper.updatedAt = Date.now();
		            registryChanged = true;
		          }
		
			          if (p.paperId !== paperId) {
			            p.paperId = paperId;
			            changed = true;
			          }
			          if (p.paperName !== paper.name) {
			            p.paperName = paper.name;
			            changed = true;
			          }
			
			          // If this problem previously belonged to another paperId, merge aliases and (later) prune orphans.
			          if (prevPaperId && prevPaperId !== paperId && reg.papers?.[prevPaperId]) {
			            mergePaperAliases(prevPaperId, paperId);
			            mergedPaperIds.add(prevPaperId);
			          }
			
			          // For split-part imports, keep a stable canonical id for the base key during this pass.
			          if (isPartSplit && paperId) canonicalIdByKey.set(sourceKey, paperId);
			        });
			      });
			
			      // Cleanup: remove merged paper registry entries that no longer have any problems.
			      if (mergedPaperIds.size) {
			        const counts = {};
			        try {
			          Object.keys(src).forEach(title => {
			            (src[title] || []).forEach(p => {
			              const pid = String(p?.paperId || '').trim();
			              if (!pid) return;
			              counts[pid] = (counts[pid] || 0) + 1;
			            });
			          });
			        } catch { }
			        mergedPaperIds.forEach(pid => {
			          if ((counts[pid] || 0) > 0) return;
			          try { delete reg.papers[pid]; registryChanged = true; } catch { }
			          try {
			            Object.keys(reg.aliasToId || {}).forEach(k => { if (reg.aliasToId[k] === pid) { delete reg.aliasToId[k]; registryChanged = true; } });
			          } catch { }
			        });
			      }
			
			      if (registryChanged) savePaperRegistry(reg);
			      return changed;
			    }
		    function paperKeyForProblem(p) {
		      if (!p) return '';
		      return String(p.paperId || '').trim();
		    }
		    function formatPaperNameDisplay(paperName, qid) {
		      let s = String(paperName || '').trim();
		      if (!s) s = extractPaperFromQid(qid);
		      if (!s) return '';
		      return normalizePaperNameDisplay(s);
		    }

    // Data-URI masking for editor ergonomics (ideology: hide unwieldy blobs while keeping full fidelity)
    function hashStringFNV1a(str) {
      let h = 2166136261;
      const s = String(str || '');
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0).toString(36);
    }
	    function maskDataImages(text, el) {
	      if (!el) return text;
	      const map = {};
	      const masked = coerceText(text || '').replace(/!\[img\]\((data:image\/[^;]+;base64,[^)]+)\)/g, (_m, src) => {
	        const [prefix, dataPartRaw] = src.split(';base64,');
	        const dataPart = dataPartRaw || '';
	        const head = dataPart.slice(0, 12);
	        const tail = dataPart.slice(-8);
        // Avoid collisions: different images can share the same head/tail chunks.
        const key = `${prefix};base64,${head}...ì¤‘ëµ...${tail}#${hashStringFNV1a(src)}`;
        map[key] = `![img](${src})`;
        return `![img](${key})`;
      });
      el._imgMap = map;
      return masked;
    }
	    function unmaskDataImages(text, el) {
	      if (!el || !el._imgMap) return text;
	      const m = el._imgMap;
	      // Back-compat: older sessions stored an array and relied on order.
	      if (Array.isArray(m)) {
	        let idx = 0;
	        return coerceText(text || '').replace(/!\[img\]\((data:image\/[^;]+;base64,[^)]+)\)/g, (_mm) => {
	          const full = m[idx++];
	          return full || _mm;
	        });
	      }
	      return coerceText(text || '').replace(/!\[img\]\((data:image\/[^;]+;base64,[^)]+)\)/g, (mm, src) => {
	        return m[src] || mm;
	      });
	    }
    function remaskTextarea(el) {
      if (!el) return;
      const full = unmaskDataImages(el.value, el);
      el.value = maskDataImages(full, el);
    }

    function renderInlineBold(text) {
      if (!text || typeof text !== 'string') return text || '';
      if (text.indexOf('**') === -1 && text.indexOf('__') === -1) return text;
      return text
        .replace(/\*\*(?=\S)((?:(?!\*\*)[\s\S])*?)\*\*/g, '<strong>$1</strong>')
        .replace(/__(?=\S)((?:(?!__)[\s\S])*?)__/g, '<strong>$1</strong>');
    }

    function formatAnswerChoices(choices, officialAnswer) {
      // ideology: emphasize the decision point in-place to reduce scanning cost
      const t = String(choices || '');
      const ans = String(officialAnswer || '').trim();

      // try to extract target circled index
      let targetIdx = -1;
      const ENC = ['â‘ ', 'â‘¡', 'â‘¢', 'â‘£', 'â‘¤', 'â‘¥', 'â‘¦', 'â‘§', 'â‘¨', 'â‘©', 'â‘ª', 'â‘«', 'â‘¬', 'â‘­', 'â‘®', 'â‘¯', 'â‘°', 'â‘±', 'â‘²', 'â‘³'];
      const D1 = ['â€', 'â', 'â‚', 'âƒ', 'â„', 'â…', 'â†', 'â‡', 'âˆ', 'â‰'];
      const D2 = ['âŠ', 'â‹', 'âŒ', 'â', 'â', 'â', 'â', 'â‘', 'â’', 'â“'];
      const idxMap = {};
      ENC.forEach((ch, idx) => { idxMap[ch] = idx; });
      D1.forEach((ch, idx) => { idxMap[ch] = idx; });
      D2.forEach((ch, idx) => { idxMap[ch] = idx; });

      const circled = ans.match(/[â‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨â‘©â‘ªâ‘«â‘¬â‘­â‘®â‘¯â‘°â‘±â‘²â‘³â€ââ‚âƒâ„â…â†â‡âˆâ‰âŠâ‹âŒâââââ‘â’â“]/);
      if (circled && typeof idxMap[circled[0]] === 'number') targetIdx = idxMap[circled[0]];
      // numeric (1..20)
      if (targetIdx < 0) {
        const m = ans.match(/(^|[^\d])([1-9]|1\d|20)([^\d]|$)/);
        if (m) { const n = parseInt(m[2], 10); if (n >= 1 && n <= 20) targetIdx = n - 1; }
      }
      // letter (A-D)
      if (targetIdx < 0) {
        const m = ans.match(/[A-D]/i);
        if (m) targetIdx = m[0].toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
      }

	      // If we found a target circled index, bold that entire choice segment
	      if (targetIdx >= 0) {
	        const parsed = splitAnswerChoiceBlock(t);
	        const lineItems = parsed.hasMarkers
	          ? (parsed.items || []).map(it => ({ mark: it.mark, idx: (typeof idxMap[it.mark] === 'number') ? idxMap[it.mark] : null, text: it.text }))
	          : [];
	        if (lineItems.length) {
	          const prefix = parsed.prefix ? (parsed.prefix.trimEnd() + '\n') : '';
	          const out = prefix + lineItems.map(item => {
	            const seg = item.mark + (item.text ? ` ${item.text}` : '');
	            return item.idx === targetIdx ? `<strong>${seg}</strong>` : seg;
	          }).join('\n');
	          return renderInlineBold(out.trim());
	        }
	      }

      // Fallback: bold first exact occurrence of the official answer text (best effort)
      if (ans) {
        try {
          const re = new RegExp(ans.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&'), 'i');
          return renderInlineBold(t.replace(re, (m) => `<strong>${m}</strong>`));
        } catch { /* ignore */ }
      }
      return renderInlineBold(t);
    }

    function parseGuide(text) {
      // Split by separator lines of = ... = (8 or more =)
      const segments = text.split(/\n={8,}\n/g);
      const types = [];

      segments.forEach((segment, idxSeg) => {
        if (!/^\s*##\s*Standard Problem/m.test(segment)) return; // skip if no Standard Problem

        // Extract "Standard Problem" block up to first '---' line (standalone)
        const stdMatch = segment.match(/(^\s*##\s*Standard Problem[\s\S]*?)^\s*---\s*$/m);
        if (!stdMatch) {
          // fallback: try to the end if --- not found
          const stdFallback = segment.match(/(^\s*##\s*Standard Problem[\s\S]*)$/m);
          if (!stdFallback) return;
        }

        const standardMarkdown = (stdMatch ? stdMatch[1] : segment).trim();

        let explanationMarkdown = '';
        if (stdMatch) {
          // rest of segment after '---'
          explanationMarkdown = segment.slice(stdMatch.index + stdMatch[0].length).trim();
        } else {
          explanationMarkdown = '';
        }

        // Find nearest preceding H1 (# ...) before the "## Standard Problem" start
        const posStdStart = stdMatch ? stdMatch.index : segment.indexOf('## Standard Problem');
        const before = segment.slice(0, Math.max(0, posStdStart));
        const h1Matches = [...before.matchAll(/^\s*#\s+(.+?)\s*$/gm)];
        const fallbackTitle = (typeof currentLang !== 'undefined' && currentLang === 'en')
          ? `Type ${types.length + 1}`
          : `ìœ í˜• ${types.length + 1}`;
        const typeTitle = h1Matches.length ? h1Matches[h1Matches.length - 1][1].trim() : fallbackTitle;

        types.push({
          title: typeTitle,
          standardMarkdown,
          explanationMarkdown
        });
      });

      return types;
    }

    function renderTypes(types) {
      // === ADD: apply saved explanation overrides =================================
      // Ideology: if the user edited it, they own it; we render their version by default.
      types.forEach(t => {
        const slug = String(t.title || '').toLowerCase().replace(/\s+/g, '_');
        const savedStd = store.getItem(`fmm_standard_${slug}`);
        if (savedStd != null) {
          t.standardMarkdown = savedStd;
        } else if (hasIndexSuffix(t.title)) {
          const base = stripIndexSuffix(t.title);
          const baseSlug = String(base || '').toLowerCase().replace(/\s+/g, '_');
          const baseStd = store.getItem(`fmm_standard_${baseSlug}`);
          if (baseStd != null) {
            t.standardMarkdown = baseStd;
            store.setItem(`fmm_standard_${slug}`, baseStd);
          }
        }
        const saved = store.getItem(`fmm_explanation_${slug}`);
        if (saved != null) {
          t.explanationMarkdown = saved;
        } else if (hasIndexSuffix(t.title)) {
          const base = stripIndexSuffix(t.title);
          const baseSlug = String(base || '').toLowerCase().replace(/\s+/g, '_');
          const baseExp = store.getItem(`fmm_explanation_${baseSlug}`);
          if (baseExp != null) {
            t.explanationMarkdown = baseExp;
            store.setItem(`fmm_explanation_${slug}`, baseExp);
          }
        }
      });

      outputEl.innerHTML = '';
      typesNavEl.innerHTML = '';
      typesNavEl.style.display = types.length ? '' : 'none';

      // Navigation pills
      types.forEach((t, i) => {
        const a = document.createElement('a');
        a.href = `#type-${i + 1}`;
        a.textContent = `${i + 1}. ${t.title}`;
        typesNavEl.appendChild(a);
      });

      // Cards
      types.forEach((t, i) => {
        const sec = document.createElement('section');
        sec.className = 'type-card';
        sec.id = `type-${i + 1}`;

        // Header
        const head = document.createElement('div');
        head.className = 'type-head';
        head.innerHTML = `
          <div class="type-title">
            <span class="pill type-idx">#${i + 1}</span>
            <h2>${sanitize(t.title)}</h2>
          </div>
          <div class="type-jump">
            <button class="btn" data-action="copyTypeRaw" data-idx="${i}" title="ì´ ìœ í˜• ê°€ì´ë“œ ì›ë¬¸(ë§ˆí¬ë‹¤ìš´) ë³µì‚¬">ğŸ“‹ ì›ë¬¸</button>
            ${i > 0 ? `<a class="btn" href="#type-${i}">â† ì´ì „</a>` : ''}
            ${i < types.length - 1 ? `<a class="btn" href="#type-${i + 2}">ë‹¤ìŒ â†’</a>` : ''}
          </div>
        `;
        sec.appendChild(head);

        // Columns
        const cols = document.createElement('div');
        cols.className = 'cols';

        // Problem
        const left = document.createElement('div');
        left.className = 'col problem md';
        left.innerHTML = `<h3>í‘œì¤€ë¬¸ì œ</h3><div class="hr"></div>`;

        const problemHTML = formatAnswerInProblem(
          renderMarkdown(t.standardMarkdown, undefined, 'parseThenSanitize')
        );
        const problemWrap = document.createElement('div');
        problemWrap.innerHTML = problemHTML;
        problemWrap.classList.add('standard-content'); // editor anchor
        // ADD: ë³´ê¸° ê°€ë…ì„± ì²˜ë¦¬
        insertBreaksBeforeCircled(problemWrap);
        // Ensure links open in new tab
        $$('a', problemWrap).forEach(a => a.setAttribute('target', '_blank'));
        left.appendChild(problemWrap);

        // Explanation
        const right = document.createElement('div');
        right.className = 'col explanation md';
        right.innerHTML = `<h3>í•´ì„¤</h3><div class="hr"></div>`;
        const explanationHTML = renderMarkdown(t.explanationMarkdown || '_í•´ì„¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤._', undefined, 'parseThenSanitize');
        const expWrap = document.createElement('div');
        expWrap.innerHTML = explanationHTML;
        $$('a', expWrap).forEach(a => a.setAttribute('target', '_blank'));
        expWrap.classList.add('explanation-content'); // ADD: in-place editor anchor
        right.appendChild(expWrap);

        cols.appendChild(left);
        cols.appendChild(right);
        sec.appendChild(cols);

        outputEl.appendChild(sec);
      });

      // Ensure visible spacing after bold in rendered guide body.
      ensureSpaceAfterStrong(outputEl);
      applyInlineBoldMarkers(outputEl);

      // Activate nav highlight on scroll
      const sections = types.map((_, i) => $(`#type-${i + 1}`));
      function onScrollSpy() {
        let current = 0;
        const fromTop = window.scrollY + 100;
        sections.forEach((sec, i) => { if (sec.offsetTop <= fromTop) current = i; });
        $$('.types-nav a').forEach((a, i) => a.classList.toggle('active', i === current));
      }
      document.removeEventListener('scroll', onScrollSpy);
      document.addEventListener('scroll', onScrollSpy);
      onScrollSpy();

      // ADD: LaTeX typesetting after DOM is ready
      typesetMath(outputEl); // ideology: typeset exactly what users see now
    }

    function render() {
      // preserve viewing position relative to current type
      const anchorInfo = (() => {
        const secs = $$('.type-card');
        if (!secs.length) return null;
        const idx = (function () { let i = 0, y = window.scrollY + 100; secs.forEach((s, ii) => { if (s.offsetTop <= y) i = ii; }); return i; })();
        const sec = secs[idx]; if (!sec) return null;
        const topAbs = sec.getBoundingClientRect().top + window.scrollY;
        return { idx, rel: window.scrollY - topAbs };
      })();
      const text = unmaskDataImages(sourceEl.value, sourceEl);
      if (!text.trim()) {
        statusEl.textContent = 'ì…ë ¥ ì—†ìŒ';
        return;
      }
      statusEl.textContent = 'íŒŒì‹± ì¤‘...';
      try {
        const types = parseGuide(text);
        if (types.length === 0) {
          statusEl.textContent = 'ìœ í˜•(## Standard Problem) ë¯¸ê²€ì¶œ';
          outputEl.innerHTML = `<div class="panel empty">ì…ë ¥ ë‚´ì—ì„œ "## Standard Problem" êµ¬ì—­ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</div>`;
          typesNavEl.style.display = 'none';
          return;
        }
        renderTypes(types);
        statusEl.textContent = `ì™„ë£Œ Â· ìœ í˜• ${types.length}ê±´`;
        // restore previous scroll position
        if (anchorInfo) {
          const sec = document.getElementById(`type-${anchorInfo.idx + 1}`);
          if (sec) {
            const topAbs = sec.getBoundingClientRect().top + window.scrollY;
            window.scrollTo({ top: topAbs + anchorInfo.rel });
          }
        }
      } catch (e) {
        console.error(e);
        statusEl.textContent = 'ì˜¤ë¥˜ ë°œìƒ';
        outputEl.innerHTML = `<div class="panel">ë Œë”ë§ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.</div>`;
      }
    }

	    // Events
	    renderBtn.addEventListener('click', render);
	    clearBtn.addEventListener('click', () => {
	      sourceEl.value = '';
	      outputEl.innerHTML = '';
	      typesNavEl.style.display = 'none';
	      statusEl.textContent = t('status_cleared');
	      // Prevent the example guide from auto-loading again after an explicit clear.
	      try { store.setItem('fmm_example_dismissed', '1'); } catch { }
	      try {
	        store.removeItem('fmm_example_autoloaded');
	        store.removeItem('fmm_example_lang');
	        store.removeItem('fmm_example_hash');
	      } catch { }
	      store.removeItem('fmm_source');
	      // Ensure snapshots cannot resurrect the old guide if the user refreshes immediately.
	      try { snapshotDB.saveNow(); } catch { }
	    });
	    hardClearBtn?.addEventListener('click', () => {
		      const ok = confirm(
		        (currentLang === 'ko')
		          ? (
		            'âš ï¸ ì™„ì „ ì‚­ì œ(Clear)ë¥¼ ì§„í–‰í•˜ë©´ ì´ ë¸Œë¼ìš°ì €ì— ì €ì¥ëœ ëª¨ë“  ë°ì´í„°ê°€ ì‚­ì œë©ë‹ˆë‹¤.\n' +
		            '- ë¬¸ì œ ë©”ëª¨ / ìœ í˜• ë©”ëª¨ / ê¸€ë¡œë²Œ ë©”ëª¨\n' +
		            '- ë¬¸ì œ íƒœê·¸ / ì˜¤ë‹µÂ·ì •ë‹µ ê¸°ë¡ / ì°ê¸° ê¸°ë¡\n' +
		            '- ì‹œí—˜ì§€ / ì±„íŒ… / ì„¤ì •\n\n' +
		            '- ì„¸ì´ë¸Œ ìŠ¬ë¡¯(IndexedDB)\n\n' +
		            'ê³„ì†í• ê¹Œìš”?'
		          )
		          : (
		            'âš ï¸ Hard Clear will delete ALL saved data in this browser.\n' +
		            '- Problem memos / type memos / global memo\n' +
		            '- Tags / wrong & correct history / bookmarks\n' +
		            '- Sheets / chat / settings\n\n' +
		            '- Save slots (IndexedDB)\n\n' +
		            'Continue?'
		          )
		      );
	      if (!ok) return;
	      const phrase = prompt((currentLang === 'ko') ? 'ì •ë§ ì‚­ì œí•˜ë ¤ë©´ DELETE ë¥¼ ì…ë ¥í•˜ì„¸ìš”.' : 'Type DELETE to confirm.');
	      if (String(phrase || '').trim() !== 'DELETE') {
	        alert((currentLang === 'ko') ? 'ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.' : 'Cancelled.');
	        return;
	      }
      const removePrefixedKeys = (storage, prefix) => {
        try {
          if (!storage) return;
          for (let i = storage.length - 1; i >= 0; i--) {
            const k = storage.key(i);
            if (k && String(k).startsWith(prefix)) storage.removeItem(k);
          }
        } catch { }
      };
	      try { removePrefixedKeys(window.localStorage, 'fmm_'); } catch { }
	      try { removePrefixedKeys(window.sessionStorage, 'fmm_'); } catch { }
	      try { if ('indexedDB' in window) indexedDB.deleteDatabase('fmm_snapshot_db'); } catch { }
	      try { if ('indexedDB' in window) indexedDB.deleteDatabase('fmm_multi_save_db'); } catch { }
	      try { window.localStorage?.removeItem('fmmActiveSaveSlot'); } catch { }
	      try { window.localStorage?.removeItem('fmmLoadedSaveSlot'); } catch { }
		      try { statusEl.textContent = (currentLang === 'ko') ? 'ì™„ì „ ì‚­ì œë¨' : 'Hard cleared'; } catch { }
		      alert((currentLang === 'ko') ? 'ì‚­ì œ ì™„ë£Œ. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.' : 'Done. Reloading the page.');
		      try { location.reload(); } catch { }
		    });

    // ADD: PDF ì €ì¥ ì´ë²¤íŠ¸
	    pdfBtn.addEventListener('click', () => {
	      // ë Œë”ë§ëœ ë‚´ìš©ì´ ì—†ìœ¼ë©´ ê²½ê³ 
	      if (!outputEl.innerHTML.trim()) {
	        alert((currentLang === 'ko') ? 'ë¨¼ì € ê°€ì´ë“œë¥¼ ë Œë”ë§í•´ì£¼ì„¸ìš”.' : 'Render the guide first.');
	        return;
	      }
	      // ë¸Œë¼ìš°ì €ì˜ ì¸ì‡„ ê¸°ëŠ¥ í˜¸ì¶œ. @media print ìŠ¤íƒ€ì¼ì´ ì ìš©ë¨
	      window.print();
	    });

    // Example hint (optional placeholder)
    sourceEl.placeholder =
      `# Final Mastery Manual

> GLOBAL_QID í˜•ì‹: {PaperName}::{LocalQID} ì˜ˆ) Midterm2024.pdf::Q33
> ì—¬ëŸ¬ ì‹œí—˜ì§€ë¥¼ í†µí•©í•  ë•Œ ë¬¸ì œ ì‹ë³„ì„ ëª…í™•íˆ í•˜ê¸° ìœ„í•œ ê·œì¹™ì…ë‹ˆë‹¤.

---

# Power Electronics and Converters

## Standard Problem
ë¬¸ì œ: ... (ì—¬ê¸°ì— í‘œì¤€ë¬¸ì œë¥¼ í¬í•¨í•œ ë¸”ë¡ì„ ë„£ê³ )
...
**Answer:** ...
---
## Coverage (GLOBAL_QIDs)
...

========================================
# Fundamental Electrical Concepts, Laws, and Units

## Standard Problem
...
**Answer:** ...
---
## Coverage (GLOBAL_QIDs)
...

========================================
# Electric Machine Construction and Windings

## Standard Problem
...
**Answer:** ...
---
## Coverage (GLOBAL_QIDs)
...`;

    // Keyboard shortcut: Ctrl/Cmd+Enter to render
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { render(); }
    });

    function restoreSavedBox(el, storeKey) {
      const saved = JSON.parse(store.getItem(storeKey) || 'null');
      if (!el || !saved) return;
      const MIN_W = 120, MIN_H = 120;
      const clamp = (v, min) => (typeof v === 'number' ? (v < min ? null : v) : null);

      const w = clamp(saved.width, MIN_W);
      const h = clamp(saved.height, MIN_H);
      let l = Number.isFinite(saved.left) ? saved.left : null;
      let t = Number.isFinite(saved.top) ? saved.top : null;

      // í™”ë©´ ë°–ì— ì™„ì „íˆ ë‚˜ê°€ë²„ë¦° ì°½ì€ ë‹¤ì‹œ ë³´ì´ë„ë¡ ì‚´ì§ ì•ˆìª½ìœ¼ë¡œ í´ë¨í”„
      const vw = window.innerWidth || 0;
      const vh = window.innerHeight || 0;
      const margin = 16;
      if (vw > 0 && l != null) {
        if (l > vw - margin) l = vw - margin;
        if (l < - (w || MIN_W) + margin) l = margin - (w || MIN_W);
      }
      if (vh > 0 && t != null) {
        if (t > vh - margin) t = vh - margin;
        if (t < margin * -1) t = margin;
      }

      if (l != null) el.style.left = l + 'px';
      if (t != null) el.style.top = t + 'px';
      if (w != null) el.style.width = w + 'px';
      if (h != null) el.style.height = h + 'px';
    }

    /* === ADD: Memos, Problems viewer, and LLM chat system =======================
       Ideological note: we add explicit confirmations and visible anchors to avoid
       silent data loss or hidden stateâ€”LLMs/UIs often drift from structure, so we
       prefer user-controlled, auditable actions. */
    (() => {
      const LS = {
        get(k, d) { try { return JSON.parse(store.getItem(k)) ?? d; } catch { return d; } },
        set(k, v) { store.setItem(k, JSON.stringify(v)); }
      };

      // === Tags (single source of truth) ======================================
      // Required UI order: ğŸ”’ âŒ â€¼ï¸ â“ â— â— âœ…
      const TAG_DEFS = [
        { tag: 'ğŸ”’', label: 'ì ê¸ˆ/ë¯¸ë¶„ë¥˜' },
        { tag: 'âŒ', label: 'í¬ê¸°/ë„ˆë¬´ ì–´ë ¤ì›€' },
        { tag: 'â€¼ï¸', label: 'í‹€ë¦° ë¬¸ì œ' },
        { tag: 'â“', label: 'ì „í˜€ ëª¨ë¦„' },
        { tag: 'â—', label: 'ì• ë§¤í•¨' },
        { tag: 'â—', label: 'ë³´ë¥˜/ì¬ê²€í† ' },
        { tag: 'âœ…', label: 'ìˆ™ë‹¬' }
      ];
      const TAG_SET = new Set(TAG_DEFS.map(t => t.tag));
      const DEFAULT_TAG = 'ğŸ”’';
      function normalizeTag(tag) {
        const t = String(tag || '').trim();
        return TAG_SET.has(t) ? t : DEFAULT_TAG;
      }
      function tagOrderIndex(tag) {
        const t = normalizeTag(tag);
        const idx = TAG_DEFS.findIndex(x => x.tag === t);
        return idx >= 0 ? idx : 0;
      }
      function tagLabel(tag) {
        const t = normalizeTag(tag);
        return TAG_DEFS.find(x => x.tag === t)?.label || '';
      }
      // === Problem-level state (tag/official answer/memos) ======================
      const PROBLEM_STATE_KEY = 'fmm_problem_state';
      const PROBLEM_MEMO_KEY = 'fmm_problem_memos';
      const ANSWER_API_KEY = 'fmm_answer_api_settings';
      const SOLVE_HISTORY_KEY = 'fmm_solve_history';
      const SHEETS_KEY = 'fmm_exam_sheets';

      const problemState = {
        map: LS.get(PROBLEM_STATE_KEY, {}),
        memos: LS.get(PROBLEM_MEMO_KEY, {}),
        save() { LS.set(PROBLEM_STATE_KEY, this.map); },
        saveMemos() { LS.set(PROBLEM_MEMO_KEY, this.memos); }
      };
	      function getProblemState(qid) {
	        const q = String(qid || '');
	        if (!problemState.map[q]) problemState.map[q] = {};
	        const st = problemState.map[q];
	        st.tag = normalizeTag(st.tag);
        if (typeof st.attempts !== 'number') st.attempts = 0;
        if (typeof st.correctCount !== 'number') st.correctCount = 0;
        if (typeof st.wrongCount !== 'number') st.wrongCount = 0;
        if (!Array.isArray(st.history)) st.history = [];
        // memoLink: ë©”ëª¨ ê³µìœ  ê·¸ë£¹ì˜ ëŒ€í‘œ qid (ì—†ìœ¼ë©´ ìê¸° ìì‹ )
        if (typeof st.memoLink !== 'string' || !st.memoLink) st.memoLink = q;
        // auto-memo sharing opt-out (similarity group)
        if (typeof st.memoAutoOff !== 'boolean') st.memoAutoOff = false;
        if (typeof st.memoLinkMode !== 'string') st.memoLinkMode = ''; // '', 'auto', 'manual'
        if (st.memoLink !== q && !st.memoLinkMode) st.memoLinkMode = 'manual'; // legacy: treat existing links as user-chosen
        // ëŒ€í‘œ ë©”ëª¨ id (ì„ íƒ ì‚¬í•­)
        if (typeof st.representativeMemoId === 'undefined') st.representativeMemoId = null;
        // tag sharing across similar problems (render-time effective tag)
        if (typeof st.tagLink !== 'string' || !st.tagLink) st.tagLink = q;
        if (typeof st.tagAutoOff !== 'boolean') st.tagAutoOff = false;
        if (typeof st.tagLinkMode !== 'string') st.tagLinkMode = ''; // '', 'auto', 'manual'
	        if (st.tagLink !== q && !st.tagLinkMode) st.tagLinkMode = 'manual';
	        return st;
	      }
	
	      // === NEW: QID canonicalization / merge for split PDF parts =================
	      // Example: Some generators emit `xxx.pdf_Part_4_p10-12::Q13` which should be treated as `xxx.pdf::Q13`.
	      function canonicalizePartSuffixQid(qid) {
	        let s = String(qid || '').trim();
	        if (!s) return s;

	        // Legacy compat: allow single-colon delimiter like "file.pdf:Q13" and normalize to "::".
	        if (s.indexOf('::') < 0) {
	          const m = s.match(/^(.*?):\s*(Q\d+[a-z]?(?:@[-_0-9A-Za-zê°€-í£]+)?)$/i);
	          if (m) s = `${String(m[1] || '').trim()}::${String(m[2] || '').trim()}`;
	        }

	        const idx = s.indexOf('::');
	        if (idx <= 0) return s;
	        const paper = s.slice(0, idx);
	        const rest = s.slice(idx);
	        const canon = canonicalizePaperName(paper);
	        if (canon && canon !== paper) return canon + rest;
	        return s;
	      }
	      function dedupeKeepOrder(arr) {
	        const out = [];
	        const seen = new Set();
	        (arr || []).forEach(v => {
	          const s = String(v || '').trim();
	          if (!s || seen.has(s)) return;
	          seen.add(s);
	          out.push(s);
	        });
	        return out;
	      }
	      function extractPartIndexFromQid(qid) {
	        const s = String(qid || '').trim();
	        if (!s) return null;
	        const idx = s.indexOf('::');
	        const paper = idx > 0 ? s.slice(0, idx) : s;
	        const m = paper.match(/(?:^|[_\s-]+)Part[_\s-]*(\d{1,3})(?=$|[^0-9])/i);
	        if (!m) return null;
	        const n = parseInt(m[1], 10);
	        return Number.isFinite(n) ? n : null;
	      }
	      function mergeSplitTextParts(a, b) {
	        const sa = repairObjectObjectArtifactsInText(coerceText(a || '')).replace(/\r\n/g, '\n');
	        const sb = repairObjectObjectArtifactsInText(coerceText(b || '')).replace(/\r\n/g, '\n');
	        if (!sa.trim()) return sb;
	        if (!sb.trim()) return sa;
	        if (sa.includes(sb)) return sa;
	        if (sb.includes(sa)) return sb;

	        // Try to remove a small overlapping seam (common when page headers repeat).
	        const max = Math.min(sa.length, sb.length, 2000);
	        const minOverlap = 24;
	        for (let k = max; k >= minOverlap; k--) {
	          if (sa.slice(-k) === sb.slice(0, k)) {
	            return sa + sb.slice(k);
	          }
	        }

	        const joiner = (sa.endsWith('\n') || sb.startsWith('\n')) ? '' : '\n';
	        return sa + joiner + sb;
	      }
	      function mergeProblemStateEntries(a, b, selfQid) {
	        const out = { ...(a || {}) };
	        const src = b || {};
	
	        // scalar preference: keep existing unless empty
	        Object.keys(src).forEach(k => {
	          if (k === 'question_text' || k === 'answer_choices' || k === 'official_explanation') return;
	          if (typeof out[k] === 'undefined' || out[k] === null || out[k] === '') out[k] = src[k];
	        });
	
	        // tag: prefer non-default
	        const ta = normalizeTag(out.tag);
	        const tb = normalizeTag(src.tag);
	        if (ta === DEFAULT_TAG && tb !== DEFAULT_TAG) out.tag = tb;
	
	        // counters: keep the larger (avoid double-counting on accidental duplicates)
	        out.attempts = Math.max(Number(out.attempts || 0), Number(src.attempts || 0));
	        out.correctCount = Math.max(Number(out.correctCount || 0), Number(src.correctCount || 0));
	        out.wrongCount = Math.max(Number(out.wrongCount || 0), Number(src.wrongCount || 0));
	
	        // history: merge by (sessionId|ts) key, keep latest 50 by ts
	        const ha = Array.isArray(out.history) ? out.history : [];
	        const hb = Array.isArray(src.history) ? src.history : [];
	        const byKey = new Map();
	        const pushHist = (h) => {
	          if (!h || typeof h !== 'object') return;
	          const key = `${String(h.sessionId || '')}|${String(h.ts || '')}`;
	          if (!key) return;
	          if (!byKey.has(key)) byKey.set(key, h);
	        };
	        ha.forEach(pushHist);
	        hb.forEach(pushHist);
	        const mergedHist = Array.from(byKey.values()).slice().sort((x, y) => {
	          const ax = Number(x?.ts || 0);
	          const ay = Number(y?.ts || 0);
	          return ax - ay;
	        });
	        const MAX_HISTORY = 50;
	        out.history = mergedHist.length > MAX_HISTORY ? mergedHist.slice(mergedHist.length - MAX_HISTORY) : mergedHist;
	
	        // lastAttemptAt: keep the latest
	        const la = Number(out.lastAttemptAt || 0);
	        const lb = Number(src.lastAttemptAt || 0);
	        if (lb > la) {
	          out.lastAttemptAt = lb;
	          if (typeof src.lastResult !== 'undefined') out.lastResult = src.lastResult;
	          if (typeof src.lastAnswer !== 'undefined') out.lastAnswer = src.lastAnswer;
	          if (typeof src.lastOfficial !== 'undefined') out.lastOfficial = src.lastOfficial;
	        }
	
	        // memo/tag link: prefer non-self links
	        const self = String(selfQid || '');
	        const mla = (typeof out.memoLink === 'string' && out.memoLink) ? out.memoLink : self;
	        const mlb = (typeof src.memoLink === 'string' && src.memoLink) ? src.memoLink : self;
	        if (mla === self && mlb !== self) {
	          out.memoLink = mlb;
	          out.memoLinkMode = src.memoLinkMode || out.memoLinkMode || 'manual';
	        }
	        const tla = (typeof out.tagLink === 'string' && out.tagLink) ? out.tagLink : self;
	        const tlb = (typeof src.tagLink === 'string' && src.tagLink) ? src.tagLink : self;
	        if (tla === self && tlb !== self) {
	          out.tagLink = tlb;
	          out.tagLinkMode = src.tagLinkMode || out.tagLinkMode || 'manual';
	        }
	
	        out.memoAutoOff = !!(out.memoAutoOff || src.memoAutoOff);
	        out.tagAutoOff = !!(out.tagAutoOff || src.tagAutoOff);
	
	        if ((out.representativeMemoId == null) && (src.representativeMemoId != null)) out.representativeMemoId = src.representativeMemoId;
	
	        // official answer/explanation overrides: prefer the one that actually has content
	        if (!hasOfficialAnswer(out.official_answer) && hasOfficialAnswer(src.official_answer)) out.official_answer = src.official_answer;
	        if (Object.prototype.hasOwnProperty.call(src, 'official_explanation')) {
	          out.official_explanation = mergeSplitTextParts(out.official_explanation, src.official_explanation);
	        }
	        if (Object.prototype.hasOwnProperty.call(src, 'question_text')) {
	          out.question_text = mergeSplitTextParts(out.question_text, src.question_text);
	        }
	        if (Object.prototype.hasOwnProperty.call(src, 'answer_choices')) {
	          out.answer_choices = mergeSplitTextParts(out.answer_choices, src.answer_choices);
	        }
	
	        return out;
	      }
	      function migratePartSuffixQids() {
	        const map = {};
	        const note = (qid) => {
	          const old = String(qid || '').trim();
	          if (!old) return;
	          const next = canonicalizePartSuffixQid(old);
	          if (next && next !== old) map[old] = next;
	        };
	        const mapQid = (qid) => {
	          const s = String(qid || '').trim();
	          if (!s) return s;
	          return map[s] || canonicalizePartSuffixQid(s);
	        };
	
	        // 1) Discover candidates across existing state + loaded problems
	        Object.keys(problemState.map || {}).forEach(note);
	        Object.keys(problemState.memos || {}).forEach(note);
	        Object.values(problemState.map || {}).forEach(st => {
	          if (!st || typeof st !== 'object') return;
	          note(st.memoLink);
	          note(st.tagLink);
	        });
	        const typesObj = problems.json?.types;
	        if (typesObj && typeof typesObj === 'object') {
	          Object.keys(typesObj).forEach(typeTitle => {
	            (typesObj[typeTitle] || []).forEach(p => note(p?.qid));
	          });
	        }
	        const hist = LS.get(SOLVE_HISTORY_KEY, []);
	        (hist || []).forEach(h => {
	          (h?.queue || []).forEach(note);
	          (h?.correct || []).forEach(note);
	          (h?.wrong || []).forEach(note);
	          (h?.skipped || []).forEach(note);
	          (h?.marked || []).forEach(note);
	          Object.keys(h?.answers || {}).forEach(note);
	        });
	        const sheets = LS.get(SHEETS_KEY, []);
	        (sheets || []).forEach(s => { (s?.qids || []).forEach(note); });

	        const hasMapping = Object.keys(map).length > 0;
	
	        // 2) Normalize/merge problems.json qids (and de-dupe/merge collisions across split parts)
	        let problemsChanged = false;
	        if (typesObj && typeof typesObj === 'object') {
	          Object.keys(typesObj).forEach(typeTitle => {
	            const list = Array.isArray(typesObj[typeTitle]) ? typesObj[typeTitle] : [];
	            if (!list.length) return;
	            const order = [];
	            const orderSeen = new Set();
	            const buckets = new Map(); // qid -> [{p, partIdx, orderIdx}]
	
	            list.forEach((p0, orderIdx) => {
	              const p = (p0 && typeof p0 === 'object') ? { ...p0 } : null;
	              const oldQ = p ? String(p.qid || '').trim() : '';
	              if (!p || !oldQ) return;
	              const nextQ = mapQid(oldQ);
	              if (nextQ !== oldQ) { problemsChanged = true; p.qid = nextQ; }
	
	              const arr = buckets.get(p.qid) || [];
	              arr.push({ p, partIdx: extractPartIndexFromQid(oldQ), orderIdx });
	              buckets.set(p.qid, arr);
	              if (!orderSeen.has(p.qid)) { orderSeen.add(p.qid); order.push(p.qid); }
	            });
	
	            const mergeBucket = (arr) => {
	              const entries = Array.isArray(arr) ? arr.slice() : [];
	              if (!entries.length) return null;
	              if (entries.length === 1) return entries[0].p;
	
	              problemsChanged = true;
	              entries.sort((a, b) => {
	                const pa = a.partIdx, pb = b.partIdx;
	                if (pa != null && pb != null && pa !== pb) return pa - pb;
	                if (pa != null && pb == null) return -1;
	                if (pa == null && pb != null) return 1;
	                return Number(a.orderIdx || 0) - Number(b.orderIdx || 0);
	              });
	
	              let merged = { ...(entries[0].p || {}) };
	              for (let i = 1; i < entries.length; i++) {
	                const cur = entries[i].p || {};
	                merged.question_text = mergeSplitTextParts(merged.question_text, cur.question_text);
	                merged.answer_choices = mergeSplitTextParts(merged.answer_choices, cur.answer_choices);
	                merged.official_explanation = mergeSplitTextParts(merged.official_explanation, cur.official_explanation);
	
	                if (!hasOfficialAnswer(merged.official_answer) && hasOfficialAnswer(cur.official_answer)) {
	                  merged.official_answer = cur.official_answer;
	                }
	
	                Object.keys(cur).forEach(k => {
	                  if (k === 'qid' || k === 'question_text' || k === 'answer_choices' || k === 'official_explanation' || k === 'official_answer') return;
	                  if (typeof merged[k] === 'undefined' || merged[k] === null || merged[k] === '') merged[k] = cur[k];
	                });
	              }
	              return merged;
	            };
	
	            const nextList = order.map(qid => mergeBucket(buckets.get(qid))).filter(Boolean);
	            if (nextList.length !== list.length) problemsChanged = true;
	            typesObj[typeTitle] = nextList;
	          });
	          if (problemsChanged) {
	            problems.json = { types: typesObj };
	            try { LS.set('fmm_problems_json', problems.json); } catch { }
	          }
	        }
	
	        // If there is no part-suffix mapping to apply, we still may have merged duplicates above.
	        if (!hasMapping) return problemsChanged;
	
	        // 3) Migrate problemState.map keys + link targets
	        const nextState = {};
	        Object.keys(problemState.map || {}).forEach(oldKey => {
	          const st = problemState.map[oldKey];
	          if (!st || typeof st !== 'object') return;
	          const nextKey = mapQid(oldKey);
	          const migrated = { ...st };
	          if (typeof migrated.memoLink === 'string') migrated.memoLink = mapQid(migrated.memoLink);
	          if (typeof migrated.tagLink === 'string') migrated.tagLink = mapQid(migrated.tagLink);
	          if (!nextState[nextKey]) nextState[nextKey] = migrated;
	          else nextState[nextKey] = mergeProblemStateEntries(nextState[nextKey], migrated, nextKey);
	        });
	        problemState.map = nextState;
	        problemState.save();
	
	        // 4) Migrate memo buckets
	        const nextMemos = {};
	        Object.keys(problemState.memos || {}).forEach(oldKey => {
	          const list = problemState.memos[oldKey];
	          const nextKey = mapQid(oldKey);
	          const arr = Array.isArray(list) ? list.slice() : [];
	          if (!nextMemos[nextKey]) nextMemos[nextKey] = arr;
	          else {
	            const byId = new Map();
	            (nextMemos[nextKey] || []).forEach(m => { if (m && m.id != null) byId.set(String(m.id), m); });
	            arr.forEach(m => { if (m && m.id != null && !byId.has(String(m.id))) byId.set(String(m.id), m); });
	            nextMemos[nextKey] = Array.from(byId.values()).sort((a, b) => Number(a?.createdAt || a?.id || 0) - Number(b?.createdAt || b?.id || 0));
	          }
	        });
	        problemState.memos = nextMemos;
	        problemState.saveMemos();
	
	        // 5) Migrate solve history records (queue/correct/wrong/answers/marked)
	        const nextHist = (hist || []).map(h => {
	          if (!h || typeof h !== 'object') return h;
	          const out = { ...h };
	          out.queue = dedupeKeepOrder((h.queue || []).map(mapQid));
	          const correct = new Set((h.correct || []).map(mapQid));
	          const wrong = new Set((h.wrong || []).map(mapQid));
	          const skipped = new Set((h.skipped || []).map(mapQid));
	          out.correct = out.queue.length ? out.queue.filter(q => correct.has(q)) : dedupeKeepOrder(Array.from(correct));
	          out.wrong = out.queue.length ? out.queue.filter(q => wrong.has(q)) : dedupeKeepOrder(Array.from(wrong));
	          out.skipped = out.queue.length ? out.queue.filter(q => skipped.has(q)) : dedupeKeepOrder(Array.from(skipped));
	          if (Array.isArray(h.marked)) out.marked = dedupeKeepOrder(h.marked.map(mapQid));
	          if (h.answers && typeof h.answers === 'object') {
	            const ans = {};
	            Object.keys(h.answers || {}).forEach(k => {
	              const nk = mapQid(k);
	              const v = h.answers[k];
	              if (!ans[nk]) ans[nk] = v;
	              else {
	                // merge: keep existing unless the new has a choice
	                const cur = ans[nk] || {};
	                if (cur.choice == null && v && v.choice != null) ans[nk] = { ...cur, ...v };
	              }
	            });
	            out.answers = ans;
	          }
	          return out;
	        });
	        LS.set(SOLVE_HISTORY_KEY, nextHist);
	
	        // 6) Migrate exam sheets
	        const nextSheets = (sheets || []).map(s => {
	          if (!s || typeof s !== 'object') return s;
	          return { ...s, qids: dedupeKeepOrder((s.qids || []).map(mapQid)) };
	        });
	        LS.set(SHEETS_KEY, nextSheets);
	
	        // 7) Migrate active solve session (if any)
	        try {
	          if (solveState && solveState.session) {
	            const sess = solveState.session;
	            sess.queue = dedupeKeepOrder((sess.queue || []).map(mapQid));
	            const pm = {};
	            Object.keys(sess.problemMap || {}).forEach(k => { pm[mapQid(k)] = sess.problemMap[k]; });
	            sess.problemMap = pm;
	            const ans = {};
	            Object.keys(sess.answers || {}).forEach(k => { ans[mapQid(k)] = sess.answers[k]; });
	            sess.answers = ans;
	            if (sess.marked && typeof sess.marked === 'object') {
	              const mk = {};
	              Object.keys(sess.marked || {}).forEach(k => { if (sess.marked[k]) mk[mapQid(k)] = true; });
	              sess.marked = mk;
	            }
	            if (sess.result) {
	              const q = Array.isArray(sess.queue) ? sess.queue : [];
	              const c = new Set((sess.result.correct || []).map(mapQid));
	              const w = new Set((sess.result.wrong || []).map(mapQid));
	              const sk = new Set((sess.result.skipped || []).map(mapQid));
	              sess.result.correct = q.filter(x => c.has(x));
	              sess.result.wrong = q.filter(x => w.has(x));
	              sess.result.skipped = q.filter(x => sk.has(x));
	            }
	          }
	        } catch { }
	
	        return true;
	      }

      function getTagLinkChain(qid) {
        let key = String(qid || '');
        const visited = new Set();
        const chain = [];
        while (true) {
          if (!key) break;
          if (visited.has(key)) break;
          visited.add(key);
          chain.push(key);
          const st = getProblemState(key);
          const next = (typeof st.tagLink === 'string' && st.tagLink) ? String(st.tagLink) : key;
          if (next === key) break;
          key = next;
        }
        return chain;
      }
      function getTagOwnerKey(qid) {
        const chain = getTagLinkChain(qid);
        return chain.length ? chain[chain.length - 1] : String(qid || '');
      }
      function getEffectiveTag(qid) {
        const q = String(qid || '');
        const st = getProblemState(q);
        if (st.tagAutoOff) return normalizeTag(st.tag);
        const owner = getTagOwnerKey(q);
        if (owner && owner !== q) return normalizeTag(getProblemState(owner).tag);
        return normalizeTag(st.tag);
      }
      function setProblemTag(qid, tag) {
        const q = String(qid || '');
        const t = normalizeTag(tag);
        const st = getProblemState(q);
        if (st.tagAutoOff) {
          updateProblemState(q, { tag: t });
          return t;
        }
        const owner = getTagOwnerKey(q);
        updateProblemState(owner || q, { tag: t });
        return t;
      }
      function updateProblemState(qid, patch) {
        const cur = getProblemState(qid);
        const normalized = { ...patch };
        if (Object.prototype.hasOwnProperty.call(normalized, 'official_answer')) {
          normalized.official_answer = normalizeOfficialAnswerValue(normalized.official_answer);
        }
        const next = { ...cur, ...normalized };
        if (!hasOfficialAnswer(next.official_answer)) delete next.official_answer;
        problemState.map[String(qid || '')] = next;
        problemState.save();
      }
      function scrubProblemStatePlaceholderAnswers() {
        let changed = false;
        Object.keys(problemState.map || {}).forEach(qid => {
          const st = problemState.map[qid];
          if (!st || !Object.prototype.hasOwnProperty.call(st, 'official_answer')) return;
          if (!hasOfficialAnswer(st.official_answer)) {
            delete st.official_answer;
            changed = true;
          }
        });
        if (changed) problemState.save();
        return changed;
      }
      scrubProblemStatePlaceholderAnswers();

      // Repair legacy "[object Object]" artifacts already persisted in strings.
      // This cannot recover lost content, but prevents visibly broken render output.
	      function repairObjectArtifactsInAllData() {
	        const fix = (v) => {
	          // Only repair legacy artifacts already persisted in *strings*.
	          // Do not stringify objects/arrays here (can cause irreversible structural loss).
	          if (typeof v !== 'string') return v;
	          if (v.indexOf('[object Object]') === -1) return v;
	          return repairObjectObjectArtifactsInText(v);
	        };
	        let changed = false;

        // Problem state overrides
        let stateChanged = false;
        Object.keys(problemState.map || {}).forEach(qid => {
          const st = problemState.map[qid];
          if (!st || typeof st !== 'object') return;
	          ['question_text', 'answer_choices', 'official_explanation'].forEach(k => {
	            if (!Object.prototype.hasOwnProperty.call(st, k)) return;
	            const v = st[k];
	            const next = fix(v);
	            if (typeof v === 'string' && next !== v) { st[k] = next; stateChanged = true; }
	          });
	        });
        if (stateChanged) { problemState.save(); changed = true; }

        // Problem memos
        let memosChanged = false;
        Object.keys(problemState.memos || {}).forEach(owner => {
          const list = problemState.memos[owner];
          if (!Array.isArray(list)) return;
	          list.forEach(m => {
	            if (!m || typeof m !== 'object') return;
	            if (!Object.prototype.hasOwnProperty.call(m, 'text')) return;
	            const v = m.text;
	            const next = fix(v);
	            if (typeof v === 'string' && next !== v) { m.text = next; memosChanged = true; }
	          });
	        });
        if (memosChanged) { problemState.saveMemos(); changed = true; }

        // Loaded problems.json (if present)
        let pjChanged = false;
        const typesObj = problems?.json?.types;
        if (typesObj && typeof typesObj === 'object') {
          Object.keys(typesObj).forEach(title => {
	            (typesObj[title] || []).forEach(p => {
	              if (!p || typeof p !== 'object') return;
	              // Ensure critical identifiers are not "[object Object]"
	              if (Object.prototype.hasOwnProperty.call(p, 'qid')) {
	                const prevQid = p.qid;
	                const nextQid = (typeof prevQid === 'string')
	                  ? repairObjectObjectArtifactsInText(prevQid)
	                  : coerceText(prevQid);
	                if (typeof nextQid === 'string' && nextQid && nextQid !== '[object Object]' && nextQid !== prevQid) {
	                  p.qid = nextQid;
	                  pjChanged = true;
	                }
	              }
	              if (Object.prototype.hasOwnProperty.call(p, 'paperName') && typeof p.paperName !== 'string') {
	                // paperName should be a string; coerce without introducing "[object Object]".
	                p.paperName = coerceText(p.paperName);
	                pjChanged = true;
	              }
	              ['question_text', 'answer_choices', 'official_explanation'].forEach(k => {
	                if (!Object.prototype.hasOwnProperty.call(p, k)) return;
	                const v = p[k];
	                const next = fix(v);
	                if (typeof v === 'string' && next !== v) { p[k] = next; pjChanged = true; }
	              });
            });
          });
        }
        if (pjChanged) {
          try { LS.set('fmm_problems_json', problems.json); } catch { }
          changed = true;
        }

        // Stored guide markdown overrides (best-effort)
        let guideChanged = false;
        let fixedGuideSource = null;
        try {
          for (let i = 0; i < store.length; i++) {
            const k = store.key(i);
            if (!k) continue;
            if (!(k.startsWith('fmm_explanation_') || k.startsWith('fmm_standard_') || k === 'fmm_source')) continue;
            const raw = store.getItem(k);
            if (typeof raw !== 'string' || raw.indexOf('[object Object]') === -1) continue;
            const next = fix(raw);
            if (next !== raw) {
              store.setItem(k, next);
              guideChanged = true;
              if (k === 'fmm_source') fixedGuideSource = next;
            }
          }
        } catch { }

        // Also repair the live textarea content (it is loaded before this repair runs).
        try {
          if (sourceEl && typeof sourceEl.value === 'string' && sourceEl.value.indexOf('[object Object]') !== -1) {
            const raw = unmaskDataImages(sourceEl.value, sourceEl);
            const next = fix(raw);
            if (next !== raw) {
              fixedGuideSource = next;
              guideChanged = true;
              store.setItem('fmm_source', next);
            }
          }
        } catch { }

        // Sync textarea + re-render if user is currently seeing the artifacts.
        try {
          if (fixedGuideSource != null && sourceEl && typeof sourceEl.value === 'string' && sourceEl.value.indexOf('[object Object]') !== -1) {
            sourceEl.value = maskDataImages(fixedGuideSource, sourceEl);
            if (outputEl && (outputEl.innerHTML || '').indexOf('[object Object]') !== -1) {
              try { render(); } catch { }
            }
          }
        } catch { }
        if (guideChanged) changed = true;

        return changed;
      }
      function recordProblemAttempt(qid, payload) {
        const st = getProblemState(qid);
        const now = Date.now();
        const history = Array.isArray(st.history) ? st.history.slice() : [];
        const sid = payload.sessionId || null;
        const already = sid != null && history.some(h => h && h.sessionId === sid);
        history.push({
          ts: now,
          sessionId: sid,
          choice: payload.choice ?? null,
          official: payload.official ?? null,
          correct: payload.correct
        });
        const MAX_HISTORY = 50;
        if (history.length > MAX_HISTORY) {
          history.splice(0, history.length - MAX_HISTORY);
        }
        const attemptsDelta = already ? 0 : 1;
        const correctDelta = already || payload.correct !== true ? 0 : 1;
        const wrongDelta = already || payload.correct !== false ? 0 : 1;
        updateProblemState(qid, {
          attempts: (st.attempts || 0) + attemptsDelta,
          correctCount: (st.correctCount || 0) + correctDelta,
          wrongCount: (st.wrongCount || 0) + wrongDelta,
          lastResult: payload.correct === null ? 'skipped' : (payload.correct ? 'correct' : 'wrong'),
          lastAnswer: payload.choice ?? null,
          lastOfficial: payload.official ?? st.lastOfficial ?? null,
          lastAttemptAt: now,
          history
        });
      }
      function appendSolveHistory(entry) {
        const list = LS.get(SOLVE_HISTORY_KEY, []);
        const idx = list.findIndex(h => h && h.id === entry.id);
        if (idx >= 0) {
          list[idx] = { ...list[idx], ...entry };
        } else {
          list.push(entry);
        }
        LS.set(SOLVE_HISTORY_KEY, list);
      }
	      function applyProblemOverrides(q) {
	        if (!q || !q.qid) return q;
	        const st = getProblemState(q.qid);
	        const mergedOfficial = (typeof st.official_answer !== 'undefined') ? st.official_answer : q.official_answer;
	        const mergedOfficialNormalized = normalizeOfficialAnswerValue(mergedOfficial);
	        const baseQuestion = st.question_text ?? q.question_text;
	        const baseChoices = st.answer_choices ?? q.answer_choices;
	        const normalized = normalizeQuestionAndChoices(baseQuestion, baseChoices);
	        return {
	          ...q,
	          question_text: normalized.question_text,
	          answer_choices: normalized.answer_choices,
	          official_answer: mergedOfficialNormalized,
	          official_explanation: st.official_explanation ?? q.official_explanation
	        };
	      }
      function getMemoLinkChain(qid) {
        // memoLink ì²´ì¸ì„ ë”°ë¼ê°€ì„œ ê·¸ë£¹ì˜ ëŒ€í‘œ í‚¤ë¥¼ ì°¾ëŠ”ë‹¤
        // ideology: ì´ë¯¸ ê³µìœ ëœ ë¬¸ì œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë˜ ê³µìœ í•´ë„ ëª¨ë‘ í•œ ê·¸ë£¹ìœ¼ë¡œ ë¬¶ì´ë„ë¡
        let key = String(qid || '');
        const visited = new Set();
        const chain = [];
        while (true) {
          if (!key) break;
          if (visited.has(key)) break; // cycle safety
          visited.add(key);
          chain.push(key);
          const st = getProblemState(key);
          const next = (typeof st.memoLink === 'string' && st.memoLink) ? String(st.memoLink) : key;
          if (next === key) break;
          key = next;
        }
        return chain;
      }
      function getMemoOwnerKey(qid) {
        const chain = getMemoLinkChain(qid);
        return chain.length ? chain[chain.length - 1] : String(qid || '');
      }
      function getProblemMemos(qid) {
        const chain = getMemoLinkChain(qid);
        const ownerKey = chain.length ? chain[chain.length - 1] : String(qid || '');
        const buckets = [];
        chain.forEach(k => {
          const list = problemState.memos[k];
          if (Array.isArray(list)) buckets.push({ key: k, list });
        });
        if (!buckets.length) return [];
        if (buckets.length === 1 && buckets[0].key === ownerKey) return buckets[0].list;

        // Merge all memo buckets across the chain into the owner key (data-preserving).
        const merged = [];
        const seen = new Set();
        buckets.forEach(({ list }) => {
          (list || []).forEach(m => {
            if (!m) return;
            const id = (m.id != null) ? String(m.id) : '';
            if (id) {
              if (seen.has(id)) return;
              seen.add(id);
            }
            merged.push(m);
          });
        });
        merged.sort((a, b) => Number(a?.createdAt || a?.id || 0) - Number(b?.createdAt || b?.id || 0));

        problemState.memos[ownerKey] = merged;
        chain.forEach(srcKey => { if (srcKey !== ownerKey) { try { delete problemState.memos[srcKey]; } catch { } } });
        problemState.saveMemos();
        return merged;
      }
      function saveProblemMemos(qid, list) {
        const key = getMemoOwnerKey(qid);
        problemState.memos[key] = Array.isArray(list) ? list : [];
        // Purge per-qid buckets inside the group to avoid deleted memos resurfacing after share/unshare.
        const chain = getMemoLinkChain(qid);
        chain.forEach(srcKey => { if (srcKey !== key) { try { delete problemState.memos[srcKey]; } catch { } } });
        problemState.saveMemos();
      }

      function linkProblemMemos(qid, baseQid) {
        const src = String(qid || '').trim();
        const base = String(baseQid || '').trim();
        if (!src || !base) return { ok: false, owner: null };
        const baseOwner = getMemoOwnerKey(base);
        const srcOwner = getMemoOwnerKey(src);
        if (!baseOwner) return { ok: false, owner: null };
        if (srcOwner === baseOwner) {
          updateProblemState(src, { memoLink: baseOwner, memoLinkMode: 'manual', representativeMemoId: null });
          return { ok: true, owner: baseOwner };
        }

        // Ensure both groups are canonicalized before merge (merge per-qid buckets into each owner).
        const a = getProblemMemos(base).slice();
        const b = getProblemMemos(src).slice();

        // Merge memos into base owner (data-preserving).
        const merged = [];
        const seen = new Set();
        const pushAll = (arr) => {
          (arr || []).forEach(m => {
            if (!m) return;
            const id = (m.id != null) ? String(m.id) : '';
            if (id) {
              if (seen.has(id)) return;
              seen.add(id);
            }
            merged.push(m);
          });
        };
        pushAll(a);
        pushAll(b);
        merged.sort((x, y) => Number(x?.createdAt || x?.id || 0) - Number(y?.createdAt || y?.id || 0));
        problemState.memos[baseOwner] = merged;

        // Link the source *group owner* into the base owner so entire groups merge.
        updateProblemState(srcOwner, { memoLink: baseOwner, memoLinkMode: 'manual', representativeMemoId: null });
        updateProblemState(src, { memoLink: baseOwner, memoLinkMode: 'manual', representativeMemoId: null });

        // Old owner bucket becomes redundant after merge.
        try { delete problemState.memos[srcOwner]; } catch { }
        problemState.saveMemos();
        return { ok: true, owner: baseOwner };
      }
      function unlinkProblemMemos(qid) {
        const src = String(qid || '').trim();
        if (!src) return { ok: false };
        const prevOwner = getMemoOwnerKey(src);
        if (prevOwner === src) {
          updateProblemState(src, { memoLink: src });
          return { ok: true, owner: src };
        }
        const snapshot = getProblemMemos(src).slice();
        const prevRep = getProblemState(prevOwner).representativeMemoId;
        updateProblemState(src, { memoLink: src, representativeMemoId: prevRep == null ? null : Number(prevRep) });
        problemState.memos[src] = snapshot;
        problemState.saveMemos();
        return { ok: true, owner: src, prevOwner };
      }

      // ----- Right sidebar: Global & Type memos -----
      const typeMemoEl = $('#typeMemo'), typeMemoTitle = $('#typeMemoTitle');
      function currentTypeIndex() {
        const cards = $$('.type-card');
        if (cards.length === 0) return 0;
        const fromTop = window.scrollY + 100;
        let cur = 0; cards.forEach((sec, i) => { if (sec.offsetTop <= fromTop) cur = i; });
        return cur;
      }
      function currentTypeTitle() {
        const idx = currentTypeIndex();
        const t = (window.fmm_types || [])[idx];
        return t ? t.title : null;
      }

      function escapeCssSelectorValue(v) {
        const s = String(v || '');
        if (window.CSS && typeof window.CSS.escape === 'function') return window.CSS.escape(s);
        return s.replace(/[^a-zA-Z0-9_-]/g, (ch) => '\\' + ch.charCodeAt(0).toString(16) + ' ');
      }
      function flashProblemsItem(el) {
        if (!el) return;
        flashUiElement(el);
      }
      function flashUiElement(el) {
        if (!el) return;
        el.classList.remove('flash');
        // force reflow so the animation restarts even if called twice quickly
        void el.offsetWidth;
        el.classList.add('flash');
        setTimeout(() => { try { el.classList.remove('flash'); } catch { } }, 1400);
      }

      async function gotoProblemByQid(qid, opts) {
        opts = opts || {};
        const q = String(qid || '').trim();
        if (!q) return false;
        const typeTitle = (problems && problems.qidType && problems.qidType[q]) ? String(problems.qidType[q]) : '';
        if (!typeTitle) {
          alert('ì´ QIDì˜ ìœ í˜•ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ë¬¸ì œ JSONì´ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”)');
          return false;
        }
        const norm = normalizeTitle(typeTitle);
        const types = window.fmm_types || [];
        const idx = types.findIndex(t => normalizeTitle(t?.title || '') === norm);
        if (idx < 0) {
          alert('í•´ë‹¹ ìœ í˜• ì„¹ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ê°€ì´ë“œê°€ ë Œë”ë§ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”)');
          return false;
        }
        const sec = document.getElementById(`type-${idx + 1}`);
        if (sec) {
          const topAbs = sec.getBoundingClientRect().top + window.scrollY;
          window.scrollTo({ top: Math.max(0, topAbs - 80), behavior: opts.behavior || 'smooth' });
        }

        // Ensure the left sidebar is visible so we can scroll/highlight inside it
        if (opts.openLeftAside !== false) {
          const aside = document.getElementById('leftAside');
          if (aside) {
            aside.style.display = '';
            try { restoreSavedBox(aside, 'fmm_ui_leftAside'); } catch { }
          }
        }

        // Wait until the target type is the "current" one (scroll spy uses scroll position)
        await new Promise(resolve => {
          const start = Date.now();
          const tick = () => {
            if (currentTypeIndex() === idx) return resolve();
            if (Date.now() - start > 1400) return resolve();
            requestAnimationFrame(tick);
          };
          tick();
        });

        try { renderProblemsForCurrentType(); } catch { }
        await new Promise(r => requestAnimationFrame(r));

        const listEl = document.getElementById('problemsList');
        if (listEl) {
          const sel = `.problems-item[data-qid="${escapeCssSelectorValue(q)}"]`;
          const item = listEl.querySelector(sel);
          if (item) {
            try { item.scrollIntoView({ block: 'center', behavior: 'smooth' }); } catch { }
            flashProblemsItem(item);
            item.dispatchEvent(new MouseEvent('click', { bubbles: true }));
          }
        }
        return true;
      }
      window.gotoProblemByQid = gotoProblemByQid;

      function loadGlobalMemo() { const el = $('#globalMemo'); if (el) { el.value = maskDataImages(LS.get('fmm_memo_global', ''), el); } }
      function saveGlobalMemo() { const el = $('#globalMemo'); if (el) { LS.set('fmm_memo_global', unmaskDataImages(el.value, el)); } }
      // PATCH: Replaced simple save listener with one that prioritizes category memos
      // ideology: single save action should do â€œthe obvious thingâ€ the user sees selected
      $('#globalMemoSave').addEventListener('click', () => {
        const panel = $('#globalMemoPanel');
        if (panel && panel._category && panel._category.updateSelectedContent()) {
          statusEl.textContent = (currentLang === 'ko') ? 'ì¹´í…Œê³ ë¦¬ ë©”ëª¨ ì—…ë°ì´íŠ¸ë¨' : 'Category memo updated';
        } else {
          saveGlobalMemo();
        }
      });
      $('#globalMemoDelete').addEventListener('click', () => {
        $('#globalMemo').value = ''; saveGlobalMemo();
      }); // ideology: deletion must be explicit & reversible via exports

      function loadTypeMemo() {
        const title = currentTypeTitle();
        typeMemoTitle.textContent = title ? `(${title})` : '';
        typeMemoEl.value = title ? maskDataImages(LS.get(`fmm_memo_type_${title}`, ''), typeMemoEl) : '';
      }
      function saveTypeMemo() {
        const title = currentTypeTitle();
        if (title) LS.set(`fmm_memo_type_${title}`, unmaskDataImages(typeMemoEl.value, typeMemoEl));
      }
      // PATCH: Replaced simple save listener with one that prioritizes category memos
      $('#typeMemoSave').addEventListener('click', () => {
        const panel = $('#typeMemoPanel');
        if (panel && panel._category && panel._category.updateSelectedContent()) {
          statusEl.textContent = (currentLang === 'ko') ? 'ì¹´í…Œê³ ë¦¬ ë©”ëª¨ ì—…ë°ì´íŠ¸ë¨' : 'Category memo updated';
        } else {
          saveTypeMemo();
        }
      });
      $('#typeMemoDelete').addEventListener('click', () => {
        $('#typeMemo').value = ''; saveTypeMemo();
      });

		      // Minimize panels
		      document.body.addEventListener('click', (e) => {
		        const btn = e.target.closest('button[data-action="min"]'); if (!btn) return;
		        const target = document.querySelector(btn.dataset.target); if (!target) return;
		        const isMin = target.classList.toggle('min');
		        const aside = target.closest('.aside');
		        if (aside) aside.classList.toggle('min', isMin);
		        btn.textContent = isMin ? '+' : 'â€”';
		        btn.title = isMin ? 'í¼ì¹˜ê¸°' : 'ì ‘ê¸°';
		      });

      // Track type changes
      let _lastType = -1;
      function onTypeMaybeChange() {
        const idx = currentTypeIndex();
        if (idx !== _lastType) {
          _lastType = idx;
          loadTypeMemo();
          renderProblemsForCurrentType();
          // PATCH START: refresh Type memo list if visible
          const tPanel = $('#typeMemoPanel');
          if (tPanel && tPanel._category) tPanel._category.refresh(); // ideology: UI mirrors current type without extra clicks
          // PATCH END
        }
      }
      document.addEventListener('scroll', onTypeMaybeChange);
      window.addEventListener('hashchange', onTypeMaybeChange);
      setTimeout(onTypeMaybeChange, 200);

      // ----- Anchored memos: word & spot (thumbnail on hover, main popup on click) -----
      function getMemoStore(kind) { return LS.get(kind === 'word' ? 'fmm_memos_words' : 'fmm_memos_spots', {}); }
      function setMemoStore(kind, data) { LS.set(kind === 'word' ? 'fmm_memos_words' : 'fmm_memos_spots', data); }

      // selection menu
      const selectionMenu = document.createElement('div');
      selectionMenu.className = 'memo-pop'; selectionMenu.style.display = 'none';
      selectionMenu.innerHTML = `<div style="display:flex; gap:6px; flex-wrap:wrap;">
        <button class="btn" data-kind="word">ğŸ”– ë‹¨ì–´ ë©”ëª¨</button>
        <button class="btn" data-kind="spot">ğŸ“ ìœ„ì¹˜ ë©”ëª¨</button>
        <button class="btn" data-action="close">ì·¨ì†Œ</button>
      </div>`;
      document.body.appendChild(selectionMenu);
      function showSelectionMenu(x, y) { selectionMenu.style.left = x + 'px'; selectionMenu.style.top = y + 'px'; selectionMenu.style.display = ''; }
      function hideSelectionMenu() { selectionMenu.style.display = 'none'; }

      outputEl.addEventListener('mouseup', (e) => {
        const sel = window.getSelection(); const str = sel && sel.toString().trim();
        if (!str) return hideSelectionMenu();
        const scope = sel.anchorNode?.parentElement?.closest('.md');
        if (!scope) return hideSelectionMenu();
        showSelectionMenu(e.pageX, e.pageY);
      });
      selectionMenu.addEventListener('click', (e) => {
        const b = e.target.closest('button'); if (!b) return;
        if (b.dataset.action === 'close') return hideSelectionMenu();
        const sel = window.getSelection(); const str = sel && sel.toString().trim(); if (!str) return hideSelectionMenu();
        const range = sel.getRangeAt(0);
        const span = document.createElement('span');
        if (b.dataset.kind === 'word') {
          const key = str.toLowerCase();
          span.className = 'memo-anchor'; span.dataset.kind = 'word'; span.dataset.key = key;
          range.surroundContents(span);
          openMemoEditor({ kind: 'word', key }, span, str);
        } else {
          const key = 'spot_' + Date.now() + '_' + Math.random().toString(36).slice(2, 7);
          span.className = 'memo-anchor'; span.dataset.kind = 'spot'; span.dataset.key = key;
          span.dataset.typeIndex = String(currentTypeIndex());
          span.dataset.side = (sel.anchorNode?.parentElement?.closest('.explanation')) ? 'explanation' : 'problem';
          range.surroundContents(span);
          openMemoEditor({ kind: 'spot', key }, span, str);
        }
        hideSelectionMenu();
      });

      // ideology: ê°€ì‹œ ìƒíƒœ = ì €ì¥ ìƒíƒœ ë™í˜•; ì €ì¥ì†Œì—ì„œ ì‚¬ë¼ì§€ë©´ í™”ë©´ì—ì„œë„ í”ì ì´ ì—†ì–´ì•¼ í•¨
      function unwrapAllAnchorsFor(kind, key) {
        $$('.memo-anchor').forEach(el => {
          if (el.dataset.kind === kind && el.dataset.key === key) {
            const parent = el.parentNode;
            while (el.firstChild) parent.insertBefore(el.firstChild, el);
            el.remove();
          }
        });
      }

	      function openMemoEditor(meta, anchorEl, anchorText) {
	        const store = getMemoStore(meta.kind);
        // PATCH START: Add snippet capture for spot memos
        const entry = store[meta.key] || {
          thumb: '', text: '', createdAt: Date.now(),
          ...(meta.kind === 'spot' ? {
            typeIndex: Number(anchorEl?.dataset.typeIndex || currentTypeIndex()),
            side: anchorEl?.dataset.side || 'problem',
            snippet: String(anchorText || anchorEl?.textContent || '').slice(0, 200) // ideology: anchor on user-selected context, not DOM indices
          } : {})
        };
	        // PATCH END
	        const pop = document.createElement('div');
	        pop.className = 'memo-pop memo-editor'; // IDEOLOGY: richer editor sizing without affecting other popups
	        const targetText = meta.kind === 'word' ? String(anchorText || '') : String(anchorEl?.textContent || '');
	        pop.innerHTML = `
	          <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
	            <strong>${meta.kind === 'word' ? 'ğŸ”– ë‹¨ì–´ ë©”ëª¨' : 'ğŸ“ ìœ„ì¹˜ ë©”ëª¨'}</strong>
	            <button class="btn" data-action="close">âœ•</button>
	          </div>
	          <div class="muted" style="margin:6px 0;">ëŒ€ìƒ: <code>${escapeHtml(targetText)}</code></div>
	          <input class="memo-textarea" id="thumb" placeholder="ì¸ë„¤ì¼(í˜¸ë²„ ì‹œ ë³´ì„)" style="min-height:38px;">
	          <textarea class="memo-textarea" id="text" placeholder="ë©”ëª¨ ë³¸ë¬¸" style="min-height:160px;"></textarea>
	          <div class="md memo-render" id="memoRender" style="margin-top:8px; border:1px dashed var(--border); border-radius:8px; padding:8px;"></div>
	          <div class="chat-controls">
	            <button class="btn-primary" data-action="save">ì €ì¥</button>
	            <button class="btn" data-action="delete">ì‚­ì œ</button>
	          </div>`;
        document.body.appendChild(pop);
        const r = anchorEl.getBoundingClientRect();
        pop.style.left = (r.left + window.scrollX) + 'px';
        pop.style.top = (r.bottom + window.scrollY + 6) + 'px';
        pop.querySelector('#thumb').value = entry.thumb || '';
        const ta = pop.querySelector('#text');
        const renderBox = pop.querySelector('#memoRender');
        ta.value = entry.text || '';
        function renderMemo() {
          const html = renderMarkdown(ta.value || '', { breaks: true, autoAsciiMath: true }, 'parseThenSanitize');
          renderBox.innerHTML = html;
          typesetMath(renderBox);
        }
        renderMemo();
        ta.addEventListener('input', renderMemo);
        pop.addEventListener('click', (e) => {
          const b = e.target.closest('button'); if (!b) return;
          if (b.dataset.action === 'close') { pop.remove(); return; }
          if (b.dataset.action === 'save') {
            entry.thumb = pop.querySelector('#thumb').value;
            entry.text = ta.value;
            store[meta.key] = entry; setMemoStore(meta.kind, store); pop.remove();

            // === ADD: auto-apply to all content immediately =========================
            // Ideology: no hidden steps â€” when user records a word, the UI reflects it everywhere.
            applyWordMemos(document.body);
          }
          if (b.dataset.action === 'delete') {
            if (confirm('ë©”ëª¨ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
              delete store[meta.key];
              setMemoStore(meta.kind, store);

              // í™”ë©´ì˜ í•´ë‹¹ ì•µì»¤ ëª¨ë‘ ì œê±° (ë¬¸ì œ/í•´ì„¤/ì¢Œì¸¡ ìƒì„¸ í¬í•¨)
              unwrapAllAnchorsFor(meta.kind, meta.key);

              // re-renderë¡œ ë¶€ìˆ˜íš¨ê³¼ ì •ë¦¬
              renderTypes(window.fmm_types || []);
              applyWordMemos(document.body);
              pop.remove();
            }
          }
        });

        // ADD: close editor when clicking outside
        // ideology: transient tools should disappear when context switches
        const outside = (ev) => {
          if (!ev.target.closest('.memo-pop.memo-editor')) {
            pop.remove(); document.removeEventListener('mousedown', outside, true);
          }
        };
        setTimeout(() => document.addEventListener('mousedown', outside, true), 0);
      }

      // Hover thumbnail + click to open
      document.body.addEventListener('mouseover', (e) => {
        const a = e.target.closest('.memo-anchor'); if (!a) return;
        const data = getMemoStore(a.dataset.kind)[a.dataset.key];
        if (!data?.thumb) return;
        const tip = document.createElement('div');
        tip.className = 'memo-pop memo-thumb'; tip.textContent = data.thumb;
        document.body.appendChild(tip);
        // FIX: place above the cursor with viewport clamping
        // ideology: tooltips should not occlude the reading target
        const tr = tip.getBoundingClientRect();
        const margin = 10;
        let x = (e.pageX || (a.getBoundingClientRect().left + window.scrollX)) + 12;
        let y = (e.pageY || (a.getBoundingClientRect().top + window.scrollY)) - tr.height - margin;
        const vx = window.scrollX, vy = window.scrollY, vw = window.innerWidth, vh = window.innerHeight;
        // clamp horizontally
        x = Math.max(vx + 8, Math.min(vx + vw - tr.width - 8, x));
        // if above goes off-screen, show below cursor
        if (y < vy + 8) y = (e.pageY || (a.getBoundingClientRect().bottom + window.scrollY)) + margin;
        tip.style.left = x + 'px';
        tip.style.top = y + 'px';
        // FIX: use mouseleave so moving within a long anchor doesn't dismiss
        // ideology: hover affordances must be stable for long selections
        a.addEventListener('mouseleave', () => tip.remove(), { once: true });
      });
      document.body.addEventListener('click', (e) => {
        const a = e.target.closest('.memo-anchor'); if (!a) return;
        openMemoEditor({ kind: a.dataset.kind, key: a.dataset.key }, a, a.textContent);
      });

      // Re-apply word-memo highlighting after re-renders
      function applyWordMemos(root) {
        const words = getMemoStore('word'); const keys = Object.keys(words); if (!keys.length) return;
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
          acceptNode(node) {
            if (!node.nodeValue) return NodeFilter.FILTER_SKIP;
            const pe = node.parentElement;
            if (!pe || pe.closest('.memo-anchor') || ['CODE', 'PRE', 'SCRIPT', 'STYLE'].includes(pe.tagName)) return NodeFilter.FILTER_SKIP;
            return NodeFilter.FILTER_ACCEPT;
          }
        });
        const nodes = []; let n; while ((n = walker.nextNode())) nodes.push(n);
        nodes.forEach(node => {
          const text = node.nodeValue, low = text.toLowerCase();
          let out = []; let i = 0; let changed = false;
          while (i < text.length) {
            let hit = null;
            for (const k of keys) { if (!k) continue; if (low.startsWith(k, i)) { hit = k; break; } }
            if (hit) {
              const span = document.createElement('span');
              span.className = 'memo-anchor'; span.dataset.kind = 'word'; span.dataset.key = hit;
              span.textContent = text.slice(i, i + hit.length);
              out.push(span); i += hit.length; changed = true;
            } else { out.push(document.createTextNode(text[i])); i++; }
          }
          if (changed) {
            const frag = document.createDocumentFragment(); out.forEach(x => frag.appendChild(x)); node.replaceWith(frag);
          }
        });
      }

      // PATCH START: Function to re-apply spot memos by searching for their snippet
      function reapplySpotMemos(scope) {
        const spots = getMemoStore('spot'); const keys = Object.keys(spots || {});
        if (!keys.length) return;
        keys.forEach(k => {
          const s = spots[k]; if (!s) return;
          // skip if already anchored
          let exists = false;
          $$('.memo-anchor[data-kind="spot"]', scope || document).forEach(el => { if (el.dataset.key === k) exists = true; });
          if (exists) return;

          const typeIdx = Number(s.typeIndex);
          const side = s.side || 'problem';
          const sec = $$('.type-card')[typeIdx]; if (!sec) return;
          const container = sec.querySelector(side === 'explanation' ? '.explanation' : '.problem'); if (!container) return;
          const snippet = (s.snippet || '').trim(); if (!snippet) return;

          const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, {
            acceptNode(node) {
              if (!node.nodeValue) return NodeFilter.FILTER_SKIP;
              const pe = node.parentElement;
              if (!pe || pe.closest('.memo-anchor') || ['CODE', 'PRE', 'SCRIPT', 'STYLE'].includes(pe.tagName)) return NodeFilter.FILTER_SKIP;
              return node.nodeValue.includes(snippet) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
            }
          });
          const n = walker.nextNode(); if (!n) return;
          const i = n.nodeValue.indexOf(snippet);
          const before = n.nodeValue.slice(0, i), match = n.nodeValue.slice(i, i + snippet.length), after = n.nodeValue.slice(i + snippet.length);
          const span = document.createElement('span');
          span.className = 'memo-anchor'; span.dataset.kind = 'spot'; span.dataset.key = k;
          span.dataset.typeIndex = String(typeIdx); span.dataset.side = side;
          span.textContent = match;
          const frag = document.createDocumentFragment();
          if (before) frag.appendChild(document.createTextNode(before));
          frag.appendChild(span);
          if (after) frag.appendChild(document.createTextNode(after));
          n.replaceWith(frag);
        });
      }
      // PATCH END

      function captureReadingAnchorText(root) {
        if (!root) return '';
        const y = 140; // below header area
        const candidates = root.querySelectorAll('h1,h2,h3,h4,h5,h6,p,li,blockquote,pre,table');
        let chosen = null;
        for (const el of candidates) {
          const r = el.getBoundingClientRect();
          if (r.top <= y && r.bottom >= y) { chosen = el; break; }
        }
        if (!chosen) {
          for (const el of candidates) {
            const r = el.getBoundingClientRect();
            if (r.bottom > 0 && r.top < window.innerHeight) { chosen = el; break; }
          }
        }
        const text = String((chosen || root).textContent || '').replace(/\s+/g, ' ').trim();
        return text.slice(0, 80);
      }

	      function restoreReadingAnchorText(root, anchorText) {
	        const key = String(anchorText || '').replace(/\s+/g, ' ').trim();
	        if (!root || !key) return false;
        const needle = key.slice(0, Math.min(40, key.length));
        if (!needle) return false;
        const candidates = root.querySelectorAll('h1,h2,h3,h4,h5,h6,p,li,blockquote,pre,table');
        for (const el of candidates) {
          const t = String(el.textContent || '').replace(/\s+/g, ' ').trim();
          if (t.includes(needle)) {
            el.scrollIntoView({ block: 'center' });
            return true;
          }
        }
	        return false;
	      }

	      // ----- Render-edit mode: edit small markdown chunks from the rendered view -----
	      const renderEditState = {
	        active: new Set(), // key -> enabled
	        maps: new Map(),   // key -> { blocks: string[], typeIndex, side, title, slug, wasEmpty }
	        modal: null,
	        current: null
	      };
	      const EMPTY_EXPLANATION_PLACEHOLDER = '_í•´ì„¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤._';
	
	      function renderEditKey(typeIndex, side) {
	        return `type:${Number(typeIndex)}:${String(side || '')}`;
	      }
	      function parseRenderEditKey(key) {
	        const m = String(key || '').match(/^type:(\d+):(problem|explanation)$/);
	        if (!m) return null;
	        return { typeIndex: parseInt(m[1], 10), side: m[2] };
	      }
	      function typeSlugFromTitle(title) {
	        return String(title || '').toLowerCase().replace(/\s+/g, '_');
	      }
	      function lexMarkdownBlocks(md) {
	        const src = String(md || '').replace(/\r\n/g, '\n');
	        try {
	          if (typeof marked !== 'undefined' && typeof marked.lexer === 'function') {
	            const toks = marked.lexer(src);
	            const blocks = (toks || []).map(t => (t && typeof t.raw === 'string') ? t.raw : '').filter(s => s !== '');
	            if (blocks.length) return blocks;
	          }
	        } catch { }
	        return [src];
	      }
	
	      function ensureRenderEditModal() {
	        if (renderEditState.modal) return renderEditState.modal;
	        const overlay = document.createElement('div');
	        overlay.className = 'fmm-modal-overlay';
	        overlay.id = 'fmmRenderEditModal';
	        overlay.innerHTML = `
	          <div class="fmm-modal" role="dialog" aria-modal="true" aria-label="ë Œë”í¸ì§‘">
	            <div class="fmm-modal-head">
	              <strong id="fmmRenderEditTitle">ğŸª„ ë Œë”í¸ì§‘</strong>
	              <div style="display:flex;gap:8px;align-items:center;">
	                <button class="btn" id="fmmRenderEditClose">âœ•</button>
	              </div>
	            </div>
	            <div class="fmm-modal-body">
	              <div class="muted" id="fmmRenderEditHint" style="margin-bottom:6px;"></div>
	              <textarea class="memo-textarea" id="fmmRenderEditText" style="min-height:180px;"></textarea>
	              <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px;">
	                <button class="btn-primary" id="fmmRenderEditSave">ì €ì¥</button>
	                <button class="btn" id="fmmRenderEditCancel">ì·¨ì†Œ</button>
	                <span class="muted" style="margin-left:auto;">íŒ: ì—¬ê¸°ì„œëŠ” â€œí•´ë‹¹ ë¸”ë¡â€ë§Œ ìˆ˜ì •ë©ë‹ˆë‹¤.</span>
	              </div>
	              <div class="fmm-modal-preview md" id="fmmRenderEditPreview"></div>
	            </div>
	          </div>
	        `;
	        document.body.appendChild(overlay);
	        const titleEl = overlay.querySelector('#fmmRenderEditTitle');
	        const hintEl = overlay.querySelector('#fmmRenderEditHint');
	        const ta = overlay.querySelector('#fmmRenderEditText');
	        const preview = overlay.querySelector('#fmmRenderEditPreview');
	        const closeBtn = overlay.querySelector('#fmmRenderEditClose');
	        const cancelBtn = overlay.querySelector('#fmmRenderEditCancel');
	        const saveBtn = overlay.querySelector('#fmmRenderEditSave');
	
	        const close = () => {
	          overlay.style.display = 'none';
	          renderEditState.current = null;
	          try { ta.value = ''; } catch { }
	          try { preview.innerHTML = ''; } catch { }
	        };
	        const open = () => {
	          overlay.style.display = 'flex';
	        };
	
	        const renderPreview = () => {
	          const cur = renderEditState.current;
	          if (!cur) return;
	          const map = renderEditState.maps.get(cur.key);
	          if (!map) return;
	          const raw = unmaskDataImages(ta.value || '', ta);
	          const html = (map.side === 'problem')
	            ? formatAnswerInProblem(renderMarkdown(raw, undefined, 'parseThenSanitize'))
	            : renderMarkdown(raw || EMPTY_EXPLANATION_PLACEHOLDER, undefined, 'parseThenSanitize');
	          preview.innerHTML = html;
	          try { insertBreaksBeforeCircled(preview); } catch { }
	          try { applyInlineBoldMarkers(preview); } catch { }
	          try { applyWordMemos(preview); } catch { }
	          try { typesetMath(preview); } catch { }
	        };
	        let tmr = null;
	        const schedulePreview = () => {
	          if (tmr) clearTimeout(tmr);
	          tmr = setTimeout(renderPreview, 90);
	        };
	
	        closeBtn?.addEventListener('click', close);
	        cancelBtn?.addEventListener('click', close);
	        overlay.addEventListener('click', (ev) => {
	          if (ev.target === overlay) close();
	        });
	        ta?.addEventListener('input', schedulePreview);
	
	        saveBtn?.addEventListener('click', () => {
	          const cur = renderEditState.current;
	          if (!cur) return;
	          const map = renderEditState.maps.get(cur.key);
	          if (!map) return;
	
	          const spots = Object.values(LS.get('fmm_memos_spots', {})).filter(s => s.typeIndex === map.typeIndex && s.side === map.side).length;
	          if (spots > 0 && !confirm(`ì´ êµ¬ì—­ì—ëŠ” ${spots}ê°œì˜ ìœ„ì¹˜ ë©”ëª¨ê°€ ìˆìŠµë‹ˆë‹¤. ì €ì¥ ì‹œ í‘œì‹œ ìœ„ì¹˜ê°€ ì‚¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
	
	          const newBlock = unmaskDataImages(ta.value || '', ta);
	          map.blocks[cur.blockIdx] = newBlock;
	          let nextMd = map.blocks.join('');
	          // If it started empty and user didn't change the placeholder, keep it empty.
	          if (map.wasEmpty && nextMd.trim() === EMPTY_EXPLANATION_PLACEHOLDER.trim()) nextMd = '';
	
	          const types = window.fmm_types || [];
	          const t = types[map.typeIndex];
	          if (!t) return;
	
	          const sec = document.getElementById(`type-${map.typeIndex + 1}`);
	          const content = sec?.querySelector(map.side === 'problem' ? '.standard-content' : '.explanation-content');
	          const scrollAnchor = captureReadingAnchorText(content || sec);
	          const secTopAbs = sec ? (sec.getBoundingClientRect().top + window.scrollY) : 0;
	          const scrollRel = window.scrollY - secTopAbs;
	
	          if (map.side === 'problem') t.standardMarkdown = nextMd;
	          else t.explanationMarkdown = nextMd;
	          const keyBase = (map.side === 'problem') ? 'fmm_standard_' : 'fmm_explanation_';
	          store.setItem(`${keyBase}${map.slug}`, nextMd);
	
	          close();
	          renderTypes(types);
	
	          const secNew = document.getElementById(`type-${map.typeIndex + 1}`);
	          if (secNew) {
	            const root = secNew.querySelector(map.side === 'problem' ? '.standard-content' : '.explanation-content') || secNew;
	            const ok = restoreReadingAnchorText(root, scrollAnchor);
	            if (!ok) {
	              const topAbs2 = secNew.getBoundingClientRect().top + window.scrollY;
	              window.scrollTo({ top: topAbs2 + (scrollRel || 0) });
	            }
	          }
	          statusEl.textContent = 'ë Œë”í¸ì§‘ ì €ì¥ë¨';
	        });
	
	        renderEditState.modal = { overlay, titleEl, hintEl, ta, preview, open, close, renderPreview };
	        return renderEditState.modal;
	      }
	
	      function renderTypeSectionNormal(typeIndex, side) {
	        const idx = Number(typeIndex);
	        const sec = document.getElementById(`type-${idx + 1}`);
	        const t = (window.fmm_types || [])[idx];
	        if (!sec || !t) return;
	        const content = sec.querySelector(side === 'problem' ? '.standard-content' : '.explanation-content');
	        if (!content) return;
	        const mdRaw = side === 'problem' ? (t.standardMarkdown || '') : (t.explanationMarkdown || '');
	        const md = (side === 'explanation' && !String(mdRaw || '').trim()) ? EMPTY_EXPLANATION_PLACEHOLDER : mdRaw;
	        content.classList.remove('fmm-render-edit-on');
	        const html = (side === 'problem')
	          ? formatAnswerInProblem(renderMarkdown(md, undefined, 'parseThenSanitize'))
	          : renderMarkdown(md, undefined, 'parseThenSanitize');
	        content.innerHTML = html;
	        try { $$('a', content).forEach(a => a.setAttribute('target', '_blank')); } catch { }
	        try { if (side === 'problem') insertBreaksBeforeCircled(content); } catch { }
	        try { applyInlineBoldMarkers(content); } catch { }
	        try { applyWordMemos(content); } catch { }
	        try { typesetMath(content); } catch { }
	      }
	
	      function renderTypeSectionBlocks(typeIndex, side) {
	        const idx = Number(typeIndex);
	        const sec = document.getElementById(`type-${idx + 1}`);
	        const t = (window.fmm_types || [])[idx];
	        if (!sec || !t) return;
	        const content = sec.querySelector(side === 'problem' ? '.standard-content' : '.explanation-content');
	        if (!content) return;
	
	        const title = String(t.title || '');
	        const slug = typeSlugFromTitle(title);
	        const rawMd = side === 'problem' ? (t.standardMarkdown || '') : (t.explanationMarkdown || '');
	        const wasEmpty = (side === 'explanation') && !String(rawMd || '').trim();
	        const displayMd = wasEmpty ? EMPTY_EXPLANATION_PLACEHOLDER : rawMd;
	
	        const key = renderEditKey(idx, side);
	        const blocks = lexMarkdownBlocks(displayMd);
	        renderEditState.maps.set(key, { blocks: blocks.slice(), typeIndex: idx, side, title, slug, wasEmpty });
	
	        content.innerHTML = '';
	        content.classList.add('fmm-render-edit-on');
	
	        blocks.forEach((blk, bi) => {
	          const wrap = document.createElement('div');
	          wrap.className = 'fmm-rend-block';
	          wrap.dataset.fmmBlockIdx = String(bi);
	          const html = (side === 'problem')
	            ? formatAnswerInProblem(renderMarkdown(blk, undefined, 'parseThenSanitize'))
	            : renderMarkdown(blk, undefined, 'parseThenSanitize');
	          wrap.innerHTML = html;
	          try { $$('a', wrap).forEach(a => a.setAttribute('target', '_blank')); } catch { }
	          content.appendChild(wrap);
	        });
	
	        try { if (side === 'problem') insertBreaksBeforeCircled(content); } catch { }
	        try { applyInlineBoldMarkers(content); } catch { }
	        try { applyWordMemos(content); } catch { }
	        try { typesetMath(content); } catch { }
	
	        if (!content._renderEditClickMounted) {
	          content._renderEditClickMounted = true;
	          content.addEventListener('click', (ev) => {
	            const sel = window.getSelection();
	            if (sel && sel.toString().length > 0) return;
	            if (ev.target.closest && ev.target.closest('a, button, input, textarea, select, label')) return;
	
	            const curKey = renderEditKey(idx, side);
	            if (!renderEditState.active.has(curKey)) return;
	
	            const blockEl = ev.target.closest?.('.fmm-rend-block');
	            if (!blockEl) return;
	            const bi = parseInt(blockEl.getAttribute('data-fmm-block-idx') || blockEl.dataset.fmmBlockIdx || '', 10);
	            if (!Number.isFinite(bi) || bi < 0) return;
	
	            const modal = ensureRenderEditModal();
	            const map = renderEditState.maps.get(curKey);
	            if (!map) return;
	
	            renderEditState.current = { key: curKey, blockIdx: bi };
	            modal.titleEl.textContent = `ğŸª„ ë Œë”í¸ì§‘ Â· ${map.title || ''} Â· ${side === 'problem' ? 'í‘œì¤€ë¬¸ì œ' : 'í•´ì„¤'} Â· ë¸”ë¡ ${bi + 1}/${map.blocks.length}`;
	            modal.hintEl.textContent = 'ë Œë”ë§ í™”ë©´ì—ì„œ ì„ íƒí•œ ë¸”ë¡ì˜ ë§ˆí¬ë‹¤ìš´ë§Œ ìˆ˜ì •í•©ë‹ˆë‹¤.';
	
	            const raw = map.wasEmpty ? '' : (map.blocks[bi] || '');
	            modal.ta.value = maskDataImages(raw, modal.ta);
	            enableImagePaste(modal.ta);
	            modal.open();
	            try { modal.ta.focus(); } catch { }
	            try { modal.renderPreview(); } catch { }
	
	            try { ev.preventDefault(); ev.stopPropagation(); } catch { }
	          });
	        }
	      }
	
	      function toggleRenderEdit(typeIndex, side, on) {
	        const idx = Number(typeIndex);
	        const secId = `type-${idx + 1}`;
	        const sec = document.getElementById(secId);
	        const contentSel = side === 'problem' ? '.standard-content' : '.explanation-content';
	        const rootBefore = sec ? (sec.querySelector(contentSel) || sec) : null;
	        const scrollAnchor = captureReadingAnchorText(rootBefore);
	        const secTopAbs = sec ? (sec.getBoundingClientRect().top + window.scrollY) : 0;
	        const scrollRel = sec ? (window.scrollY - secTopAbs) : 0;

	        const key = renderEditKey(idx, side);
	        const next = (typeof on === 'boolean') ? on : !renderEditState.active.has(key);
	        if (next) {
	          renderEditState.active.add(key);
	          renderTypeSectionBlocks(idx, side);
	        } else {
	          renderEditState.active.delete(key);
	          renderTypeSectionNormal(idx, side);
	        }

	        // Keep the user's reading position stable (render-edit toggling can subtly change layout).
	        requestAnimationFrame(() => {
	          const secNew = document.getElementById(secId);
	          if (!secNew) return;
	          const root = secNew.querySelector(contentSel) || secNew;
	          const ok = restoreReadingAnchorText(root, scrollAnchor);
	          if (!ok) {
	            const topAbs2 = secNew.getBoundingClientRect().top + window.scrollY;
	            window.scrollTo({ top: topAbs2 + (scrollRel || 0) });
	          }
	        });
	        return next;
	      }
	
	      function restoreRenderEditActiveSections() {
	        Array.from(renderEditState.active).forEach(key => {
	          const parsed = parseRenderEditKey(key);
	          if (!parsed) return;
	          renderTypeSectionBlocks(parsed.typeIndex, parsed.side);
	        });
	      }

	      // ----- Explanation editor (edit/save with warning for spot-memo loss) -----
	      function mountExplanationEditors() {
	        $$('.type-card').forEach((sec, i) => {
	          const ex = sec.querySelector('.explanation');
	          if (!ex || ex.dataset.editorMounted) return;
	          ex.dataset.editorMounted = '1';
	          const content = sec.querySelector('.explanation-content');
		          const bar = document.createElement('div');
		          bar.className = 'editbar';
		          bar.style.display = 'flex'; bar.style.gap = '8px'; bar.style.margin = '8px 0';
		          bar.innerHTML = `<button class="btn" data-action="edit">âœï¸ í¸ì§‘</button>
		                           <button class="btn" data-action="rend">ğŸª„ ë Œë”í¸ì§‘</button>
		                           <button class="btn" data-action="save" style="display:none;">ğŸ’¾ ì €ì¥</button>`;
		          ex.insertBefore(bar, ex.firstChild.nextSibling);
		          let textarea, editing = false;
	          let scrollAnchor = '';
	          let scrollRel = 0;
	          const startEdit = (focusSnippet) => {
	            if (editing) return;
	            editing = true;
	            const md = (window.fmm_types || [])[i]?.explanationMarkdown || '';
	            // capture where the user was reading (string anchor + fallback relative offset)
	            scrollAnchor = captureReadingAnchorText(content || ex);
	            const secTopAbs = sec.getBoundingClientRect().top + window.scrollY;
	            scrollRel = window.scrollY - secTopAbs;
	            textarea = document.createElement('textarea');
	            textarea.className = 'memo-textarea';
	            textarea.style.minHeight = Math.max(200, content?.offsetHeight || 0) + 'px';
	            textarea.value = maskDataImages(md, textarea);
	            enableImagePaste(textarea);
		            if (content) content.style.display = 'none';
		            // place editor where the content was (not at the bottom)
		            ex.insertBefore(textarea, content ? content.nextSibling : ex.firstChild.nextSibling);
		            const editBtn = bar.querySelector('[data-action="edit"]');
		            if (editBtn) editBtn.style.display = 'none';
		            const rendBtn = bar.querySelector('[data-action="rend"]');
		            if (rendBtn) rendBtn.style.display = 'none';
		            bar.querySelector('[data-action="save"]').style.display = '';
	            try {
	              textarea.focus();
	              const sn = String(focusSnippet || '').trim();
	              if (sn && sn.length >= 4) {
	                const pos = textarea.value.indexOf(sn);
	                if (pos >= 0 && textarea.setSelectionRange) textarea.setSelectionRange(pos, pos + sn.length);
	              }
	            } catch { }
	          };
	          const saveEdit = () => {
	            if (!editing) return;
	            const spots = Object.values(LS.get('fmm_memos_spots', {})).filter(s => s.typeIndex === i && s.side === 'explanation').length;
	            if (spots > 0 && !confirm(`ì´ í•´ì„¤ì—ëŠ” ${spots}ê°œì˜ ìœ„ì¹˜ ë©”ëª¨ê°€ ìˆìŠµë‹ˆë‹¤. ì €ì¥ ì‹œ í‘œì‹œ ìœ„ì¹˜ê°€ ì‚¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
	            const raw = unmaskDataImages(textarea.value || '', textarea);
	            (window.fmm_types || [])[i].explanationMarkdown = raw;
	            const title = (window.fmm_types || [])[i]?.title || '';
	            const slug = title.toLowerCase().replace(/\s+/g, '_');
	            store.setItem(`fmm_explanation_${slug}`, raw); // persist
	            renderTypes(window.fmm_types); // re-render with new markdown
	
	            // FIX: Request #12 - Refresh solver view immediately if open
	            if (typeof renderSolveQuestion === 'function') renderSolveQuestion();
	
	            const secNew = document.getElementById(`type-${i + 1}`);
	            if (secNew) {
	              const root = secNew.querySelector('.explanation-content') || secNew.querySelector('.explanation');
	              const ok = restoreReadingAnchorText(root, scrollAnchor);
	              if (!ok) {
	                const topAbs2 = secNew.getBoundingClientRect().top + window.scrollY;
	                window.scrollTo({ top: topAbs2 + (scrollRel || 0) });
	              }
	            }
	            statusEl.textContent = 'í•´ì„¤ ì €ì¥ë¨';
	          };
		          bar.addEventListener('click', (e) => {
		            const b = e.target.closest('button'); if (!b) return;
		            if (b.dataset.action === 'edit') startEdit();
		            else if (b.dataset.action === 'rend') {
		              if (editing) return;
		              const on = toggleRenderEdit(i, 'explanation');
		              b.textContent = on ? 'ğŸª„ ë Œë”í¸ì§‘âœ…' : 'ğŸª„ ë Œë”í¸ì§‘';
		              statusEl.textContent = on ? 'ë Œë”í¸ì§‘ ON (í´ë¦­í•´ì„œ ë¸”ë¡ í¸ì§‘)' : 'ë Œë”í¸ì§‘ OFF';
		            }
		            else if (b.dataset.action === 'save') saveEdit();
		          });
		          // Initialize render-edit button state for this type
		          const rb = bar.querySelector('[data-action="rend"]');
		          if (rb) rb.textContent = renderEditState.active.has(renderEditKey(i, 'explanation')) ? 'ğŸª„ ë Œë”í¸ì§‘âœ…' : 'ğŸª„ ë Œë”í¸ì§‘';
		        });
		      }

	      // ----- Standard Problem editor (edit/save) -----
	      function mountStandardProblemEditors() {
	        $$('.type-card').forEach((sec, i) => {
	          const pr = sec.querySelector('.problem');
	          if (!pr || pr.dataset.stdEditorMounted) return;
	          pr.dataset.stdEditorMounted = '1';
	          const content = sec.querySelector('.standard-content');
		          const bar = document.createElement('div');
		          bar.className = 'editbar';
		          bar.style.display = 'flex'; bar.style.gap = '8px'; bar.style.margin = '8px 0';
		          bar.innerHTML = `<button class="btn" data-action="edit">âœï¸ í¸ì§‘</button>
		                           <button class="btn" data-action="rend">ğŸª„ ë Œë”í¸ì§‘</button>
		                           <button class="btn" data-action="save" style="display:none;">ğŸ’¾ ì €ì¥</button>`;
	          const hr = pr.querySelector('.hr');
	          pr.insertBefore(bar, hr ? hr.nextSibling : pr.firstChild);

	          let textarea, editing = false;
	          let scrollAnchor = '';
	          let scrollRel = 0;
	          const startEdit = (focusSnippet) => {
	            if (editing) return;
	            editing = true;
	            const md = (window.fmm_types || [])[i]?.standardMarkdown || '';
	            scrollAnchor = captureReadingAnchorText(content || pr);
	            const secTopAbs = sec.getBoundingClientRect().top + window.scrollY;
	            scrollRel = window.scrollY - secTopAbs;
	
	            textarea = document.createElement('textarea');
	            textarea.className = 'memo-textarea';
	            textarea.style.minHeight = Math.max(200, content?.offsetHeight || 0) + 'px';
	            textarea.value = maskDataImages(md, textarea);
	            enableImagePaste(textarea);
		            if (content) content.style.display = 'none';
		            pr.insertBefore(textarea, content ? content.nextSibling : bar.nextSibling);
		            const editBtn = bar.querySelector('[data-action="edit"]');
		            if (editBtn) editBtn.style.display = 'none';
		            const rendBtn = bar.querySelector('[data-action="rend"]');
		            if (rendBtn) rendBtn.style.display = 'none';
		            bar.querySelector('[data-action="save"]').style.display = '';
	            try {
	              textarea.focus();
	              const sn = String(focusSnippet || '').trim();
	              if (sn && sn.length >= 4) {
	                const pos = textarea.value.indexOf(sn);
	                if (pos >= 0 && textarea.setSelectionRange) textarea.setSelectionRange(pos, pos + sn.length);
	              }
	            } catch { }
	          };
	          const saveEdit = () => {
	            if (!editing) return;
	            const spots = Object.values(LS.get('fmm_memos_spots', {})).filter(s => s.typeIndex === i && s.side === 'problem').length;
	            if (spots > 0 && !confirm(`ì´ í‘œì¤€ë¬¸ì œì—ëŠ” ${spots}ê°œì˜ ìœ„ì¹˜ ë©”ëª¨ê°€ ìˆìŠµë‹ˆë‹¤. ì €ì¥ ì‹œ í‘œì‹œ ìœ„ì¹˜ê°€ ì‚¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
	            const raw = unmaskDataImages(textarea.value || '', textarea);
	            (window.fmm_types || [])[i].standardMarkdown = raw;
	            const title = (window.fmm_types || [])[i]?.title || '';
	            const slug = title.toLowerCase().replace(/\s+/g, '_');
	            store.setItem(`fmm_standard_${slug}`, raw);
	            renderTypes(window.fmm_types);
	
	            // FIX: keep solve view synced (standard problem is used as context)
	            if (typeof renderSolveQuestion === 'function') renderSolveQuestion();
	
	            const secNew = document.getElementById(`type-${i + 1}`);
	            if (secNew) {
	              const root = secNew.querySelector('.standard-content') || secNew.querySelector('.problem');
	              const ok = restoreReadingAnchorText(root, scrollAnchor);
	              if (!ok) {
	                const topAbs2 = secNew.getBoundingClientRect().top + window.scrollY;
	                window.scrollTo({ top: topAbs2 + (scrollRel || 0) });
	              }
	            }
	            statusEl.textContent = 'í‘œì¤€ë¬¸ì œ ì €ì¥ë¨';
	          };

		          bar.addEventListener('click', (e) => {
		            const b = e.target.closest('button'); if (!b) return;
		            if (b.dataset.action === 'edit') startEdit();
		            else if (b.dataset.action === 'rend') {
		              if (editing) return;
		              const on = toggleRenderEdit(i, 'problem');
		              b.textContent = on ? 'ğŸª„ ë Œë”í¸ì§‘âœ…' : 'ğŸª„ ë Œë”í¸ì§‘';
		              statusEl.textContent = on ? 'ë Œë”í¸ì§‘ ON (í´ë¦­í•´ì„œ ë¸”ë¡ í¸ì§‘)' : 'ë Œë”í¸ì§‘ OFF';
		            }
		            else if (b.dataset.action === 'save') saveEdit();
		          });
		          // Initialize render-edit button state for this type
		          const rb = bar.querySelector('[data-action="rend"]');
		          if (rb) rb.textContent = renderEditState.active.has(renderEditKey(i, 'problem')) ? 'ğŸª„ ë Œë”í¸ì§‘âœ…' : 'ğŸª„ ë Œë”í¸ì§‘';
		        });
		      }

	      // ----- Problems loader & sidebar -----
	      const problems = { json: LS.get('fmm_problems_json', null) };
	      // problems ê°ì²´ë¥¼ ì™¸ë¶€ì—ì„œë„ ì•ˆì „í•˜ê²Œ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡ ê³µê°œ
	      window.fmm_problems = problems;
	      // init indices for already-loaded problems (e.g., restored from export/import)
			      (function initProblemsIndex() {
			        scrubProblemsJsonPlaceholderAnswers();
			        const paperNormalized = normalizeProblemsPaperNamesInPlace(problems.json);
			        try { migratePartSuffixQids(); } catch { }
			        try { repairObjectArtifactsInAllData(); } catch { }
			        problems.norm = {};
			        problems.byQid = {};
			        problems.qidType = {};
		        if (paperNormalized) {
		          try { LS.set('fmm_problems_json', problems.json); } catch { }
	        }
	        const src = problems.json?.types;
	        if (!src || typeof src !== 'object') return;
	          Object.keys(src).forEach(k => {
	            problems.norm[normalizeTitle(k)] = src[k];
	            (src[k] || []).forEach(p => {
	              const qid = String(p?.qid || '');
            if (!qid) return;
            problems.qidType[qid] = k;
            problems.byQid[qid] = { ...p, __typeTitle: k };
          });
        });
      })();
      $('#problemsLoadBtn').addEventListener('click', () => $('#problemsFile').click());
	      $('#problemsFile').addEventListener('change', async (e) => {
	        const file = e.target.files?.[0]; if (!file) return;
	        const text = await file.text();
			        try {
			          problems.json = JSON.parse(text);
			          scrubProblemsJsonPlaceholderAnswers();
			          normalizeProblemsPaperNamesInPlace(problems.json);
			          try { migratePartSuffixQids(); } catch { }
			          try { repairObjectArtifactsInAllData(); } catch { }
			          // build normalized title -> array map once
			          const src = problems.json?.types || {};
		          problems.norm = {};
		          problems.byQid = {};
          problems.qidType = {};
          Object.keys(src).forEach(k => {
            problems.norm[normalizeTitle(k)] = src[k];
            (src[k] || []).forEach(p => {
              const qid = String(p?.qid || '');
              if (!qid) return;
              problems.qidType[qid] = k;
              problems.byQid[qid] = { ...p, __typeTitle: k };
            });
	          });
	          LS.set('fmm_problems_json', problems.json);
	          alert((currentLang === 'ko') ? 'ë¬¸ì œ íŒŒì¼ì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.' : 'Problems file loaded.');
	          $('#leftAside').style.display = '';
	          renderProblemsForCurrentType();
	          try { rebuildSimilarityGroupsAndApplyAutoSharing(); } catch { }
	        } catch (err) { alert(((currentLang === 'ko') ? 'JSON íŒŒì‹± ì˜¤ë¥˜: ' : 'JSON parse error: ') + err.message); }
	      });
      $('#problemsToggleBtn').addEventListener('click', () => {
        const el = $('#leftAside');
        el.style.display = (el.style.display === 'none' ? '' : 'none');
        if (el.style.display !== 'none') { restoreSavedBox(el, 'fmm_ui_leftAside'); } // ADD
      });

    function problemsForType(title) {
      const key = normalizeTitle(title || '');
      if (window.fmm_patch_problems) {
        const cleanTitle = normalizePatchTitle(title || '');
        if (window.fmm_patch_problems[cleanTitle]) return window.fmm_patch_problems[cleanTitle];
      }
      if (problems.norm && problems.norm[key]) return problems.norm[key];
      const cleanKey = normalizeTitle(normalizePatchTitle(title || ''));
      if (problems.norm && problems.norm[cleanKey]) return problems.norm[cleanKey];
      const direct = problems.json?.types?.[title] || problems.json?.types?.[normalizePatchTitle(title || '')];
      return direct || [];
    }

    function getProblemId(p) {
      return p?.qid || p?.id || p?.global_qid || p?.problem_id || '';
    }
    function buildProblemIdSet(list) {
      const set = new Set();
      (list || []).forEach(p => {
        const id = getProblemId(p);
        if (id) set.add(id);
      });
      return set;
    }
    function setsEqual(a, b) {
      if (a.size !== b.size) return false;
      for (const v of a) if (!b.has(v)) return false;
      return true;
    }
    function isSubset(a, b) {
      for (const v of a) if (!b.has(v)) return false;
      return true;
    }
    function rebuildProblemsIndex() {
      problems.norm = {};
      const src = problems.json?.types || {};
      Object.keys(src).forEach(k => {
        problems.norm[normalizeTitle(k)] = src[k] || [];
      });
      try { LS.set('fmm_problems_json', problems.json); } catch { }
    }
    function scrubProblemsJsonPlaceholderAnswers() {
      const src = problems.json?.types;
      if (!src || typeof src !== 'object') return false;
      let changed = false;
      Object.keys(src).forEach(title => {
        if (scrubPlaceholderOfficialAnswersInList(src[title])) changed = true;
      });
      if (changed) {
        try { LS.set('fmm_problems_json', problems.json); } catch { }
        try { store.setItem('fmm_problems_json', JSON.stringify(problems.json)); } catch { }
      }
      return changed;
    }

      function renderProblemsForCurrentType() {
        const title = currentTypeTitle();
        const listEl = $('#problemsList'), metaEl = $('#problemsMeta'), detailEl = $('#problemDetail');
        if (!title || !listEl) return;
        const activeQid = detailEl ? (detailEl.dataset.qid || null) : null;
        const arrRaw = problemsForType(title);
        const arr = arrRaw.map(applyProblemOverrides);

        function yearKey(qid) {
          const y = extractYearFromQid(String(qid || ''));
          return (typeof y === 'number' && Number.isFinite(y)) ? y : Infinity;
        }
        function cmpProblem(a, b) {
          const ya = yearKey(a?.qid);
          const yb = yearKey(b?.qid);
          if (ya !== yb) return ya - yb;
          return String(a?.qid || '').localeCompare(String(b?.qid || ''), 'ko');
        }
        function sortProblemsForSidebarLocal(list) {
          const base = Array.isArray(list) ? list.slice() : [];
          if (base.length <= 1) return base;
          try {
            if (typeof clusterSimilarProblemGroups !== 'function') return base.sort(cmpProblem);
            const groups = clusterSimilarProblemGroups(base);
            (groups || []).forEach(g => { if (g && Array.isArray(g.items)) g.items.sort(cmpProblem); });
            (groups || []).sort((ga, gb) => {
              const a0 = ga?.items?.[0];
              const b0 = gb?.items?.[0];
              return cmpProblem(a0 || {}, b0 || {});
            });
            return (groups || []).flatMap(g => (g && Array.isArray(g.items)) ? g.items : []);
          } catch {
            return base.sort(cmpProblem);
          }
        }

        const arrSorted = sortProblemsForSidebarLocal(arr);
        metaEl.textContent = arrSorted.length ? `${title} Â· ë¬¸ì œ ${arrSorted.length}ë¬¸í•­` : 'ë¬¸ì œ íŒŒì¼ì— í•´ë‹¹ ìœ í˜•ì´ ì—†ìŠµë‹ˆë‹¤.';
        // Add an "ì „ì²´ ë³´ê¸°" button once
        let fullBtn = $('#problemsFullBtn');
        if (!fullBtn) {
          fullBtn = document.createElement('button');
          fullBtn.id = 'problemsFullBtn';
          fullBtn.className = 'btn';
          fullBtn.textContent = 'ì „ì²´ ë³´ê¸°';
          metaEl.parentElement.insertBefore(fullBtn, metaEl.nextSibling);
        }
        // Add a "TXT ë‚´ë³´ë‚´ê¸°" button once
        let txtBtn = $('#problemsTxtBtn');
        if (!txtBtn) {
          txtBtn = document.createElement('button');
          txtBtn.id = 'problemsTxtBtn';
          txtBtn.className = 'btn';
          txtBtn.textContent = 'TXT ë‚´ë³´ë‚´ê¸°';
          metaEl.parentElement.insertBefore(txtBtn, fullBtn.nextSibling);
        }

        // í•­ìƒ "í˜„ì¬" íƒ€ì…ì„ ê¸°ì¤€ìœ¼ë¡œ ì¦‰ì‹œ ë°ì´í„° ì¬ì¡°íšŒ (stale closure ë°©ì§€)
        // ideology: í•¸ë“¤ëŸ¬ì—ì„œ ì¦‰ì‹œ ì¡°íšŒ â†’ í´ë¡œì €ì— ê°‡íŒ ë‚¡ì€ ìƒíƒœ ì œê±° (LLM/ì‚¬ìš©ì ì•¡ì…˜ì´ ìƒíƒœë¥¼ ë°”ê¿ˆ)
        fullBtn.onclick = () => {
          const titleNow = currentTypeTitle();
          const arrNow = sortProblemsForSidebarLocal(problemsForType(titleNow).map(applyProblemOverrides));
          if (!arrNow.length) { detailEl.innerHTML = ''; return; }
          let html = '';
          arrNow.forEach(q => {
            const tag = getEffectiveTag(q.qid);
            const paper = formatPaperNameDisplay(q.paperName, q.qid);
            html += `<div class="md" style="margin-bottom:18px;">
              <div class="muted">${sanitize(paper)} Â· <span class="tag-badge">${tag}</span></div>
              <h3>${sanitize(q.qid)}</h3><div class="hr"></div>
              ${renderMarkdown(stripAnswerEmphasis(q.question_text), undefined, 'sanitizeThenParse')}
              <div style="margin-top:8px;">${sanitize(formatAnswerChoices(stripAnswerEmphasis(q.answer_choices), getOfficialAnswerText(q.official_answer)))}</div>
              ${hasOfficialAnswer(q.official_answer) ? `<div class="answer" style="margin-top:10px;"><span class="badge">ì •ë‹µ</span>${getOfficialAnswerText(q.official_answer)}</div>` : ''}
              ${q.official_explanation ? `<div class="md" style="margin-top:8px;"><h3>ê³µì‹ í•´ì„¤</h3><div class="hr"></div>${renderMarkdown(stripAnswerEmphasis(q.official_explanation), undefined, 'sanitizeThenParse')}</div>` : ''}
              <div style="margin-top:8px;">
                <button class="btn btn-sm" onclick="mountProblemEditor(this.parentNode, '${q.qid}')">âœï¸ ë¬¸ì œ ìˆ˜ì •</button>
              </div>
            </div>`;
          });
          detailEl.innerHTML = html;
          insertBreaksBeforeCircled(detailEl);
          applyInlineBoldMarkers(detailEl);
          applyWordMemos(detailEl);
          typesetMath(detailEl);
        };
        txtBtn.onclick = () => {
          const titleNow = currentTypeTitle();
          const arrNow = sortProblemsForSidebarLocal(problemsForType(titleNow).map(applyProblemOverrides));
          if (!arrNow.length) {
            alert('ì´ ìœ í˜•ì— í•´ë‹¹í•˜ëŠ” ë¬¸ì œ JSONì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë¬¸ì œ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”.');
            return;
          }
	          const blocks = arrNow.map(q => {
	            const qid = String(q?.qid || q?.id || q?.global_qid || q?.problem_id || '').trim() || 'Q';
	            let out = `${qid}:\n${coerceText(q.question_text || '')}`;
	            if (q.answer_choices) out += `\nChoices: ${coerceText(q.answer_choices)}`;
	            const official = getOfficialAnswerText(q.official_answer);
	            if (official) out += `\n[Official Answer]\n${official}`;
	            if (q.official_explanation) out += `\n[Official Explanation]\n${coerceText(q.official_explanation)}`;
	            return out.trim();
	          });
	          const text = `# ${titleNow}\n\n${blocks.join('\n\n---\n\n')}\n`;
	          const blob = new Blob([text], { type: 'text/plain' });
	          const a = document.createElement('a');
	          a.download = `${sanitizeForFilename(titleNow, 40)}_problems.txt`;
	          const url = URL.createObjectURL(blob);
	          a.href = url;
	          a.click();
	          setTimeout(() => { try { URL.revokeObjectURL(url); } catch { } }, 1000);
	          statusEl.textContent = 'ìœ í˜• ë¬¸ì œ TXTê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.';
	        };
        listEl.innerHTML = '';
        arrSorted.forEach((q, idx) => {
          const div = document.createElement('div');
          div.className = 'problems-item'; div.dataset.idx = String(idx);
          div.dataset.qid = String(q?.qid || '');
          const tag = getEffectiveTag(q.qid);
          const paper = formatPaperNameDisplay(q.paperName, q.qid);
          div.innerHTML = `<div><strong><span class="tag-badge">${tag}</span>${sanitize(q.qid)}</strong></div>
                           <div class="muted">${sanitize(paper)}</div>`; // title + source only
          listEl.appendChild(div);
        });
        function showDetail(i) {
          const q = arrSorted[i]; if (!q) { detailEl.innerHTML = ''; return; }
          const st = getProblemState(q.qid);
          const tag = getEffectiveTag(q.qid);
	          const paper = formatPaperNameDisplay(q.paperName, q.qid);
	          const memos = getProblemMemos(q.qid);
	          const ownerKey = getMemoOwnerKey(q.qid);
	          const repSt = getProblemState(ownerKey);
	          const repId = repSt.representativeMemoId == null ? null : String(repSt.representativeMemoId);
	          const orderedMemos = memos.slice();
	          if (repId) {
	            const ridx = orderedMemos.findIndex(m => String(m.id) === repId);
	            if (ridx > 0) {
	              const [repMemo] = orderedMemos.splice(ridx, 1);
	              orderedMemos.unshift(repMemo);
	            }
	          }
	          const html = `
	            <div class="col md" style="border:none; padding:0;">
	              <div class="muted">${sanitize(paper)} Â· <span class="tag-badge">${tag}</span></div>
	              <h3>${sanitize(q.qid)} Â· ë¬¸ì œ</h3><div class="hr"></div>
	              <div style="display:flex; gap:6px; flex-wrap:wrap; margin:6px 0 0;">
	                <button class="btn" id="detailSimilarBtn">ğŸ§² ìœ ì‚¬ ë¬¸ì œ</button>
	              </div>
	              <div>${renderMarkdown(stripAnswerEmphasis(q.question_text), undefined, 'sanitizeThenParse')}</div>
              <div style="margin-top:8px;">${sanitize(formatAnswerChoices(stripAnswerEmphasis(q.answer_choices), getOfficialAnswerText(q.official_answer)))}</div> <!-- ideology: less hunt, more signal -->
              ${hasOfficialAnswer(q.official_answer) ? `<div class="answer" style="margin-top:10px;"><span class="badge">ì •ë‹µ</span>${getOfficialAnswerText(q.official_answer)}</div>` : ''}
              ${q.official_explanation ? `<div class="md" style="margin-top:8px;"><h3>ê³µì‹ í•´ì„¤</h3><div class="hr"></div>${renderMarkdown(stripAnswerEmphasis(q.official_explanation), undefined, 'sanitizeThenParse')}</div>` : ''}
	              <div class="chat-actions" style="display:flex; gap:6px; flex-wrap:wrap; margin-top:8px;">
	                <span class="muted">íƒœê·¸ ë³€ê²½:</span>
	                <button class="tag-chip detail-tag" data-tag="ğŸ”’">ğŸ”’</button>
	                <button class="tag-chip detail-tag" data-tag="âŒ">âŒ</button>
	                <button class="tag-chip detail-tag" data-tag="â€¼ï¸">â€¼ï¸</button>
	                <button class="tag-chip detail-tag" data-tag="â“">â“</button>
	                <button class="tag-chip detail-tag" data-tag="â—">â—</button>
	                <button class="tag-chip detail-tag" data-tag="â—">â—</button>
	                <button class="tag-chip detail-tag" data-tag="âœ…">âœ…</button>
	              </div>
	              <div class="panel" style="padding:8px; margin-top:8px;">
	                <div class="muted">ê³µì‹ ì •ë‹µ/í•´ì„¤ í¸ì§‘</div>
	                <input class="memo-textarea" id="detailOfficialAnswer" value="" placeholder="ì •ë‹µ ì—†ìŒ ì‹œ ì…ë ¥" style="min-height:36px;">
	                <textarea class="memo-textarea" id="detailOfficialExplanation" placeholder="ê³µì‹ í•´ì„¤ ì…ë ¥"></textarea>
	                <div class="chat-actions" style="display:flex; gap:6px;">
	                  <button class="btn" id="detailOfficialSave">ì €ì¥</button>
	                  <button class="btn" id="detailOfficialLlm" title="í˜„ì¬ ë¬¸ì œì˜ ê³µì‹ í•´ì„¤ì„ LLMìœ¼ë¡œ ìƒì„±/ë®ì–´ì“°ê¸°">LLMë¡œ í•´ì„¤ ì±„ìš°ê¸°</button>
	                </div>
	              </div>
              <div class="panel" style="padding:8px; margin-top:8px;">
                <div class="muted">ë¬¸ì œ/ë³´ê¸° ìˆ˜ì •</div>
                <textarea class="memo-textarea" id="detailQuestionEdit" placeholder="ë¬¸ì œ í…ìŠ¤íŠ¸ ìˆ˜ì •"></textarea>
                <textarea class="memo-textarea" id="detailChoicesEdit" placeholder="ë³´ê¸° í…ìŠ¤íŠ¸ ìˆ˜ì • (ì›ë³¸ í˜•ì‹ ìœ ì§€)"></textarea>
                <div class="chat-actions" style="display:flex; gap:6px;">
                  <button class="btn" id="detailQBSave">ì €ì¥</button>
                  <button class="btn" id="detailQBReset">ì›ë³¸ìœ¼ë¡œ</button>
                </div>
              </div>
	              <div class="panel" style="padding:8px; margin-top:8px;">
	                <div style="display:flex; justify-content:space-between; align-items:center;">
	                  <div>ë¬¸ì œ ë©”ëª¨</div>
	                  <div class="image-tools">
	                    <button class="btn" id="detailImgUrl">ğŸ–¼ URL</button>
	                  </div>
	                </div>
	                <textarea class="memo-textarea" id="detailMemoArea" placeholder="ìƒˆ ë©”ëª¨ (ì €ì¥ ì „ê¹Œì§€ ë¹„ì›Œë‘ )"></textarea>
	                <div class="chat-actions" style="display:flex; gap:6px; margin-top:6px;">
	                  <button class="btn-primary" id="detailMemoSave">ìƒˆë¡œ ì €ì¥</button>
	                  <button class="btn" id="detailMemoUpdate">ìˆ˜ì • ì €ì¥</button>
	                  <button class="btn" id="detailMemoClear">ë¹„ìš°ê¸°</button>
	                </div>
	                <div class="solve-memo-list" id="detailMemoList">
	                  ${orderedMemos.length ? orderedMemos.map(m => `
	                    <div class="detail-memo-item" data-memo-id="${m.id}" style="margin-bottom:6px;">
	                      <div style="display:flex;gap:6px;align-items:center;">
	                        <button class="btn detail-memo" data-id="${m.id}">ìˆ˜ì • Â· ${new Date(m.createdAt).toLocaleString()}${repId === String(m.id) ? ' Â· â­ ëŒ€í‘œ' : ''}</button>
	                        <button class="btn memo-delete" data-id="${m.id}">ì‚­ì œ</button>
	                        <button class="btn memo-up" data-id="${m.id}" title="ìœ„ë¡œ" ${repId === String(m.id) ? 'disabled' : ''}>â–²</button>
	                        <button class="btn memo-down" data-id="${m.id}" title="ì•„ë˜ë¡œ" ${repId === String(m.id) ? 'disabled' : ''}>â–¼</button>
	                        <button class="btn memo-rep" data-id="${m.id}">${repId === String(m.id) ? 'ëŒ€í‘œ í•´ì œ' : 'ëŒ€í‘œ'}</button>
	                      </div>
	                      <div class="problem-memo-preview md detail-memo-preview" data-memo-id="${m.id}"
	                        style="display:block; margin-top:4px; padding:6px; border:1px dashed var(--border); border-radius:6px; ${m.previewFont != null ? `font-size:${Number(m.previewFont)}px;` : ''}">
	                        <div class="muted">ë¯¸ë¦¬ë³´ê¸° Â· ${new Date(m.createdAt).toLocaleString()}</div>
	                        <div class="hr"></div>
	                        ${renderMarkdown(m.text || '', { breaks: true, autoAsciiMath: true }, 'parseThenSanitize')}
	                      </div>
	                    </div>`).join('') : '<div class="muted">ì €ì¥ëœ ë©”ëª¨ ì—†ìŒ</div>'}
	                </div>
	              </div>
              <div class="panel" style="padding:8px; margin-top:8px;">
                <div class="muted">ë©”ëª¨ ê³µìœ  (ì‚¬ì‹¤ìƒ ê°™ì€ ë¬¸ì œë¼ë¦¬ ë©”ëª¨ ë™ê¸°í™”)</div>
                <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
                  <input class="memo-textarea" id="detailMemoLinkQid" placeholder="ê³µìœ í•  ê¸°ì¤€ ë¬¸ì œ GLOBAL_QID ì…ë ¥" style="min-height:32px; flex:1;">
                  <button class="btn" id="detailMemoLinkApply">ì´ ë¬¸ì œë¥¼ í•´ë‹¹ ë¬¸ì œì™€ ë©”ëª¨ ê³µìœ </button>
                  <button class="btn" id="detailMemoLinkReset">ê³µìœ  í•´ì œ</button>
                </div>
                <div class="muted" style="margin-top:4px;">í˜„ì¬ ë©”ëª¨ ê³µìœ  ê¸°ì¤€: <span id="detailMemoLinkCurrent">${sanitize(getMemoOwnerKey(q.qid))}</span></div>
              </div>
            </div>`;
	          detailEl.innerHTML = html;
	          detailEl.dataset.qid = q.qid || '';
	          detailEl.dataset.idx = String(i);
	          const ansInput = $('#detailOfficialAnswer');
	          if (ansInput) {
	            ansInput.value = displayOfficialAnswerValue(q.official_answer);
	          }
	          // ë¬¸ì œ/ë³´ê¸° ìˆ˜ì •ìš© í…ìŠ¤íŠ¸ ë°•ìŠ¤ì— í˜„ì¬ ê°’ì„ ì£¼ì…
	          const qArea = $('#detailQuestionEdit');
	          if (qArea) {
	            qArea.value = maskDataImages(q.question_text || '', qArea);
	            enableImagePaste(qArea);
	          }
          const cArea = $('#detailChoicesEdit');
          if (cArea) {
            cArea.value = maskDataImages(q.answer_choices || '', cArea);
            enableImagePaste(cArea);
          }
          const expArea = $('#detailOfficialExplanation');
          if (expArea) {
            expArea.value = maskDataImages(q.official_explanation || '', expArea);
            enableImagePaste(expArea);
          }
          insertBreaksBeforeCircled(detailEl); // ë™ì¼ ê°€ë…ì„± ì²˜ë¦¬
          applyInlineBoldMarkers(detailEl);
          applyWordMemos(detailEl);
          typesetMath(detailEl); // ADD: typeset selected problem detail
          enableImagePaste($('#detailMemoArea'));
        }
        // NOTE: use property handlers to avoid stacking listeners across re-renders
        listEl.onclick = (e) => {
          const item = e.target.closest('.problems-item'); if (!item) return;
          showDetail(Number(item.dataset.idx));
        };
        let initialIndex = 0;
        if (activeQid) {
          const idx = arrSorted.findIndex(q => String(q.qid) === activeQid);
          if (idx >= 0) initialIndex = idx;
        }
        if (arrSorted.length) showDetail(initialIndex); else detailEl.innerHTML = '';
        refreshSolveSetup(arrSorted, title);
        if (detailEl && !detailEl._wired) {
          detailEl._wired = true;
          detailEl.addEventListener('click', async (ev) => {
            const qid = detailEl.dataset.qid;
            if (!qid) return;
            const tagBtn = ev.target.closest('.detail-tag');
            if (tagBtn) {
              setProblemTag(qid, tagBtn.dataset.tag);
              renderProblemsForCurrentType(); // refresh badges
              return;
            }
            if (ev.target.id === 'detailSimilarBtn') {
              if (typeof window.openSimilarWindowForQid === 'function') window.openSimilarWindowForQid(qid);
              return;
            }
            if (ev.target.id === 'detailQBSave') {
              const qArea = $('#detailQuestionEdit');
              const cArea = $('#detailChoicesEdit');
              const newQ = qArea ? unmaskDataImages(qArea.value || '', qArea) : '';
              const newC = cArea ? unmaskDataImages(cArea.value || '', cArea) : '';
              updateProblemState(qid, {
                question_text: newQ.trim() || undefined,
                answer_choices: newC.trim() || undefined
              });
              renderProblemsForCurrentType();
              statusEl.textContent = 'ë¬¸ì œ/ë³´ê¸° ìˆ˜ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.';
              return;
            }
            if (ev.target.id === 'detailQBReset') {
              // override ì œê±° â†’ ì›ë³¸ìœ¼ë¡œ ë³µì›
              updateProblemState(qid, { question_text: undefined, answer_choices: undefined });
              renderProblemsForCurrentType();
              statusEl.textContent = 'ë¬¸ì œ/ë³´ê¸° ìˆ˜ì •ì´ ì›ë³¸ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.';
              return;
            }
            if (ev.target.id === 'detailOfficialSave') {
              const ans = $('#detailOfficialAnswer')?.value || '';
              const expArea = $('#detailOfficialExplanation');
              const exp = expArea ? unmaskDataImages(expArea.value || '', expArea) : '';
              updateProblemState(qid, { official_answer: normalizeOfficialAnswerValue(ans), official_explanation: exp.trim() || undefined });
              renderProblemsForCurrentType();
              statusEl.textContent = 'ê³µì‹ ì •ë‹µ ì €ì¥ë¨';
              return;
            }
            if (ev.target.id === 'detailOfficialLlm') {
              await llmFillOfficialExplanationForQid(qid);
              return;
            }
            if (ev.target.id === 'detailMemoSave') {
              // "ìƒˆë¡œ ì €ì¥"ì€ í•­ìƒ ìƒˆ ë©”ëª¨ë¡œ ì €ì¥
              const area = $('#detailMemoArea');
              const text = area ? unmaskDataImages(area.value || '', area) : '';
              if (!text.trim()) return;
	        const list = getProblemMemos(qid);
	        const newId = Date.now();
	        list.push({ id: newId, text, createdAt: newId, sessionId: solveState.session?.id || null });
	        if (area) area.dataset.editingId = String(newId);
	        saveProblemMemos(qid, list);
              renderProblemsForCurrentType();
              statusEl.textContent = 'ë¬¸ì œ ë©”ëª¨ ìƒˆë¡œ ì €ì¥ë¨';
              return;
            }
            if (ev.target.id === 'detailMemoUpdate') {
              // "ìˆ˜ì • ì €ì¥"ì€ ì„ íƒëœ ë©”ëª¨ë§Œ ë®ì–´ì“°ê¸°
              const area = $('#detailMemoArea');
              const text = area ? unmaskDataImages(area.value || '', area) : '';
              if (!text.trim()) return;
              const editingId = area && area.dataset.editingId ? String(area.dataset.editingId) : null;
              if (!editingId) {
                alert('ìˆ˜ì •í•  ë©”ëª¨ë¥¼ ëª©ë¡ì—ì„œ ì„ íƒí•˜ì„¸ìš”.');
                return;
              }
              const list = getProblemMemos(qid);
              const idx = list.findIndex(m => String(m.id) === editingId);
              if (idx < 0) {
                alert('ìˆ˜ì • ëŒ€ìƒ ë©”ëª¨ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
              }
              list[idx] = { ...list[idx], text, updatedAt: Date.now() };
              saveProblemMemos(qid, list);
              renderProblemsForCurrentType();
              statusEl.textContent = 'ë¬¸ì œ ë©”ëª¨ ìˆ˜ì •ë¨';
              return;
            }
            if (ev.target.id === 'detailMemoClear') {
              const area = $('#detailMemoArea');
              if (area) {
                area.value = '';
                delete area.dataset.editingId;
              }
              return;
            }
	            const memoBtn = ev.target.closest('.detail-memo');
	            if (memoBtn) {
	              const list = getProblemMemos(qid);
	              const found = list.find(m => String(m.id) === memoBtn.dataset.id);
	              if (found) {
	                const area = $('#detailMemoArea');
	                if (area) {
	                  area.value = maskDataImages(found.text || '', area);
	                  area.dataset.editingId = String(found.id);
	                }
	              }
	              return;
	            }
	            const upBtn = ev.target.closest('.memo-up');
	            if (upBtn) {
	              const ownerKey = getMemoOwnerKey(qid);
	              const repId = getProblemState(ownerKey).representativeMemoId == null ? null : String(getProblemState(ownerKey).representativeMemoId);
	              const targetId = upBtn.dataset.id ? String(upBtn.dataset.id) : '';
	              if (repId && targetId && repId === targetId) return;
	              const list = getProblemMemos(qid);
	              const idx = list.findIndex(m => String(m.id) === targetId);
	              if (idx <= 0) return;
	              const repIdx = repId ? list.findIndex(m => String(m.id) === repId) : -1;
	              if (repIdx === 0 && idx === 1) return;
	              const [item] = list.splice(idx, 1);
	              list.splice(idx - 1, 0, item);
	              saveProblemMemos(qid, list);
	              renderProblemsForCurrentType();
	              return;
	            }
	            const downBtn = ev.target.closest('.memo-down');
	            if (downBtn) {
	              const ownerKey = getMemoOwnerKey(qid);
	              const repId = getProblemState(ownerKey).representativeMemoId == null ? null : String(getProblemState(ownerKey).representativeMemoId);
	              const targetId = downBtn.dataset.id ? String(downBtn.dataset.id) : '';
	              if (repId && targetId && repId === targetId) return;
	              const list = getProblemMemos(qid);
	              const idx = list.findIndex(m => String(m.id) === targetId);
	              if (idx < 0 || idx >= list.length - 1) return;
	              const [item] = list.splice(idx, 1);
	              const nextIdx = Math.min(list.length, idx + 1);
	              list.splice(nextIdx, 0, item);
	              saveProblemMemos(qid, list);
	              renderProblemsForCurrentType();
	              return;
	            }
	            const delBtn = ev.target.closest('.memo-delete');
	            if (delBtn) {
	              const list = getProblemMemos(qid);
	              const idx = list.findIndex(m => String(m.id) === delBtn.dataset.id);
	              if (idx > -1 && confirm('ì´ ë©”ëª¨ë¥¼ ì™„ì „íˆ ì‚­ì œí• ê¹Œìš”?')) {
                list.splice(idx, 1);
                saveProblemMemos(qid, list);
                renderProblemsForCurrentType();
                statusEl.textContent = 'ë¬¸ì œ ë©”ëª¨ ì‚­ì œë¨';
              }
              return;
            }
	            const repBtn = ev.target.closest('.memo-rep');
	            if (repBtn) {
	              const ownerKey = getMemoOwnerKey(qid);
	              const cur = getProblemState(ownerKey);
	              const currentId = cur.representativeMemoId == null ? null : String(cur.representativeMemoId);
	              const targetId = repBtn.dataset.id ? String(repBtn.dataset.id) : null;
	              const newId = (currentId && targetId && currentId === targetId) ? null : (targetId ? Number(targetId) : null);
	              updateProblemState(ownerKey, { representativeMemoId: newId });
	              if (newId != null) {
	                const list = getProblemMemos(qid);
	                const mi = list.findIndex(m => String(m.id) === String(newId));
	                if (mi > 0) {
	                  const [item] = list.splice(mi, 1);
	                  list.unshift(item);
	                  saveProblemMemos(qid, list);
	                }
	              }
	              renderProblemsForCurrentType();
	              statusEl.textContent = newId == null ? 'ëŒ€í‘œ ë©”ëª¨ í•´ì œë¨' : 'ëŒ€í‘œ ë©”ëª¨ ì§€ì •ë¨';
	              return;
	            }
            if (ev.target.id === 'detailImgUrl') {
              const url = prompt('ì´ë¯¸ì§€ URL'); if (!url) return;
              const area = $('#detailMemoArea'); if (area) {
                const start = area.selectionStart || 0;
                const insert = `![img](${url})`;
                area.value = area.value.slice(0, start) + insert + area.value.slice(start);
              }
              return;
            }
            if (ev.target.id === 'detailMemoLinkApply') {
              const inp = $('#detailMemoLinkQid');
              const base = (inp?.value || '').trim();
              if (!base) {
                alert('ê³µìœ  ê¸°ì¤€ì´ ë  GLOBAL_QID ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
                return;
              }
              const r = linkProblemMemos(qid, base);
              const owner = r.owner || getMemoOwnerKey(base);
              const curSpan = $('#detailMemoLinkCurrent');
              if (curSpan) curSpan.textContent = owner;
              renderProblemsForCurrentType();
              statusEl.textContent = 'ì´ ë¬¸ì œì˜ ë©”ëª¨ê°€ ì§€ì •í•œ ë¬¸ì œì™€ ë©”ëª¨ ê³µìœ ë˜ë„ë¡ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.';
              return;
            }
            if (ev.target.id === 'detailMemoLinkReset') {
              unlinkProblemMemos(qid);
              const curSpan = $('#detailMemoLinkCurrent');
              if (curSpan) curSpan.textContent = String(qid);
              renderProblemsForCurrentType();
              statusEl.textContent = 'ë©”ëª¨ ê³µìœ ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.';
              return;
            }
          });
          detailEl.addEventListener('dblclick', (ev) => {
            const qid = detailEl.dataset.qid;
            if (!qid) return;
            const memoBtn = ev.target.closest('.detail-memo');
            if (!memoBtn) return;
            const id = memoBtn.dataset.id ? String(memoBtn.dataset.id) : '';
            if (!id) return;
            const wrap = memoBtn.closest('.detail-memo-item');
            const previewEl = wrap ? wrap.querySelector('.detail-memo-preview') : null;
            if (!previewEl) return;

            // toggle off (unrender)
            if (previewEl.style.display !== 'none') {
              previewEl.style.display = 'none';
              previewEl.innerHTML = '';
              statusEl.textContent = 'ë¬¸ì œ ë©”ëª¨ ë¯¸ë¦¬ë³´ê¸° í•´ì œë¨';
              return;
            }

            const list = getProblemMemos(qid);
            const found = list.find(m => String(m?.id) === id);
            if (!found) return;
            const ts = Number(found.createdAt || found.id || 0);
            previewEl.style.display = '';
            previewEl.innerHTML = `
              <div class="muted">ë¯¸ë¦¬ë³´ê¸° Â· ${ts ? new Date(ts).toLocaleString() : ''}</div>
              <div class="hr"></div>
              ${renderMarkdown(found.text || '', { breaks: true }, 'parseThenSanitize')}
            `;
            try { insertBreaksBeforeCircled(previewEl); } catch { }
            try { applyInlineBoldMarkers(previewEl); } catch { }
            try { applyWordMemos(previewEl); } catch { }
            try { typesetMath(previewEl); } catch { }
            statusEl.textContent = 'ë¬¸ì œ ë©”ëª¨ ë¯¸ë¦¬ë³´ê¸° í‘œì‹œë¨';
          });
        }
      }

      // ----- Hook renderTypes/render to re-apply behaviors -----
      const _origRenderTypes = renderTypes;
	      renderTypes = function (types) {
	        window.fmm_types = types;           // keep parsed guide accessible
	        _origRenderTypes(types);
	        applyWordMemos(outputEl);           // re-annotate word memos after render
	        mountStandardProblemEditors();      // add edit/save controls for í‘œì¤€ë¬¸ì œ
	        mountExplanationEditors();          // add edit/save controls for í•´ì„¤
	        restoreRenderEditActiveSections();  // keep render-edit mode across re-renders
	        onTypeMaybeChange();
	      };
      const _origRender = render;
      render = function () { _origRender(); if (window.fmm_types) { onTypeMaybeChange(); } };

      // ----- Copy current type guide raw markdown -----
      function buildTypeGuideRawMarkdown(t) {
        const title = String(t?.title || '').trim();
        const std = coerceText(t?.standardMarkdown).replace(/\s+$/g, '');
        const exp = coerceText(t?.explanationMarkdown).replace(/\s+$/g, '');
        const parts = [];
        if (title) parts.push(`# ${title}`, '');
        if (std.trim()) parts.push(std.trim());
        if (exp.trim()) parts.push('---', '', exp.trim());
        return parts.join('\n').replace(/\n{3,}/g, '\n\n').trim() + '\n';
      }
      if (outputEl && !outputEl._copyTypeRawMounted) {
        outputEl._copyTypeRawMounted = true;
        outputEl.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button[data-action]');
          if (!btn) return;
          const action = btn.getAttribute('data-action');
          if (action !== 'copyTypeRaw') return;
          const idx = parseInt(btn.getAttribute('data-idx') || '', 10);
          if (!Number.isFinite(idx) || idx < 0) return;
          const t = (window.fmm_types || [])[idx];
          if (!t) return;
          const raw = buildTypeGuideRawMarkdown(t);
          if (!raw.trim()) return;
          copyPlainText(raw);
          statusEl.textContent = 'ìœ í˜• ê°€ì´ë“œ ì›ë¬¸ì´ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.';
        });
      }

      // ----- Floating Chat window: rooms, editable history, resend, token expansion -----
      const chatWin = $('#chatWindow');
      $('#chatToggleBtn').addEventListener('click', () => {
        chatWin.classList.toggle('active');
        if (chatWin.classList.contains('active')) {
          restoreSavedBox(chatWin, 'fmm_ui_chatWindow');
          // ideology: ë³´ì´ê¸° ì•¡ì…˜ = ì‹œê°ì  í”¼ë“œë°±; ìµœì†Œ í¬ê¸° ë³´ì¥
          const r = chatWin.getBoundingClientRect();
          if (r.width < 300) chatWin.style.width = '420px';
          if (r.height < 220) chatWin.style.height = '360px';
          if (r.width < 300 || r.height < 220) {
            // í™”ë©´ ìš°ì¸¡ í•˜ë‹¨ ê¸°ë³¸ ìœ„ì¹˜
            chatWin.style.right = '350px';
            chatWin.style.left = '';
            chatWin.style.bottom = '14px';
          }
        }
      });
      document.body.addEventListener('click', (e) => {
        const b = e.target.closest('button[data-action="close"]'); if (!b) return;
        const t = document.querySelector(b.dataset.target); if (t) t.classList.remove('active');
      });

      const chats = {
        rooms: LS.get('fmm_chat_rooms', []),
        current: LS.get('fmm_chat_current', null),
        ensureRoom() {
          if (!this.rooms.length) {
            const id = 'room_' + Date.now();
            this.rooms = [{ id, name: 'ê¸°ë³¸ ë°©', messages: [] }]; this.current = id; this.sync();
          }
          if (!this.current || !this.rooms.find(r => r.id === this.current)) { this.current = this.rooms[0].id; this.sync(); }
        },
        currentRoom() { return this.rooms.find(r => r.id === this.current); },
        sync() { LS.set('fmm_chat_rooms', this.rooms); LS.set('fmm_chat_current', this.current); }
      };
      chats.ensureRoom();

      function buildPrompt(input) {
        // Legacy: macro expansion into a single string (kept for compatibility)
        const idx = currentTypeIndex();
        const t = (window.fmm_types || [])[idx] || {};
        const title = t.title || '';
        const std = t.standardMarkdown || '';
        const exp = t.explanationMarkdown || '';
        const probs = problemsForType(title);
        const fullProblemText = probs.map(p => {
          const official = getOfficialAnswerText(p.official_answer);
          return `- [${p.qid}] ${p.question_text}
ì„ ì§€: ${p.answer_choices}${official ? `\nì •ë‹µ:${official}` : ''}${p.official_explanation ? `\nê³µì‹í•´ì„¤:${p.official_explanation}` : ''}`;
        }).join('\n\n');

        let out = String(input || '');
        const reps = [
          { re: /<\s*(standard[\s_-]*problem|í‘œì¤€ë¬¸ì œ)\s*>/ig, text: std },
          { re: /<\s*(explanation|í•´ì„¤|commentary)\s*>/ig, text: exp },
          { re: /<\s*(problem|ë¬¸ì œ)\s*>/ig, text: fullProblemText }
        ];
        reps.forEach(({ re, text }) => { out = out.replace(re, text || ''); });
        out = out.replace(/<\s*(standard[\s_-]*problem|í‘œì¤€ë¬¸ì œ|explanation|í•´ì„¤|commentary|problem|ë¬¸ì œ)\s*>/ig, '');
        return out;
      }

      // NEW: separate macro context and user text
      function buildContextAndUser(input) {
        const idx = currentTypeIndex();
        const t = (window.fmm_types || [])[idx] || {};
        const title = t.title || '';
        const std = t.standardMarkdown || '';
        const exp = t.explanationMarkdown || '';
        const probs = problemsForType(title);
        const fullProblemText = probs.map(p => {
          const official = getOfficialAnswerText(p.official_answer);
          return `- [${p.qid}] ${p.question_text}
ì„ ì§€: ${p.answer_choices}${official ? `\nì •ë‹µ:${official}` : ''}${p.official_explanation ? `\nê³µì‹í•´ì„¤:${p.official_explanation}` : ''}`;
        }).join('\n\n');

        let user = String(input || '');
        const parts = [];
        const macros = [
          { re: /<\s*(standard[\s_-]*problem|í‘œì¤€ë¬¸ì œ)\s*>/ig, text: std },
          { re: /<\s*(explanation|í•´ì„¤|commentary)\s*>/ig, text: exp },
          { re: /<\s*(problem|ë¬¸ì œ)\s*>/ig, text: fullProblemText }
        ];
        macros.forEach(({ re, text }) => {
          if (!text) { user = user.replace(re, ''); return; }
          let matched = false;
          user = user.replace(re, () => { matched = true; return ''; });
          if (matched) parts.push(text);
        });
        user = user.replace(/\s+/g, ' ').trim();
        const context = parts.join('\n\n');
        return { context, user };
      }

	      const llm = {
	        settings: LS.get('fmm_llm_settings', { endpoint: '', proxyUrl: '', apiKey: '', model: '' }),
	        save() { LS.set('fmm_llm_settings', this.settings); },
	        async call(messages) {
	          if (!this.settings.endpoint) {
	            chatStatus.clear(); // offline echo is "success" for UI purposes
	            return { role: 'assistant', content: `[LLM API ë¯¸ì„¤ì •]\nìš”ì²­ ë©”ì‹œì§€ ìˆ˜: ${messages.length}\në§ˆì§€ë§‰ í”„ë¡¬í”„íŠ¸(ë¯¸ë¦¬ë³´ê¸°):\n${messages.at(-1).content.slice(0, 200)}â€¦` };
	          }
	          try {
	            const result = await callLlmApiWithKeyRoll({
	              endpoint: this.settings.endpoint,
	              proxyUrl: this.settings.proxyUrl,
	              apiKeysRaw: this.settings.apiKey,
	              model: this.settings.model || 'gpt-4o-mini',
	              messages,
	              cursorKey: 'fmm_llm_key_cursor',
	              cooldownKey: 'fmm_llm_key_cooldowns',
	              timeoutMs: 5 * 60 * 1000
	            });
	            const content = result.contentText || JSON.stringify(result.data || {});
	            chatStatus.clear(); // success hides previous error
	            return { role: 'assistant', content };
	          } catch (err) {
	            chatStatus.error(`LLM í˜¸ì¶œ ì‹¤íŒ¨: ${err.message}`); // ideology: surface errors explicitly, don't eat them
	            throw err;
          }
        }
      };

      function renderChat() {
        const box = $('#chatMessages'); const room = chats.currentRoom(); if (!box || !room) return;
        box.innerHTML = '';

        room.messages.forEach((m, i) => {
          const wrap = document.createElement('div');
          wrap.className = 'chat-msg ' + (m.role === 'user' ? 'you' : '');
          const html = renderMarkdown(m.content || '', { breaks: true, autoAsciiMath: true }, 'parseThenSanitize'); // breaks:true -> line breaks respected

          // actions row (buttons, not blue links)
          const actions = `
            <div class="chat-actions" style="font-size:12px; display:flex; gap:6px; ${m.role === 'user' ? 'justify-content:flex-end;' : 'justify-content:flex-start;'}">
              <button class="btn" data-action="edit" data-idx="${i}">í¸ì§‘</button>
              <button class="btn" data-action="copy" data-idx="${i}">ë³µì‚¬</button>
              <button class="btn" data-action="delete" data-idx="${i}">ì‚­ì œ</button>
              <button class="btn" data-action="resend" data-idx="${i}">ì´ ë©”ì‹œì§€ê¹Œì§€ ì¬ì „ì†¡</button>
            </div>`;

          const isContext = m._isContext === true; // ideology: visually tag context without overloading system role semantics
          const roleLabel = isContext ? '<div class="muted" style="font-size:12px;">[ì»¨í…ìŠ¤íŠ¸]</div>' : '';
          const errStyle = m._error ? ' style="border:1px solid var(--danger); background: color-mix(in oklab, var(--danger) 8%, var(--card));"' : '';
          wrap.innerHTML = `
            ${roleLabel}
            <div class="bubble md"${errStyle}>${html}</div>
            ${actions}
          `;

          box.appendChild(wrap);
        });

        box.scrollTop = box.scrollHeight;
        typesetMath(box); // keep LaTeX rendering
      }
      renderChat();

      // ADD: transient error banner control for chat
      const chatErrorEl = $('#chatError');
      const chatStatus = {
        error(msg) { if (chatErrorEl) { chatErrorEl.textContent = msg; chatErrorEl.style.display = ''; } },
        clear() { if (chatErrorEl) { chatErrorEl.textContent = ''; chatErrorEl.style.display = 'none'; } }
      };

      function removeTrailingErrors(room) {
        while (room.messages.length && room.messages[room.messages.length - 1]._error) { room.messages.pop(); }
      }

      $('#chatSend').addEventListener('click', async () => {
        const input = $('#chatInput').value.trim(); if (!input) return;
        const room = chats.currentRoom();
        const { context, user } = buildContextAndUser(input);

        if (context) {
          room.messages.push({
            role: 'user',
            content: context,
            _isContext: true   // ideology: keep API role as 'user' while still surfacing macro-expanded context separately
          });
        }
        if (user) {
          room.messages.push({ role: 'user', content: user });
        }

        renderChat(); $('#chatInput').value = '';
        try {
          const reply = await llm.call(room.messages);
          removeTrailingErrors(room);
          room.messages.push(reply); chats.sync(); renderChat();
        } catch (err) {
          room.messages.push({ role: 'assistant', content: `[API ì˜¤ë¥˜] ${err.message}`, _error: true });
          chats.sync(); renderChat();
        }
      });

      $('#chatMessages').addEventListener('click', async (e) => {
        const a = e.target.closest('[data-action]'); if (!a) return; e.preventDefault();
        const idx = Number(a.dataset.idx); const room = chats.currentRoom();
        const msg = room?.messages?.[idx]; if (!msg) return;

        if (a.dataset.action === 'copy') {
          try {
            await navigator.clipboard.writeText(msg.content || '');
            statusEl.textContent = 'ë©”ì‹œì§€ ë³µì‚¬ë¨';
          } catch {
            // fallback: select & copy
            const tmp = document.createElement('textarea'); tmp.value = msg.content || '';
            document.body.appendChild(tmp); tmp.select(); document.execCommand('copy'); tmp.remove();
            statusEl.textContent = 'ë©”ì‹œì§€ ë³µì‚¬ë¨(ëŒ€ì²´ ê²½ë¡œ)';
          }
          return;
        }

	        if (a.dataset.action === 'edit') {
	          // inline editor under message
	          const host = a.closest('.chat-msg');
	          if (host.querySelector('.chat-edit')) return; // already open

	          const editor = document.createElement('div');
	          editor.className = 'chat-edit';
	          const ta = document.createElement('textarea');
	          ta.className = 'memo-textarea';
	          ta.value = msg.content || '';
	          editor.appendChild(ta);

	          const row = document.createElement('div');
	          row.style.display = 'flex';
	          row.style.gap = '6px';
	          row.style.marginTop = '6px';

	          const saveBtn = document.createElement('button');
	          saveBtn.className = 'btn-primary';
	          saveBtn.dataset.action = 'save-edit';
	          saveBtn.dataset.idx = String(idx);
	          saveBtn.textContent = 'ì €ì¥';
	          row.appendChild(saveBtn);

	          const cancelBtn = document.createElement('button');
	          cancelBtn.className = 'btn';
	          cancelBtn.dataset.action = 'cancel-edit';
	          cancelBtn.dataset.idx = String(idx);
	          cancelBtn.textContent = 'ì·¨ì†Œ';
	          row.appendChild(cancelBtn);

	          editor.appendChild(row);
	          host.appendChild(editor);
	          try { ta.focus(); } catch { }
	          return;
	        }

        if (a.dataset.action === 'save-edit') {
          const host = a.closest('.chat-msg');
          const ta = host.querySelector('.chat-edit textarea');
          room.messages[idx].content = ta.value;
          chats.sync();
          renderChat(); // re-render to show markdown + math
          return;
        }

        if (a.dataset.action === 'cancel-edit') {
          const host = a.closest('.chat-msg');
          const ed = host.querySelector('.chat-edit'); if (ed) ed.remove();
          return;
        }

        if (a.dataset.action === 'delete') {
          if (confirm('ì´ ë©”ì‹œì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) { room.messages.splice(idx, 1); chats.sync(); renderChat(); }
          return;
        }

        if (a.dataset.action === 'resend') {
          try {
            const reply = await llm.call(room.messages.slice(0, idx + 1));
            removeTrailingErrors(room);
            room.messages.push(reply); chats.sync(); renderChat();
          } catch (err) {
            room.messages.push({ role: 'assistant', content: `[API ì˜¤ë¥˜] ${err.message}`, _error: true });
            chats.sync(); renderChat();
          }
          return;
        }
      });

      // === REPLACE: prompt-based room/settings with in-window GUIs ===============
      // Ideology: visible state & reversible actions â€” no opaque prompt branches.

      const chatPanels = {
        roomsEl: null,
        settingsEl: null
      };

      function ensureChatPanels() {
        if (!chatPanels.roomsEl) {
          const r = document.createElement('div');
          r.id = 'chatRoomsPanel';
          r.className = 'chat-overlay';
          r.style.display = 'none';
          r.innerHTML = `
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
              <strong>ë°© ëª©ë¡</strong>
              <button class="btn" id="chatRoomAdd">+ ìƒˆ ë°©</button>
            </div>
            <div id="chatRoomsList"></div>
          `;
          $('#chatWindow').appendChild(r); // ideology: overlays live at window level so they appear over the current scroll position
          chatPanels.roomsEl = r;
          r.addEventListener('click', (e) => {
            const b = e.target.closest('button[data-room]');
            if (!b) return;
            const id = b.dataset.room;
            const act = b.dataset.act;
            if (act === 'switch') { chats.current = id; chats.sync(); renderChat(); renderRoomsUI(); }
            if (act === 'rename') {
              const newName = prompt('ë°© ì´ë¦„', chats.rooms.find(x => x.id === id)?.name || '');
              if (newName != null) { chats.rooms.find(x => x.id === id).name = newName.trim() || 'ë°©'; chats.sync(); renderRoomsUI(); }
            }
            if (act === 'delete') {
              if (confirm('ì´ ë°©ì„ ì‚­ì œí• ê¹Œìš”?')) {
                chats.rooms = chats.rooms.filter(x => x.id !== id);
                if (!chats.rooms.length) chats.ensureRoom(); chats.current = chats.rooms[0].id; chats.sync(); renderChat(); renderRoomsUI();
              }
            }
          });
          $('#chatRoomAdd').addEventListener('click', () => {
            const id = 'room_' + Date.now();
            chats.rooms.push({ id, name: 'ìƒˆ ë°©', messages: [] }); chats.current = id; chats.sync();
            renderChat(); renderRoomsUI();
          });
        }
        if (!chatPanels.settingsEl) {
          const s = document.createElement('div');
          s.id = 'chatSettingsPanel';
          s.className = 'chat-overlay';
          s.style.display = 'none';
	          s.innerHTML = `
	            <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;"><strong>ì„¤ì •</strong></div>
	            <div style="display:grid;gap:6px;">
	              <input class="memo-textarea" id="llmEndpoint" placeholder="Endpoint URL">
	              <input class="memo-textarea" id="llmProxyUrl" placeholder="Proxy URL (ì˜µì…˜) â€” cf_proxy.py ê°™ì€ CORS í”„ë¡ì‹œ">
	              <textarea class="memo-textarea" id="llmApiKey" placeholder="API Keys (ì˜µì…˜) â€” í•œ ì¤„ì— 1ê°œ ë˜ëŠ” ì‰¼í‘œë¡œ êµ¬ë¶„"></textarea>
	              <input class="memo-textarea" id="llmModel" placeholder="Model (ì˜µì…˜)">
	              <div style="display:flex;gap:8px;">
	                <button class="btn-primary" id="llmSave">ì €ì¥</button>
	                <button class="btn" id="llmClose">ë‹«ê¸°</button>
	              </div>
            </div>
          `;
          $('#chatWindow').appendChild(s); // ideology: settings should pop up in-place instead of dragging you back to the top of history
          chatPanels.settingsEl = s;
          s.addEventListener('click', (e) => {
	            if (e.target.id === 'llmSave') {
	              llm.settings.endpoint = $('#llmEndpoint').value.trim();
	              llm.settings.proxyUrl = $('#llmProxyUrl').value.trim();
	              llm.settings.apiKey = $('#llmApiKey').value.trim();
	              llm.settings.model = $('#llmModel').value.trim();
	              llm.save(); alert('LLM ì„¤ì • ì €ì¥ë¨');
	            }
	            if (e.target.id === 'llmClose') { s.style.display = 'none'; }
	          });
        }
	        // populate fields
	        $('#llmEndpoint') && ($('#llmEndpoint').value = llm.settings.endpoint || '');
	        $('#llmProxyUrl') && ($('#llmProxyUrl').value = llm.settings.proxyUrl || '');
	        $('#llmApiKey') && ($('#llmApiKey').value = llm.settings.apiKey || '');
	        $('#llmModel') && ($('#llmModel').value = llm.settings.model || '');
	      }

      // === ADD: Raw messages editor (JSON) ==========================================
      // ideology: expose the exact payload sent to the API for auditability & control
      let chatRawPanel = null;
      function ensureChatRawPanel() {
        if (chatRawPanel) return chatRawPanel;
        const p = document.createElement('div');
        p.id = 'chatRawPanel';
        p.className = 'chat-overlay';
        p.style.display = 'none';
        p.innerHTML = `
          <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
            <strong>Raw Messages (JSON)</strong>
          </div>
          <textarea class="memo-textarea" id="rawMessages" style="min-height:160px;"></textarea>
          <div style="display:flex;gap:8px;margin-top:6px;">
            <button class="btn-primary" id="rawApply">ì ìš©</button>
            <button class="btn" id="rawClose">ë‹«ê¸°</button>
          </div>
        `;
        $('#chatWindow').appendChild(p); // ideology: raw inspector should float over history to encourage inspection, not scrolling
        p.addEventListener('click', (e) => {
          if (e.target.id === 'rawApply') {
            try {
              const arr = JSON.parse($('#rawMessages').value || '[]');
              if (!Array.isArray(arr)) throw new Error('messages must be an array');
              chats.currentRoom().messages = arr;
              chats.sync(); renderChat();
              alert('Raw ì ìš© ì™„ë£Œ');
            } catch (err) { alert('JSON ì˜¤ë¥˜: ' + err.message); }
          }
          if (e.target.id === 'rawClose') { p.style.display = 'none'; }
        });
        chatRawPanel = p;
        return p;
      }

      $('#chatRawBtn').addEventListener('click', () => {
        const panel = ensureChatRawPanel();
        const room = chats.currentRoom();
        $('#rawMessages').value = JSON.stringify(room?.messages || [], null, 2);
        panel.style.display = panel.style.display === 'none' ? '' : 'none';
      });


	      function renderRoomsUI() {
	        ensureChatPanels();
	        const list = $('#chatRoomsList'); if (!list) return;
	        list.innerHTML = chats.rooms.map(r => `
	          <div class="panel" style="padding:8px;margin-bottom:6px;border:1px dashed var(--border);">
	            <div style="display:flex;justify-content:space-between;align-items:center;">
	              <div>${escapeHtml(r.name)} ${r.id === chats.current ? '<span class="pill">í˜„ì¬</span>' : ''}</div>
	              <div style="display:flex;gap:6px;">
	                <button class="btn" data-room="${r.id}" data-act="switch">ì „í™˜</button>
	                <button class="btn" data-room="${r.id}" data-act="rename">ì´ë¦„</button>
	                <button class="btn" data-room="${r.id}" data-act="delete">ì‚­ì œ</button>
	              </div>
	            </div>
	          </div>`).join('');
	      }

      $('#chatRoomsBtn').addEventListener('click', () => {
        ensureChatPanels();
        chatPanels.settingsEl.style.display = 'none';
        chatPanels.roomsEl.style.display = chatPanels.roomsEl.style.display === 'none' ? '' : 'none';
        renderRoomsUI();
      });

      $('#chatSettingsBtn').addEventListener('click', () => {
        ensureChatPanels();
        chatPanels.roomsEl.style.display = 'none';
        chatPanels.settingsEl.style.display = chatPanels.settingsEl.style.display === 'none' ? '' : 'none';
      });

      // ideology: ê°€ì ¸ì˜¤ê¸° í›„ 'ì¦‰ì‹œ' ì¬ìˆ˜í™” â€” ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨ ìš”êµ¬ ê¸ˆì§€
      function rehydrateAfterImport() {
        // FIX: Reset ALL in-memory state to empty defaults FIRST
        // ideology: importing should be a complete reset; old data must not bleed through
        problems.json = null;
        problems.norm = {};
        problems.byQid = {};
        problems.qidType = {};
        problemState.map = {};
        problemState.memos = {};
        sheetState.list = [];
        sheetState.selectedId = null;
        chats.rooms = [];
        chats.current = null;
        solveState.session = null;
        solveState.manualSelected.clear();

        // theme
        document.body.dataset.theme = store.getItem('fmm_theme') || 'dark';
        updateThemeLabel();
        // Now load from store (will be empty defaults if not in bundle)
        problemState.map = LS.get(PROBLEM_STATE_KEY, {});
        problemState.memos = LS.get(PROBLEM_MEMO_KEY, {});
        scrubProblemStatePlaceholderAnswers();
        try { repairObjectArtifactsInAllData(); } catch { }
        answerAPI.settings = { ...DEFAULT_ANSWER_SETTINGS, ...(LS.get(ANSWER_API_KEY, {}) || {}) };
        populateAnswerUI();
	        sheetState.list = LS.get(SHEETS_KEY, []);
	        solveState.manualSelected.clear();
	        try { migratePartSuffixQids(); } catch { }
	        try { sheetState.list = LS.get(SHEETS_KEY, []); } catch { }
	
	        // source (editor shows masked version)
	        sourceEl.value = maskDataImages(store.getItem('fmm_source') || '', sourceEl);

        // PATCH START: Re-ordered import logic for immediate problem list population
        // 1) Rehydrate problems source (norm map + show sidebar)
        const rawPJ = store.getItem('fmm_problems_json') || store.getItem('fmm_problems') || '';
        let pj = null; try { pj = rawPJ ? JSON.parse(rawPJ) : null; } catch { }
	        if (pj) {
	          const typesObj = pj.types && typeof pj.types === 'object' ? pj.types : (pj && typeof pj === 'object' ? pj : null);
	          if (typesObj) {
		            problems.json = { types: typesObj };
		            scrubProblemsJsonPlaceholderAnswers();
			            const paperNormalized = normalizeProblemsPaperNamesInPlace(problems.json);
			            if (paperNormalized) {
			              try { LS.set('fmm_problems_json', problems.json); } catch { }
			            }
			            try { migratePartSuffixQids(); } catch { }
			            try { repairObjectArtifactsInAllData(); } catch { }
			            try { sheetState.list = LS.get(SHEETS_KEY, []); } catch { }
			            problems.norm = {};
			            problems.byQid = {};
		            problems.qidType = {};
	            Object.keys(typesObj).forEach(k => {
              problems.norm[normalizeTitle(k)] = typesObj[k];
              (typesObj[k] || []).forEach(p => {
                const qid = String(p?.qid || '');
                if (!qid) return;
                problems.qidType[qid] = k;
                problems.byQid[qid] = { ...p, __typeTitle: k };
              });
            });
            $('#leftAside').style.display = '';
          }
        }

        // 2) Render guide FIRST so currentTypeTitle/index are valid
        render();
        // FIX: collapse guide input if a guide is present (respect user preference)
        // ideology: default to reading context after import; editing remains opt-in
        if ((sourceEl.value || '').trim()) {
          const gp = sourceEl.closest('.panel');
          if (gp) {
            const pref = store.getItem('fmm_guide_collapsed');
            const shouldCollapse = (pref === '1') || (pref === null);
            gp.classList.toggle('collapsed', !!shouldCollapse);
          }
        }

        // 3) Re-apply problems & memos immediately (no scroll dependency)
        renderProblemsForCurrentType();
        try { rebuildSimilarityGroupsAndApplyAutoSharing(); } catch { }
        refreshSolveSetup(currentTypeProblems(), currentTypeTitle());
        reapplySpotMemos(outputEl); // revive location memos immediately
        onTypeMaybeChange();

        // 4) LLM + Rooms + basic memos + chat
        llm.settings = LS.get('fmm_llm_settings', llm.settings);
        chats.rooms = LS.get('fmm_chat_rooms', []);
        chats.current = LS.get('fmm_chat_current', null);
        chats.ensureRoom();

        // Apply persisted UI controls (font size, width)
        if (typeof UI !== 'undefined') {
          const font = Number(store.getItem('fmm_ui_fontSize') || UI.font || 15);
          const solveFont = Number(store.getItem('fmm_ui_solveFontSize') || UI.solveFont || font || 15);
          const width = Number(store.getItem('fmm_ui_mainWidth') || UI.width || 1200);
          UI.font = font;
          UI.solveFont = solveFont;
          UI.width = width;
          UI.apply();
        }

        loadGlobalMemo();
        loadTypeMemo();
        renderChat();

        // 5) Restore geometry (split asides)
        restoreSavedBox($('#globalAside'), 'fmm_ui_globalAside');
        restoreSavedBox($('#typeAside'), 'fmm_ui_typeAside');
        restoreSavedBox($('#leftAside'), 'fmm_ui_leftAside');
        restoreSavedBox($('#chatWindow'), 'fmm_ui_chatWindow');

        typesetMath(document.body);
        // PATCH END
      }
      // expose for IndexedDB snapshot bootstrapping
      window.rehydrateAfterImport = rehydrateAfterImport;

      // ----- Export / Import everything (all fmm_* keys) -----
      // === CHANGE: robust export/import =========================================
      // Ideology: portable, auditable backups â€” never silently coerce types.

      function fmmDumpAll() {
        const data = {};
        // 1) Load potentially stale data from localStorage (fallback)
        try {
          if (window.localStorage) {
            for (let i = 0; i < window.localStorage.length; i++) {
              const k = window.localStorage.key(i);
              if (!k || !k.startsWith('fmm_')) continue;
              const raw = window.localStorage.getItem(k);
              if (raw == null) continue;
              try {
                data[k] = { kind: 'json', value: JSON.parse(raw) };
              } catch {
                data[k] = { kind: 'raw', value: raw };
              }
            }
          }
        } catch { /* ignore */ }

        // 2) Overwrite with fresh in-memory store data (Authority)
        // Store dump contains the most up-to-date state (flushed by fmmSaveAll)
        const snapshot = store.dump();
        Object.keys(snapshot).forEach(k => {
          if (!k.startsWith('fmm_')) return;
          const raw = snapshot[k];
          try {
            data[k] = { kind: 'json', value: JSON.parse(raw) };
          } catch {
            data[k] = { kind: 'raw', value: raw };
          }
        });
        return { __fmm_bundle__: 1, exportedAt: new Date().toISOString(), items: data };
      }

      function fmmRestoreAll(bundle) {
        if (!bundle || bundle.__fmm_bundle__ !== 1 || !bundle.items) throw new Error('Invalid FMM bundle');
        const items = bundle.items;
        store.clear();
        // FIX: Clear ALL existing fmm_* keys from localStorage, not just ones in bundle
        // ideology: importing should be a clean slate; old data should not bleed through
        try {
          if (window.localStorage) {
            const toRemove = [];
            for (let i = 0; i < window.localStorage.length; i++) {
              const k = window.localStorage.key(i);
              if (k && k.startsWith('fmm_')) toRemove.push(k);
            }
            toRemove.forEach(k => window.localStorage.removeItem(k));
          }
        } catch {/* ignore */ }
        Object.keys(items).forEach(k => {
          const { kind, value } = items[k] || {};
          const raw = (kind === 'raw')
            ? String(value ?? '')
            : JSON.stringify(value ?? null);
          store.setItem(k, raw);
          try {
            if (window.localStorage && k.startsWith('fmm_')) {
              window.localStorage.setItem(k, raw);
            }
          } catch {/* ignore */ }
        });
      }

      $('#exportBtn').addEventListener('click', () => {
        // FIX: Ensure all runtime state is flushed to store before export using the unified saver
        // ideology: "Export" and "Rescue" should behave identically regarding data completeness
        if (typeof window.fmmSaveAll === 'function') window.fmmSaveAll();

        const blob = new Blob([JSON.stringify(fmmDumpAll(), null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'fmm_export.json'; a.click();
        URL.revokeObjectURL(url);
      });

	      // === TXT Export (problems + official answer/expl + memos) =====================
	      function sanitizeForFilename(text, maxLen) {
	        let s = String(text || '').trim();
	        if (!s) s = 'file';
	        s = s.replace(/[\\/:*?"<>|]/g, '_').replace(/\s+/g, ' ').trim();
	        const n = Number(maxLen);
	        if (Number.isFinite(n) && n > 0 && s.length > n) s = s.slice(0, n);
	        s = s.replace(/[. ]+$/g, '').trim();
	        return s || 'file';
	      }
	      function maskDataImagesForExport(text) {
	        return String(text || '').replace(/!\[img\]\((data:image\/[^;]+;base64,)([^)]+)\)/g, (_m, prefix, dataPart) => {
	          const head = String(dataPart || '').slice(0, 12);
	          const tail = String(dataPart || '').slice(-8);
          return `![img](${prefix}${head}...ì¤‘ëµ...${tail})`;
        });
      }

      function buildTxtExportContent(opts) {
        const includeExplanation = !!opts.includeExplanation;
        const includeMemo = !!opts.includeMemo;
        const tagFilter = String(opts.tag || '');
        const yearMin = Number.isFinite(opts.yearMin) ? opts.yearMin : null;

        const allTypes = statsAllTypes();
        const typeSel = String(opts.type || '__all__');
        const targetTypes = (typeSel === '__all__') ? allTypes : [typeSel];

        const nowIso = new Date().toISOString();
        const header = [
          `FMM TXT Export`,
          `generatedAt: ${nowIso}`,
          `type: ${typeSel}`,
          `tag: ${tagFilter || 'ALL'}`,
          `yearMin: ${yearMin != null ? yearMin : 'NONE'}`,
          `includeExplanation: ${includeExplanation ? 'YES' : 'NO'}`,
          `includeMemo: ${includeMemo ? 'YES' : 'NO'}`,
          ``
        ].join('\n');

        const blocks = [header];
        const sepType = '========================================';
        const sepProb = '----------------------------------------';

        targetTypes.forEach(typeTitle => {
          const list = problemsForType(typeTitle).map(applyProblemOverrides).filter(p => p && p.qid);
          const filtered = list.filter(p => {
            if (yearMin != null) {
              const y = extractYearFromQid(p.qid);
              if (!y || y < yearMin) return false;
            }
            if (tagFilter) {
              const tag = getEffectiveTag(p.qid);
              if (tag !== tagFilter) return false;
            }
            return true;
          });
          if (!filtered.length) return;

          blocks.push(sepType);
          blocks.push(`[ìœ í˜•] ${typeTitle}`);
          blocks.push(sepType);
          blocks.push('');

          filtered.forEach(p => {
            const qid = String(p.qid || '');
            const year = extractYearFromQid(qid);
            const tag = getEffectiveTag(qid);
            const question = maskDataImagesForExport(stripAnswerEmphasis(p.question_text || '')).trim();
            const choices = maskDataImagesForExport(stripAnswerEmphasis(p.answer_choices || '')).trim();
            const ans = getOfficialAnswerText(p.official_answer);
            const exp = maskDataImagesForExport(stripAnswerEmphasis(p.official_explanation || '')).trim();
            const paper = formatPaperNameDisplay(p.paperName, p.qid);

            blocks.push(sepProb);
            blocks.push(`QID: ${qid}`);
            if (paper) blocks.push(`Paper: ${paper}`);
            if (year) blocks.push(`Year: ${year}`);
            blocks.push(`Tag: ${tag}`);
            blocks.push('');
            blocks.push('[ë¬¸ì œ]');
            blocks.push(question || '(ì—†ìŒ)');
            blocks.push('');
            blocks.push('[ì„ ì§€]');
            blocks.push(choices || '(ì—†ìŒ)');
            blocks.push('');
            blocks.push('[ê³µì‹ì •ë‹µ]');
            blocks.push(ans || '');

            if (includeExplanation) {
              blocks.push('');
              blocks.push('[ê³µì‹í•´ì„¤]');
              blocks.push(exp || '(ì—†ìŒ)');
            }

            if (includeMemo) {
              blocks.push('');
              blocks.push('[ë¬¸ì œë©”ëª¨]');
              const memos = getProblemMemos(qid);
              if (!memos.length) {
                blocks.push('(ì—†ìŒ)');
              } else {
                const ownerKey = getMemoOwnerKey(qid);
                const repId = getProblemState(ownerKey).representativeMemoId == null ? null : String(getProblemState(ownerKey).representativeMemoId);
                memos.forEach(m => {
                  const ts = new Date(m.updatedAt || m.createdAt || Date.now()).toLocaleString();
                  const isRep = repId && String(m.id) === repId;
                  blocks.push(`- ${isRep ? '(ëŒ€í‘œ) ' : ''}${ts}`);
                  blocks.push(maskDataImagesForExport(String(m.text || '')).trim() || '(ë¹ˆ ë©”ëª¨)');
                  blocks.push('');
                });
                // remove trailing blank line between problems
                if (blocks[blocks.length - 1] === '') blocks.pop();
              }
            }

            blocks.push('');
          });
        });

        return blocks.join('\n');
      }

      function downloadTextFile(name, text) {
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = name;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }

      function ensureTxtExportDialogWired() {
        const dlg = document.getElementById('txtExportDialog');
        if (!dlg || dlg._wired) return dlg;
        dlg._wired = true;
        document.getElementById('txtExportClose')?.addEventListener('click', () => {
          try { dlg.close(); } catch { dlg.style.display = 'none'; }
        });
        document.getElementById('txtExportRun')?.addEventListener('click', () => {
          if (!problems?.json?.types || Object.keys(problems.json.types || {}).length === 0) {
            alert('ë¬¸ì œ JSONì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”.');
            return;
          }
          const type = document.getElementById('txtExportType')?.value || '__all__';
          const tag = document.getElementById('txtExportTag')?.value || '';
          const yearRaw = String(document.getElementById('txtExportYear')?.value || '').trim();
          const yearMin = yearRaw ? (parseInt(yearRaw, 10) || null) : null;
          const includeExplanation = !!document.getElementById('txtExportIncludeExplanation')?.checked;
          const includeMemo = !!document.getElementById('txtExportIncludeMemo')?.checked;
          const text = buildTxtExportContent({ type, tag, yearMin, includeExplanation, includeMemo });
          const stamp = new Date().toISOString().slice(0, 10);
          const safeType = type === '__all__' ? 'ALL' : String(type).replace(/[\\/:*?\"<>|]/g, '_').slice(0, 80);
          downloadTextFile(`fmm_problems_${safeType}_${stamp}.txt`, text);
          try { dlg.close(); } catch { dlg.style.display = 'none'; }
        });
        return dlg;
      }

      function populateTxtExportTypeOptions() {
        const sel = document.getElementById('txtExportType');
        if (!sel) return;
        sel.innerHTML = '';
        const optAll = document.createElement('option');
        optAll.value = '__all__';
        optAll.textContent = 'ì „ì²´ ìœ í˜•';
        sel.appendChild(optAll);
        statsAllTypes().forEach(t => {
          const opt = document.createElement('option');
          opt.value = t;
          opt.textContent = t;
          sel.appendChild(opt);
        });
        const cur = currentTypeTitle();
        if (cur && Array.from(sel.options).some(o => o.value === cur)) sel.value = cur;
      }

      $('#txtExportBtn')?.addEventListener('click', () => {
        const dlg = ensureTxtExportDialogWired();
        if (!dlg) return;
        populateTxtExportTypeOptions();
        try { dlg.showModal(); } catch { dlg.style.display = ''; }
      });

      $('#importBtn').addEventListener('click', () => $('#importFile').click());
      $('#importFile').addEventListener('change', async (e) => {
        const f = e.target.files?.[0]; if (!f) return;
        if (!confirm('ê°€ì ¸ì˜¤ê¸°ë¥¼ ì§„í–‰í•˜ë©´ ê¸°ì¡´ ë°ì´í„°ê°€ ë®ì–´ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        try {
          const text = await f.text();
          const json = JSON.parse(text);
          fmmRestoreAll(json);

          // REHYDRATE UI (no refresh) â€” ideology: user-owned state should "snap in" instantly
          rehydrateAfterImport();

          alert('ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ. í˜„ì¬ í™”ë©´ì— ë°˜ì˜í–ˆìŠµë‹ˆë‹¤.');
        } catch (err) {
          alert('ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: ' + err.message);
        } finally {
          e.target.value = ''; // allow re-importing same file later
        }
      });

      // === Multi-save slots (isolated via IndexedDB) ===========================
      // Strategy: keep only ONE slot loaded into browser storage at a time.
      // Switching slots wipes all `fmm_*` keys first, then restores the selected bundle.
      const SAVE_DB_NAME = 'fmm_multi_save_db';
      const SAVE_STORE = 'saves';
      const ACTIVE_SLOT_KEY = 'fmmActiveSaveSlot'; // not removed by fmmRestoreAll (only removes 'fmm_' prefix)
      const LOADED_SLOT_KEY = 'fmmLoadedSaveSlot';

      function openSaveDb() {
        return new Promise(resolve => {
          try {
            if (!('indexedDB' in window)) { resolve(null); return; }
            const req = indexedDB.open(SAVE_DB_NAME, 1);
            req.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains(SAVE_STORE)) {
                db.createObjectStore(SAVE_STORE, { keyPath: 'id' });
              }
            };
            req.onsuccess = () => resolve(req.result || null);
            req.onerror = () => resolve(null);
          } catch {
            resolve(null);
          }
        });
      }
      const saveDbReady = openSaveDb();
      function saveDbTx(mode, fn) {
        return saveDbReady.then(db => new Promise((resolve, reject) => {
          if (!db) { reject(new Error('IndexedDB unavailable')); return; }
          try {
            const tx = db.transaction(SAVE_STORE, mode);
            const store0 = tx.objectStore(SAVE_STORE);
            const out = fn(store0, tx);
            tx.oncomplete = () => resolve(out);
            tx.onerror = () => reject(tx.error || new Error('tx error'));
          } catch (e) {
            reject(e);
          }
        }));
      }
      function saveDbGetAll() {
        return saveDbTx('readonly', (st) => new Promise((resolve) => {
          const req = st.getAll();
          req.onsuccess = () => resolve(req.result || []);
          req.onerror = () => resolve([]);
        }));
      }
      function saveDbGet(id) {
        const key = String(id || '').trim();
        if (!key) return Promise.resolve(null);
        return saveDbTx('readonly', (st) => new Promise((resolve) => {
          const req = st.get(key);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = () => resolve(null);
        }));
      }
      function saveDbPut(rec) {
        return saveDbTx('readwrite', (st) => { st.put(rec); });
      }
      function saveDbDelete(id) {
        const key = String(id || '').trim();
        if (!key) return Promise.resolve();
        return saveDbTx('readwrite', (st) => { st.delete(key); });
      }

      function removePrefixedKeys(storage, prefix) {
        try {
          if (!storage) return;
          for (let i = storage.length - 1; i >= 0; i--) {
            const k = storage.key(i);
            if (k && String(k).startsWith(prefix)) storage.removeItem(k);
          }
        } catch { }
      }
      function wipeCurrentFmmData() {
        try { store.clear(); } catch { }
        try { removePrefixedKeys(window.localStorage, 'fmm_'); } catch { }
        try { removePrefixedKeys(window.sessionStorage, 'fmm_'); } catch { }
        // also kill snapshot DB so it can't revive old state
        try { if ('indexedDB' in window) indexedDB.deleteDatabase('fmm_snapshot_db'); } catch { }
      }

      const saveWin = $('#saveManagerWindow');
      const saveToggleBtn = $('#saveManagerToggleBtn');
      const saveCloseBtn = $('#saveManagerCloseBtn');
      const saveMeta = $('#saveManagerMeta');
      const saveList = $('#saveManagerList');
      const saveState = { selectedId: null, list: [] };

      function activeSlotId() {
        try { return String(window.localStorage?.getItem(ACTIVE_SLOT_KEY) || '').trim() || null; } catch { return null; }
      }
      function setActiveSlotId(id) {
        const v = String(id || '').trim();
        try { window.localStorage?.setItem(ACTIVE_SLOT_KEY, v); } catch { }
        try { window.localStorage?.setItem(LOADED_SLOT_KEY, v); } catch { }
      }

      function renderSaveManager() {
        if (!saveWin || !saveList) return;
        const act = activeSlotId();
        if (saveMeta) saveMeta.textContent = act ? `í˜„ì¬ ìŠ¬ë¡¯: ${act}` : 'í˜„ì¬ ìŠ¬ë¡¯: (ì—†ìŒ) Â· ìƒˆ ìŠ¬ë¡¯ì„ ë§Œë“¤ê±°ë‚˜ ì €ì¥í•˜ì„¸ìš”.';
        const rows = (saveState.list || []).slice().sort((a, b) => {
          const ta = Number(a?.updatedAt || 0);
          const tb = Number(b?.updatedAt || 0);
          if (tb !== ta) return tb - ta;
          return String(a?.name || '').localeCompare(String(b?.name || ''), 'ko');
        });
        if (!rows.length) {
          saveList.innerHTML = '<div class="muted" style="padding:8px;">ìŠ¬ë¡¯ì´ ì—†ìŠµë‹ˆë‹¤. â€œìƒˆ ìŠ¬ë¡¯â€ì„ ëˆŒëŸ¬ ìƒì„±í•˜ì„¸ìš”.</div>';
          return;
        }
        const selId = saveState.selectedId || act || rows[0].id;
        saveState.selectedId = selId;
        saveList.innerHTML = rows.map(r => {
          const id = String(r.id || '');
          const checked = id === selId ? 'checked' : '';
          const activePill = id === act ? '<span class="pill">í˜„ì¬</span>' : '';
          const ts = r.updatedAt ? new Date(r.updatedAt).toLocaleString() : '';
          return `<label class="problems-item" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
            <input type="radio" name="saveSlotSel" value="${id.replace(/\"/g, '&quot;')}" ${checked}>
            <strong>${sanitize(r.name || id)}</strong>
            ${activePill}
            ${ts ? `<span class="muted">${sanitize(ts)}</span>` : ''}
            <span class="muted">${sanitize(id)}</span>
          </label>`;
        }).join('');
        saveList.querySelectorAll('input[type="radio"][name="saveSlotSel"]').forEach(rb => {
          rb.addEventListener('change', () => { saveState.selectedId = rb.value || null; });
        });
      }

      async function refreshSaveSlots() {
        try { saveState.list = await saveDbGetAll(); } catch { saveState.list = []; }
        renderSaveManager();
      }

      async function saveCurrentToSlot(id, nameMaybe) {
        const sid = String(id || '').trim();
        if (!sid) return;
        if (typeof window.fmmSaveAll === 'function') window.fmmSaveAll();
        const bundle = (typeof window.fmmDumpAll === 'function') ? window.fmmDumpAll() : fmmDumpAll();
        const rec = {
          id: sid,
          name: String(nameMaybe || '').trim() || (saveState.list.find(x => x.id === sid)?.name || sid),
          updatedAt: Date.now(),
          bundle
        };
        await saveDbPut(rec);
      }

      async function switchToSlot(id) {
        const sid = String(id || '').trim();
        if (!sid) return;
        const rec = await saveDbGet(sid);
        if (!rec || !rec.bundle) { alert('ìŠ¬ë¡¯ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }

        // Save current to active slot (optional)
        const act = activeSlotId();
        if (act) {
          const keep = confirm('ì „í™˜í•˜ê¸° ì „ì—, í˜„ì¬ ìŠ¬ë¡¯ì— í˜„ì¬ ìƒíƒœë¥¼ ì €ì¥í• ê¹Œìš”?');
          if (keep) {
            try { await saveCurrentToSlot(act); } catch { }
          }
        }

        wipeCurrentFmmData();
        try { fmmRestoreAll(rec.bundle); } catch (e) { alert('ìŠ¬ë¡¯ ë³µì› ì‹¤íŒ¨: ' + (e?.message || e)); return; }
        try { rehydrateAfterImport(); } catch { }
        setActiveSlotId(sid);
        await refreshSaveSlots();
        alert(`ìŠ¬ë¡¯ ì „í™˜ ì™„ë£Œ: ${rec.name || sid}`);
      }

      saveToggleBtn?.addEventListener('click', async () => {
        const showing = saveWin.classList.contains('active');
        saveWin.classList.toggle('active', !showing);
        saveWin.style.display = showing ? 'none' : '';
        if (!showing) {
          try { restoreSavedBox(saveWin, 'fmm_ui_saveManagerWindow'); } catch { }
          await refreshSaveSlots();
        }
      });
      saveCloseBtn?.addEventListener('click', () => {
        if (!saveWin) return;
        saveWin.classList.remove('active');
        saveWin.style.display = 'none';
      });

      $('#saveSlotNewBtn')?.addEventListener('click', async () => {
        const name = prompt('ìƒˆ ìŠ¬ë¡¯ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.', 'ìƒˆ ìŠ¬ë¡¯');
        if (!name) return;
        const id = 'slot_' + Date.now();
        try {
          await saveCurrentToSlot(id, name.trim());
          setActiveSlotId(id);
          saveState.selectedId = id;
          await refreshSaveSlots();
        } catch (e) {
          alert('ìŠ¬ë¡¯ ìƒì„± ì‹¤íŒ¨: ' + (e?.message || e));
        }
      });
      $('#saveSlotSaveBtn')?.addEventListener('click', async () => {
        const sid = saveState.selectedId || activeSlotId();
        if (!sid) {
          alert('ë¨¼ì € ìŠ¬ë¡¯ì„ ì„ íƒí•˜ê±°ë‚˜ ìƒˆ ìŠ¬ë¡¯ì„ ë§Œë“œì„¸ìš”.');
          return;
        }
        const rec = saveState.list.find(x => x.id === sid);
        try {
          await saveCurrentToSlot(sid, rec?.name || sid);
          setActiveSlotId(sid);
          await refreshSaveSlots();
          alert('í˜„ì¬ ìƒíƒœë¥¼ ìŠ¬ë¡¯ì— ì €ì¥í–ˆìŠµë‹ˆë‹¤.');
        } catch (e) {
          alert('ì €ì¥ ì‹¤íŒ¨: ' + (e?.message || e));
        }
      });
      $('#saveSlotSwitchBtn')?.addEventListener('click', async () => {
        const sid = saveState.selectedId;
        if (!sid) { alert('ì „í™˜í•  ìŠ¬ë¡¯ì„ ì„ íƒí•˜ì„¸ìš”.'); return; }
        if (!confirm('ì„ íƒí•œ ìŠ¬ë¡¯ìœ¼ë¡œ ì „í™˜í• ê¹Œìš”?\n(í˜„ì¬ ë¸Œë¼ìš°ì € ë°ì´í„°ëŠ” ì„ íƒ ìŠ¬ë¡¯ ë°ì´í„°ë¡œ ë®ì–´ì¨ì§‘ë‹ˆë‹¤.)')) return;
        try { await switchToSlot(sid); } catch (e) { alert('ì „í™˜ ì‹¤íŒ¨: ' + (e?.message || e)); }
      });
      $('#saveSlotRenameBtn')?.addEventListener('click', async () => {
        const sid = saveState.selectedId;
        if (!sid) { alert('ì´ë¦„ì„ ë°”ê¿€ ìŠ¬ë¡¯ì„ ì„ íƒí•˜ì„¸ìš”.'); return; }
        const rec = saveState.list.find(x => x.id === sid);
        const name = prompt('ìƒˆ ìŠ¬ë¡¯ ì´ë¦„', rec?.name || sid);
        if (!name) return;
        const full = await saveDbGet(sid);
        if (!full) return;
        full.name = name.trim();
        full.updatedAt = Date.now();
        await saveDbPut(full);
        await refreshSaveSlots();
      });
      $('#saveSlotDeleteBtn')?.addEventListener('click', async () => {
        const sid = saveState.selectedId;
        if (!sid) { alert('ì‚­ì œí•  ìŠ¬ë¡¯ì„ ì„ íƒí•˜ì„¸ìš”.'); return; }
        if (!confirm('ì´ ìŠ¬ë¡¯ì„ ì‚­ì œí• ê¹Œìš”?\n(ì‚­ì œí•œ ìŠ¬ë¡¯ì€ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.)')) return;
        await saveDbDelete(sid);
        if (activeSlotId() === sid) {
          try { window.localStorage?.removeItem(ACTIVE_SLOT_KEY); } catch { }
          try { window.localStorage?.removeItem(LOADED_SLOT_KEY); } catch { }
        }
        saveState.selectedId = null;
        await refreshSaveSlots();
      });

      // Auto-load active slot on startup if needed
      (async function bootActiveSlot() {
        const act = activeSlotId();
        if (!act) return;
        const loaded = (() => { try { return String(window.localStorage?.getItem(LOADED_SLOT_KEY) || '').trim() || null; } catch { return null; } })();
        if (loaded === act) return;
        try {
          const rec = await saveDbGet(act);
          if (!rec || !rec.bundle) return;
          wipeCurrentFmmData();
          fmmRestoreAll(rec.bundle);
          rehydrateAfterImport();
          setActiveSlotId(act);
        } catch { }
      })();

      // Ensure new renders get the extras
      const _origRenderTypes2 = renderTypes;
      renderTypes = function (types) {
        window.fmm_types = types;
        _origRenderTypes2(types);
        applyWordMemos(outputEl);
        reapplySpotMemos(outputEl);
        mountStandardProblemEditors();
        mountExplanationEditors();
        onTypeMaybeChange();

        // FIX: Request #18 - Refresh Type Memo and Problems List on Scroll/Type Change
        // ideology: Sidebar should always reflect the content currently in view.
        if (window._fmmTypeSpy) document.removeEventListener('scroll', window._fmmTypeSpy);

        let lastIdx = currentTypeIndex();
        const spy = () => {
          const nowIdx = currentTypeIndex();
          if (nowIdx !== lastIdx) {
            lastIdx = nowIdx;
            if (window.loadTypeMemo) window.loadTypeMemo();
            else loadTypeMemo();
            renderProblemsForCurrentType();
            onTypeMaybeChange();
          }
        };
        window._fmmTypeSpy = spy;
        document.addEventListener('scroll', spy, { passive: true });
        // Initial sync
        if (window.loadTypeMemo) window.loadTypeMemo();
        else loadTypeMemo();
        renderProblemsForCurrentType();
      };

      function onTypeMaybeChange() {
        // FIX: Request #15 - Type-specific LLM chat context
        const title = currentTypeTitle();
        if (title) {
          const roomId = 'type_' + title;
          if (!chats.rooms.some(r => r.id === roomId)) {
            chats.rooms.push({ id: roomId, name: title, messages: [] });
          }
          // Only auto-switch if the user is already in a type-room (or no room yet).
          // If user explicitly selected a global room, keep it.
          const curId = String(chats.current || '');
          const isTypeRoom = curId.startsWith('type_');
          if (!curId || isTypeRoom) {
            chats.current = roomId;
            chats.sync();
          }
          renderRoomsUI();
          renderChat();
        }
      }

      // === ADD: drag + persist for asides & chat window ==========================
      // Ideology: explicit, user-controlled placement survives refresh/export.

      function makeDraggablePersist(el, handleSelector, storeKey) {
        if (!el) return;
        // el.style.position = 'fixed';  // ì œê±°: ì´ˆê¸° í¬ì§€ì…˜ì€ CSSê°€ ë‹´ë‹¹
        const MIN_W = 120, MIN_H = 120;

        // restore saved box (0x0 ê°™ì€ ì˜ëª»ëœ ê°’ ë¬´ì‹œ)
        const saved = JSON.parse(store.getItem(storeKey) || 'null');
        if (saved) {
          // FIX: if the element was positioned via right/bottom in CSS, clear them so left/top resizing works.
          // (Otherwise, users can hit "can't resize / weird blank area" constraints.)
          try { el.style.right = 'auto'; el.style.bottom = 'auto'; } catch { }
          ['left', 'top', 'width', 'height'].forEach(k => {
            const v = typeof saved[k] === 'number' ? saved[k] : parseFloat(saved[k]);
            if (Number.isFinite(v)) {
              if ((k === 'width' && v < MIN_W) || (k === 'height' && v < MIN_H)) return;
              el.style[k] = v + 'px';
            }
          });
        }

        const saveBox = () => {
          const r = el.getBoundingClientRect();
          // 0x0 ì €ì¥ ê¸ˆì§€
          if (r.width < MIN_W || r.height < MIN_H) return;
          store.setItem(storeKey, JSON.stringify({
            left: r.left, top: r.top, width: r.width, height: r.height
          }));
        };

        el.addEventListener('mousedown', (ev) => {
          const handle = ev.target.closest(handleSelector);
          if (!handle) return;
          ev.preventDefault();
          const r = el.getBoundingClientRect();
          const start = { x: ev.clientX, y: ev.clientY, left: r.left, top: r.top };
          el.classList.add('dragging');
          function onMove(e) {
            const dx = e.clientX - start.x, dy = e.clientY - start.y;
            let nextLeft = (start.left + dx);
            let nextTop = (start.top + dy);
            // Ensure left/top are the active positioning axes while dragging.
            try { el.style.right = 'auto'; el.style.bottom = 'auto'; } catch { }
            const vw = window.innerWidth || 0;
            const vh = window.innerHeight || 0;
            const margin = 24; // í•­ìƒ ìƒë‹¨ ì¼ë¶€ëŠ” í™”ë©´ ì•ˆì— ë‚¨ë„ë¡
            if (vw > 0) {
              const maxLeft = vw - margin;
              if (nextLeft > maxLeft) nextLeft = maxLeft;
              if (nextLeft < - (r.width || MIN_W) + margin) nextLeft = margin - (r.width || MIN_W);
            }
            if (vh > 0) {
              const maxTop = vh - margin;
              if (nextTop > maxTop) nextTop = maxTop;
              if (nextTop < 0) nextTop = 0; // ì°½ ìƒë‹¨ì´ í™”ë©´ ë°–ìœ¼ë¡œ ì™„ì „íˆ ë‚˜ê°€ì§€ ì•Šë„ë¡ ê³ ì •
            }
            el.style.left = nextLeft + 'px';
            el.style.top = nextTop + 'px';
          }
          function onUp() {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            el.classList.remove('dragging'); saveBox();
          }
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
        });

        // í¬ê¸° ë³€ê²½ ì €ì¥ (0x0 ê°€ë“œ í¬í•¨)
        const ro = new ResizeObserver(() => saveBox());
        ro.observe(el);
      }

	      // PATCH START: Apply draggable to new split asides
	      makeDraggablePersist($('#globalAside'), '.sidebar-head', 'fmm_ui_globalAside');
	      makeDraggablePersist($('#typeAside'), '.sidebar-head', 'fmm_ui_typeAside');
			      makeDraggablePersist($('#leftAside'), '.sidebar-head', 'fmm_ui_leftAside');
			      makeDraggablePersist($('#chatWindow'), '.window-head', 'fmm_ui_chatWindow');
			      makeDraggablePersist($('#searchWindow'), '.window-head', 'fmm_ui_searchWindow');
			      makeDraggablePersist($('#similarWindow'), '.window-head', 'fmm_ui_similarWindow');
			      makeDraggablePersist($('#latexToolWindow'), '.window-head', 'fmm_ui_latexToolWindow');
			      makeDraggablePersist($('#solveWindow'), '.window-head', 'fmm_ui_solveWindow');
			      makeDraggablePersist($('#memoShareManagerWindow'), '.window-head', 'fmm_ui_memoShareManagerWindow');
			      makeDraggablePersist($('#statsWindow'), '.window-head', 'fmm_ui_statsWindow');
			      makeDraggablePersist($('#llmFillWindow'), '.window-head', 'fmm_ui_llmFillWindow');
			      makeDraggablePersist($('#paperManagerWindow'), '.window-head', 'fmm_ui_paperManagerWindow');
			      makeDraggablePersist($('#saveManagerWindow'), '.window-head', 'fmm_ui_saveManagerWindow');
		      // PATCH END

      // === ADD: category memo mini-UI for Global & Type panels ====================
      // Ideology: structured recall beats long scroll â€” save memos by topic & rearrange.

      function makeMemoCategoryUI(panelId, textareaId, storeKeyFactory) {
        const panel = $(panelId); const area = $(textareaId);
        if (!panel || !area) return;

        const wrap = document.createElement('div');
	        wrap.style.marginTop = '8px';
	        wrap.style.display = 'flex';
	        wrap.style.flexDirection = 'column';
	        wrap.style.flex = '0 0 auto';
	        wrap.innerHTML = `
          <div class="hr"></div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
            <input class="memo-textarea" style="min-height:36px;flex:2" placeholder="ì¹´í…Œê³ ë¦¬ ê²½ë¡œ (ì˜ˆ: Study/PE)">
            <input class="memo-textarea" style="min-height:36px;flex:2" placeholder="ë©”ëª¨ ì œëª©">
            <button class="btn" data-act="new" title="ìƒˆ ë©”ëª¨ ì‘ì„±">+</button>
            <button class="btn" data-act="save" title="í˜„ì¬ ë‚´ìš©ì„ ìƒˆ ë©”ëª¨ë¡œ ì €ì¥">ìƒˆë¡œ ì €ì¥</button>
            <button class="btn" data-act="show">ëª©ë¡ ë³´ê¸°</button>
          </div>
          <div class="category-list" style="margin-top:8px; display:none;"></div>
        `;
        panel.querySelector('.sidebar-body').appendChild(wrap);
        try { translateUiChrome(wrap); } catch { }
	        const catInput = wrap.querySelectorAll('input')[0];
	        const titleInput = wrap.querySelectorAll('input')[1];
	        const listEl = wrap.querySelector('.category-list');
	        // default the list CLOSED (keep panels compact)
	        listEl.style.display = 'none';

        // storage helpers
        const getState = (key) => JSON.parse(store.getItem(key) || '[]');
        const setState = (key, v) => store.setItem(key, JSON.stringify(v));

        // build tree like in reference code
        function buildTree(chunks) {
          const root = { name: '', fullPath: '', children: {}, memos: [] };
          chunks.forEach(m => {
            const path = (m.categoryPath || 'Uncategorized').split('/').map(s => s.trim()).filter(Boolean);
            let node = root, p = '';
            path.forEach(part => {
              p = p ? (p + '/' + part) : part;
              node.children[part] ||= { name: part, fullPath: p, children: {}, memos: [] };
              node = node.children[part];
            });
            node.memos.push(m);
          });
          return root;
        }

        // FIX: Request #1 - Default to ALL OPEN, track CLOSED instead
        function renderTree(chunks) {
          const closedSet = new Set();
          listEl.querySelectorAll('.memo-viewer').forEach(v => {
            if (v.style.display === 'none') {
              const id = v.dataset.memoId;
              if (id) closedSet.add(String(id));
            }
          });
          const prevScroll = listEl.scrollTop;
          listEl.innerHTML = '';
          listEl.style.display = '';
          const tree = buildTree(chunks);
          const names = Object.keys(tree.children).sort((a, b) => a.localeCompare(b));
          names.forEach(n => listEl.appendChild(renderNode(tree.children[n], 0, closedSet)));
          listEl.scrollTop = prevScroll;
        }

	        function renderNode(node, depth, closedSet) {
	          const box = document.createElement('div');
	          box.innerHTML = `
	            <div class="category-node-header" style="padding-left:${depth * 12}px;">
	              <button class="btn" data-act="expand">â–¼</button>
	              <button class="btn category-select-btn" draggable="true" data-path="${escapeHtml(node.fullPath)}">${escapeHtml(node.name)}</button>
	            </div>
	          `;
          const childrenWrap = document.createElement('div');
          childrenWrap.className = 'category-children';
          // memos
          node.memos.forEach(m => {
            const b = document.createElement('button');
            b.className = 'btn category-memo-btn';
            b.style.marginLeft = (depth + 1) * 12 + 'px';
            b.draggable = true;
            b.dataset.memoId = String(m.id);
            b.textContent = `ã„´ ${m.title || '(ì œëª© ì—†ìŒ)'}`;
            // PATCH START: Mark selected memo for editing
            b.addEventListener('click', () => {
              area.value = maskDataImages(m.content || '', area);
              panel.dataset.selectedMemoId = String(m.id);
              catInput.value = String(m.categoryPath || '');
              titleInput.value = String(m.title || '');
              $$('.category-memo-btn', listEl).forEach(btn => btn.classList.toggle('selected', btn === b));
            });
            // PATCH END

            // === ADD: openable viewer with markdown + LaTeX ===============================
            // ideology: let multiple memos stay open concurrentlyâ€”reference beats recall
            const viewer = document.createElement('div');
            viewer.className = 'md memo-viewer';
            viewer.dataset.memoId = String(m.id);
            viewer.style.margin = '6px 0 10px';
            viewer.style.padding = '8px';
	            viewer.style.border = '1px dashed var(--border)';
	            viewer.style.borderRadius = '8px';
	            viewer.style.fontSize = (m.previewFont != null) ? (String(Number(m.previewFont)) + 'px') : '';
	            // FIX: Default to OPEN (display: ''), checks closedSet. Request #1
	            viewer.style.display = closedSet.has(String(m.id)) ? 'none' : '';

	            function renderViewer() {
	              const html = renderMarkdown(m.content || '', { breaks: true, autoAsciiMath: true }, 'parseThenSanitize');
	              viewer.innerHTML = `
	                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
	                  <strong>ë¯¸ë¦¬ë³´ê¸°</strong>
	                  <div class="chat-actions" style="display:flex;gap:6px;">
	                    <button class="btn" data-act="memo-font-minus" title="ë¯¸ë¦¬ë³´ê¸° ê¸€ì ì‘ê²Œ">Aâˆ’</button>
	                    <button class="btn" data-act="memo-font-plus" title="ë¯¸ë¦¬ë³´ê¸° ê¸€ì í¬ê²Œ">A+</button>
	                    <button class="btn" data-act="memo-toggle">ë‹«ê¸°</button>
	                    <button class="btn" data-act="memo-edit">ì—ë””í„°ë¡œ</button>
	                  </div>
	                </div>
	                ${html}
	              `;
	              viewer.style.fontSize = (m.previewFont != null) ? (String(Number(m.previewFont)) + 'px') : '';
	              applyInlineBoldMarkers(viewer);
	              typesetMath(viewer);
	            }
            if (!closedSet.has(String(m.id))) renderViewer();

            const rowWrap = document.createElement('div');
            rowWrap.appendChild(viewer);

            // toggle open/close without affecting others
            b.addEventListener('dblclick', () => {
              viewer.style.display = (viewer.style.display === 'none' ? '' : 'none');
              if (viewer.style.display !== 'none') renderViewer();
            });

            // local actions on viewer
	            rowWrap.addEventListener('click', (ev) => {
	              const q = ev.target.closest('[data-act]');
	              if (!q) return;
	              if (q.dataset.act === 'memo-font-minus') {
	                const base = Number(m.previewFont || UI.memoPreviewFont || 15);
	                const next = clamp(base - 1, 12, 32);
	                m.previewFont = next;
	                viewer.style.fontSize = String(next) + 'px';
	                const key = storeKeyFactory();
	                const chunks = getState(key);
	                const found = chunks.find(x => String(x.id) === String(m.id));
	                if (found) found.previewFont = next;
	                setState(key, chunks);
	              }
	              if (q.dataset.act === 'memo-font-plus') {
	                const base = Number(m.previewFont || UI.memoPreviewFont || 15);
	                const next = clamp(base + 1, 12, 32);
	                m.previewFont = next;
	                viewer.style.fontSize = String(next) + 'px';
	                const key = storeKeyFactory();
	                const chunks = getState(key);
	                const found = chunks.find(x => String(x.id) === String(m.id));
	                if (found) found.previewFont = next;
	                setState(key, chunks);
	              }
	              if (q.dataset.act === 'memo-toggle') {
	                viewer.style.display = (viewer.style.display === 'none' ? '' : 'none');
	                if (viewer.style.display !== 'none') renderViewer();
	              }
              if (q.dataset.act === 'memo-edit') {
                area.value = maskDataImages(m.content || '', area);
                panel.dataset.selectedMemoId = String(m.id);
                catInput.value = String(m.categoryPath || '');
                titleInput.value = String(m.title || '');
                $$('.category-memo-btn', listEl).forEach(btn => btn.classList.toggle('selected', btn === b));
              }
            });

            // drag source: memo
            b.addEventListener('dragstart', (ev) => { ev.dataTransfer.setData('text/memo-id', String(m.id)); });

            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.gap = '6px';

            row.appendChild(b);

            const del = document.createElement('button');
            del.className = 'btn';
            del.textContent = 'ğŸ—‘';
            del.title = 'ì´ ë©”ëª¨ ì‚­ì œ';
            del.addEventListener('click', (ev) => {
              ev.stopPropagation();
              if (!confirm('ì´ ë©”ëª¨ë¥¼ ì¹´í…Œê³ ë¦¬ì—ì„œ ì™„ì „íˆ ì‚­ì œí• ê¹Œìš”?')) return;
              const key = storeKeyFactory();
              const chunks = getState(key);
              const idx = chunks.findIndex(x => String(x.id) === String(m.id));
              if (idx > -1) {
                chunks.splice(idx, 1);
                setState(key, chunks);
                renderTree(chunks);
              }
            });
            row.appendChild(del);

            childrenWrap.appendChild(row);
            childrenWrap.appendChild(rowWrap);
          });
          // child categories
          Object.keys(node.children).sort((a, b) => a.localeCompare(b)).forEach(cn => {
            childrenWrap.appendChild(renderNode(node.children[cn], depth + 1, closedSet));
          });
          // drop targets
          const header = box.querySelector('.category-select-btn');
          header.addEventListener('dragover', ev => ev.preventDefault());
          header.addEventListener('drop', ev => {
            ev.preventDefault();
            const memoId = ev.dataTransfer.getData('text/memo-id');
            const catSrc = ev.dataTransfer.getData('text/category-path');
            const key = storeKeyFactory();
            const chunks = getState(key);
            if (memoId) {
              const m = chunks.find(x => String(x.id) === String(memoId)); if (!m) return;
              m.categoryPath = header.dataset.path || '';
              setState(key, chunks); renderTree(chunks);
            } else if (catSrc) {
              if (header.dataset.path === catSrc || header.dataset.path.startsWith(catSrc + '/')) return;
              chunks.forEach(m => {
                const cp = m.categoryPath || '';
                if (cp === catSrc || cp.startsWith(catSrc + '/')) {
                  m.categoryPath = header.dataset.path + cp.slice(catSrc.length);
                }
              });
              setState(key, chunks); renderTree(chunks);
            }
          });
          // drag a whole category
          header.addEventListener('dragstart', ev => {
            ev.dataTransfer.setData('text/category-path', header.dataset.path || '');
          });
          box.appendChild(childrenWrap);
          return box;
        }

        // actions
        wrap.addEventListener('click', () => {
          /* noop to keep delegated handlers local */
        });
        // FIX: Request - "Save as New" support
        wrap.querySelector('[data-act="new"]').addEventListener('click', () => {
          panel.dataset.selectedMemoId = '';
          area.value = '';
          titleInput.value = '';
          area.focus();
          $$('.category-memo-btn', listEl).forEach(btn => btn.classList.remove('selected'));
        });
        wrap.querySelector('[data-act="save"]').addEventListener('click', () => {
          const key = storeKeyFactory();
          const chunks = getState(key);
          const title = titleInput.value.trim() || 'ë©”ëª¨';
          const categoryPath = catInput.value.trim() || '';
          const content = unmaskDataImages(area.value || '', area);
          const id = chunks.length ? Math.max(...chunks.map(c => c.id || 0)) + 1 : 1;
          chunks.push({ id, title, categoryPath, content, createdAt: Date.now() });
          panel.dataset.selectedMemoId = String(id);
          setState(key, chunks);
          if (listEl.style.display !== 'none') renderTree(chunks);
          // ensure the freshly saved memo previews render markdown & LaTeX immediately
          typesetMath(listEl);
          // ì œëª©ì€ ìƒˆë¡œ ì…ë ¥í•˜ë„ë¡ë§Œ ì´ˆê¸°í™”, ê²½ë¡œëŠ” ìœ ì§€
          titleInput.value = '';
          statusEl.textContent = (currentLang === 'ko') ? 'ì¹´í…Œê³ ë¦¬ ë©”ëª¨ ìƒˆë¡œ ì €ì¥ë¨' : 'Category memo saved';
        });
        wrap.querySelector('[data-act="show"]').addEventListener('click', () => {
          const key = storeKeyFactory();
          const chunks = getState(key);
          listEl.style.display = listEl.style.display === 'none' ? '' : 'none';
          if (listEl.style.display !== 'none') renderTree(chunks);
        });

        // PATCH START: Expose a small API on the panel for refresh and updates
        panel._category = {
          refresh() {
            const key = storeKeyFactory();
            const chunks = getState(key);
            if (listEl.style.display !== 'none') renderTree(chunks);
          },
          updateSelectedContent() {
            const id = panel.dataset.selectedMemoId;
            if (!id) return false;
            const key = storeKeyFactory();
            const chunks = getState(key);
            const item = chunks.find(x => String(x.id) === String(id));
            if (!item) return false;
            item.title = titleInput.value.trim() || item.title || 'ë©”ëª¨';
            item.categoryPath = catInput.value.trim() || item.categoryPath || '';
            item.content = unmaskDataImages(area.value || '', area);
            item.updatedAt = Date.now();
            setState(key, chunks);
            if (listEl.style.display !== 'none') renderTree(chunks);
            typesetMath(listEl);
            return true;
          }
        };
        // PATCH END
      }

      // mount for ê¸€ë¡œë²Œ/ìœ í˜•
      makeMemoCategoryUI('#globalMemoPanel', '#globalMemo', () => 'fmm_global_memo_chunks');
      makeMemoCategoryUI('#typeMemoPanel', '#typeMemo', () => {
        const t = (window.fmm_types || [])[currentTypeIndex()]?.title || 'unknown';
        return 'fmm_type_memo_chunks_' + normalizeTitle(t).replace(/\s+/g, '_');
      });

      // FIX: Request - Ensure Type Memo follows Type Change by refreshing Category UI
      // Use window.loadTypeMemo override to hook into the existing refresh cycle
      window.loadTypeMemo = function () {
        const title = currentTypeTitle();
        const typeMemoTitle = document.getElementById('typeMemoTitle');
        const typeMemoEl = document.getElementById('typeMemo');
        if (typeMemoTitle) typeMemoTitle.textContent = title ? `(${title})` : '';

        const panel = document.getElementById('typeMemoPanel');
        if (panel && panel._category) {
          panel._category.refresh();
          // Optional: clear editor if switching types? 
          // ideology: new context = clean slate (unless we persist 'current selection' per type, which is hard)
          // For now, let's leave the textarea as is OR clear it to avoid confusion?
          // User compliant: "List doesn't change". Refresh fixes list.
          // If we don't clear textarea, it might show memo from PREVIOUS type.
          // Let's clear it to be safe, or load "Legacy" if user relies on it.
          // Given "Save as New" request, user is likely using Categories.
          // Safe bet: Clear it to avoid crossing streams.
          // typeMemoEl.value = ''; 
          // BUT, if user is just scrolling? Clearing their work-in-progress is bad.
          // Better: only refresh list.
        } else {
          // Legacy Fallback
          if (typeMemoEl) typeMemoEl.value = title ? maskDataImages(LS.get(`fmm_memo_type_${title}`, ''), typeMemoEl) : '';
        }
      };

      // === ADD: Search window logic (separate results to preserve reading context) ===
      const searchWin = $('#searchWindow');
      const searchToggleBtn = $('#searchToggleBtn');
      searchToggleBtn.addEventListener('click', () => {
        searchWin.classList.toggle('active');
        if (searchWin.classList.contains('active')) {
          restoreSavedBox(searchWin, 'fmm_ui_searchWindow'); // ideology: preserve userâ€™s working layout
          const input = $('#searchInput');
          input && input.focus();
          const q = input?.value?.trim();
          if (q) runSearch();
          else $('#searchResults').innerHTML = '<div class="muted">ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</div>';
        }
      });
	      function clearSearchHighlights() {
	        document.querySelectorAll('mark.search-hit').forEach(m => {
	          const parent = m.parentNode;
	          if (!parent) return;
	          parent.replaceChild(document.createTextNode(m.textContent || ''), m);
	          parent.normalize();
	        });
	        document.querySelectorAll('mjx-container.math-search-hit').forEach(el => {
	          el.classList.remove('math-search-hit');
	        });
	      }

      $('#searchRun').addEventListener('click', runSearch);
      $('#searchInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') { runSearch(); } });
      // ê²€ìƒ‰ì°½ ë‹«ì„ ë•Œë„ í•˜ì´ë¼ì´íŠ¸ ì œê±°
      searchWin.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action="close"][data-target="#searchWindow"]');
        if (btn) {
          clearSearchHighlights();
        }
      });

      function runSearch() {
	        const q = $('#searchInput').value.trim();
	        const resultsBox = $('#searchResults');
	        if (!q) {
	          resultsBox.innerHTML = '<div class="muted">ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</div>';
	          return;
	        }
	        try {
	        const mode = (document.querySelector('input[name="searchScope"]:checked')?.value) || 'type';
	        const results = [];
	        const escaped = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	        const highlightRe = new RegExp(escaped, 'ig');
	        const needleLower = q.toLowerCase();
	        const needleLen = q.length;
	        const needleCompact = needleLower.replace(/\s+/g, '');

	        function stripOuterMathDelims(raw) {
	          let t = String(raw || '').trim();
	          if (!t) return '';
	          const pairs = [
	            { open: '$$', close: '$$' },
	            { open: '$', close: '$' },
	            { open: '\\\\[', close: '\\\\]' },
	            { open: '\\\\(', close: '\\\\)' },
	            { open: '\\[', close: '\\]' },
	            { open: '\\(', close: '\\)' }
	          ];
	          for (const p of pairs) {
	            if (t.startsWith(p.open) && t.endsWith(p.close) && t.length > p.open.length + p.close.length) {
	              t = t.slice(p.open.length, -p.close.length).trim();
	              break;
	            }
	          }
	          return t;
	        }

	        const texNeedleCompact = stripOuterMathDelims(q).toLowerCase().replace(/\s+/g, '') || needleCompact;
	        const texNeedleLen = texNeedleCompact.length;

	        function escapeHtml(s) {
	          return String(s || '')
	            .replace(/&/g, '&amp;')
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;')
	            .replace(/"/g, '&quot;')
	            .replace(/'/g, '&#39;');
	        }
	        function makeHighlightedSnippet(raw) {
	          const rawStr = String(raw || '');
	          if (!rawStr) return '';
	          const lower = rawStr.toLowerCase();
	          let out = '';
	          let start = 0;
	          while (start < rawStr.length) {
	            const idx = lower.indexOf(needleLower, start);
	            if (idx === -1) {
	              out += escapeHtml(rawStr.slice(start));
	              break;
	            }
	            out += escapeHtml(rawStr.slice(start, idx));
	            out += `<mark>${escapeHtml(rawStr.slice(idx, idx + needleLen))}</mark>`;
	            start = idx + needleLen;
	          }
	          return out;
	        }

	        // ì´ì „ ê²€ìƒ‰ì˜ í•˜ì´ë¼ì´íŠ¸ ì œê±°
	        clearSearchHighlights();

        const MAX_RESULTS = 200;
        let total = 0;

	        function highlightAt(node, offset, len) {
	          if (!node || !node.parentNode) return;
	          clearSearchHighlights();
	          const text = node.nodeValue || '';
          const before = text.slice(0, offset);
          const match = text.slice(offset, offset + len);
          const after = text.slice(offset + len);
          const frag = document.createDocumentFragment();
          if (before) frag.appendChild(document.createTextNode(before));
          const mark = document.createElement('mark');
          mark.className = 'search-hit selected';
          mark.textContent = match;
          frag.appendChild(mark);
          if (after) frag.appendChild(document.createTextNode(after));
          node.parentNode.replaceChild(frag, node);
          const r = mark.getBoundingClientRect();
          const top = r.top + window.scrollY - 100;
          window.scrollTo({ top, behavior: 'smooth' });
	          setTimeout(() => mark.classList.remove('selected'), 1200);
	        }

	        function highlightMathAt(el) {
	          if (!el) return;
	          clearSearchHighlights();
	          el.classList.add('math-search-hit');
	          const r = el.getBoundingClientRect();
	          const top = r.top + window.scrollY - 100;
	          window.scrollTo({ top, behavior: 'smooth' });
	          setTimeout(() => el.classList.remove('math-search-hit'), 1200);
	        }

	        function acceptTextNodeForSearch(node) {
	          if (!node || !node.nodeValue) return NodeFilter.FILTER_SKIP;
	          const pe = node.parentElement;
	          if (!pe || pe.closest('.memo-anchor') || ['CODE', 'PRE', 'SCRIPT', 'STYLE'].includes(pe.tagName)) {
	            return NodeFilter.FILTER_SKIP;
	          }
	          return NodeFilter.FILTER_ACCEPT;
	        }

	        function locateNthTextOccurrence(container, nth) {
	          if (!container) return null;
	          const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, { acceptNode: acceptTextNodeForSearch });
	          let textNode;
	          let count = 0;
	          while ((textNode = walker.nextNode())) {
	            const fullText = textNode.nodeValue || '';
	            const lower = fullText.toLowerCase();
	            let startIndex = 0;
	            while (true) {
	              const idx = lower.indexOf(needleLower, startIndex);
	              if (idx === -1) break;
	              if (count === nth) return { node: textNode, offset: idx };
	              count++;
	              startIndex = idx + needleLen;
	            }
	          }
	          return null;
	        }

	        function textSearch(container, label) {
	          if (!container || total >= MAX_RESULTS) return;
	          const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, { acceptNode: acceptTextNodeForSearch });

	          let textNode;
	          let occIndex = 0;
	          while ((textNode = walker.nextNode()) && total < MAX_RESULTS) {
	            const fullText = textNode.nodeValue || '';
	            const lower = fullText.toLowerCase();
	            let startIndex = 0;
	            while (total < MAX_RESULTS) {
	              const idx = lower.indexOf(needleLower, startIndex);
	              if (idx === -1) break;

	              const left = Math.max(0, idx - 60);
	              const right = Math.min(fullText.length, idx + needleLen + 60);
	              const rawSnippet = fullText.slice(left, right);
	              const snippet = makeHighlightedSnippet(rawSnippet);
	              const occ = occIndex++;

	              results.push({
	                kind: 'hit',
	                label,
	                snippet,
	                onNav: () => {
	                  clearSearchHighlights();
	                  const loc = locateNthTextOccurrence(container, occ);
	                  if (loc && loc.node) highlightAt(loc.node, loc.offset, needleLen);
	                }
	              });
	              total++;
	              startIndex = idx + needleLen;
	            }
	          }
	        }

		        function texSearch(container, label) {
		          if (!container || total >= MAX_RESULTS) return;
		          if (!texNeedleCompact) return;
		          const nodes = container.querySelectorAll('mjx-container');

	          function compactRangeToOriginal(original, startCompact, lenCompact) {
	            let start = -1;
	            let end = -1;
	            let count = 0;
	            for (let i = 0; i < original.length; i++) {
	              const ch = original[i];
	              if (/\s/.test(ch)) continue;
	              if (start === -1 && count === startCompact) start = i;
	              if (start !== -1 && count === startCompact + lenCompact) { end = i; break; }
	              count++;
	            }
	            if (start !== -1 && end === -1) end = original.length;
	            return start !== -1 ? { start, end } : null;
	          }
	          function makeHighlightedSnippetByRange(raw, start, end) {
	            const rawStr = String(raw || '');
	            if (!rawStr) return '';
	            const left = Math.max(0, start - 60);
	            const right = Math.min(rawStr.length, end + 60);
	            return `${escapeHtml(rawStr.slice(left, start))}<mark>${escapeHtml(rawStr.slice(start, end))}</mark>${escapeHtml(rawStr.slice(end, right))}`;
	          }

	          nodes.forEach(mjx => {
	            if (total >= MAX_RESULTS) return;
	            const tex = String(getTexForMjx(mjx) || mjx.getAttribute('data-tex') || '');
	            if (!tex) return;
	            const lower = tex.toLowerCase();
	            const compact = lower.replace(/\s+/g, '');
	            let startIndex = 0;
	            while (total < MAX_RESULTS) {
	              const idx = compact.indexOf(texNeedleCompact, startIndex);
	              if (idx === -1) break;
	              const range = compactRangeToOriginal(tex, idx, texNeedleLen) || { start: 0, end: Math.min(tex.length, 80) };
	              const snippet = makeHighlightedSnippetByRange(tex, range.start, range.end);
	              const hitEl = mjx;
	              results.push({
	                kind: 'tex',
	                label: `${label} Â· LaTeX`,
	                snippet,
	                onNav: () => highlightMathAt(hitEl)
	              });
	              total++;
	              startIndex = idx + Math.max(1, texNeedleLen);
	            }
		          });
		        }

		        function openProblemBatchView(list, label) {
		          const aside = $('#leftAside');
		          if (aside) {
		            aside.style.display = '';
		            try { restoreSavedBox(aside, 'fmm_ui_leftAside'); } catch { }
		          }
		          const detailEl = $('#problemDetail');
		          const metaEl = $('#problemsMeta');
		          if (!detailEl) return;
		          const title = String(label || currentTypeTitle() || '').trim();
		          if (metaEl) metaEl.textContent = title ? `${title} Â· ê²€ìƒ‰ ê²°ê³¼ ${list.length}ë¬¸í•­` : `ê²€ìƒ‰ ê²°ê³¼ ${list.length}ë¬¸í•­`;
		          let html = '';
		          (list || []).forEach(p0 => {
		            const p = applyProblemOverrides(p0);
		            if (!p || !p.qid) return;
		            const tag = getEffectiveTag(p.qid);
		            const paper = formatPaperNameDisplay(p.paperName, p.qid);
		            html += `<div class="md" style="margin-bottom:18px;">
		              <div class="muted">${sanitize(paper)} Â· <span class="tag-badge">${tag}</span></div>
		              <h3>${sanitize(p.qid)}</h3><div class="hr"></div>
		              ${renderMarkdown(stripAnswerEmphasis(p.question_text), undefined, 'sanitizeThenParse')}
		              <div style="margin-top:8px;">${sanitize(formatAnswerChoices(stripAnswerEmphasis(p.answer_choices), getOfficialAnswerText(p.official_answer)))}</div>
		              ${hasOfficialAnswer(p.official_answer) ? `<div class="answer" style="margin-top:10px;"><span class="badge">ì •ë‹µ</span>${getOfficialAnswerText(p.official_answer)}</div>` : ''}
		              ${p.official_explanation ? `<div class="md" style="margin-top:8px;"><h3>ê³µì‹ í•´ì„¤</h3><div class="hr"></div>${renderMarkdown(stripAnswerEmphasis(p.official_explanation), undefined, 'sanitizeThenParse')}</div>` : ''}
		            </div>`;
		          });
		          detailEl.innerHTML = html || '<div class="muted">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
		          insertBreaksBeforeCircled(detailEl);
		          applyInlineBoldMarkers(detailEl);
		          applyWordMemos(detailEl);
		          typesetMath(detailEl);
		        }

		        function openProblemCollectionInSolve(list, label) {
		          const items = (list || []).map(applyProblemOverrides).filter(p => p && p.qid);
		          if (!items.length) {
		            alert('ëª¨ì•„ë³¼ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
		            return;
		          }
		          const win = document.getElementById('solveWindow');
		          if (win) {
		            win.classList.add('active');
		            win.style.display = '';
		            try { restoreSavedBox(win, 'fmm_ui_solveWindow'); } catch { }
		          }
		          if (typeof startSolveSession === 'function') {
		            const title = String(label || 'ê²€ìƒ‰ ê²°ê³¼').trim();
		            startSolveSession(items, {
		              reviewOnly: true,
		              historyId: 'COLLECT_' + Date.now(),
		              typeTitle: `[ëª¨ì•„ë³´ê¸°] ${title}`
		            });
		          }
		        }

		        if (mode === 'type') {
		          const sec = $$('.type-card')[currentTypeIndex()];
		          const label = currentTypeTitle() || '';
		          if (sec) {
		            textSearch(sec.querySelector('.problem'), `í˜„ì¬ ìœ í˜• Â· í‘œì¤€ë¬¸ì œ Â· ${label}`);
		            textSearch(sec.querySelector('.explanation'), `í˜„ì¬ ìœ í˜• Â· í•´ì„¤ Â· ${label}`);
		            texSearch(sec.querySelector('.problem'), `í˜„ì¬ ìœ í˜• Â· í‘œì¤€ë¬¸ì œ Â· ${label}`);
		            texSearch(sec.querySelector('.explanation'), `í˜„ì¬ ìœ í˜• Â· í•´ì„¤ Â· ${label}`);
		          }

		          // Also search the current type memo (right sidebar) and navigate with highlight.
		          const openTypeMemoAndHighlight = (opts = {}) => {
		            const panel = document.getElementById('typeMemoPanel');
		            const aside = document.getElementById('typeAside') || panel?.closest('.aside') || null;
		            if (aside) {
		              try { aside.style.display = ''; } catch { }
		              try { restoreSavedBox(aside, 'fmm_ui_typeAside'); } catch { }
		              try { aside.classList.remove('min'); } catch { }
		            }
		            if (panel) {
		              try { panel.classList.remove('min'); } catch { }
		              const minBtn = panel.querySelector('button[data-action="min"][data-target="#typeMemoPanel"]');
		              if (minBtn) { minBtn.textContent = 'â€”'; minBtn.title = 'ì ‘ê¸°'; }
		              flashUiElement(panel);
		            }
		            const ta = document.getElementById('typeMemo');
		            if (ta) {
		              const v = String(ta.value || '');
		              const idx = v.toLowerCase().indexOf(needleLower);
		              try { ta.focus(); } catch { }
		              if (idx >= 0 && typeof ta.setSelectionRange === 'function') {
		                try { ta.setSelectionRange(idx, idx + needleLen); } catch { }
		              }
		              flashUiElement(ta);
		            }

		            // Optional: open category list + select a specific memo chunk
		            const memoId = opts.memoId;
		            if (panel && memoId != null) {
		              const listEl = panel.querySelector('.category-list');
		              const showBtn = panel.querySelector('button[data-act="show"]');
		              try {
		                if (listEl && listEl.style.display === 'none') showBtn?.click();
		              } catch { }
		              try { panel._category?.refresh?.(); } catch { }
		              const btn = panel.querySelector(`button.category-memo-btn[data-memo-id="${String(memoId)}"]`);
		              if (btn) {
		                try { btn.click(); } catch { }
		                const ta2 = document.getElementById('typeMemo');
		                if (ta2) {
		                  const vv = String(ta2.value || '');
		                  const j = vv.toLowerCase().indexOf(needleLower);
		                  try { ta2.focus(); } catch { }
		                  if (j >= 0 && typeof ta2.setSelectionRange === 'function') {
		                    try { ta2.setSelectionRange(j, j + needleLen); } catch { }
		                  }
		                  flashUiElement(ta2);
		                }
		              }
		            }
		          };

		          // 1) Current memo textarea (in-progress / currently loaded)
		          try {
		            const ta = document.getElementById('typeMemo');
		            const memoText = String(ta?.value || '');
		            if (memoText && memoText.toLowerCase().includes(needleLower) && total < MAX_RESULTS) {
		              const lower = memoText.toLowerCase();
		              const idx = lower.indexOf(needleLower);
		              const snippetSrc = idx >= 0
		                ? memoText.slice(Math.max(0, idx - 80), Math.min(memoText.length, idx + needleLen + 80))
		                : memoText.slice(0, 200);
		              results.push({
		                kind: 'memo',
		                label: `í˜„ì¬ ìœ í˜• Â· ìœ í˜• ë©”ëª¨ Â· ${label}`,
		                snippet: makeHighlightedSnippet(snippetSrc),
		                actionText: 'ì´ë™',
		                onNav: () => openTypeMemoAndHighlight()
		              });
		              total++;
		            }
		          } catch { }

		          // 2) Category memos for this type (stored chunks)
		          try {
		            if (label) {
			              const key = 'fmm_type_memo_chunks_' + normalizeTitle(label).replace(/\s+/g, '_');
		              const chunks = JSON.parse(store.getItem(key) || '[]');
		              (Array.isArray(chunks) ? chunks : []).forEach(m => {
		                if (total >= MAX_RESULTS) return;
		                const content = String(m?.content || '');
		                if (!content) return;
		                const lower = content.toLowerCase();
		                const idx = lower.indexOf(needleLower);
		                if (idx < 0) return;
		                const snippetSrc = content.slice(Math.max(0, idx - 80), Math.min(content.length, idx + needleLen + 80));
		                const path = String(m?.categoryPath || '').trim();
		                const title = String(m?.title || '').trim();
		                results.push({
		                  kind: 'memo_chunk',
		                  label: `í˜„ì¬ ìœ í˜• Â· ìœ í˜• ë©”ëª¨ Â· ${label} Â· ${path ? path + '/' : ''}${title || '(ì œëª© ì—†ìŒ)'}`,
		                  snippet: makeHighlightedSnippet(snippetSrc),
		                  actionText: 'ì´ë™',
		                  onNav: () => openTypeMemoAndHighlight({ memoId: m?.id })
		                });
		                total++;
		              });
		            }
		          } catch { }
		        } else if (mode === 'problems') {
		          const title = currentTypeTitle() || '';
		          const pool = (currentTypeProblems() || []).map(applyProblemOverrides);
		          if (!pool.length) {
		            results.push({
		              kind: 'problems',
		              label: `í˜„ì¬ ìœ í˜• ë¬¸ì œ${title ? ` Â· ${title}` : ''}`,
		              snippet: '<div class="muted">ë¬¸ì œ JSONì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë¬¸ì œ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”.</div>'
		            });
		            } else {
		              const matches = [];
		              pool.forEach(p => {
		              const hay = `${p.qid}\n${coerceText(p.question_text)}\n${coerceText(p.answer_choices)}\n${coerceText(p.official_explanation)}`;
		              if (hay.toLowerCase().includes(needleLower)) matches.push(p);
		            });
		            const limited = matches.slice(0, MAX_RESULTS);
		            results.push({
		              kind: 'problems',
		              label: `í˜„ì¬ ìœ í˜• ë¬¸ì œ Â· ${title || '(ìœ í˜• ì—†ìŒ)'} Â· ${matches.length}ê°œ`,
		              snippet: matches.length
		                ? '<div class="muted">ê²€ìƒ‰ì— í•´ë‹¹í•˜ëŠ” ë¬¸ì œë§Œ ëª¨ì•„ë´…ë‹ˆë‹¤. (ë¬¸ì œë³µê¸°)</div>'
		                : '<div class="muted">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>',
		              actionText: matches.length ? 'ëª¨ì•„ë³´ê¸°' : null,
		              onNav: matches.length ? () => openProblemCollectionInSolve(limited, title || 'í˜„ì¬ ìœ í˜•') : null
		            });
		            limited.forEach(p => {
		              const hay = `${p.qid}\n${coerceText(p.question_text)}\n${coerceText(p.answer_choices)}\n${coerceText(p.official_explanation)}`;
		              const lower = hay.toLowerCase();
		              const idx = lower.indexOf(needleLower);
		              const snippetSrc = idx >= 0
		                ? hay.slice(Math.max(0, idx - 80), Math.min(hay.length, idx + needleLen + 80))
		                : coerceText(p.question_text).slice(0, 200);
		              results.push({
		                kind: 'problem',
		                label: `ë¬¸ì œ Â· ${p.qid}`,
		                snippet: makeHighlightedSnippet(snippetSrc),
		                actionText: 'ì´ë™',
		                onNav: () => (typeof window.gotoProblemByQid === 'function' ? window.gotoProblemByQid(p.qid) : null)
		              });
		            });
		          }
		        } else if (mode === 'allProblems') {
		          const all = (typeof statsCollectProblems === 'function') ? statsCollectProblems().map(applyProblemOverrides) : [];
		          if (!all.length) {
		            results.push({
		              kind: 'problems',
		              label: 'ì „ì²´ ë¬¸ì œ',
		              snippet: '<div class="muted">ë¬¸ì œ JSONì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë¬¸ì œ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”.</div>'
		            });
		          } else {
		            const matches = [];
		            all.forEach(p => {
		              const hay = `${p.__typeTitle || ''}\n${p.qid}\n${coerceText(p.question_text)}\n${coerceText(p.answer_choices)}\n${coerceText(p.official_explanation)}`;
		              if (hay.toLowerCase().includes(needleLower)) matches.push(p);
		            });
		            const limited = matches.slice(0, MAX_RESULTS);
		            results.push({
		              kind: 'problems',
		              label: `ì „ì²´ ë¬¸ì œ Â· ${matches.length}ê°œ`,
		              snippet: matches.length
		                ? '<div class="muted">ê²€ìƒ‰ì— í•´ë‹¹í•˜ëŠ” ë¬¸ì œë§Œ ëª¨ì•„ë´…ë‹ˆë‹¤. (ë¬¸ì œë³µê¸°)</div>'
		                : '<div class="muted">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>',
		              actionText: matches.length ? 'ëª¨ì•„ë³´ê¸°' : null,
		              onNav: matches.length ? () => openProblemCollectionInSolve(limited, 'ì „ì²´ ë¬¸ì œ') : null
		            });
		            limited.forEach(p => {
		              const hay = `${p.qid}\n${coerceText(p.question_text)}\n${coerceText(p.answer_choices)}\n${coerceText(p.official_explanation)}`;
		              const lower = hay.toLowerCase();
		              const idx = lower.indexOf(needleLower);
		              const snippetSrc = idx >= 0
		                ? hay.slice(Math.max(0, idx - 80), Math.min(hay.length, idx + needleLen + 80))
		                : coerceText(p.question_text).slice(0, 200);
		              results.push({
		                kind: 'problem',
		                label: `ë¬¸ì œ Â· ${p.qid} Â· ${p.__typeTitle || ''}`,
		                snippet: makeHighlightedSnippet(snippetSrc),
		                actionText: 'ì´ë™',
		                onNav: () => (typeof window.gotoProblemByQid === 'function' ? window.gotoProblemByQid(p.qid) : null)
		              });
		            });
		          }
		        } else {
		          (window.fmm_types || []).forEach((t, i) => {
		            const sec = document.getElementById(`type-${i + 1}`);
		            if (!sec) return;
		            if (mode === 'commentary') {
	              textSearch(sec.querySelector('.explanation'), `í•´ì„¤ Â· #${i + 1} ${t.title}`);
	              texSearch(sec.querySelector('.explanation'), `í•´ì„¤ Â· #${i + 1} ${t.title}`);
	            } else { // global
	              textSearch(sec.querySelector('.problem'), `í‘œì¤€ë¬¸ì œ Â· #${i + 1} ${t.title}`);
	              textSearch(sec.querySelector('.explanation'), `í•´ì„¤ Â· #${i + 1} ${t.title}`);
	              texSearch(sec.querySelector('.problem'), `í‘œì¤€ë¬¸ì œ Â· #${i + 1} ${t.title}`);
	              texSearch(sec.querySelector('.explanation'), `í•´ì„¤ Â· #${i + 1} ${t.title}`);
	            }
	          });

          if (mode === 'global') {
            // guide source (collapsed panel holds original)
	            const guideText = sourceEl.value || '';
	            if (new RegExp(escaped, 'i').test(guideText)) {
	              results.push({
	                kind: 'guide',
	                label: 'ê°€ì´ë“œ ì›ë¬¸',
	                snippet: makeHighlightedSnippet(guideText.slice(0, 200)),
	                onNav: () => {
	                  const guidePanel = sourceEl.closest('.panel');
	                  if (guidePanel) guidePanel.classList.remove('collapsed');
	                  sourceEl.focus();
	                }
	              });
	            }

            // global & type memos and chats
	            const pushMisc = (label, text, onNav) => {
	              const hay = String(text || '');
	              if (!new RegExp(escaped, 'i').test(hay)) return;
	              const snippet = makeHighlightedSnippet(hay.slice(0, 200));
	              results.push({ kind: 'memo', label, snippet, onNav });
	            };
            pushMisc('ê¸€ë¡œë²Œ ë©”ëª¨', store.getItem('fmm_memo_global') || '', () => { $('#globalAside').style.display = ''; restoreSavedBox($('#globalAside'), 'fmm_ui_globalAside'); });
            (window.fmm_types || []).forEach(t => {
              const v = store.getItem(`fmm_memo_type_${t.title}`) || '';
              pushMisc(`ìœ í˜• ë©”ëª¨ Â· ${t.title}`, v, () => { $('#typeAside').style.display = ''; restoreSavedBox($('#typeAside'), 'fmm_ui_typeAside'); });
            });
            (JSON.parse(store.getItem('fmm_global_memo_chunks') || '[]') || []).forEach(m => pushMisc(`ì¹´í…Œê³ ë¦¬ ë©”ëª¨(ê¸€ë¡œë²Œ) Â· ${m.categoryPath || '/'}/${m.title || ''}`, m.content || '', () => { }));
            (window.fmm_types || []).forEach(t => {
              const key = 'fmm_type_memo_chunks_' + normalizeTitle(t.title).replace(/\s+/g, '_');
              (JSON.parse(store.getItem(key) || '[]') || []).forEach(m => pushMisc(`ì¹´í…Œê³ ë¦¬ ë©”ëª¨(ìœ í˜•) Â· ${t.title} Â· ${m.title || ''}`, m.content || '', () => { }));
            });
            (LS.get('fmm_chat_rooms', []) || []).forEach(r => { (r.messages || []).forEach((msg) => pushMisc(`ì±„íŒ… Â· ${r.name} Â· ${msg.role}`, msg.content || '', () => { $('#chatWindow').classList.add('active'); restoreSavedBox($('#chatWindow'), 'fmm_ui_chatWindow'); })); });
          }
        }

	        resultsBox.innerHTML = results.length
	          ? results.map((r, idx) => `<div class="panel" style="margin:8px 0;">
	              <div class="muted">${sanitize(r.label)}</div>
	              <div>${r.snippet}</div>
	              ${r.onNav ? `<div style="margin-top:6px;"><button class="btn" data-nav data-idx="${idx}">${sanitize(r.actionText || 'ì´ë™')}</button></div>` : ''}
	            </div>`).join('')
	          : '<div class="muted">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';

	        resultsBox.querySelectorAll('[data-nav][data-idx]').forEach((b) => {
	          b.addEventListener('click', () => {
	            const idx = parseInt(b.getAttribute('data-idx') || '', 10);
	            if (!Number.isFinite(idx) || idx < 0 || idx >= results.length) return;
	            const fn = results[idx] && results[idx].onNav;
	            if (typeof fn === 'function') fn();
	          });
	        });
        } catch (err) {
          const msg = (err && err.message) ? err.message : String(err);
          resultsBox.textContent = `ê²€ìƒ‰ ì˜¤ë¥˜: ${msg}`;
        }
      }

      // === ADD: Similar window logic ==========================================
      const similarWin = $('#similarWindow');
      const similarThreshold = $('#similarThreshold');
      const similarThresholdLabel = $('#similarThresholdLabel');
      const similarMeta = $('#similarMeta');
      const similarList = $('#similarList');
      const similarMemoOwner = $('#similarMemoOwner');
      const similarTagOwner = $('#similarTagOwner');
      let similarFocusQid = null;

      function getSimilarGroupQidsFor(qid) {
        const q = String(qid || '').trim();
        const info = (typeof similarityState !== 'undefined' && similarityState.byQid) ? similarityState.byQid[q] : null;
        if (!info || !info.groupId) return null;
        const g = (similarityState.groups || []).find(x => x && x.id === info.groupId);
        return g && Array.isArray(g.qids) ? g.qids.slice() : null;
      }

      function resolveProblemByQid(qid) {
        const q = String(qid || '').trim();
        if (!q) return null;
        if (problems && problems.byQid && problems.byQid[q]) return applyProblemOverrides(problems.byQid[q]);
        try {
          const all = (typeof statsCollectProblems === 'function') ? statsCollectProblems() : [];
          const found = all.find(p => p && String(p.qid || '') === q);
          return found ? applyProblemOverrides(found) : null;
        } catch {
          return null;
        }
      }

      function renderSimilarWindow() {
        if (!similarWin || !similarList) return;
        const qid = String(similarFocusQid || '').trim();
        if (!qid) {
          similarMeta.textContent = 'ê¸°ì¤€ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.';
          similarList.innerHTML = '<div class="muted">ë¨¼ì € ë¬¸ì œë¥¼ ì„ íƒí•˜ì„¸ìš”.</div>';
          return;
        }
        const th = Number(similarThreshold?.value || 0.78);
        if (similarThresholdLabel) similarThresholdLabel.textContent = th.toFixed(2);

        // Ensure groups exist at least once
        try {
          if (typeof rebuildSimilarityGroupsAndApplyAutoSharing === 'function' && (!similarityState || !similarityState.groups || !similarityState.groups.length)) {
            rebuildSimilarityGroupsAndApplyAutoSharing();
          }
        } catch { }

        const gInfo = (typeof similarityState !== 'undefined' && similarityState.byQid) ? similarityState.byQid[qid] : null;
        const groupNote = gInfo && gInfo.groupId ? ` Â· ìœ ì‚¬ê·¸ë£¹ ${gInfo.groupId} (ëŒ€í‘œ ${gInfo.ownerQid})` : '';
        if (similarMeta) similarMeta.textContent = `ê¸°ì¤€: ${qid}${groupNote}`;
        if (similarMemoOwner) similarMemoOwner.textContent = getMemoOwnerKey(qid);
        if (similarTagOwner) similarTagOwner.textContent = getTagOwnerKey(qid);

        const sims = (typeof findSimilarProblems === 'function') ? findSimilarProblems(qid, th, 120) : [];
        if (!sims.length) {
          similarList.innerHTML = '<div class="muted">ìœ ì‚¬í•œ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
          return;
        }
        similarList.innerHTML = sims.map(r => {
          const p = resolveProblemByQid(r.qid);
          const typeTitle = p?.__typeTitle ? String(p.__typeTitle) : (problems?.qidType?.[r.qid] || '');
          const year = extractYearFromQid(r.qid) || '';
          const tag = getEffectiveTag(r.qid);
          const score = Math.round((r.score || 0) * 100);
          return `<div class="problems-item" data-qid="${sanitize(String(r.qid)).replace(/\"/g, '&quot;')}" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
            <strong>${sanitize(r.qid)}</strong>
            <span class="pill">${score}%</span>
            ${year ? `<span class="pill">${year}</span>` : ''}
            <span class="pill">${tag}</span>
            ${typeTitle ? `<span class="pill">${sanitize(formatTypeLabel(typeTitle))}</span>` : ''}
            <button class="btn" data-act="goto" data-qid="${sanitize(String(r.qid)).replace(/\"/g, '&quot;')}" style="margin-left:auto;">ì´ë™</button>
          </div>`;
        }).join('');
      }

      function openSimilarWindowForQid(qid) {
        const q = String(qid || '').trim();
        if (!q) return;
        similarFocusQid = q;
        if (similarWin) {
          similarWin.classList.add('active');
          similarWin.style.display = '';
          try { restoreSavedBox(similarWin, 'fmm_ui_similarWindow'); } catch { }
        }
        renderSimilarWindow();
      }
      window.openSimilarWindowForQid = openSimilarWindowForQid;

      similarThreshold?.addEventListener('input', renderSimilarWindow);
      $('#similarRefreshBtn')?.addEventListener('click', renderSimilarWindow);
      $('#similarRebuildBtn')?.addEventListener('click', () => {
        try { rebuildSimilarityGroupsAndApplyAutoSharing(); } catch { }
        try { renderProblemsForCurrentType(); } catch { }
        try { if (solveState?.session) renderSolveQuestion(); } catch { }
        renderSimilarWindow();
      });
      similarWin?.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-act]');
        if (btn && btn.dataset.act === 'goto') {
          const qid = btn.dataset.qid || '';
          if (qid && typeof window.gotoProblemByQid === 'function') window.gotoProblemByQid(qid);
          return;
        }
      });

      function applyAutoMemoShareForGroup(baseQid, enable) {
        const groupQids = getSimilarGroupQidsFor(baseQid);
        const targets = groupQids && groupQids.length ? groupQids : [String(baseQid || '')];
        if (!enable) {
          targets.forEach(qid => {
            try { unlinkProblemMemos(qid); } catch { }
            updateProblemState(qid, { memoAutoOff: true, memoLinkMode: 'manual' });
          });
        } else {
          targets.forEach(qid => updateProblemState(qid, { memoAutoOff: false, memoLinkMode: '' }));
          try { rebuildSimilarityGroupsAndApplyAutoSharing(); } catch { }
        }
        try { renderProblemsForCurrentType(); } catch { }
        try { if (solveState?.session) renderSolveQuestion(); } catch { }
      }
      function applyAutoTagShareForGroup(baseQid, enable) {
        const groupQids = getSimilarGroupQidsFor(baseQid);
        const targets = groupQids && groupQids.length ? groupQids : [String(baseQid || '')];
        if (!enable) {
          targets.forEach(qid => {
            const cur = getEffectiveTag(qid);
            updateProblemState(qid, { tag: cur, tagAutoOff: true, tagLink: String(qid), tagLinkMode: 'manual' });
          });
        } else {
          targets.forEach(qid => updateProblemState(qid, { tagAutoOff: false, tagLinkMode: '' }));
          try { rebuildSimilarityGroupsAndApplyAutoSharing(); } catch { }
        }
        try { renderProblemsForCurrentType(); } catch { }
        try { if (solveState?.session) renderSolveQuestion(); } catch { }
      }
      $('#similarAutoMemoOn')?.addEventListener('click', () => { if (similarFocusQid) applyAutoMemoShareForGroup(similarFocusQid, true); renderSimilarWindow(); });
      $('#similarAutoMemoOff')?.addEventListener('click', () => { if (similarFocusQid) applyAutoMemoShareForGroup(similarFocusQid, false); renderSimilarWindow(); });
      $('#similarAutoTagOn')?.addEventListener('click', () => { if (similarFocusQid) applyAutoTagShareForGroup(similarFocusQid, true); renderSimilarWindow(); });
      $('#similarAutoTagOff')?.addEventListener('click', () => { if (similarFocusQid) applyAutoTagShareForGroup(similarFocusQid, false); renderSimilarWindow(); });

      $('#similarCollectBtn')?.addEventListener('click', () => {
        if (!similarFocusQid) return;
        const th = Number(similarThreshold?.value || 0.78);
        const sims = (typeof findSimilarProblems === 'function') ? findSimilarProblems(similarFocusQid, th, 200) : [];
        const qids = [String(similarFocusQid)].concat(sims.map(x => x.qid));
        const uniq = Array.from(new Set(qids)).filter(Boolean);
        const items = uniq.map(resolveProblemByQid).filter(Boolean);
        if (!items.length) return;
        if (typeof window.openCollectionInSolve === 'function') {
          window.openCollectionInSolve(items, `[ìœ ì‚¬] ${similarFocusQid}`);
        } else if (typeof startSolveSession === 'function') {
          startSolveSession(items, { reviewOnly: true, historyId: 'COLLECT_' + Date.now(), typeTitle: `[ìœ ì‚¬] ${similarFocusQid}` });
        }
      });

      // === NEW: shared helpers (image paste, answer parsing, latex copy) =======
	      function insertAtCursor(el, text) {
	        if (!el) return;
	        const start = el.selectionStart ?? el.value.length;
	        const end = el.selectionEnd ?? el.value.length;
	        const before = el.value.slice(0, start);
	        const after = el.value.slice(end);
	        el.value = before + text + after;
	        const pos = start + text.length;
	        if (el.setSelectionRange) el.setSelectionRange(pos, pos);
	        el.dispatchEvent(new Event('input', { bubbles: true }));
	      }

		      function isTextEditable(el) {
		        if (!el) return false;
		        const tag = (el.tagName || '').toUpperCase();
		        if (tag === 'TEXTAREA') return true;
		        if (tag === 'INPUT') {
		          const type = String(el.type || '').toLowerCase();
		          return !type || type === 'text' || type === 'search';
		        }
		        return false;
		      }

		      // === NEW: API key rolling + multi-endpoint compatibility (general-test parity) ===
		      function parseApiKeyList(raw) {
		        const s = String(raw || '').trim();
		        if (!s) return [];
		        // Support JSON array: ["k1","k2"]
		        try {
		          const parsed = JSON.parse(s);
		          if (Array.isArray(parsed)) return parsed.map(x => String(x || '').trim()).filter(Boolean);
		        } catch { }
		        return s.split(/[\r\n,;|\s]+/).map(k => k.trim()).filter(Boolean);
		      }
			      function resolveEndpointTemplate(endpoint, model) {
			        const url = String(endpoint || '').trim();
			        const m = String(model || '').trim();
			        return url.replaceAll('{model}', m).replaceAll('{{MODEL}}', m);
			      }
				      function normalizeOpenAiCompatEndpoint(endpoint) {
				        const raw = String(endpoint || '').trim();
				        if (!raw) return raw;
				        const lower = raw.toLowerCase();
				        if (lower.includes('/chat/completions')) return raw;
				        if (/\/v1\/[^/]+\/?$/i.test(raw)) return raw.replace(/\/?$/i, '') + '/chat/completions';
				        if (/\/v1\/?$/i.test(raw)) return raw.replace(/\/v1\/?$/i, '/v1/chat/completions');
				        if (/\/openai\/?$/i.test(raw)) return raw.replace(/\/openai\/?$/i, '/openai/chat/completions');
				        return raw;
				      }
			      function detectApiModeFromEndpoint(endpoint) {
			        const lower = String(endpoint || '').toLowerCase();
			        if (lower.includes(':generatecontent') || lower.includes(':streamgeneratecontent')) return 'gemini_generatecontent';
			        if (lower.includes('/ai/run/')) return 'cf_ai_run';
			        if (lower.includes('/ai/v1/responses')) return 'cf_responses';
			        return 'openai_chat_completions';
			      }
		      function withKeyParam(u, key) {
		        if (!key) return u;
		        try {
		          const parsed = new URL(u);
		          parsed.searchParams.set('key', key);
		          return parsed.toString();
		        } catch {
		          if (!u) return u;
		          const sep = u.includes('?') ? '&' : '?';
		          return `${u}${sep}key=${encodeURIComponent(key)}`;
		        }
		      }
		      function toGeminiPayload(msgs) {
		        const systemParts = [];
		        const contents = [];
		        for (const m of (msgs || [])) {
		          const role = String(m?.role || '').toLowerCase();
		          const text = extractTextContent(m?.content ?? '').toString();
		          if (!text) continue;
		          if (role === 'system' || role === 'developer') {
		            systemParts.push(text);
		            continue;
		          }
		          const gemRole = (role === 'assistant' || role === 'model') ? 'model' : 'user';
		          contents.push({ role: gemRole, parts: [{ text }] });
		        }
		        const systemInstruction = systemParts.length ? { parts: [{ text: systemParts.join('\n\n') }] } : null;
		        if (!contents.length && systemInstruction) {
		          contents.push({ role: 'user', parts: [{ text: systemParts.join('\n\n') }] });
		          return { contents, systemInstruction: null };
		        }
		        return { contents, systemInstruction };
		      }
			      function extractTextContent(content) {
			        if (typeof content === 'string') return content;
			        if (Array.isArray(content)) return content.map(part => coerceText(part?.text ?? part?.content ?? part)).join('');
			        return coerceText(content);
			      }
			      function adaptMessagesNoSystem(messages) {
			        const systemParts = [];
			        const kept = [];
			        for (const m of (messages || [])) {
			          const role = String(m?.role || '').toLowerCase();
			          const text = extractTextContent(m?.content ?? '').toString();
			          if (!text) continue;
			          if (role === 'system' || role === 'developer') systemParts.push(text);
			          else kept.push({ ...m, content: text });
			        }
			        if (!systemParts.length) return kept;
			        const prefix = `### INSTRUCTIONS ###\n${systemParts.join('\n\n')}\n\n`;
			        const firstUserIdx = kept.findIndex(x => String(x?.role || '').toLowerCase() === 'user');
			        if (firstUserIdx >= 0) {
			          kept[firstUserIdx].content = prefix + (kept[firstUserIdx].content || '');
			          return kept;
			        }
			        return [{ role: 'user', content: prefix.trim() }, ...kept];
			      }
		      function extractOpenAiChatText(data) {
		        try {
		          const msg = data?.choices?.[0]?.message;
		          const c1 = msg?.content;
		          if (typeof c1 === 'string') return c1;
		          if (Array.isArray(c1)) return c1.map(p => p?.text || p?.content || '').filter(Boolean).join('');
		          const c2 = data?.choices?.[0]?.text;
		          if (typeof c2 === 'string') return c2;
		        } catch { }
		        return '';
		      }
		      function extractGeminiText(data) {
		        try {
		          const parts = data?.candidates?.[0]?.content?.parts || [];
		          return parts.map(p => p?.text || '').filter(Boolean).join('');
		        } catch { }
		        return '';
		      }
		      function extractGeminiStreamText(text) {
		        const raw = String(text || '');
		        if (!raw) return '';
		        // SSE-like: lines prefixed with "data: {json}"
		        const lines = raw.split(/\r?\n/);
		        let out = '';
		        for (const line of lines) {
		          const t = line.trim();
		          if (!t.toLowerCase().startsWith('data:')) continue;
		          const payload = t.slice(5).trim();
		          if (!payload || payload === '[DONE]') continue;
		          try {
		            const obj = JSON.parse(payload);
		            const chunk = extractGeminiText(obj);
		            if (chunk) out += chunk;
		          } catch { }
		        }
		        return out;
		      }
		      function toCfInputText(messages) {
		        const parts = [];
		        for (const m of (messages || [])) {
		          const role = String(m?.role || '').toLowerCase();
		          const text = extractTextContent(m?.content).trim();
		          if (!text) continue;
		          if (role === 'system' || role === 'developer') parts.push(`[System]\n${text}`);
		          else if (role === 'assistant') parts.push(`[Assistant]\n${text}`);
		          else parts.push(`[User]\n${text}`);
		        }
		        return parts.join('\n\n').trim();
		      }
		      function extractCfResponseText(data, apiMode) {
		        if (apiMode === 'cf_ai_run') {
		          return (
		            data?.result?.response ||
		            data?.result?.output_text ||
		            data?.result?.output?.[0]?.content?.[0]?.text ||
		            data?.result?.output?.[0]?.text ||
		            data?.result?.choices?.[0]?.message?.content ||
		            ''
		          );
		        }
		        return (
		          data?.result?.response ||
		          data?.result?.output_text ||
		          data?.output_text ||
		          data?.response?.output_text ||
		          data?.response?.output?.[0]?.content?.[0]?.text ||
		          data?.result?.output?.[0]?.content?.[0]?.text ||
		          data?.choices?.[0]?.message?.content ||
		          ''
		        );
		      }
		      function parseRetryAfterMs(res) {
		        try {
		          const v = res?.headers?.get?.('retry-after');
		          if (!v) return null;
		          const sec = parseFloat(v);
		          if (Number.isFinite(sec)) return Math.max(0, sec * 1000);
		        } catch { }
		        return null;
		      }
		      async function fetchJsonOrText(url, { headers, body, timeoutMs }) {
		        const controller = new AbortController();
		        const to = Number.isFinite(timeoutMs) ? timeoutMs : 0;
		        let t = null;
		        if (to > 0) t = setTimeout(() => { try { controller.abort(); } catch { } }, to);
		        try {
		          const res = await fetch(url, {
		            method: 'POST',
		            headers: headers || {},
		            body: JSON.stringify(body || {}),
		            signal: controller.signal
		          });
		          let text = '';
		          try { text = await res.text(); } catch { text = ''; }
		          let data = null;
		          if (text) {
		            try { data = JSON.parse(text); } catch { data = null; }
		          }
		          return { res, text, data };
		        } finally {
		          if (t) clearTimeout(t);
		        }
		      }
		      function loadKeyCooldownMap(lsKey) {
		        const raw = LS.get(lsKey, {});
		        return (raw && typeof raw === 'object') ? raw : {};
		      }
		      function saveKeyCooldownMap(lsKey, map) {
		        LS.set(lsKey, map && typeof map === 'object' ? map : {});
		      }
		      function getCursor(lsKey) {
		        const n = parseInt(LS.get(lsKey, 0), 10);
		        return Number.isFinite(n) ? n : 0;
		      }
		      function setCursor(lsKey, n) {
		        LS.set(lsKey, Number.isFinite(n) ? n : 0);
		      }
		      async function sleepInterruptible(ms, shouldAbort) {
		        const total = Math.max(0, Number(ms) || 0);
		        const end = Date.now() + total;
		        while (Date.now() < end) {
		          if (typeof shouldAbort === 'function' && shouldAbort()) throw new Error('ì‚¬ìš©ì ì¤‘ë‹¨');
		          const slice = Math.min(250, end - Date.now());
		          await new Promise(r => setTimeout(r, slice));
		        }
		      }
		      async function pickApiKey(keys, { cursorKey, cooldownKey, shouldAbort }) {
		        const list = Array.isArray(keys) ? keys : [];
		        if (!list.length) return { key: '', idx: -1, waitMs: 0 };
		        const now = Date.now();
		        const cooldowns = loadKeyCooldownMap(cooldownKey);
		        // purge stale/unknown keys
		        Object.keys(cooldowns).forEach(k => {
		          const until = Number(cooldowns[k]);
		          if (!Number.isFinite(until) || until <= now || !list.includes(k)) delete cooldowns[k];
		        });
		        saveKeyCooldownMap(cooldownKey, cooldowns);
		        const start = getCursor(cursorKey) % list.length;
		        for (let off = 0; off < list.length; off++) {
		          const idx = (start + off) % list.length;
		          const key = list[idx];
		          const until = Number(cooldowns[key]);
		          if (!Number.isFinite(until) || until <= now) {
		            setCursor(cursorKey, (idx + 1) % list.length);
		            return { key, idx, waitMs: 0 };
		          }
		        }
		        // all keys cooling down -> wait for earliest (clamped)
		        let bestIdx = start;
		        let bestUntil = Infinity;
		        for (let off = 0; off < list.length; off++) {
		          const idx = (start + off) % list.length;
		          const key = list[idx];
		          const until = Number(cooldowns[key]);
		          if (Number.isFinite(until) && until < bestUntil) { bestUntil = until; bestIdx = idx; }
		        }
		        const waitMs = bestUntil !== Infinity ? Math.max(0, bestUntil - now) : 0;
		        if (waitMs > 0) await sleepInterruptible(waitMs, shouldAbort);
		        setCursor(cursorKey, (bestIdx + 1) % list.length);
		        return { key: list[bestIdx], idx: bestIdx, waitMs };
		      }
		      function wrapWithProxyIfNeeded(proxyUrl, requestUrl, headers, body) {
		        const p = String(proxyUrl || '').trim();
		        if (!p) return { url: requestUrl, headers, body };
		        const targetUrl = requestUrl;
		        const encoded = encodeURIComponent(targetUrl);
		        if (p.includes('{url}') || p.includes('{{URL}}')) {
		          return { url: p.replaceAll('{url}', encoded).replaceAll('{{URL}}', encoded), headers, body };
		        }
		        return {
		          url: p,
		          headers: { 'Content-Type': 'application/json' },
		          body: { url: targetUrl, method: 'POST', headers, body }
		        };
		      }
				      async function callLlmApiWithKeyRoll({ endpoint, proxyUrl, apiKeysRaw, model, messages, cursorKey, cooldownKey, timeoutMs, temperature, shouldAbort, bypassSystemRole }) {
				        const m = String(model || '').trim();
				        const url0 = resolveEndpointTemplate(endpoint, m);
				        let url = url0;
				        if (!url) throw new Error('Endpoint URL ì—†ìŒ');
				        let keys = parseApiKeyList(apiKeysRaw);
				        const apiMode = detectApiModeFromEndpoint(url);
				        if (apiMode === 'openai_chat_completions') url = normalizeOpenAiCompatEndpoint(url);
				        let finalMessages = Array.isArray(messages) ? messages.slice() : [];
				        if (bypassSystemRole) finalMessages = adaptMessagesNoSystem(finalMessages);
				        const errors = [];
				        const attempts = Math.max(1, keys.length || 0);
			        for (let attempt = 0; attempt < attempts; attempt++) {
			          if (typeof shouldAbort === 'function' && shouldAbort()) throw new Error('ì‚¬ìš©ì ì¤‘ë‹¨');
			          const pick = keys.length ? await pickApiKey(keys, { cursorKey, cooldownKey, shouldAbort }) : { key: '', idx: -1, waitMs: 0 };
		          const key = pick.key;
		          const headersBase = { 'Content-Type': 'application/json' };
			          let headers = { ...headersBase };
			          let body = null;
			          let requestUrl = url;
			          if (apiMode === 'gemini_generatecontent') {
			            requestUrl = key ? withKeyParam(requestUrl, key) : requestUrl;
			            const payload = toGeminiPayload(finalMessages);
			            const generationConfig = {};
			            if (Number.isFinite(temperature)) generationConfig.temperature = temperature;
			            body = { contents: payload.contents, generationConfig };
			            if (payload.systemInstruction) body.systemInstruction = payload.systemInstruction;
			          } else if (apiMode === 'cf_ai_run') {
			            if (key) headers = { ...headers, 'Authorization': `Bearer ${key}` };
			            body = { input: toCfInputText(finalMessages) };
			            if (Number.isFinite(temperature)) body.temperature = temperature;
			          } else if (apiMode === 'cf_responses') {
			            if (key) headers = { ...headers, 'Authorization': `Bearer ${key}` };
			            body = { model: m || 'gpt-4o-mini', input: toCfInputText(finalMessages) };
			            if (Number.isFinite(temperature)) body.temperature = temperature;
			          } else {
			            if (key) headers = { ...headers, 'Authorization': `Bearer ${key}` };
			            body = { model: m || 'gpt-4o-mini', messages: finalMessages };
			            if (Number.isFinite(temperature)) body.temperature = temperature;
			          }
		          const wrapped = wrapWithProxyIfNeeded(proxyUrl, requestUrl, headers, body);
		          try {
		            const { res, text, data } = await fetchJsonOrText(wrapped.url, { headers: wrapped.headers, body: wrapped.body, timeoutMs });
		            if (!res.ok) {
		              const code = res.status;
		              const briefBody = (text || '').slice(0, 300);
		              if (keys.length && (code === 429 || code === 408 || code === 409) && key) {
		                const ra = parseRetryAfterMs(res);
		                const coolMs = Number.isFinite(ra) ? ra : 15000;
		                const m = loadKeyCooldownMap(cooldownKey);
		                m[key] = Date.now() + Math.max(3000, coolMs);
		                saveKeyCooldownMap(cooldownKey, m);
		              }
		              if (keys.length && (code === 401 || code === 403) && key) {
		                // likely invalid key: drop from this call's rotation
		                keys = keys.filter(k => k !== key);
		              }
		              errors.push(`HTTP ${code}${briefBody ? ` â€” ${briefBody}` : ''}`);
		              continue;
		            }
		            let contentText = '';
		            if (apiMode === 'gemini_generatecontent') {
		              contentText = extractGeminiText(data) || '';
		              if (!contentText) contentText = extractGeminiStreamText(text) || '';
		            } else if (apiMode === 'cf_ai_run' || apiMode === 'cf_responses') {
		              contentText = extractCfResponseText(data, apiMode) || '';
		            } else {
		              contentText = extractOpenAiChatText(data) || '';
		            }
		            if (!contentText) contentText = text || (data ? JSON.stringify(data) : '');
		            return { apiMode, data, text, contentText, keyUsed: key };
		          } catch (err) {
		            errors.push(err && err.message ? err.message : String(err));
		            continue;
		          }
		        }
		        throw new Error(errors.length ? errors.join(' / ') : 'API í˜¸ì¶œ ì‹¤íŒ¨');
		      }

		      // === ADD: lightweight ASCII math -> LaTeX converter ======================
		      // Targeted for simple expressions like: 3*3, 4/3, a=sqrt(3)
		      function tokenizeAsciiMath(expr) {
		        const s = String(expr || '').trim();
		        const tokens = [];
	        let i = 0;
	        while (i < s.length) {
	          const ch = s[i];
	          if (/\s/.test(ch)) { i++; continue; }
	          if (/[0-9]/.test(ch) || (ch === '.' && /[0-9]/.test(s[i + 1] || ''))) {
	            let j = i + 1;
	            while (j < s.length && /[0-9]/.test(s[j])) j++;
	            if (s[j] === '.' && /[0-9]/.test(s[j + 1] || '')) {
	              j++;
	              while (j < s.length && /[0-9]/.test(s[j])) j++;
	            }
	            tokens.push({ type: 'num', value: s.slice(i, j) });
	            i = j;
	            continue;
	          }
	          if (/[A-Za-z]/.test(ch)) {
	            let j = i + 1;
	            while (j < s.length && /[A-Za-z0-9]/.test(s[j])) j++;
	            tokens.push({ type: 'id', value: s.slice(i, j) });
	            i = j;
	            continue;
	          }
	          if (ch === ',') { tokens.push({ type: 'comma', value: ',' }); i++; continue; }
	          if ('+-*/^=()'.includes(ch)) { tokens.push({ type: ch, value: ch }); i++; continue; }
	          // unsupported character: bail by keeping raw
	          tokens.push({ type: 'char', value: ch });
	          i++;
	        }
	        return tokens;
	      }

	      function asciiToLatex(expr) {
	        try {
	          const tokens = tokenizeAsciiMath(expr);
	          if (!tokens.length) return '';
	          let pos = 0;
	          const peek = () => tokens[pos] || null;
	          const next = () => tokens[pos++] || null;
	          const match = (type) => {
	            const t = peek();
	            if (!t) return false;
	            if (t.type === type) { pos++; return true; }
	            return false;
	          };
	          const expect = (type) => {
	            if (!match(type)) throw new Error('parse');
	          };

	          const idToLatex = (name) => {
	            const key = String(name || '');
	            const lower = key.toLowerCase();
	            const map = {
	              pi: '\\pi',
	              theta: '\\theta',
	              mu: '\\mu',
	              omega: '\\omega',
	              ohm: '\\Omega'
	            };
	            return map[lower] || key;
	          };

	          const prec = (node) => {
	            if (!node) return 0;
	            if (node.type === 'bin') {
	              if (node.op === '=') return 1;
	              if (node.op === '+' || node.op === '-') return 2;
	              if (node.op === '*' || node.op === '/') return 3;
	              if (node.op === '^') return 4;
	            }
	            if (node.type === 'unary') return 5;
	            return 6;
	          };
	          const wrap = (child, parentPrec) => {
	            const s = toLatex(child, parentPrec);
	            return prec(child) < parentPrec ? `\\left(${s}\\right)` : s;
	          };
	          const toLatex = (node, parentPrec = 0) => {
	            if (!node) return '';
	            if (node.type === 'num') return String(node.value || '');
	            if (node.type === 'id') return idToLatex(node.value);
	            if (node.type === 'group') return `\\left(${toLatex(node.value, 0)}\\right)`;
	            if (node.type === 'raw') return String(node.value || '');
	            if (node.type === 'func') {
	              const name = String(node.name || '').toLowerCase();
	              if (name === 'sqrt') return `\\sqrt{${toLatex(node.arg, 0)}}`;
	              return `${idToLatex(node.name)}\\left(${toLatex(node.arg, 0)}\\right)`;
	            }
	            if (node.type === 'unary') {
	              const inner = wrap(node.value, prec(node));
	              return node.op === '-' ? `-${inner}` : inner;
	            }
	            if (node.type === 'bin') {
	              const p = prec(node);
	              if (node.op === '/') return `\\frac{${toLatex(node.left, 0)}}{${toLatex(node.right, 0)}}`;
	              if (node.op === '^') {
	                const base = (prec(node.left) < p) ? `\\left(${toLatex(node.left, 0)}\\right)` : toLatex(node.left, p);
	                const exp = toLatex(node.right, 0);
	                return `${base}^{${exp}}`;
	              }
	              const opLatex = node.op === '*' ? '\\times' : node.op;
	              const left = wrap(node.left, p);
	              const right = wrap(node.right, p);
	              const s = `${left} ${opLatex} ${right}`;
	              return p < parentPrec ? `\\left(${s}\\right)` : s;
	            }
	            return '';
	          };

	          function parseExpression() { return parseEquality(); }
	          function parseEquality() {
	            let left = parseAddSub();
	            while (match('=')) {
	              const right = parseAddSub();
	              left = { type: 'bin', op: '=', left, right };
	            }
	            return left;
	          }
	          function parseAddSub() {
	            let left = parseMulDiv();
	            while (true) {
	              if (match('+')) { const right = parseMulDiv(); left = { type: 'bin', op: '+', left, right }; continue; }
	              if (match('-')) { const right = parseMulDiv(); left = { type: 'bin', op: '-', left, right }; continue; }
	              break;
	            }
	            return left;
	          }
	          function parseMulDiv() {
	            let left = parsePow();
	            while (true) {
	              if (match('*')) { const right = parsePow(); left = { type: 'bin', op: '*', left, right }; continue; }
	              if (match('/')) { const right = parsePow(); left = { type: 'bin', op: '/', left, right }; continue; }
	              break;
	            }
	            return left;
	          }
	          function parsePow() {
	            let left = parseUnary();
	            if (match('^')) {
	              const right = parsePow(); // right-associative
	              left = { type: 'bin', op: '^', left, right };
	            }
	            return left;
	          }
	          function parseUnary() {
	            if (match('+')) return parseUnary();
	            if (match('-')) return { type: 'unary', op: '-', value: parseUnary() };
	            return parsePrimary();
	          }
	          function parsePrimary() {
	            const t = peek();
	            if (!t) return { type: 'raw', value: '' };
	            if (match('num')) return { type: 'num', value: t.value };
	            if (match('id')) {
	              const name = String(t.value || '');
	              if (name.toLowerCase() === 'sqrt') {
	                if (match('(')) {
	                  const inner = parseExpression();
	                  expect(')');
	                  return { type: 'func', name: 'sqrt', arg: inner };
	                }
	                const inner = parsePrimary();
	                return { type: 'func', name: 'sqrt', arg: inner };
	              }
	              return { type: 'id', value: name };
	            }
	            if (match('(')) {
	              const inner = parseExpression();
	              expect(')');
	              return { type: 'group', value: inner };
	            }
	            // unknown token: consume and keep raw
	            next();
	            return { type: 'raw', value: t.value || '' };
	          }

	          const ast = parseExpression();
	          // If we couldn't consume tokens cleanly, fall back to empty (avoid mangling).
	          if (tokens.slice(pos).some(t => t && t.type === 'char')) return '';
	          return toLatex(ast, 0).trim();
	        } catch {
	          return '';
	        }
	      }

	      function autoAsciiMathTransform(text) {
	        const s = String(text || '');
	        if (!s) return s;
		        const lines = s.replace(/\r\n/g, '\n').split('\n');
		        let inFence = false;
		        const fenceRe = /^\s*(```+|~~~+)/;

		        // Inline transform: render-time only, does not mutate saved text.
		        // Goal: make snippets like "p=2*3/k" or "2/3" render as LaTeX even inside normal sentences.
		        function convertInlineAsciiMath(line) {
		          const t = String(line || '');
		          if (!t.trim()) return t;
		          // Avoid interfering with already-authored math blocks (partial parsing is complex).
		          if (t.indexOf('$') !== -1 || t.indexOf('\\(') !== -1 || t.indexOf('\\[') !== -1) return t;
		          // Match candidate ASCII-math snippets (kept conservative to avoid mangling URLs / dates).
		          const exprRe = /(^|[^0-9A-Za-z_])([0-9A-Za-z][0-9A-Za-z._+*\/^=()_-]{2,})(?=$|[^0-9A-Za-z_])/g;
		          return t.replace(exprRe, (m, pre, expr) => {
		            const raw = String(expr || '');
		            if (!raw) return m;
		            if (raw.includes('://') || raw.includes('www.') || raw.includes('@')) return m;
		            if (/^\d{4}\/\d{1,2}\/\d{1,2}$/.test(raw)) return m; // date-like
		            if (!(/[=+*/^]/.test(raw) || /\bsqrt\b/i.test(raw))) return m;
		            // Only auto-convert when it's "math-like" enough (digits or an equality).
		            if (!(/\d/.test(raw) || raw.includes('='))) return m;
		            if (raw.includes('++') || raw.includes('--')) return m;
		            const latex = asciiToLatex(raw);
		            if (!latex || latex === raw) return m;
		            return `${pre}$${latex}$`;
		          });
		        }

	        return lines.map(line => {
	          const t = String(line || '');
	          const trim = t.trim();
	          const fm = trim.match(fenceRe);
	          if (fm) { inFence = !inFence; return t; }
	          if (inFence) return t;
	          if (!trim) return t;

	          // 1) Whole-line conversion for clean ASCII expressions (keeps old behavior).
	          if (trim.indexOf('$') === -1 && trim.indexOf('\\(') === -1 && trim.indexOf('\\[') === -1) {
	            if (!/[ê°€-í£]/.test(trim) && !/^[-*]\s+/.test(trim)) {
	              if ((/[=+*/^]/.test(trim) || /\bsqrt\b/i.test(trim)) && /^[0-9A-Za-z.\s+\-*/^=()_]+$/.test(trim)) {
	                const latex = asciiToLatex(trim);
	                if (latex && latex !== trim) {
	                  const prefix = (t.match(/^\s*/) || [''])[0];
	                  return `${prefix}$${latex}$`;
	                }
	              }
	            }
		          }

		          // 2) Inline ASCII-math conversion inside normal sentences (e.g., "... p=2*3/k ...", "... 2/3 ...").
		          return convertInlineAsciiMath(t);
		        }).join('\n');
		      }

	      // === ADD: LaTeX tools window ============================================
	      (function initLatexToolWindow() {
	        const win = $('#latexToolWindow');
	        const toggleBtn = $('#latexToolToggleBtn');
	        if (!win || !toggleBtn) return;

	        const input = $('#latexToolInput');
	        const preview = $('#latexToolPreview');
	        const delimiter = $('#latexToolDelimiter');
	        const insertBtn = $('#latexToolInsert');
	        const clearBtn = $('#latexToolClear');
	        const tools = $('#latexToolButtons');
	        const autoToggle = $('#autoAsciiMathToggle');
	        const selConvertBtn = $('#latexToolConvertSelection');
	        const asciiIn = $('#asciiMathInput');
	        const asciiConvertBtn = $('#asciiMathConvert');
	        const asciiInsertBtn = $('#asciiMathInsert');
	        const asciiOut = $('#asciiMathOutput');

	        let lastTarget = null;

	        function normalizeToolTex(raw) {
	          let t = String(raw || '').replace(/\r\n/g, '\n').trim();
	          if (!t) return '';
	          // Users often paste or type with extra escaping (e.g., "\\frac" or "\\[...\\]").
	          // Make the tool forgiving by normalizing to single-backslash TeX for preview/insertion.
	          if (t.startsWith('\\\\[')) t = '\\[' + t.slice(3);
	          if (t.endsWith('\\\\]')) t = t.slice(0, -3) + '\\]';
	          if (t.startsWith('\\\\(')) t = '\\(' + t.slice(3);
	          if (t.endsWith('\\\\)')) t = t.slice(0, -3) + '\\)';
	          t = t.replace(/\\\\(?=[A-Za-z])/g, '\\'); // \\frac -> \frac
	          t = t.replace(/\\\[\\\[/g, '\\[').replace(/\\\]\\\]/g, '\\]');
	          t = t.replace(/\\\(\\\(/g, '\\(').replace(/\\\)\\\)/g, '\\)');
	          return t;
	        }

	        function wrapWithDelimiter(tex, kind) {
	          const t = normalizeToolTex(tex);
	          if (!t) return '';
	          // If user already wrapped with a supported delimiter, don't double-wrap.
	          // (Common when pasting full TeX like \[\frac{2}{3}\] into the tool.)
	          const alreadyWrapped =
	            (t.startsWith('$$') && t.endsWith('$$') && t.length > 4) ||
	            (t.startsWith('$') && t.endsWith('$') && !t.startsWith('$$') && !t.endsWith('$$') && t.length > 2) ||
	            (t.startsWith('\\[') && t.endsWith('\\]') && t.length > 4) ||
	            (t.startsWith('\\(') && t.endsWith('\\)') && t.length > 4) ||
	            (t.startsWith('\\\\[') && t.endsWith('\\\\]') && t.length > 6) ||
	            (t.startsWith('\\\\(') && t.endsWith('\\\\)') && t.length > 6);
	          if (alreadyWrapped) return t;

	          const d = kind || (delimiter ? delimiter.value : '$');
	          if (d === '$$') return `$$${t}$$`;
	          // Important: preview (and MathJax) expects single-backslash delimiters.
	          if (d === '\\\\[') return `\\[${t}\\]`;
	          if (d === '\\\\(') return `\\(${t}\\)`;
	          return `$${t}$`;
	        }

	        function captureTarget() {
	          const ae = document.activeElement;
	          if (isTextEditable(ae) && !win.contains(ae)) lastTarget = ae;
	        }

	        document.addEventListener('focusin', (ev) => {
	          const el = ev.target;
	          if (isTextEditable(el) && !win.contains(el)) lastTarget = el;
	        });

	        function getTarget() {
	          if (lastTarget && document.contains(lastTarget)) return lastTarget;
	          const ae = document.activeElement;
	          if (isTextEditable(ae) && !win.contains(ae)) return ae;
	          return null;
	        }

	        function updatePreview() {
	          if (!preview) return;
	          const tex = input ? (input.value || '') : '';
	          preview.textContent = wrapWithDelimiter(tex);
	          try { typesetMath(preview); } catch { }
	        }

	        function insertTemplate(el, tpl) {
	          if (!el) return;
	          const start = el.selectionStart ?? el.value.length;
	          const end = el.selectionEnd ?? el.value.length;
	          const before = el.value.slice(0, start);
	          const after = el.value.slice(end);
	          el.value = before + tpl + after;
	          let pos = start + tpl.length;
	          const hole = tpl.indexOf('{}');
	          if (hole !== -1) pos = start + hole + 1;
	          if (el.setSelectionRange) el.setSelectionRange(pos, pos);
	          el.dispatchEvent(new Event('input', { bubbles: true }));
	        }

	        function buildToolButtons() {
	          if (!tools || tools._built) return;
	          tools._built = true;
	          const defs = [
	            { label: 'aâ„b', ins: '\\frac{}{}' },
	            { label: 'âˆš', ins: '\\sqrt{}' },
	            { label: 'x^y', ins: '^{}' },
	            { label: 'xáµ¢', ins: '_{}' },
	            { label: '|x|', ins: '\\abs{}' },
	            { label: '( )', ins: '\\paren{}' },
	            { label: '[ ]', ins: '\\bracket{}' },
	            { label: '{ }', ins: '\\set{}' },
	            { label: 'âŒˆxâŒ‰', ins: '\\ceil{}' },
	            { label: 'âŒŠxâŒ‹', ins: '\\floor{}' },
	            { label: 'Ã—', ins: '\\times ' },
	            { label: 'Â·', ins: '\\cdot ' },
	            { label: 'Â±', ins: '\\pm ' },
	            { label: 'â‰¤', ins: '\\le ' },
	            { label: 'â‰¥', ins: '\\ge ' },
	            { label: 'Ï€', ins: '\\pi' },
	            { label: 'Î¼', ins: '\\mu' },
	            { label: 'Î©', ins: '\\Omega' },
	            { label: 'Î£', ins: '\\sum_{}^{}' },
	            { label: 'âˆ«', ins: '\\int_{}^{}' },
	            { label: 'â†’', ins: '\\to ' },
	            { label: 'lim', ins: '\\lim_{}' },
	            { label: 'd', ins: '\\dd ' },
	            { label: 'unit', ins: '\\unit{}' },
	            { label: 'text', ins: '\\text{}' },
	            { label: 'test', ins: '\\test{}' },
	            { label: 'red', ins: '\\color{red}{}' }
	          ];
	          defs.forEach(d => {
	            const b = document.createElement('button');
	            b.className = 'btn';
	            b.type = 'button';
	            b.textContent = d.label;
	            b.addEventListener('click', () => insertTemplate(input, d.ins));
	            tools.appendChild(b);
	          });
	        }

	        toggleBtn.addEventListener('click', () => {
	          win.classList.toggle('active');
	          if (win.classList.contains('active')) {
	            restoreSavedBox(win, 'fmm_ui_latexToolWindow');
	            captureTarget();
	            buildToolButtons();
	            if (autoToggle && typeof UI !== 'undefined') autoToggle.checked = !!UI.autoAsciiMath;
	            updatePreview();
	            try { input && input.focus(); } catch { }
	          }
	        });

	        input?.addEventListener('input', updatePreview);
	        delimiter?.addEventListener('change', updatePreview);

	        clearBtn?.addEventListener('click', () => {
	          if (!input) return;
	          input.value = '';
	          updatePreview();
	        });

	        autoToggle?.addEventListener('change', () => {
	          if (typeof UI === 'undefined') return;
	          UI.autoAsciiMath = !!autoToggle.checked;
	          UI.save();
	          statusEl.textContent = UI.autoAsciiMath ? 'ë©”ëª¨ ìë™ë³€í™˜(í‘œì‹œ) ON' : 'ë©”ëª¨ ìë™ë³€í™˜(í‘œì‹œ) OFF';
	        });

	        insertBtn?.addEventListener('click', () => {
	          const t = getTarget();
	          if (!t) { alert('ì‚½ì…í•  ì…ë ¥ì¹¸ì„ ë¨¼ì € í´ë¦­í•˜ì„¸ìš”.'); return; }
	          const tex = input ? (input.value || '') : '';
	          if (!String(tex || '').trim()) return;
	          insertAtCursor(t, wrapWithDelimiter(tex));
	          try { t.focus(); } catch { }
	        });

	        selConvertBtn?.addEventListener('click', () => {
	          const t = getTarget();
	          if (!t) { alert('ë³€í™˜í•  ì…ë ¥ì¹¸ì„ ë¨¼ì € í´ë¦­í•˜ì„¸ìš”.'); return; }
	          const start = t.selectionStart ?? 0;
	          const end = t.selectionEnd ?? start;
	          if (end <= start) { alert('ë³€í™˜í•  ë¬¸ìì—´ì„ ë“œë˜ê·¸ë¡œ ì„ íƒí•˜ì„¸ìš”.'); return; }
	          const raw = t.value.slice(start, end);
	          const tex = asciiToLatex(raw);
	          if (!tex) { alert('ë³€í™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ì˜ˆ: 3*3, 4/3, a=sqrt(3))'); return; }
	          const wrapped = wrapWithDelimiter(tex);
	          t.value = t.value.slice(0, start) + wrapped + t.value.slice(end);
	          const pos = start + wrapped.length;
	          if (t.setSelectionRange) t.setSelectionRange(pos, pos);
	          t.dispatchEvent(new Event('input', { bubbles: true }));
	          try { t.focus(); } catch { }
	        });

	        function updateAsciiOut() {
	          if (!asciiOut) return '';
	          const raw = asciiIn ? (asciiIn.value || '') : '';
	          const tex = asciiToLatex(raw);
	          asciiOut.textContent = tex || '';
	          asciiOut.dataset.tex = tex || '';
	          return tex || '';
	        }

	        asciiConvertBtn?.addEventListener('click', () => {
	          const tex = updateAsciiOut();
	          if (tex && input) {
	            input.value = tex;
	            updatePreview();
	          }
	        });
	        asciiInsertBtn?.addEventListener('click', () => {
	          const t = getTarget();
	          if (!t) { alert('ì‚½ì…í•  ì…ë ¥ì¹¸ì„ ë¨¼ì € í´ë¦­í•˜ì„¸ìš”.'); return; }
	          const tex = (asciiOut && asciiOut.dataset.tex) ? asciiOut.dataset.tex : '';
	          if (!tex) { alert('ë¨¼ì € ë³€í™˜í•˜ì„¸ìš”.'); return; }
	          insertAtCursor(t, wrapWithDelimiter(tex));
	          try { t.focus(); } catch { }
	        });
	      })();

	      function enableImagePaste(el) {
	        if (!el || el._imgPasteFixed) return;
	        el._imgPasteFixed = true;
	        el.addEventListener('paste', (e) => {
          const items = e.clipboardData?.items;
          if (!items || items.length === 0) return;

          // Only intercept when clipboard is "effectively an image paste".
          // Many environments include an empty text/plain alongside image/png.
          const hasImage = Array.from(items).some(it => it.type?.startsWith('image/'));
          if (!hasImage) return;
          const plain = (e.clipboardData?.getData && e.clipboardData.getData('text/plain')) ? e.clipboardData.getData('text/plain') : '';
          if (String(plain || '').trim()) return;

          for (const it of items) {
            if (it.type?.startsWith('image/')) {
              e.preventDefault();
              const file = it.getAsFile();
              if (!file) continue;

              // FIX: Bug #11 - Ensure fresh reader for every paste event
              const reader = new FileReader();
              reader.onload = () => {
                const result = reader.result;
                insertAtCursor(el, `![img](${result})`);
                remaskTextarea(el);
              };
              reader.readAsDataURL(file);
              return; // Process only the first image
            }
          }
        });
      }
	      function attachImageUrlButton(btn, targetGetter) {
	        if (!btn) return;
	        btn.addEventListener('click', () => {
	          const url = prompt((currentLang === 'ko') ? 'ì´ë¯¸ì§€ URL' : 'Image URL'); if (!url) return;
	          const target = typeof targetGetter === 'function' ? targetGetter() : targetGetter;
	          if (target) insertAtCursor(target, `![img](${url})`);
	        });
	      }

	      function persistTextareaHeight(textarea, storeKey, defaultPx) {
	        const el = textarea;
	        const key = String(storeKey || '');
	        if (!el || !key) return;
	        const minH = 90;
	        const maxH = 2400;
	        try {
	          const saved = Number(LS.get(key, 0) || 0);
	          const base = Number(defaultPx || 240) || 240;
	          const h = (saved >= minH && saved <= maxH) ? saved : base;
	          el.style.height = `${h}px`;
	        } catch { }
	        try {
	          if ('ResizeObserver' in window) {
	            const ro = new ResizeObserver(() => {
	              const h = Math.round(el.getBoundingClientRect().height || 0);
	              // Guard: don't persist collapsed/hidden 0px heights.
	              if (h < minH || h > maxH) return;
	              try { LS.set(key, h); } catch { }
	            });
	            ro.observe(el);
	          }
	        } catch { }
	      }

	      // add image tool rows to ê¸€ë¡œë²Œ/ìœ í˜• ë©”ëª¨
	      [['#globalMemoPanel', '#globalMemo'], ['#typeMemoPanel', '#typeMemo']].forEach(([panelSel, areaSel]) => {
	        const panel = $(panelSel); const area = $(areaSel);
	        if (panel && area) {
          const tools = document.createElement('div');
          tools.className = 'image-tools';
          tools.innerHTML = `<button class="btn image-url-btn">ğŸ–¼ URL</button><span class="muted">${t('img_hint')}</span>`;
          panel.querySelector('.sidebar-body')?.insertBefore(tools, area.nextSibling);
          try { translateUiChrome(tools); } catch { }
	          const btn = tools.querySelector('.image-url-btn');
	          attachImageUrlButton(btn, area);
	          enableImagePaste(area);
	          if (areaSel === '#globalMemo') persistTextareaHeight(area, 'fmm_ui_globalMemoTextareaH', 240);
	          if (areaSel === '#typeMemo') persistTextareaHeight(area, 'fmm_ui_typeMemoTextareaH', 240);
	        }
	      });
      attachImageUrlButton($('#guideImgUrl'), () => $('#source'));

      function setWindowCollapsed(win, collapsed) {
        if (!win) return;
        if (collapsed) {
          win.dataset.prevHeight = win.style.height || '';
          win.dataset.prevMinHeight = win.style.minHeight || '';
          win.dataset.prevMaxHeight = win.style.maxHeight || '';
          win.classList.add('collapsed');
          win.style.height = 'auto';
          win.style.minHeight = '0';
          win.style.maxHeight = 'none';
        } else {
          win.classList.remove('collapsed');
          if ('prevHeight' in win.dataset) win.style.height = win.dataset.prevHeight;
          if ('prevMinHeight' in win.dataset) win.style.minHeight = win.dataset.prevMinHeight;
          if ('prevMaxHeight' in win.dataset) win.style.maxHeight = win.dataset.prevMaxHeight;
        }
      }

      // image modal (ideology: keep context while zooming)
      function showImageModal(src) {
        const modal = document.getElementById('imgModal');
        if (!modal) return;
        const img = modal.querySelector('img');
        img.src = src;
        modal.style.display = 'flex';
      }
      (function initImgModal() {
        const modal = document.getElementById('imgModal');
        if (!modal) return;
        modal.addEventListener('click', () => modal.style.display = 'none');
      })();
      (function initImgDblClickZoom() {
        // ideology: global affordance beats per-panel wiring; works everywhere markdown renders.
        const body = document.body;
        if (!body || body._fmmImgZoomInit) return;
        body._fmmImgZoomInit = true;
        body.addEventListener('dblclick', (e) => {
          const img = e.target?.closest?.('img');
          if (!img) return;
          if (img.closest('#imgModal')) return;
          const src = img.currentSrc || img.src || '';
          if (!src) return;
          showImageModal(src);
        });
      })();

      function isDisplayMathNode(node) {
        if (!node) return false;
        const attr = String(node.getAttribute('data-display') || node.getAttribute('display') || '').toLowerCase();
        if (attr === 'block' || attr === 'true' || attr === '1') return true;
        const mapVal = mjxDisplayMap.get ? mjxDisplayMap.get(node) : null;
        return !!mapVal;
      }
      function selectionTextWithMath(range) {
        const frag = range.cloneContents();
        if (!frag.querySelectorAll) return null;
        const mjx = frag.querySelectorAll('mjx-container');
        const brs = frag.querySelectorAll('br');
        if (mjx.length === 0 && brs.length === 0) return null;
        function walk(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            return node.nodeValue || '';
          }
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return '';
          }
          const tag = (node.tagName || '').toUpperCase();
          if (tag === 'BR') return '\n';
          if (tag === 'MJX-CONTAINER') {
            const tex = node.getAttribute('data-tex') || '';
            if (!tex) return '';
            return isDisplayMathNode(node) ? `$$${tex}$$` : `$${tex}$`;
          }
          let out = '';
          const children = node.childNodes || [];
          for (let i = 0; i < children.length; i++) {
            out += walk(children[i]);
          }
          return out;
        }
        let text = '';
        const roots = frag.childNodes || [];
        for (let i = 0; i < roots.length; i++) {
          text += walk(roots[i]);
        }
        text = text.replace(/\u00A0/g, ' ');
        text = text.replace(/\s+\n/g, '\n').replace(/\n{3,}/g, '\n\n');
        return text;
      }

      function selectionMarkdownFromRange(range) {
        if (!range) return '';
        const frag = range.cloneContents();
        if (!frag.querySelectorAll) return '';

        function cleanMd(s) {
          return String(s || '')
            .replace(/\u00A0/g, ' ')
            .replace(/[ \t]+\n/g, '\n')
            .replace(/\n{3,}/g, '\n\n')
            .replace(/\s+$/g, '');
        }
        function normText(s) {
          return String(s || '').replace(/\u00A0/g, ' ').replace(/\s+/g, ' ').trim();
        }
        function escapePipes(s) {
          return String(s || '').replace(/\|/g, '\\|');
        }
        function texFromMjx(node) {
          if (!node) return '';
          return node.getAttribute('data-tex') || '';
        }
        function mdFromNode(node, ctx) {
          const context = ctx || { listDepth: 0, listType: null, olIndex: 1, selectionRange: null };
          if (!node) return '';
          if (node.nodeType === Node.TEXT_NODE) return node.nodeValue || '';
          if (node.nodeType !== Node.ELEMENT_NODE) return '';
          const tag = (node.tagName || '').toUpperCase();

          const children = Array.from(node.childNodes || []);
          const childrenMd = (nextCtx, nodes) => (nodes || children).map(n => mdFromNode(n, nextCtx || context)).join('');

          if (tag === 'BR') return '\n';
          if (tag === 'MJX-CONTAINER') {
            const tex = texFromMjx(node);
            if (!tex) return '';
            return isDisplayMathNode(node) ? `$$${tex}$$` : `$${tex}$`;
          }
          if (tag === 'TABLE') {
            return `\n\n${tableToMarkdown(node, context.selectionRange)}\n\n`;
          }
          if (tag === 'THEAD' || tag === 'TBODY' || tag === 'TR' || tag === 'TD' || tag === 'TH') {
            return childrenMd();
          }
          if (tag === 'HR') return '\n\n---\n\n';
          if (tag === 'H1' || tag === 'H2' || tag === 'H3' || tag === 'H4' || tag === 'H5' || tag === 'H6') {
            const level = Number(tag.slice(1)) || 1;
            return `\n\n${'#'.repeat(Math.min(6, Math.max(1, level)))} ${childrenMd().trim()}\n\n`;
          }
          if (tag === 'P') return `\n\n${childrenMd().trim()}\n\n`;
          if (tag === 'BLOCKQUOTE') {
            const inner = childrenMd().trim().replace(/\n/g, '\n> ');
            return `\n\n> ${inner}\n\n`;
          }
          if (tag === 'PRE') {
            const codeEl = node.querySelector('code');
            const codeText = (codeEl ? codeEl.textContent : node.textContent) || '';
            return `\n\n\`\`\`\n${codeText.replace(/\n+$/g, '')}\n\`\`\`\n\n`;
          }
          if (tag === 'CODE') {
            const txt = (node.textContent || '').replace(/\n/g, ' ');
            const tick = txt.includes('`') ? '``' : '`';
            return `${tick}${txt}${tick}`;
          }
          if (tag === 'STRONG' || tag === 'B') return `**${childrenMd()}**`;
          if (tag === 'EM' || tag === 'I') return `*${childrenMd()}*`;
          if (tag === 'A') {
            const href = node.getAttribute('href') || '';
            const label = childrenMd() || href;
            return href ? `[${label}](${href})` : label;
          }
          if (tag === 'IMG') {
            const src = node.getAttribute('src') || '';
            const alt = node.getAttribute('alt') || 'img';
            return src ? `![${alt}](${src})` : '';
          }
          if (tag === 'INPUT') {
            const type = (node.getAttribute('type') || '').toLowerCase();
            if (type === 'checkbox') return '';
          }
          if (tag === 'UL' || tag === 'OL') {
            const isOl = tag === 'OL';
            const nextCtx = { ...context, listDepth: context.listDepth + 1, listType: isOl ? 'ol' : 'ul', olIndex: 1, selectionRange: context.selectionRange };
            const items = Array.from(node.children || []).filter(el => (el.tagName || '').toUpperCase() === 'LI');
            const lines = items.map((li, idx) => mdFromNode(li, { ...nextCtx, olIndex: idx + 1 }).replace(/\n+$/g, ''));
            return `\n\n${lines.join('\n')}\n\n`;
          }
          if (tag === 'LI') {
            const indent = '  '.repeat(Math.max(0, context.listDepth - 1));
            const bullet = context.listType === 'ol' ? `${context.olIndex}. ` : '- ';
            const cb = children.find(n => n.nodeType === Node.ELEMENT_NODE && (n.tagName || '').toUpperCase() === 'INPUT' && (n.getAttribute('type') || '').toLowerCase() === 'checkbox');
            const cbPrefix = cb ? `[${cb.checked ? 'x' : ' '}] ` : '';
            const itemNodes = cb ? children.filter(n => n !== cb) : children;
            const body = (cbPrefix + childrenMd(context, itemNodes).trim()).replace(/\n/g, `\n${indent}  `);
            return `${indent}${bullet}${body}\n`;
          }

          return childrenMd();
        }
        function tableToMarkdown(tableEl, selectionRange) {
          const rows = Array.from(tableEl.querySelectorAll('tr'));
          if (!rows.length) return '';

          const getCells = (tr) => Array.from(tr.children || []).filter(el => {
            const t = (el.tagName || '').toUpperCase();
            return t === 'TD' || t === 'TH';
          });

          const theadRow = tableEl.querySelector('thead tr');
          const headRow = theadRow || rows.find(tr => getCells(tr).some(c => (c.tagName || '').toUpperCase() === 'TH')) || rows[0];
          const headCells = getCells(headRow);
          const colCount = headCells.length || getCells(rows[0]).length || 0;
          if (!colCount) return '';

          const selectedRows = (selectionRange && typeof selectionRange.intersectsNode === 'function')
            ? rows.filter(tr => { try { return selectionRange.intersectsNode(tr); } catch { return false; } })
            : rows;

          const head = headCells.length ? headCells : getCells(rows[0]);
          const headLine = `| ${head.map(c => escapePipes(normText(mdFromNode(c)))).join(' | ')} |`;
          const sepLine = `| ${new Array(colCount).fill('---').join(' | ')} |`;

          const bodyRows = selectedRows.filter(tr => tr !== headRow);
          const bodyLines = bodyRows.map(tr => {
            const cells = getCells(tr);
            const vals = [];
            for (let i = 0; i < colCount; i++) {
              vals.push(escapePipes(normText(mdFromNode(cells[i]))));
            }
            return `| ${vals.join(' | ')} |`;
          });

          return `${headLine}\n${sepLine}${bodyLines.length ? `\n${bodyLines.join('\n')}` : ''}`;
        }

        let text = '';
        const roots = frag.childNodes || [];
        for (let i = 0; i < roots.length; i++) {
          text += mdFromNode(roots[i], { listDepth: 0, listType: null, olIndex: 1, selectionRange: range });
        }
        return cleanMd(text);
      }

      // Copy rendered markdown as markdown (incl. tables + TeX) when possible.
      document.addEventListener('copy', (e) => {
        const ae = document.activeElement;
        if (ae && (ae.tagName === 'TEXTAREA' || ae.tagName === 'INPUT' || ae.isContentEditable)) return;

        const sel = document.getSelection();
        if (!sel || sel.rangeCount === 0) return;
        const range = sel.getRangeAt(0);
        if (!range) return;
	        const commonEl = (range.commonAncestorContainer && range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE)
	          ? range.commonAncestorContainer
	          : range.commonAncestorContainer?.parentElement;
	        if (!commonEl) return;
	        const startEl = (range.startContainer && range.startContainer.nodeType === Node.ELEMENT_NODE)
	          ? range.startContainer
	          : range.startContainer?.parentElement;
	        const endEl = (range.endContainer && range.endContainer.nodeType === Node.ELEMENT_NODE)
	          ? range.endContainer
	          : range.endContainer?.parentElement;

	        const frag = range.cloneContents();
	        if (!frag.querySelectorAll) return;

	        const mjx = frag.querySelectorAll('mjx-container');
	        const tables = frag.querySelectorAll('table');
	        const mdScope =
	          (startEl?.closest ? startEl.closest('.md') : null) ||
	          (endEl?.closest ? endEl.closest('.md') : null) ||
	          (commonEl.closest ? commonEl.closest('.md') : null);
	        const inTable =
	          (startEl?.closest ? startEl.closest('table') : null) ||
	          (endEl?.closest ? endEl.closest('table') : null) ||
	          (commonEl.closest ? commonEl.closest('table') : null);
	        const inMath =
	          (startEl?.closest ? startEl.closest('mjx-container') : null) ||
	          (endEl?.closest ? endEl.closest('mjx-container') : null) ||
	          (commonEl.closest ? commonEl.closest('mjx-container') : null);
	        if (!mdScope && !inTable && !inMath && mjx.length === 0 && tables.length === 0) return;

        e.preventDefault();

        function cleanMd(s) {
          return String(s || '')
            .replace(/\u00A0/g, ' ')
            .replace(/[ \t]+\n/g, '\n')
            .replace(/\n{3,}/g, '\n\n')
            .replace(/\s+$/g, '');
        }
        function normText(s) {
          return String(s || '').replace(/\u00A0/g, ' ').replace(/\s+/g, ' ').trim();
        }
        function escapePipes(s) {
          return String(s || '').replace(/\|/g, '\\|');
        }
        function texFromMjx(node) {
          if (!node) return '';
          return node.getAttribute('data-tex') || '';
        }

        function mdFromNode(node, ctx) {
          const context = ctx || { listDepth: 0, listType: null, olIndex: 1 };
          if (!node) return '';
          if (node.nodeType === Node.TEXT_NODE) return node.nodeValue || '';
          if (node.nodeType !== Node.ELEMENT_NODE) return '';
          const tag = (node.tagName || '').toUpperCase();

          const children = Array.from(node.childNodes || []);
          const childrenMd = (nextCtx, nodes) => (nodes || children).map(n => mdFromNode(n, nextCtx || context)).join('');

          if (tag === 'BR') return '\n';
          if (tag === 'MJX-CONTAINER') {
            const tex = texFromMjx(node);
            if (!tex) return '';
            return isDisplayMathNode(node) ? `$$${tex}$$` : `$${tex}$`;
          }
          if (tag === 'TABLE') {
            return `\n\n${tableToMarkdown(node)}\n\n`;
          }
          if (tag === 'THEAD' || tag === 'TBODY' || tag === 'TR' || tag === 'TD' || tag === 'TH') {
            return childrenMd();
          }
          if (tag === 'HR') return '\n\n---\n\n';
          if (tag === 'H1' || tag === 'H2' || tag === 'H3' || tag === 'H4' || tag === 'H5' || tag === 'H6') {
            const level = Number(tag.slice(1)) || 1;
            return `\n\n${'#'.repeat(Math.min(6, Math.max(1, level)))} ${childrenMd().trim()}\n\n`;
          }
          if (tag === 'P') return `\n\n${childrenMd().trim()}\n\n`;
          if (tag === 'BLOCKQUOTE') {
            const inner = childrenMd().trim().replace(/\n/g, '\n> ');
            return `\n\n> ${inner}\n\n`;
          }
          if (tag === 'PRE') {
            const codeEl = node.querySelector('code');
            const codeText = (codeEl ? codeEl.textContent : node.textContent) || '';
            return `\n\n\`\`\`\n${codeText.replace(/\n+$/g, '')}\n\`\`\`\n\n`;
          }
          if (tag === 'CODE') {
            const txt = (node.textContent || '').replace(/\n/g, ' ');
            // avoid breaking fences by using double backticks when needed
            const tick = txt.includes('`') ? '``' : '`';
            return `${tick}${txt}${tick}`;
          }
          if (tag === 'STRONG' || tag === 'B') return `**${childrenMd()}**`;
          if (tag === 'EM' || tag === 'I') return `*${childrenMd()}*`;
          if (tag === 'A') {
            const href = node.getAttribute('href') || '';
            const label = childrenMd() || href;
            return href ? `[${label}](${href})` : label;
          }
          if (tag === 'IMG') {
            const src = node.getAttribute('src') || '';
            const alt = node.getAttribute('alt') || 'img';
            return src ? `![${alt}](${src})` : '';
          }
          if (tag === 'INPUT') {
            const type = (node.getAttribute('type') || '').toLowerCase();
            if (type === 'checkbox') return '';
          }
          if (tag === 'UL' || tag === 'OL') {
            const isOl = tag === 'OL';
            const nextCtx = { ...context, listDepth: context.listDepth + 1, listType: isOl ? 'ol' : 'ul', olIndex: 1 };
            const items = Array.from(node.children || []).filter(el => (el.tagName || '').toUpperCase() === 'LI');
            const lines = items.map((li, idx) => mdFromNode(li, { ...nextCtx, olIndex: idx + 1 }).replace(/\n+$/g, ''));
            return `\n\n${lines.join('\n')}\n\n`;
          }
          if (tag === 'LI') {
            const indent = '  '.repeat(Math.max(0, context.listDepth - 1));
            const bullet = context.listType === 'ol' ? `${context.olIndex}. ` : '- ';
            const cb = children.find(n => n.nodeType === Node.ELEMENT_NODE && (n.tagName || '').toUpperCase() === 'INPUT' && (n.getAttribute('type') || '').toLowerCase() === 'checkbox');
            const cbPrefix = cb ? `[${cb.checked ? 'x' : ' '}] ` : '';
            const itemNodes = cb ? children.filter(n => n !== cb) : children;
            const body = (cbPrefix + childrenMd(context, itemNodes).trim()).replace(/\n/g, `\n${indent}  `);
            return `${indent}${bullet}${body}\n`;
          }

          // Default: inline-ish container
          return childrenMd();
        }

        function tableToMarkdown(tableEl, selectionRange) {
          const rows = Array.from(tableEl.querySelectorAll('tr'));
          if (!rows.length) return '';

          const getCells = (tr) => Array.from(tr.children || []).filter(el => {
            const t = (el.tagName || '').toUpperCase();
            return t === 'TD' || t === 'TH';
          });

          const theadRow = tableEl.querySelector('thead tr');
          const headRow = theadRow || rows.find(tr => getCells(tr).some(c => (c.tagName || '').toUpperCase() === 'TH')) || rows[0];
          const headCells = getCells(headRow);
          const colCount = headCells.length || getCells(rows[0]).length || 0;
          if (!colCount) return '';

          const selectedRows = (selectionRange && typeof selectionRange.intersectsNode === 'function')
            ? rows.filter(tr => { try { return selectionRange.intersectsNode(tr); } catch { return false; } })
            : rows;

          const head = headCells.length ? headCells : getCells(rows[0]);
          const headLine = `| ${head.map(c => escapePipes(normText(mdFromNode(c)))).join(' | ')} |`;
          const sepLine = `| ${new Array(colCount).fill('---').join(' | ')} |`;

          const bodyRows = selectedRows.filter(tr => tr !== headRow);
          const bodyLines = bodyRows.map(tr => {
            const cells = getCells(tr);
            const vals = [];
            for (let i = 0; i < colCount; i++) {
              vals.push(escapePipes(normText(mdFromNode(cells[i]))));
            }
            return `| ${vals.join(' | ')} |`;
          });

          return `${headLine}\n${sepLine}${bodyLines.length ? `\n${bodyLines.join('\n')}` : ''}`;
        }

        // If user selected multiple cells/rows inside one table, copy as markdown table.
        // But when selecting text within a single cell, copy just the selection (avoid "entire row copied" surprise).
        if (inTable) {
          const t0 = startEl?.closest ? startEl.closest('table') : null;
          const t1 = endEl?.closest ? endEl.closest('table') : null;
          if (t0 && t0 === t1) {
            const c0 = startEl?.closest ? startEl.closest('td,th') : null;
            const c1 = endEl?.closest ? endEl.closest('td,th') : null;
            const singleCell = c0 && c1 && c0 === c1;
            if (!singleCell) {
              const tableMd = cleanMd(tableToMarkdown(t0, range));
              if (tableMd) {
                e.clipboardData.setData('text/plain', tableMd);
                e.clipboardData.setData('text/markdown', tableMd);
                return;
              }
            }
          }
        }

        let text = '';
        const roots = frag.childNodes || [];
        for (let i = 0; i < roots.length; i++) {
          text += mdFromNode(roots[i]);
        }
        text = cleanMd(text);
        const out = text || sel.toString();
        e.clipboardData.setData('text/plain', out);
        e.clipboardData.setData('text/markdown', out);
      });
      document.addEventListener('dragstart', (e) => {
        const ae = document.activeElement;
        if (ae && (ae.tagName === 'TEXTAREA' || ae.tagName === 'INPUT' || ae.isContentEditable)) return;
        const sel = document.getSelection();
        if (!sel || sel.rangeCount === 0) return;
        const range = sel.getRangeAt(0);
        if (!range) return;
        const commonEl = (range.commonAncestorContainer && range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE)
          ? range.commonAncestorContainer
          : range.commonAncestorContainer?.parentElement;
        if (!commonEl) return;
        const startEl = (range.startContainer && range.startContainer.nodeType === Node.ELEMENT_NODE)
          ? range.startContainer
          : range.startContainer?.parentElement;
        const endEl = (range.endContainer && range.endContainer.nodeType === Node.ELEMENT_NODE)
          ? range.endContainer
          : range.endContainer?.parentElement;
        const mdScope =
          (startEl?.closest ? startEl.closest('.md') : null) ||
          (endEl?.closest ? endEl.closest('.md') : null) ||
          (commonEl.closest ? commonEl.closest('.md') : null);
        const inTable =
          (startEl?.closest ? startEl.closest('table') : null) ||
          (endEl?.closest ? endEl.closest('table') : null) ||
          (commonEl.closest ? commonEl.closest('table') : null);
        const inMath =
          (startEl?.closest ? startEl.closest('mjx-container') : null) ||
          (endEl?.closest ? endEl.closest('mjx-container') : null) ||
          (commonEl.closest ? commonEl.closest('mjx-container') : null);
        if (!mdScope && !inTable && !inMath) return;

        const md = selectionMarkdownFromRange(range);
        const text = md || selectionTextWithMath(range);
        if (!text || !e.dataTransfer) return;
        e.dataTransfer.setData('text/plain', text);
        if (md) e.dataTransfer.setData('text/markdown', md);
      });
      // annotate math with source TeX after typeset
      if (window.MathJax && MathJax.startup?.promise) {
        MathJax.startup.promise.then(() => {
          const doc = MathJax.startup.document;
          const orig = doc.postFilters.add((args) => {
            const math = args.math;
            if (math && math.typesetRoot) {
              math.typesetRoot.setAttribute('data-tex', math.math || '');
              math.typesetRoot.setAttribute('data-display', math.display ? 'block' : 'inline');
            }
            return args;
          });
          return orig;
        });
      }

      // answer parsing helpers
      const CIRCLED_CHOICES = ['â‘ ', 'â‘¡', 'â‘¢', 'â‘£', 'â‘¤', 'â‘¥', 'â‘¦', 'â‘§', 'â‘¨', 'â‘©', 'â‘ª', 'â‘«', 'â‘¬', 'â‘­', 'â‘®', 'â‘¯', 'â‘°', 'â‘±', 'â‘²', 'â‘³'];
      const DINGBAT_CIRCLED_CHOICES = ['â€', 'â', 'â‚', 'âƒ', 'â„', 'â…', 'â†', 'â‡', 'âˆ', 'â‰'];
      const DINGBAT_CIRCLED_CHOICES_BLACK = ['âŠ', 'â‹', 'âŒ', 'â', 'â', 'â', 'â', 'â‘', 'â’', 'â“'];
      const CIRCLED_INDEX = (() => {
        const m = {};
        CIRCLED_CHOICES.forEach((ch, idx) => { m[ch] = idx; });
        DINGBAT_CIRCLED_CHOICES.forEach((ch, idx) => { m[ch] = idx; });
        DINGBAT_CIRCLED_CHOICES_BLACK.forEach((ch, idx) => { m[ch] = idx; });
        return m;
      })();
			      function parseChoices(str) {
			        const clean = stripAnswerEmphasis(str);
			        const parsed = splitAnswerChoiceBlock(clean);
			        if (parsed && parsed.hasMarkers) {
			          return (parsed.items || []).map(it => ({ mark: it.mark, text: it.text }));
			        }
			        const out = [];
			        const lines = clean.replace(/\r\n/g, '\n').split('\n');
			        lines.forEach(line => {
			          const tline = String(line || '').trim();
			          if (!tline) return;
			          out.push({ mark: CIRCLED_CHOICES[out.length] || String(out.length + 1), text: tline });
			        });
			        return out;
			      }
	      function normalizeAnswerToken(ans) {
	        const t = stripAnswerEmphasis(ans).trim();
	        if (!t) return null;
        const circled = t.match(/[â‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨â‘©â‘ªâ‘«â‘¬â‘­â‘®â‘¯â‘°â‘±â‘²â‘³â€ââ‚âƒâ„â…â†â‡âˆâ‰âŠâ‹âŒâââââ‘â’â“]/);
        if (circled) {
          const idx = CIRCLED_INDEX[circled[0]];
          if (typeof idx === 'number') return { type: 'mark', mark: circled[0], index: idx };
        }
        const num = t.match(/(^|[^\d])(1?\d|20)([^\d]|$)/);
        if (num) {
          const n = parseInt(num[2], 10);
          return { type: 'index', index: n - 1, mark: CIRCLED_CHOICES[n - 1] || String(n) };
        }
        const letter = t.match(/[A-D]/i);
        if (letter) {
          const idx = letter[0].toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
          return { type: 'index', index: idx, mark: CIRCLED_CHOICES[idx] || letter[0].toUpperCase() };
        }
        return { type: 'text', text: t.toLowerCase() };
      }
      function isAnswerCorrect(userMark, official, choices) {
        const nUser = normalizeAnswerToken(userMark);
        const nOff = normalizeAnswerToken(official);
        if (!nOff || !official) return null; // skip when official answer absent
        if (nUser && nOff && nUser.index != null && nOff.index != null) return nUser.index === nOff.index;
        if (nUser && nOff && nUser.mark && nOff.mark) return nUser.mark === nOff.mark;
        if (nUser && nOff && nUser.text && nOff.text) return nUser.text === nOff.text;
        // fallback: compare choice text contents
        if (nUser && nUser.index != null && choices && choices[nUser.index]) {
          const selected = stripAnswerEmphasis(choices[nUser.index].text || '').replace(/\s+/g, '').toLowerCase();
          const offTxt = stripAnswerEmphasis(official).replace(/\s+/g, '').toLowerCase();
          if (offTxt && selected.includes(offTxt)) return true;
        }
        return false;
      }

      // === NEW: chat collapse toggle ================================================
      $('#chatToggleBtn').addEventListener('dblclick', () => setWindowCollapsed(chatWin, !chatWin.classList.contains('collapsed')));
      const chatCollapseBtn = document.createElement('button');
      chatCollapseBtn.className = 'btn';
      chatCollapseBtn.textContent = 'â–¾';
      chatCollapseBtn.title = 'ì±„íŒ… ì ‘ê¸°';
      const chatHead = $('#chatWindow')?.querySelector('.window-head div:last-child');
      if (chatHead) { chatHead.insertBefore(chatCollapseBtn, chatHead.firstChild); }
      chatCollapseBtn.addEventListener('click', () => setWindowCollapsed(chatWin, !chatWin.classList.contains('collapsed')));

	      // === NEW: Problem solving mode ================================================
	      // ideology: í’€ì´ ìƒíƒœë¥¼ ë©”ì¸ê°€ì´ë“œì™€ ë¶„ë¦¬ëœ ì‚¬ì´ë“œ í”Œë¡œìš°ë¡œ ìœ ì§€í•´ ì§‘ì¤‘ íë¦„ì„ ê¹¨ì§€ ì•ŠìŒ
		      const solveWindow = $('#solveWindow');
		      const solveState = { session: null, manualSelected: new Set(), memoShareSelected: new Set(), memoPreviewPinned: false, reviewSelected: new Set(), reviewMode: 'wrong', reviewTag: '', reviewMarkedOnly: false, reviewExcludeMastered: true, tagsRevealed: false };
	      const ACTIVE_SOLVE_SESSIONS_KEY = 'fmm_active_solve_sessions';
	      const ACTIVE_SOLVE_SESSION_CURRENT_KEY = 'fmm_active_solve_session_current';
	
	      function loadActiveSolveSessions() {
	        const list = LS.get(ACTIVE_SOLVE_SESSIONS_KEY, []);
	        return Array.isArray(list) ? list : [];
	      }
	      function saveActiveSolveSessions(list) {
	        LS.set(ACTIVE_SOLVE_SESSIONS_KEY, Array.isArray(list) ? list : []);
	      }
	      function snapshotSolveSessionForStorage(sess) {
	        if (!sess || typeof sess !== 'object') return null;
	        const id = String(sess.id || '').trim();
	        if (!id) return null;
	        const queue = Array.isArray(sess.queue) ? sess.queue.map(x => String(x || '').trim()).filter(Boolean) : [];
	        const answers = {};
	        try {
	          Object.keys(sess.answers || {}).forEach(qid => {
	            const q = String(qid || '').trim();
	            if (!q) return;
	            const a = sess.answers[qid];
	            if (!a || typeof a !== 'object') return;
	            answers[q] = {
	              choice: a.choice ?? null,
	              correct: (typeof a.result === 'boolean') ? a.result : (typeof a.correct === 'boolean' ? a.correct : null)
	            };
	          });
	        } catch { }
	        const marked = {};
	        try {
	          Object.keys(sess.marked || {}).forEach(qid => {
	            if (sess.marked && sess.marked[qid]) marked[String(qid)] = true;
	          });
	        } catch { }
	        return {
	          id,
	          startedAt: Number(sess.startedAt || Date.now()),
	          updatedAt: Date.now(),
	          typeTitle: sess.typeTitle || '',
	          sheetId: sess.sheetId || null,
	          sheetName: sess.sheetName || null,
	          reviewOnly: !!sess.reviewOnly,
	          historyId: sess.historyId || null,
	          current: (typeof sess.current === 'number' && Number.isFinite(sess.current)) ? sess.current : 0,
	          queue,
	          answers,
	          marked,
	          result: sess.result ? JSON.parse(JSON.stringify(sess.result)) : null
	        };
	      }
	      function persistActiveSolveSession(sess) {
	        const snap = snapshotSolveSessionForStorage(sess);
	        if (!snap) return false;
	        const prev = loadActiveSolveSessions();
	        const next = [snap].concat(prev.filter(x => x && String(x.id || '') !== snap.id));
	        const MAX = 30;
	        if (next.length > MAX) next.length = MAX;
	        saveActiveSolveSessions(next);
	        try { store.setItem(ACTIVE_SOLVE_SESSION_CURRENT_KEY, snap.id); } catch { }
	        return true;
	      }
	      function removeActiveSolveSession(id) {
	        const sid = String(id || '').trim();
	        if (!sid) return;
	        const prev = loadActiveSolveSessions();
	        const next = prev.filter(x => x && String(x.id || '') !== sid);
	        saveActiveSolveSessions(next);
	        try {
	          const cur = store.getItem(ACTIVE_SOLVE_SESSION_CURRENT_KEY);
	          if (String(cur || '') === sid) store.removeItem(ACTIVE_SOLVE_SESSION_CURRENT_KEY);
	        } catch { }
	      }
	      function findActiveSolveSession(id) {
	        const sid = String(id || '').trim();
	        if (!sid) return null;
	        const list = loadActiveSolveSessions();
	        return list.find(x => x && String(x.id || '') === sid) || null;
	      }
	      function renderSolveSessionsPanel() {
	        const panel = $('#solveSessionsPanel');
	        const listEl = $('#solveSessionsList');
	        if (!panel || !listEl) return;
	        const list = loadActiveSolveSessions().slice().sort((a, b) => Number(b?.updatedAt || 0) - Number(a?.updatedAt || 0));
	        if (!list.length) {
	          listEl.innerHTML = '<div class="muted">ì €ì¥ëœ ì§„í–‰ ì„¸ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
	          return;
	        }
	        listEl.innerHTML = list.map(s => {
	          const id = String(s.id || '');
	          const started = s.startedAt ? new Date(s.startedAt).toLocaleString() : '';
	          const total = Array.isArray(s.queue) ? s.queue.length : 0;
	          const cur = (typeof s.current === 'number' && Number.isFinite(s.current)) ? (s.current + 1) : 1;
	          const title = String(s.typeTitle || '').trim() || '(ì œëª© ì—†ìŒ)';
	          const safeId = id.replace(/\"/g, '&quot;');
	          return `<div class="problems-item" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
	            <div style="display:flex;flex-direction:column;gap:2px;min-width:220px;">
	              <strong>${sanitize(title)}</strong>
	              <span class="muted" style="font-size:12px;">${sanitize(started)} Â· ${cur} / ${total}</span>
	            </div>
	            <div style="display:flex;gap:6px;flex-wrap:wrap;margin-left:auto;">
	              <button class="btn" data-act="open" data-sid="${safeId}">ì—´ê¸°</button>
	              <button class="btn" data-act="pop" data-sid="${safeId}">ìƒˆ ì°½</button>
	              <button class="btn" data-act="del" data-sid="${safeId}">ì‚­ì œ</button>
	            </div>
	          </div>`;
	        }).join('');
	      }
	      function toggleSolveSessionsPanel(show) {
	        const panel = $('#solveSessionsPanel');
	        if (!panel) return;
	        panel.style.display = show ? '' : 'none';
	        if (show) renderSolveSessionsPanel();
	      }
	      function openSolveSessionInNewWindow(sessionId, opts) {
	        const sid = String(sessionId || '').trim();
	        if (!sid) return;
	        try {
	          const u = new URL(window.location.href);
	          u.searchParams.set('solveSession', sid);
	          if (opts && opts.solveOnly) u.searchParams.set('solveOnly', '1');
	          window.open(u.toString(), '_blank');
	        } catch {
	          // fallback: still try
	          try { window.open(window.location.href + (window.location.search ? '&' : '?') + 'solveSession=' + encodeURIComponent(sid), '_blank'); } catch { }
	        }
	      }
	      function restoreActiveSolveSessionById(sessionId) {
	        const saved = findActiveSolveSession(sessionId);
	        if (!saved) { alert('ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return false; }
	        const qids = Array.isArray(saved.queue) ? saved.queue : [];
	        const selected = qids.map(qid => getProblemForQid(qid)).filter(Boolean);
	        if (!selected.length) {
	          alert('ì´ ì„¸ì…˜ì˜ ë¬¸ì œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ë¬¸ì œ JSONì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”)');
	          return false;
	        }
	        startSolveSession(selected, {
	          id: saved.id,
	          startedAt: saved.startedAt,
	          typeTitle: saved.typeTitle || currentTypeTitle(),
	          sheetId: saved.sheetId || null,
	          sheetName: saved.sheetName || null,
	          reviewOnly: !!saved.reviewOnly,
	          historyId: saved.historyId || null,
	          result: saved.result || null,
	          answers: saved.answers || null,
	          marked: saved.marked || null,
	          current: saved.current
	        });
	        return true;
	      }

		      function gotoTypeGuideByTitle(typeTitle) {
		        const title = String(typeTitle || '').trim();
		        if (!title) return false;
	        const types = Array.isArray(window.fmm_types) ? window.fmm_types : [];
	        const target = normalizeTitle(title);
	        const idx = types.findIndex(t => t && normalizeTitle(t.title) === target);
	        if (idx < 0) return false;
	        const el = document.getElementById(`type-${idx + 1}`);
	        if (!el) return false;
	        try { location.hash = `#type-${idx + 1}`; } catch { }
	        try { el.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch { try { el.scrollIntoView(); } catch { } }
	        return true;
	      }

      function refreshSolveSetup(list, title) {
        const meta = $('#solveMeta');
        if (meta) meta.textContent = title ? `${title} Â· ${list.length}ë¬¸í•­` : 'ë¬¸ì œ íŒŒì¼ì„ ë¶ˆëŸ¬ì£¼ì„¸ìš”.';
        const listEl = $('#solveManualList');
        if (listEl) {
          listEl.innerHTML = '';
          (list || []).forEach(q => {
            const tag = getEffectiveTag(q.qid);
            const label = document.createElement('label');
            label.className = 'problems-item';
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" data-qid="${q.qid}" ${solveState.manualSelected.has(q.qid) ? 'checked' : ''}> <span class="tag-badge">${tag}</span> ${sanitize(q.qid)} Â· ${sanitize(stripAnswerEmphasis(q.question_text || '').slice(0, 60))}`;
            listEl.appendChild(label);
          });
        }
      }

      function currentTypeProblems() {
        const title = currentTypeTitle();
        if (!title) return [];
        return problemsForType(title).map(applyProblemOverrides);
      }

      // open/close solve window
	      $('#solveToggleBtn').addEventListener('click', () => {
	        const showing = solveWindow.classList.contains('active');
	        solveWindow.classList.toggle('active', !showing);
	        solveWindow.style.display = showing ? 'none' : '';
	        if (!showing) {
	          restoreSavedBox(solveWindow, 'fmm_ui_solveWindow');
	          refreshSolveSetup(currentTypeProblems(), currentTypeTitle());
	          // If a solve session exists, resume it instead of forcing the setup screen.
	          if (solveState.session) {
	            $('#solveSetup').classList.remove('active');
	            if (solveState.session.result) {
	              $('#solvePlay').classList.remove('active');
	              $('#solveReview').classList.add('active');
	              try { renderSolveReview(solveState.reviewMode || 'wrong'); } catch { }
	            } else {
	              $('#solveReview').classList.remove('active');
	              $('#solvePlay').classList.add('active');
	              try { renderSolveQuestion(); } catch { }
	            }
	          } else {
	            $('#solveSetup').classList.add('active');
	            $('#solvePlay').classList.remove('active');
	            $('#solveReview').classList.remove('active');
	          }
	        }
	      });
	      $('#solveSessionsBtn')?.addEventListener('click', () => {
	        const panel = $('#solveSessionsPanel');
	        const showing = !!(panel && panel.style.display !== 'none');
	        toggleSolveSessionsPanel(!showing);
	      });
	      $('#solveSessionsClose')?.addEventListener('click', () => toggleSolveSessionsPanel(false));
	      $('#solveSessionsList')?.addEventListener('click', (ev) => {
	        const btn = ev.target?.closest?.('button[data-act][data-sid]');
	        const act = btn?.getAttribute?.('data-act') || '';
	        const sid = btn?.getAttribute?.('data-sid') || '';
	        if (!act || !sid) return;
	        if (act === 'open') {
	          toggleSolveSessionsPanel(false);
	          restoreActiveSolveSessionById(sid);
	          return;
	        }
	        if (act === 'pop') {
	          openSolveSessionInNewWindow(sid, { solveOnly: true });
	          return;
	        }
	        if (act === 'del') {
	          if (!confirm('ì´ ì§„í–‰ ì„¸ì…˜ì„ ì‚­ì œí• ê¹Œìš”?')) return;
	          removeActiveSolveSession(sid);
	          renderSolveSessionsPanel();
	        }
	      });
	      $('#solvePopoutBtn')?.addEventListener('click', () => {
	        const sid = solveState?.session?.id || store.getItem(ACTIVE_SOLVE_SESSION_CURRENT_KEY) || '';
	        if (!sid) { toggleSolveSessionsPanel(true); return; }
	        try { if (solveState?.session) persistActiveSolveSession(solveState.session); } catch { }
	        openSolveSessionInNewWindow(sid, { solveOnly: true });
	      });
	      $('#solveCollapseBtn').addEventListener('click', () => setWindowCollapsed(solveWindow, !solveWindow.classList.contains('collapsed')));
      $('#solveCopyUid')?.addEventListener('click', () => {
        if (!solveState.session) { alert('ë¨¼ì € í’€ì´ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”.'); return; }
        const queue = activeSolveQueue();
        if (!queue.length) return;
        let idx = solveState.session.current || 0;
        if (idx < 0) idx = 0;
        if (idx >= queue.length) idx = queue.length - 1;
        const qid = queue[idx];
        if (!qid) return;
        copyPlainText(qid);
        const btn = $('#solveCopyUid');
        if (!btn) return;
        const prev = btn.textContent;
        btn.textContent = 'ë³µì‚¬ë¨';
        btn.disabled = true;
        setTimeout(() => { btn.textContent = prev; btn.disabled = false; }, 800);
      });
      $('#solveSimilarBtn')?.addEventListener('click', () => {
        if (!solveState.session) { alert('ë¨¼ì € í’€ì´ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”.'); return; }
        const queue = activeSolveQueue();
        if (!queue.length) return;
        let idx = solveState.session.current || 0;
        if (idx < 0) idx = 0;
        if (idx >= queue.length) idx = queue.length - 1;
        const qid = queue[idx];
        if (!qid) return;
        if (typeof window.openSimilarWindowForQid === 'function') window.openSimilarWindowForQid(qid);
      });
      $('#solveMarkBtn')?.addEventListener('click', () => {
        if (!solveState.session) { alert('ë¨¼ì € í’€ì´ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”.'); return; }
        const queue = activeSolveQueue();
        if (!queue.length) return;
        let idx = solveState.session.current || 0;
        if (idx < 0) idx = 0;
        if (idx >= queue.length) idx = queue.length - 1;
        const qid = queue[idx];
        if (!qid) return;
        const marked = ensureSolveMarkedMap();
        if (!marked) return;
	        if (marked[qid]) delete marked[qid];
	        else marked[qid] = true;
	        updateSolveMarkButton(qid);
	        persistSolveMarkedToHistory();
	        try { persistActiveSolveSession(solveState.session); } catch { }
	        if (solveState.session.result && $('#solveReview')?.classList.contains('active')) {
	          renderSolveReview(solveState.reviewMode || 'wrong');
	        }
      });
      $('#solveTagToggle')?.addEventListener('click', () => {
        // í’€ì´ ì¤‘ íƒœê·¸(íŒíŠ¸) ê°€ë¦¬ê¸°/ë³´ê¸°
        solveState.tagsRevealed = !solveState.tagsRevealed;
        applySolveTagVisibility();
      });

      // mode toggles
      document.querySelectorAll('input[name="solveMode"]').forEach(r => {
        r.addEventListener('change', () => {
          const v = r.value;
          $('#solveYearWrap').style.display = v === 'after' ? '' : 'none';
          $('#solveManualWrap').style.display = v === 'manual' ? '' : 'none';
          $('#solveTagWrap').style.display = v === 'tag' ? '' : 'none';
          $('#solveWrongWrap').style.display = v === 'wrongHist' ? '' : 'none';
        });
      });
      $('#solveManualList').addEventListener('change', (e) => {
        const cb = e.target.closest('input[type="checkbox"][data-qid]');
        const qid = cb?.dataset?.qid;
        if (!qid) return;
        if (cb.checked) solveState.manualSelected.add(qid); else solveState.manualSelected.delete(qid);
        const mode = document.querySelector('input[name="solveMode"]:checked')?.value || 'any';
        if (mode === 'manual') {
          const countEl = $('#solveCount');
          if (countEl) countEl.value = String(Math.max(1, solveState.manualSelected.size));
        }
      });

      function shuffle(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; }
        return a;
      }

      function buildSolveQueue() {
        const mode = document.querySelector('input[name="solveMode"]:checked')?.value || 'any';
        const count = Math.max(1, parseInt($('#solveCount').value || '1', 10));
        const year = parseInt($('#solveYear').value || '0', 10);
        const tagTarget = $('#solveTagSelect').value;
        const pool = currentTypeProblems();
        if (!pool.length) { alert('í•´ë‹¹ ìœ í˜•ì˜ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.'); return null; }
        let selected = [];
        if (mode === 'any') {
          selected = shuffle(pool).slice(0, count);
        } else if (mode === 'unsolved') {
          const filtered = pool.filter(p => {
            const st = getProblemState(p.qid);
            const attempts = Number(st?.attempts || 0);
            return !(Number.isFinite(attempts) && attempts > 0);
          });
          selected = shuffle(filtered.length ? filtered : pool).slice(0, count);
        } else if (mode === 'after') {
          const filtered = pool.filter(p => {
            const y = extractYearFromQid(p.qid);
            return y ? y >= year : false;
          });
          selected = shuffle(filtered.length ? filtered : pool).slice(0, count);
        } else if (mode === 'latest') {
          const sorted = pool.slice().sort((a, b) => {
            const ya = extractYearFromQid(a.qid) || -1;
            const yb = extractYearFromQid(b.qid) || -1;
            return yb - ya;
          });
          selected = sorted.slice(0, count);
        } else if (mode === 'manual') {
          // manual = ì²´í¬í•œ ë¬¸ì œ "ì „ë¶€" (countëŠ” ìë™ìœ¼ë¡œ ì²´í¬ ìˆ˜ë¡œ ë§ì¶˜ë‹¤)
          selected = pool.filter(p => solveState.manualSelected.has(p.qid));
        } else if (mode === 'tag') {
          selected = pool.filter(p => getEffectiveTag(p.qid) === tagTarget).slice(0, count);
          if (selected.length < count) selected = selected.concat(shuffle(pool.filter(p => !selected.includes(p)))).slice(0, count);
        } else if (mode === 'wrongHist') {
          const op = $('#solveWrongOp').value || '>=';
          const base = Math.max(1, parseInt($('#solveWrongCount').value || '1', 10));
          const filtered = pool.filter(p => {
            const st = getProblemState(p.qid);
            const w = st.wrongCount || 0;
            if (w <= 0) return false;
            if (op === '==') return w === base;
            if (op === '<=') return w <= base;
            return w >= base; // '>='
          });
          selected = shuffle(filtered.length ? filtered : pool).slice(0, count);
        }
        if (!selected.length) { alert('ì„ íƒëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.'); return null; }
        return selected;
      }

      function ensureAnswerSlot(qid) {
        if (!solveState.session.answers[qid]) solveState.session.answers[qid] = { choice: null, revealed: false, result: null };
        return solveState.session.answers[qid];
      }

	      function activeSolveQueue() {
	        if (!solveState.session) return [];
	        const base = Array.isArray(solveState.session.queue) ? solveState.session.queue : [];
	        if (!solveState.session.result) return base;
	        const mode = solveState.reviewFilter || 'all';
	        let list = base;
	        if (mode === 'wrong') list = Array.isArray(solveState.session.result.wrong) ? solveState.session.result.wrong : base;
	        else if (mode === 'correct') list = Array.isArray(solveState.session.result.correct) ? solveState.session.result.correct : base;
	        // íƒœê·¸ ëª¨ì•„ë³´ê¸° í•„í„° ì ìš©
	        const tag = solveState.reviewTag || '';
	        if (tag) {
	          list = list.filter(qid => getEffectiveTag(qid) === tag);
	        }
	        if (solveState.reviewMarkedOnly) {
	          const marked = solveState.session.marked || {};
	          list = list.filter(qid => marked[String(qid)] === true);
	        }
	        return list;
	      }

	      function renderSolveQuestion() {
	        if (!solveState.session) return;
	        const queue = activeSolveQueue();
	        if (!queue.length) return;
        let idx = solveState.session.current || 0;
        if (idx < 0) idx = 0;
        if (idx >= queue.length) idx = queue.length - 1;
        solveState.session.current = idx;
        const qid = queue[idx];
        const latest = currentTypeProblems().find(p => p.qid === qid);
        if (latest) solveState.session.problemMap[qid] = latest;
        let problem = solveState.session.problemMap[qid];
        if (problem) {
          const merged = applyProblemOverrides(problem);
          if (merged) {
            problem = merged;
            solveState.session.problemMap[qid] = merged;
          }
        }
        if (!problem) { return; }
        const qBox = $('#solveQuestion');
        const cBox = $('#solveChoices');
        const ansBox = $('#solveRevealAnswer');
        const expBox = $('#solveRevealExpBox');
        const revealPanel = $('#solveRevealPanel');
        const prog = $('#solveProgress');
        const badgeWrap = $('#solveBadges');
        const offWrap = $('#solveOfficialWrap');
        qBox.innerHTML = `<div class="md">${renderMarkdown(problem.question_text || '', { breaks: true }, 'sanitizeThenParse')}</div>`;
	        cBox.innerHTML = '';
	        const year = extractYearFromQid(problem.qid);
	        const tag = getEffectiveTag(qid);
	        const typeTitle = (problems && problems.qidType && problems.qidType[qid]) ? String(problems.qidType[qid]) : (problem && problem.__typeTitle ? String(problem.__typeTitle) : '');
	        badgeWrap.innerHTML =
	          `<span class="pill">${escapeHtml(problem.qid)}</span>` +
	          `${year ? `<span class="pill">${escapeHtml(year)}ë…„</span>` : ''}` +
	          `${typeTitle ? `<span class="pill solve-type-pill" data-type-title="${escapeHtml(typeTitle)}" title="ìœ í˜• ê°€ì´ë“œë¡œ ì´ë™">${escapeHtml(typeTitle)}</span>` : ''}` +
	          `<span class="pill" id="solveTagPill">${escapeHtml(tag)}</span>`;
	        const typePillEl = badgeWrap.querySelector('.solve-type-pill');
	        if (typePillEl) {
	          typePillEl.addEventListener('click', (ev) => {
	            ev.stopPropagation();
	            gotoTypeGuideByTitle(typeTitle);
	          });
	        }
	        const choices = parseChoices(problem.answer_choices || '');
	        cBox.innerHTML = '';
        const slot = ensureAnswerSlot(qid);
        choices.forEach(ch => {
          const btn = document.createElement('button');
          btn.className = 'choice-btn';
          btn.dataset.mark = ch.mark;
          btn.innerHTML = `<span class="choice-mark">${ch.mark}</span><span class="choice-text">${sanitize(ch.text)}</span>`;
          if (slot.choice === ch.mark) btn.classList.add('selected');
	          btn.addEventListener('click', () => {
	            slot.choice = ch.mark;
	            // ì„ íƒ ë³€ê²½ ì‹œ, ê¸°ì¡´ ì±„ì  ê²°ê³¼(ìŠ¤ëƒ…ìƒ·)ëŠ” ë” ì´ìƒ ìœ íš¨í•˜ì§€ ì•ŠìŒ (ì¬ì±„ì  ì „ê¹Œì§€ëŠ” null)
	            slot.result = null;
	            solveState.session.answers[qid] = slot;
	            cBox.querySelectorAll('.choice-btn').forEach(b => b.classList.toggle('selected', b.dataset.mark === ch.mark));
	            try { persistActiveSolveSession(solveState.session); } catch { }
	          });
          if (solveState.session.reviewOnly) {
            btn.title = 'ê²€í†  ê¸°ë¡ì—ì„œ ë‹µì„ ë°”ê¾¸ë©´, ì±„ì  ì‹œ ìƒˆ í’€ì´ ì„¸ì…˜ì„ ì‹œì‘í• ì§€ ë¬¼ì–´ë´…ë‹ˆë‹¤.';
          }
          cBox.appendChild(btn);
        });
        insertBreaksBeforeCircled(cBox);
        applyInlineBoldMarkers(qBox);
        applyInlineBoldMarkers(cBox);
        prog.textContent = `${idx + 1} / ${queue.length}`;
        $('#solveOfficialAnswer').value = displayOfficialAnswerValue(problem.official_answer);
        const solveOffExp = $('#solveOfficialExplanation');
        if (solveOffExp) {
          solveOffExp.value = maskDataImages(problem.official_explanation || '', solveOffExp);
          enableImagePaste(solveOffExp);
        }
        $('#solveRevealPanel').style.display = 'none';
        if (offWrap) {
          const hasOfficial = hasOfficialAnswer(problem.official_answer);
          // ê³µì‹ ì •ë‹µì´ ì—†ìœ¼ë©´ (ìŠ¤í¬ì¼ëŸ¬ê°€ ì—†ìœ¼ë¯€ë¡œ) ë°”ë¡œ ì…ë ¥ ê°€ëŠ¥í•˜ê²Œ ë…¸ì¶œ
          offWrap.style.display = hasOfficial ? 'none' : '';
        }
        $('#solveReview').classList.remove('active');
        $('#solvePlay').classList.add('active');
        $('#solveSetup').classList.remove('active');
        const memoArea = $('#solveMemoArea');
        if (memoArea) {
          memoArea.value = '';
          delete memoArea.dataset.editingId;
        }
        const editBox = $('#solveProblemEditBox');
        if (editBox) {
          editBox.innerHTML = '';
          editBox.style.display = 'none';
        }
        renderProblemMemoList(qid, $('#solveMemoList'), memoArea);
	        const linkSpan = $('#solveMemoLinkCurrent');
	        if (linkSpan) linkSpan.textContent = getMemoOwnerKey(qid);
	        const linkInput = $('#solveMemoLinkQid');
	        if (linkInput) linkInput.value = '';
		        updateTagButtons(getEffectiveTag(qid));
		        updateSolveMarkButton(qid);
		        applySolveTagVisibility();
		        try { if ($('#solveMemoSharePicker')?.style.display !== 'none') renderSolveMemoSharePicker(); } catch { }
		        applyWordMemos(qBox);
		        typesetMath(qBox);
		        typesetMath(cBox);
        enableImagePaste($('#solveMemoArea'));
        const hasResult = !!solveState.session.result;
        const inReviewListMode = solveState.reviewMode === 'wrong' || solveState.reviewMode === 'correct' || solveState.reviewMode === 'all';
	        if (solveState.session.reviewOnly || (hasResult && inReviewListMode)) {
	          // ê²€í†  ë‹¨ê³„(í‹€ë¦°/ë§ì€/ì „ì²´ ë³´ê¸°)ì—ì„œëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì •ë‹µ/í•´ì„¤ì„ ì—° ìƒíƒœë¡œ ì‹œì‘
	          revealForCurrent();
	        }
	        // Keep memo-share manager highlight in sync with current question.
	        try { maybeRenderMemoShareManager(); } catch { }
	      }

	      function updateTagButtons(tag) {
	        $$('.tag-chip', solveWindow).forEach(b => b.classList.toggle('active', b.dataset.tag === tag));
	      }
		      function applySolveTagVisibility() {
		        const sess = solveState.session;
		        const spoilerSafe = !!(sess && !sess.result && !sess.reviewOnly);
		        const q = spoilerSafe ? activeSolveQueue() : [];
		        const idx = (sess && typeof sess.current === 'number') ? sess.current : 0;
		        const qid = (q && q.length) ? q[Math.max(0, Math.min(idx, q.length - 1))] : '';
		        const curTag = qid ? getEffectiveTag(qid) : '';
		        const forceShowLock = spoilerSafe && !solveState.tagsRevealed && curTag === 'ğŸ”’';
		        const show = !spoilerSafe || !!solveState.tagsRevealed || forceShowLock;
		        const chips = $('#solveTagChips');
		        if (chips) chips.style.display = show ? 'flex' : 'none';
		        const pill = $('#solveTagPill');
		        if (pill) pill.style.display = show ? '' : 'none';
		        const toggle = $('#solveTagToggle');
		        if (toggle) {
		          toggle.style.display = spoilerSafe ? '' : 'none';
		          toggle.textContent = solveState.tagsRevealed ? 'íƒœê·¸ ìˆ¨ê¸°ê¸°' : (forceShowLock ? 'íƒœê·¸ ë³´ê¸°(ğŸ”’í‘œì‹œ)' : 'íƒœê·¸ ë³´ê¸°');
		        }
		      }

	      function ensureSolveMarkedMap() {
	        const sess = solveState.session;
	        if (!sess) return null;
	        if (!sess.marked || typeof sess.marked !== 'object') sess.marked = {};
	        return sess.marked;
	      }
	      function isSolveMarked(qid) {
	        const sess = solveState.session;
	        if (!sess || !sess.marked || typeof sess.marked !== 'object') return false;
	        return sess.marked[String(qid || '')] === true;
	      }
	      function updateSolveMarkButton(qid) {
	        const btn = $('#solveMarkBtn');
	        if (!btn) return;
	        const marked = isSolveMarked(qid);
	        btn.textContent = marked ? 'ğŸ“ ì°ìŒ' : 'ğŸ“Œ ì°ê¸°';
	        btn.title = marked ? 'ì´ í…ŒìŠ¤íŠ¸ì—ì„œ ì°ìŒ (í´ë¦­: í•´ì œ)' : 'ì´ í…ŒìŠ¤íŠ¸ì—ì„œ ì°ê¸° (í´ë¦­: í‘œì‹œ)';
	      }
	      function persistSolveMarkedToHistory() {
	        const sess = solveState.session;
	        if (!sess) return;
	        const histId = sess.reviewOnly ? (sess.historyId || null) : (sess.id || null);
	        if (!histId) return;
	        const all = LS.get(SOLVE_HISTORY_KEY, []);
	        const idx = all.findIndex(h => h && String(h.id || '') === String(histId));
	        if (idx < 0) return;
	        const marked = (sess.marked && typeof sess.marked === 'object')
	          ? Object.keys(sess.marked).filter(qid => sess.marked[qid] === true)
	          : [];
	        all[idx] = { ...all[idx], marked };
	        LS.set(SOLVE_HISTORY_KEY, all);
	      }

			      function startSolveSession(selected, opts) {
			        opts = opts || {};
			        const queue = selected.map(p => String(p.qid));
		        const startedAt = (typeof opts.startedAt === 'number') ? opts.startedAt : Date.now();
		        const sessionId = opts.reviewOnly ? (opts.historyId || null) : (opts.id || ('S' + startedAt));
		        solveState.reviewFilter = 'all';
		        solveState.reviewMarkedOnly = false;
		        solveState.tagsRevealed = !!opts.reviewOnly;
		        solveState.memoPreviewPinned = false;
		        try { solveState.memoShareSelected?.clear?.(); } catch { }
		        try { solveState.reviewSelected?.clear?.(); } catch { }
			        const restoredAnswers = {};
			        if (opts.answers && typeof opts.answers === 'object') {
		          queue.forEach(qid => {
	            const a = opts.answers[qid];
	            if (!a) return;
            restoredAnswers[qid] = {
              choice: a.choice || null,
              revealed: false,
              result: typeof a.correct === 'boolean' ? a.correct : null
	            };
	          });
	        }
		        const reviewBaseChoices = {};
		        if (opts.reviewOnly) {
		          queue.forEach(qid => {
		            const a = restoredAnswers[qid];
		            reviewBaseChoices[qid] = a ? (a.choice || null) : null;
		          });
		        }
		        const marked = {};
		        if (Array.isArray(opts.marked)) {
		          opts.marked.forEach(qid => { if (qid) marked[String(qid)] = true; });
		        } else if (opts.marked && typeof opts.marked === 'object') {
		          Object.keys(opts.marked || {}).forEach(qid => { if (opts.marked[qid]) marked[String(qid)] = true; });
		        }
			        solveState.session = {
			          id: sessionId,
			          startedAt,
			          queue,
			          problemMap: selected.reduce((m, p) => { m[String(p.qid)] = p; return m; }, {}),
			          answers: restoredAnswers,
			          current: (typeof opts.current === 'number' && Number.isFinite(opts.current))
			            ? Math.max(0, Math.min(queue.length - 1, opts.current))
			            : 0,
			          typeTitle: opts.typeTitle || currentTypeTitle(),
			          result: opts.result || null,
			          sheetId: opts.sheetId || null,
			          sheetName: opts.sheetName || null,
		          reviewOnly: !!opts.reviewOnly,
		          historyId: opts.historyId || null,
		          marked,
		          reviewBaseChoices: opts.reviewOnly ? reviewBaseChoices : null,
		          // Keep the original grading snapshot so review re-grading can be reverted.
		          reviewOriginal: opts.reviewOnly ? {
		            result: opts.result ? JSON.parse(JSON.stringify(opts.result)) : null,
		            answers: opts.answers ? JSON.parse(JSON.stringify(opts.answers)) : null,
		            baseChoices: JSON.parse(JSON.stringify(reviewBaseChoices || {}))
		          } : null,
		          reviewRegraded: false,
		          gradeOriginal: null,
		          gradeRegraded: false
		        };
	        const gradeBtn = $('#solveGrade');
			        if (gradeBtn) {
			          gradeBtn.disabled = false;
			          gradeBtn.title = solveState.session.reviewOnly
			            ? 'ê²€í†  ëª¨ë“œ ê¸°ë¡ì€ ìœ ì§€ë©ë‹ˆë‹¤. (ë³´ê¸° ë³€ê²½ì´ ê°ì§€ë˜ë©´ ìƒˆ í’€ì´ ì„¸ì…˜ ì‹œì‘ ì—¬ë¶€ë¥¼ ë¬»ìŠµë‹ˆë‹¤.)'
			            : '';
			        }
			        renderSolveQuestion();
			        try { persistActiveSolveSession(solveState.session); } catch { }
			      }

	      function openCollectionInSolve(problemsList, label) {
	        const items = (problemsList || []).map(applyProblemOverrides).filter(p => p && p.qid);
	        if (!items.length) return;
	        const title = String(label || 'ëª¨ì•„ë³´ê¸°').trim();
	        const now = Date.now();
	        const sid = 'COLLECT_' + now;
	        // Preserve current in-progress solve first (so "ëª¨ì•„ë³´ê¸°" doesn't nuke it).
	        try { if (solveState?.session) persistActiveSolveSession(solveState.session); } catch { }
	        // Store the new collection session for cross-window restore.
	        try {
	          persistActiveSolveSession({
	            id: sid,
	            startedAt: now,
	            queue: items.map(p => String(p.qid || '')).filter(Boolean),
	            answers: {},
	            current: 0,
	            typeTitle: `[ëª¨ì•„ë³´ê¸°] ${title}`,
	            result: null,
	            sheetId: null,
	            sheetName: null,
	            reviewOnly: true,
	            historyId: sid,
	            marked: {}
	          });
	        } catch { }

	        // Prefer opening in a new window to avoid wiping the current solve view.
	        let opened = false;
	        try {
	          const u = new URL(window.location.href);
	          u.searchParams.set('solveSession', sid);
	          u.searchParams.set('solveOnly', '1');
	          opened = !!window.open(u.toString(), '_blank');
	        } catch { }
	        if (opened) return;

	        // Fallback: open in current window (session is still saved, so user can resume).
	        if (typeof solveWindow !== 'undefined' && solveWindow) {
	          solveWindow.classList.add('active');
	          solveWindow.style.display = '';
	          try { restoreSavedBox(solveWindow, 'fmm_ui_solveWindow'); } catch { }
	        }
	        if (typeof startSolveSession === 'function') {
	          startSolveSession(items, { reviewOnly: true, historyId: sid, typeTitle: `[ëª¨ì•„ë³´ê¸°] ${title}` });
	        }
	      }
	      window.openCollectionInSolve = openCollectionInSolve;
	      // Auto-restore a saved solve session when opened with ?solveSession=... (supports pop-out windows).
	      (function maybeAutoRestoreSolveSessionFromUrl() {
	        let sid = '';
	        let solveOnly = false;
	        try {
	          const u = new URL(window.location.href);
	          sid = u.searchParams.get('solveSession') || '';
	          solveOnly = u.searchParams.get('solveOnly') === '1';
	        } catch { }
	        sid = String(sid || '').trim();
		        if (!sid) return;
		        if (solveOnly) {
		          try { const el = document.querySelector('header'); if (el) el.style.display = 'none'; } catch { }
		          try { const el = document.querySelector('main'); if (el) el.style.display = 'none'; } catch { }
		          try { const el = document.getElementById('leftAside'); if (el) el.style.display = 'none'; } catch { }
		          try { const el = document.getElementById('globalAside'); if (el) el.style.display = 'none'; } catch { }
		          try { const el = document.getElementById('typeAside'); if (el) el.style.display = 'none'; } catch { }
		        }
	        try {
	          if (solveWindow) {
	            solveWindow.classList.add('active');
	            solveWindow.style.display = '';
	            try { restoreSavedBox(solveWindow, 'fmm_ui_solveWindow'); } catch { }
	          }
	        } catch { }
	        setTimeout(() => {
	          try { restoreActiveSolveSessionById(sid); } catch { }
	        }, 0);
	      })();
	
	      $('#solveStartBtn').addEventListener('click', () => {
	        const selected = buildSolveQueue();
	        if (selected) startSolveSession(selected);
      });

      $('#solvePrev').addEventListener('click', () => {
        if (!solveState.session) return;
        const q = activeSolveQueue();
        if (!q.length) return;
        solveState.session.current = Math.max(0, (solveState.session.current || 0) - 1);
        renderSolveQuestion();
        try { persistActiveSolveSession(solveState.session); } catch { }
      });
      $('#solveNext').addEventListener('click', () => {
        if (!solveState.session) return;
        const q = activeSolveQueue();
        if (!q.length) return;
        const cur = solveState.session.current || 0;
        solveState.session.current = Math.min(q.length - 1, cur + 1);
        renderSolveQuestion();
        try { persistActiveSolveSession(solveState.session); } catch { }
      });

      // Problem edit toggle (below memos)
      $('#solveProblemEditToggle')?.addEventListener('click', () => {
        if (!solveState.session) return;
        const q = activeSolveQueue();
        if (!q.length) return;
        const idx = solveState.session.current || 0;
        const qid = q[idx];
        const box = $('#solveProblemEditBox');
        if (!box) return;
        const opening = box.style.display === 'none' || !box.innerHTML.trim();
        if (opening) {
          box.style.display = '';
          window.mountProblemEditor(box, qid);
        } else {
          box.style.display = 'none';
          box.innerHTML = '';
        }
      });

      function revealForCurrent() {
        if (!solveState.session) return;
        const queue = activeSolveQueue();
        if (!queue.length) return;
        let idx = solveState.session.current || 0;
        if (idx < 0) idx = 0;
        if (idx >= queue.length) idx = queue.length - 1;
        solveState.session.current = idx;
        const qid = queue[idx];
        const problem = solveState.session.problemMap[qid];
        const official = getOfficialAnswerText($('#solveOfficialAnswer').value.trim() || problem.official_answer || '');
        const exp = stripAnswerEmphasis($('#solveOfficialExplanation').value.trim() || problem.official_explanation || '');
        const ansBox = $('#solveRevealAnswer');
        const expBox = $('#solveRevealExpBox');
        $('#solveOfficialWrap').style.display = '';
        $('#solveRevealPanel').style.display = '';
        if (!official) {
          ansBox.innerHTML = `<span class="badge">ì •ë‹µ</span><span class="muted">ì—†ìŒ</span>`;
          expBox.innerHTML = '<div class="muted">ê³µì‹ ì •ë‹µì´ ì—†ìŠµë‹ˆë‹¤. ì•„ë˜ì— ì§ì ‘ ì…ë ¥í•˜ê±°ë‚˜ LLMìœ¼ë¡œ ì±„ì›Œì£¼ì„¸ìš”.</div>';
          typesetMath($('#solveRevealPanel'));
          return;
        }
        ansBox.innerHTML = `<span class="badge">ì •ë‹µ</span>${sanitize(official)}`;
        expBox.innerHTML = exp ? renderMarkdown(exp, { breaks: true }, 'sanitizeThenParse') : '<div class="muted">í•´ì„¤ ì—†ìŒ</div>';
        const choices = parseChoices(problem.answer_choices || '');
        const norm = normalizeAnswerToken(official);
        if (norm && norm.index != null && choices[norm.index]) {
          $$('.choice-btn').forEach(b => {
            if (b.dataset.mark === choices[norm.index].mark) b.classList.add('revealed');
          });
        }
        typesetMath($('#solveRevealPanel'));
        applyInlineBoldMarkers($('#solveRevealPanel'));
      }
      $('#solveRevealAll').addEventListener('click', () => revealForCurrent());

      // tag buttons in solve window
      solveWindow.addEventListener('click', (e) => {
        const btn = e.target.closest('.tag-chip');
        if (!btn) return;
        if (!solveState.session) return;
        const q = activeSolveQueue();
        if (!q.length) return;
        const idx = solveState.session.current || 0;
        const qid = q[idx];
        if (!qid) return;
        setProblemTag(qid, btn.dataset.tag);
        updateTagButtons(getEffectiveTag(qid));
        renderProblemsForCurrentType();
      });

      // official answer save within solve window
      $('#solveSaveOfficial').addEventListener('click', () => {
        if (!solveState.session) return;
        const q = activeSolveQueue();
        if (!q.length) return;
        const idx = solveState.session.current || 0;
        const qid = q[idx];
        const expEl = $('#solveOfficialExplanation');
        const exp = expEl ? unmaskDataImages(expEl.value || '', expEl) : '';
        const updated = {
          official_answer: normalizeOfficialAnswerValue($('#solveOfficialAnswer').value || ''),
          official_explanation: exp.trim() || undefined
        };
        updateProblemState(qid, updated);
        if (solveState.session.problemMap[qid]) {
          solveState.session.problemMap[qid].official_answer = updated.official_answer;
          solveState.session.problemMap[qid].official_explanation = updated.official_explanation;
          // keep merged view in-session
          solveState.session.problemMap[qid] = applyProblemOverrides(solveState.session.problemMap[qid]);
        }
        renderProblemsForCurrentType();
        // If reveal panel is open, refresh it immediately
        if ($('#solveRevealPanel')?.style.display !== 'none') {
          try { revealForCurrent(); } catch { }
        }
        statusEl.textContent = 'ê³µì‹ ì •ë‹µ ì €ì¥ë¨';
      });

      // problem memo helpers
	      function renderProblemMemoList(qid, listEl, targetArea) {
	        if (!listEl) return;
	        const ownerKey = getMemoOwnerKey(qid);
	        // In solve/play mode, do not auto-render memo previews (spoiler prevention).
	        // Review mode default = rendered.
	        const spoilerSafe = !!(solveState.session && !solveState.session.result && !solveState.session.reviewOnly);
	        const spoilerKey = spoilerSafe ? '1' : '0';
	        const forceOpenId = listEl.dataset.forceOpenMemoId ? String(listEl.dataset.forceOpenMemoId) : '';
	        if (forceOpenId) delete listEl.dataset.forceOpenMemoId;
	        // Preserve which previews are open across re-renders only when:
	        // - same memo group, AND
	        // - same solve/review mode (so solve->review flips to default rendered, review->solve flips to default hidden)
	        const prevOwnerKey = listEl.dataset.memoOwnerKey || '';
	        const prevSpoilerKey = listEl.dataset.memoSpoilerSafe || '';
        const preservePreviewState = !!(prevOwnerKey && prevOwnerKey === ownerKey && prevSpoilerKey === spoilerKey);
        const prevOpenSet = new Set();
        if (preservePreviewState) {
          listEl.querySelectorAll('.problem-memo-preview').forEach(el => {
            const id = el.getAttribute('data-memo-id');
            if (!id) return;
            if (el.style.display !== 'none') prevOpenSet.add(String(id));
          });
        }
        listEl.dataset.memoOwnerKey = ownerKey;
        listEl.dataset.memoSpoilerSafe = spoilerKey;
        const memos = getProblemMemos(qid);
        listEl.innerHTML = '';
        if (!memos.length) {
          listEl.innerHTML = '<div class="muted">ì €ì¥ëœ ë©”ëª¨ ì—†ìŒ</div>';
          return;
        }
	        const st = getProblemState(ownerKey); // ëŒ€í‘œ ë©”ëª¨ëŠ” ê³µìœ  ê·¸ë£¹ ê¸°ì¤€ìœ¼ë¡œ ì €ì¥
	        const repId = st.representativeMemoId == null ? null : String(st.representativeMemoId);
	        const orderedMemos = memos.slice();
	        if (repId) {
	          const ridx = orderedMemos.findIndex(mm => String(mm.id) === repId);
	          if (ridx > 0) {
	            const [repMemo] = orderedMemos.splice(ridx, 1);
	            orderedMemos.unshift(repMemo);
	          }
	        }
	        orderedMemos.forEach(m => {
	          const wrap = document.createElement('div');
	          wrap.style.marginBottom = '6px';

          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.gap = '6px';
          row.style.alignItems = 'center';
          const b = document.createElement('button');
          b.className = 'btn';
          b.dataset.id = String(m.id);
          b.textContent = `ìˆ˜ì • Â· ${new Date(m.createdAt).toLocaleString()}${repId === String(m.id) ? ' Â· â­ ëŒ€í‘œ' : ''}`;
          b.addEventListener('click', () => {
            const found = memos.find(mm => String(mm.id) === b.dataset.id);
            if (found && targetArea) {
              targetArea.value = maskDataImages(found.text || '', targetArea);
              targetArea.dataset.editingId = String(found.id);
            }
          });
          const del = document.createElement('button');
          del.className = 'btn';
          del.textContent = 'ì‚­ì œ';
          del.dataset.id = String(m.id);
	          del.addEventListener('click', () => {
	            const list = getProblemMemos(qid);
	            const idx = list.findIndex(mm => String(mm.id) === del.dataset.id);
	            if (idx > -1 && confirm('ì´ ë©”ëª¨ë¥¼ ì™„ì „íˆ ì‚­ì œí• ê¹Œìš”?')) {
	              list.splice(idx, 1);
	              saveProblemMemos(qid, list);
	              renderProblemMemoList(qid, listEl, targetArea);
	              statusEl.textContent = 'ë¬¸ì œ ë©”ëª¨ ì‚­ì œë¨';
	            }
	          });
	          const up = document.createElement('button');
	          up.className = 'btn';
	          up.textContent = 'â–²';
	          up.title = 'ìœ„ë¡œ';
	          up.dataset.id = String(m.id);
	          up.disabled = (repId === String(m.id));
	          up.addEventListener('click', (ev) => {
	            ev.stopPropagation();
	            if (repId === String(m.id)) return;
	            const list = getProblemMemos(qid);
	            const idx = list.findIndex(mm => String(mm.id) === up.dataset.id);
	            if (idx <= 0) return;
	            // keep representative memo pinned at top
	            const repIdx = repId ? list.findIndex(mm => String(mm.id) === repId) : -1;
	            if (repIdx === 0 && idx === 1) return;
	            const [item] = list.splice(idx, 1);
	            list.splice(idx - 1, 0, item);
	            saveProblemMemos(qid, list);
	            renderProblemMemoList(qid, listEl, targetArea);
	          });
	          const down = document.createElement('button');
	          down.className = 'btn';
	          down.textContent = 'â–¼';
	          down.title = 'ì•„ë˜ë¡œ';
	          down.dataset.id = String(m.id);
	          down.disabled = (repId === String(m.id));
	          down.addEventListener('click', (ev) => {
	            ev.stopPropagation();
	            if (repId === String(m.id)) return;
	            const list = getProblemMemos(qid);
	            const idx = list.findIndex(mm => String(mm.id) === down.dataset.id);
	            if (idx < 0 || idx >= list.length - 1) return;
	            const repIdx = repId ? list.findIndex(mm => String(mm.id) === repId) : -1;
	            if (repIdx === 0 && idx === 0) return;
	            const [item] = list.splice(idx, 1);
	            const nextIdx = Math.min(list.length, idx + 1);
	            list.splice(nextIdx, 0, item);
	            saveProblemMemos(qid, list);
	            renderProblemMemoList(qid, listEl, targetArea);
	          });
	          const rep = document.createElement('button');
	          rep.className = 'btn';
	          rep.textContent = repId === String(m.id) ? 'ëŒ€í‘œ í•´ì œ' : 'ëŒ€í‘œ';
	          rep.dataset.id = String(m.id);
	          rep.addEventListener('click', () => {
	            const cur = getProblemState(ownerKey);
	            const newId = (cur.representativeMemoId && String(cur.representativeMemoId) === rep.dataset.id) ? null : Number(rep.dataset.id);
	            updateProblemState(ownerKey, { representativeMemoId: newId });
	            if (newId != null) {
	              const list = getProblemMemos(qid);
	              const mi = list.findIndex(mm => String(mm.id) === String(newId));
	              if (mi > 0) {
	                const [item] = list.splice(mi, 1);
	                list.unshift(item);
	                saveProblemMemos(qid, list);
	              }
	            }
	            renderProblemMemoList(qid, listEl, targetArea);
	            statusEl.textContent = newId == null ? 'ëŒ€í‘œ ë©”ëª¨ í•´ì œë¨' : 'ëŒ€í‘œ ë©”ëª¨ ì§€ì •ë¨';
	          });
	          row.appendChild(b);
	          row.appendChild(del);
	          row.appendChild(up);
	          row.appendChild(down);
	          row.appendChild(rep);
	          wrap.appendChild(row);

          if (m.text) {
            const preview = document.createElement('div');
            preview.className = 'md';
            preview.classList.add('problem-memo-preview');
            preview.setAttribute('data-memo-id', String(m.id));
	            preview.style.marginTop = '4px';
	            preview.style.padding = '6px';
		            preview.style.border = '1px dashed var(--border)';
		            preview.style.borderRadius = '6px';
		            preview.style.fontSize = (m.previewFont != null) ? (String(Number(m.previewFont)) + 'px') : '';
		            const openByDefault = !spoilerSafe || !!solveState.memoPreviewPinned;
		            const openNow = (forceOpenId && String(m.id) === forceOpenId) ? true : (preservePreviewState ? prevOpenSet.has(String(m.id)) : openByDefault);
		            preview.style.display = openNow ? '' : 'none';

	            const renderPreview = () => {
	              preview.innerHTML = renderMarkdown(m.text || '', { breaks: true, autoAsciiMath: true }, 'parseThenSanitize');
	              applyInlineBoldMarkers(preview);
	              typesetMath(preview);
	            };

            const toggle = document.createElement('button');
            toggle.className = 'btn';
            toggle.textContent = (preview.style.display === 'none') ? 'ë¯¸ë¦¬ë³´ê¸°' : 'ë¯¸ë¦¬ë³´ê¸° ìˆ¨ê¸°ê¸°';
            toggle.addEventListener('click', (ev) => {
              ev.stopPropagation();
              const willShow = preview.style.display === 'none';
              if (willShow) {
                renderPreview();
                preview.style.display = '';
                toggle.textContent = 'ë¯¸ë¦¬ë³´ê¸° ìˆ¨ê¸°ê¸°';
                if (spoilerSafe) solveState.memoPreviewPinned = true;
              } else {
                preview.style.display = 'none';
                toggle.textContent = 'ë¯¸ë¦¬ë³´ê¸°';
                if (spoilerSafe) solveState.memoPreviewPinned = false;
              }
            });
            row.appendChild(toggle);
            const pvMinus = document.createElement('button');
            pvMinus.className = 'btn';
	            pvMinus.textContent = 'Aâˆ’';
	            pvMinus.title = 'ë¯¸ë¦¬ë³´ê¸° ê¸€ì ì‘ê²Œ';
		            pvMinus.addEventListener('click', (ev) => {
		              ev.stopPropagation();
		              const base = Number(m.previewFont || UI.memoPreviewFont || 15);
		              const next = clamp(base - 1, 12, 32);
		              m.previewFont = next;
		              saveProblemMemos(qid, memos);
		              preview.style.fontSize = String(next) + 'px';
		              if (preview.style.display !== 'none') renderPreview();
		            });
		            row.appendChild(pvMinus);
		            const pvPlus = document.createElement('button');
		            pvPlus.className = 'btn';
		            pvPlus.textContent = 'A+';
		            pvPlus.title = 'ë¯¸ë¦¬ë³´ê¸° ê¸€ì í¬ê²Œ';
		            pvPlus.addEventListener('click', (ev) => {
		              ev.stopPropagation();
		              const base = Number(m.previewFont || UI.memoPreviewFont || 15);
		              const next = clamp(base + 1, 12, 32);
		              m.previewFont = next;
		              saveProblemMemos(qid, memos);
		              preview.style.fontSize = String(next) + 'px';
		              if (preview.style.display !== 'none') renderPreview();
		            });
		            row.appendChild(pvPlus);

            if (preview.style.display !== 'none') renderPreview();
            wrap.appendChild(preview);
          }

          listEl.appendChild(wrap);
        });
      }
	      $('#solveMemoSave').addEventListener('click', () => {
	        // "ìƒˆë¡œ ì €ì¥"ì€ í•­ìƒ ìƒˆ ë©”ëª¨ë¡œ ì €ì¥
	        if (!solveState.session) return;
	        const q = activeSolveQueue();
	        if (!q.length) return;
	        const idx = solveState.session.current || 0;
	        const qid = q[idx];
	        const area = $('#solveMemoArea');
	        const text = area ? unmaskDataImages(area.value || '', area) : '';
	        if (!text.trim()) return;
	        const list = getProblemMemos(qid);
	        const newId = Date.now();
	        list.push({ id: newId, text, createdAt: newId });
	        if (area) area.dataset.editingId = String(newId);
	        saveProblemMemos(qid, list);
	        // ìƒˆ ë©”ëª¨ ìƒì„± ì‹œ: ì´ë²ˆ í’€ì´ ì„¸ì…˜ ë™ì•ˆ ë¯¸ë¦¬ë³´ê¸° ON ìœ ì§€ (ì‚¬ìš©ìê°€ ë„ê¸° ì „ê¹Œì§€)
	        solveState.memoPreviewPinned = true;
	        const memoListEl = $('#solveMemoList');
	        if (memoListEl) memoListEl.dataset.forceOpenMemoId = String(newId);
	        renderProblemMemoList(qid, memoListEl, $('#solveMemoArea'));
	        statusEl.textContent = 'ë¬¸ì œ ë©”ëª¨ ìƒˆë¡œ ì €ì¥ë¨';
	      });
      $('#solveMemoUpdate')?.addEventListener('click', () => {
        // "ìˆ˜ì • ì €ì¥"ì€ ì„ íƒëœ ë©”ëª¨ë§Œ ë®ì–´ì“°ê¸°
        if (!solveState.session) return;
        const q = activeSolveQueue();
        if (!q.length) return;
        const idx = solveState.session.current || 0;
        const qid = q[idx];
        const area = $('#solveMemoArea');
        const text = area ? unmaskDataImages(area.value || '', area) : '';
        if (!text.trim()) return;
        const editingId = area && area.dataset.editingId ? String(area.dataset.editingId) : null;
        if (!editingId) {
          alert('ìˆ˜ì •í•  ë©”ëª¨ë¥¼ ëª©ë¡ì—ì„œ ì„ íƒí•˜ì„¸ìš”.');
          return;
        }
        const list = getProblemMemos(qid);
        const mIdx = list.findIndex(m => String(m.id) === editingId);
        if (mIdx < 0) {
          alert('ìˆ˜ì • ëŒ€ìƒ ë©”ëª¨ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }
        list[mIdx] = { ...list[mIdx], text, updatedAt: Date.now() };
        saveProblemMemos(qid, list);
        renderProblemMemoList(qid, $('#solveMemoList'), $('#solveMemoArea'));
        statusEl.textContent = 'ë¬¸ì œ ë©”ëª¨ ìˆ˜ì •ë¨';
      });
      $('#solveMemoClear').addEventListener('click', () => {
        const a = $('#solveMemoArea');
        if (a) {
          a.value = '';
          delete a.dataset.editingId;
        }
      });
      attachImageUrlButton($('#solveImgUrl'), () => $('#solveMemoArea'));
      enableImagePaste($('#solveMemoArea'));

      // memo sharing controls inside solve window
      $('#solveMemoLinkApply')?.addEventListener('click', () => {
        if (!solveState.session) return;
        const q = activeSolveQueue();
        if (!q.length) return;
        const idx = solveState.session.current || 0;
        const qid = q[idx];
        const inp = $('#solveMemoLinkQid');
        const base = (inp?.value || '').trim();
        if (!base) {
          alert('ê³µìœ  ê¸°ì¤€ì´ ë  GLOBAL_QID ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
          return;
        }
        const r = linkProblemMemos(qid, base);
	        const owner = r.owner || getMemoOwnerKey(base);
	        const curSpan = $('#solveMemoLinkCurrent');
	        if (curSpan) curSpan.textContent = owner;
	        renderProblemMemoList(qid, $('#solveMemoList'), $('#solveMemoArea'));
	        try { if ($('#solveMemoSharePicker')?.style.display !== 'none') renderSolveMemoSharePicker(); } catch { }
	        try { maybeRenderMemoShareManager(); } catch { }
	        statusEl.textContent = 'ì´ ë¬¸ì œì˜ ë©”ëª¨ê°€ ì§€ì •í•œ ë¬¸ì œì™€ ë©”ëª¨ë¥¼ ê³µìœ í•©ë‹ˆë‹¤.';
	      });
	      $('#solveMemoLinkReset')?.addEventListener('click', () => {
	        if (!solveState.session) return;
	        const q = activeSolveQueue();
	        if (!q.length) return;
	        const idx = solveState.session.current || 0;
	        const qid = q[idx];
	        unlinkProblemMemos(qid);
	        const curSpan = $('#solveMemoLinkCurrent');
	        if (curSpan) curSpan.textContent = String(qid);
	        renderProblemMemoList(qid, $('#solveMemoList'), $('#solveMemoArea'));
	        try { if ($('#solveMemoSharePicker')?.style.display !== 'none') renderSolveMemoSharePicker(); } catch { }
	        try { maybeRenderMemoShareManager(); } catch { }
	        statusEl.textContent = 'ë©”ëª¨ ê³µìœ ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.';
	      });
	
	      function renderSolveMemoSharePicker() {
	        const box = $('#solveMemoSharePicker');
	        const sess = solveState.session;
	        if (!box) return;
	        if (!sess) { box.innerHTML = ''; return; }
	        const baseQueue = Array.isArray(sess.queue) ? sess.queue.slice() : [];
	        const active = activeSolveQueue();
	        const list = (active && active.length) ? active.slice() : baseQueue;
	        if (!list.length) { box.innerHTML = ''; return; }
	
	        const curIdx = (typeof sess.current === 'number') ? sess.current : 0;
	        const curQid = active.length ? active[Math.max(0, Math.min(curIdx, active.length - 1))] : list[0];
	        const curOwner = curQid ? getMemoOwnerKey(curQid) : '';
	        const selected = solveState.memoShareSelected || new Set();
	
	        // Clear any lingering hover preview (DOM nodes get replaced on re-render).
	        try { if (solveState._memoShareHoverTip) solveState._memoShareHoverTip.remove(); } catch { }
	        solveState._memoShareHoverTip = null;
	
	        const hideHoverTip = () => {
	          try { if (solveState._memoShareHoverTip) solveState._memoShareHoverTip.remove(); } catch { }
	          solveState._memoShareHoverTip = null;
	        };
	        const positionHoverTip = (tip, ev) => {
	          if (!tip || !ev) return;
	          const margin = 10;
	          const px = Number(ev.pageX || 0);
	          const py = Number(ev.pageY || 0);
	          const vx = window.scrollX, vy = window.scrollY, vw = window.innerWidth, vh = window.innerHeight;
	          const tr = tip.getBoundingClientRect();
	          let x = px + 12;
	          let y = py - tr.height - margin;
	          x = Math.max(vx + 8, Math.min(vx + vw - tr.width - 8, x));
	          if (y < vy + 8) y = py + margin;
	          if (y > vy + vh - 8) y = Math.max(vy + 8, vy + vh - tr.height - 8);
	          tip.style.left = x + 'px';
	          tip.style.top = y + 'px';
	        };
	        const ensureHoverTip = (qid, ev) => {
	          const q = String(qid || '').trim();
	          if (!q) return;
	          let tip = solveState._memoShareHoverTip || null;
	          if (!tip) {
	            tip = document.createElement('div');
	            tip.className = 'memo-pop problem-hover-preview md';
	            tip.dataset.qid = q;
	            document.body.appendChild(tip);
	            solveState._memoShareHoverTip = tip;
	          }
	          if (tip.dataset.qid !== q) {
	            tip.dataset.qid = q;
	            tip.innerHTML = '';
	          }
	          if (!tip.innerHTML.trim()) {
	            const p0 = (sess.problemMap && sess.problemMap[q]) ? sess.problemMap[q] : (problems && problems.byQid ? problems.byQid[q] : null);
	            const p = p0 ? applyProblemOverrides(p0) : null;
	            const qHtml = p ? renderMarkdown(stripAnswerEmphasis(p.question_text || ''), { breaks: true }, 'sanitizeThenParse') : `<div class="muted">ë¬¸ì œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</div>`;
	            const cRaw = p ? stripAnswerEmphasis(p.answer_choices || '') : '';
	            const cHtml = (cRaw && String(cRaw).trim())
	              ? `<div style="margin-top:8px; font-size:13px;">${sanitize(formatAnswerChoices(cRaw, ''))}</div>`
	              : '';
	            tip.innerHTML = `<div class="muted" style="font-size:12px; margin-bottom:6px;">${sanitize(q)}</div>${qHtml}${cHtml}`;
	            try { insertBreaksBeforeCircled(tip); } catch { }
	            try { applyInlineBoldMarkers(tip); } catch { }
	            try { typesetMath(tip); } catch { }
	          }
	          positionHoverTip(tip, ev);
	        };
	
	        box.innerHTML = '';
	        list.forEach(qid => {
	          const q = String(qid || '').trim();
	          if (!q) return;
	          const n = extractQuestionNumberFromQid(q);
	          const local = q.includes('::') ? q.split('::')[1] : q;
	          let label = (n != null) ? String(n) : String(local || '').replace(/^Q\s*/i, '');
	          if (!label) label = String(local || '?');
	
	          const wrap = document.createElement('div');
	          wrap.className = 'quick-item';
	
	          const btn = document.createElement('button');
	          btn.type = 'button';
	          btn.className = 'btn quick-qbtn';
	          btn.dataset.qid = q;
	          btn.textContent = label;
	          btn.title = `${q}\ní´ë¦­: ì´ë™`;
	
	          const owner = getMemoOwnerKey(q);
	          if (curOwner && owner === curOwner) btn.classList.add('shared-here');
	          else if (owner && owner !== q) btn.classList.add('shared-else');
	
	          const slot = sess.answers && typeof sess.answers === 'object' ? sess.answers[q] : null;
	          if (slot && slot.choice) btn.classList.add('answered');
	          if (curQid && q === curQid) btn.classList.add('current');
	
	          btn.addEventListener('click', (ev) => {
	            ev.preventDefault();
	            ev.stopPropagation();
	            hideHoverTip();
	            if (!solveState.session) return;
	            let listNow = activeSolveQueue();
	            let idxNow = listNow.indexOf(q);
	            if (idxNow < 0) {
	              solveState.reviewFilter = 'all';
	              solveState.reviewTag = '';
	              solveState.reviewMarkedOnly = false;
	              listNow = activeSolveQueue();
	              idxNow = listNow.indexOf(q);
	            }
	            if (idxNow < 0) return;
	            solveState.session.current = idxNow;
	            renderSolveQuestion();
	          });
	          btn.addEventListener('mouseenter', (ev) => ensureHoverTip(q, ev));
	          btn.addEventListener('mousemove', (ev) => ensureHoverTip(q, ev));
	          btn.addEventListener('mouseleave', () => hideHoverTip());
	
	          const linkBtn = document.createElement('button');
	          linkBtn.type = 'button';
	          linkBtn.className = 'btn quick-linkbtn';
	          linkBtn.textContent = 'ğŸ”—';
	          linkBtn.title = selected.has(q) ? 'ê²°ì† ëŒ€ìƒ(ì„ íƒë¨)' : 'ê²°ì† ëŒ€ìƒ ì„ íƒ';
	          linkBtn.classList.toggle('selected', selected.has(q));
	          linkBtn.addEventListener('click', (ev) => {
	            ev.preventDefault();
	            ev.stopPropagation();
	            if (selected.has(q)) selected.delete(q); else selected.add(q);
	            linkBtn.classList.toggle('selected', selected.has(q));
	            linkBtn.title = selected.has(q) ? 'ê²°ì† ëŒ€ìƒ(ì„ íƒë¨)' : 'ê²°ì† ëŒ€ìƒ ì„ íƒ';
	          });
	
	          wrap.appendChild(btn);
	          wrap.appendChild(linkBtn);
	
	          if (owner && owner !== q) {
	            const unlinkBtn = document.createElement('button');
	            unlinkBtn.type = 'button';
	            unlinkBtn.className = 'btn quick-unlinkbtn';
	            unlinkBtn.textContent = 'â†©';
	            unlinkBtn.title = `ì´ ë¬¸ì œë§Œ ë©”ëª¨ ê³µìœ  í•´ì œ (í˜„ì¬ ê¸°ì¤€: ${owner})`;
	            unlinkBtn.addEventListener('click', (ev) => {
	              ev.preventDefault();
	              ev.stopPropagation();
	              hideHoverTip();
	              unlinkProblemMemos(q);
	              // refresh current memo view (if current problem is affected)
	              const activeNow = activeSolveQueue();
	              const curIdxNow = (typeof sess.current === 'number') ? sess.current : 0;
	              const curNow = activeNow.length ? activeNow[Math.max(0, Math.min(curIdxNow, activeNow.length - 1))] : '';
	              if (curNow) {
	                const curSpan = $('#solveMemoLinkCurrent');
	                if (curSpan) curSpan.textContent = getMemoOwnerKey(curNow);
	                renderProblemMemoList(curNow, $('#solveMemoList'), $('#solveMemoArea'));
	              }
	              renderSolveMemoSharePicker();
	              statusEl.textContent = 'ë©”ëª¨ ê³µìœ ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.';
	            });
	            wrap.appendChild(unlinkBtn);
	          }
	
	          box.appendChild(wrap);
	        });
	      }
	
	      $('#solveMemoSharePickerToggle')?.addEventListener('click', () => {
	        if (!solveState.session) return;
	        const box = $('#solveMemoSharePicker'); if (!box) return;
	        const shouldShow = (box.style.display === 'none' || !box.style.display);
	        box.style.display = shouldShow ? 'flex' : 'none';
	        if (shouldShow) renderSolveMemoSharePicker();
	      });
	      $('#solveMemoSharePickerClear')?.addEventListener('click', () => {
	        try { solveState.memoShareSelected?.clear?.(); } catch { }
	        renderSolveMemoSharePicker();
	        try { maybeRenderMemoShareManager(); } catch { }
	      });
	      $('#solveMemoSharePickerApply')?.addEventListener('click', () => {
	        const sess = solveState.session;
	        if (!sess) return;
	        const picked = Array.from(solveState.memoShareSelected || []).map(x => String(x || '').trim()).filter(Boolean);
	        const uniqPicked = Array.from(new Set(picked));
	        if (uniqPicked.length < 2) {
	          alert('ë©”ëª¨ ê³µìœ ë¡œ ë¬¶ì„ ë¬¸ì œë¥¼ 2ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”.');
	          return;
	        }
	
	        const active = activeSolveQueue();
	        const curIdx = (typeof sess.current === 'number') ? sess.current : 0;
	        const curQid = active.length ? active[Math.max(0, Math.min(curIdx, active.length - 1))] : '';

	        const oldestMemoTsFor = (qid) => {
	          try {
	            const memos = getProblemMemos(qid);
	            let min = Infinity;
	            (memos || []).forEach(m => {
	              const t = Number(m?.createdAt || m?.id || 0);
	              if (Number.isFinite(t) && t > 0 && t < min) min = t;
	            });
	            return min;
	          } catch {
	            return Infinity;
	          }
	        };
	        const orderIndex = new Map();
	        active.forEach((qid, i) => { orderIndex.set(String(qid || ''), i); });

	        // Base selection: prefer the problem that has the oldest memo (data preservation),
	        // fallback to "current problem if selected", else to current solve order.
	        const byOldest = uniqPicked
	          .map(qid => ({ qid, ts: oldestMemoTsFor(qid) }))
	          .sort((a, b) => {
	            const at = Number(a.ts || Infinity);
	            const bt = Number(b.ts || Infinity);
	            if (at !== bt) return at - bt;
	            const ai = orderIndex.has(a.qid) ? orderIndex.get(a.qid) : 1e9;
	            const bi = orderIndex.has(b.qid) ? orderIndex.get(b.qid) : 1e9;
	            return ai - bi;
	          });
	        const hasAnyMemo = byOldest.some(x => Number.isFinite(x.ts) && x.ts !== Infinity);
	        const fallbackFirst = uniqPicked.slice().sort((a, b) => (orderIndex.get(a) ?? 1e9) - (orderIndex.get(b) ?? 1e9))[0];
	        const baseCandidate = hasAnyMemo
	          ? byOldest[0]?.qid
	          : ((curQid && solveState.memoShareSelected.has(curQid)) ? curQid : (fallbackFirst || uniqPicked[0]));
	        const baseOwner = getMemoOwnerKey(baseCandidate);

	        // Merge memos into the chosen base owner (avoid losing existing memos across groups).
	        try {
	          const merged = [];
	          const seen = new Set();
	          uniqPicked.forEach(qid => {
	            const memos = getProblemMemos(qid);
	            (memos || []).forEach(m => {
	              if (!m) return;
	              const id = (m.id != null) ? String(m.id) : '';
	              if (id) {
	                if (seen.has(id)) return;
	                seen.add(id);
	              }
	              merged.push(m);
	            });
	          });
	          merged.sort((a, b) => Number(a?.createdAt || a?.id || 0) - Number(b?.createdAt || b?.id || 0));
	          if (merged.length) saveProblemMemos(baseOwner, merged);
	        } catch { }

	        uniqPicked.forEach(qid => {
	          if (!qid) return;
	          if (qid === baseOwner) return;
	          if (getMemoOwnerKey(qid) === baseOwner) return;
	          linkProblemMemos(qid, baseOwner);
	        });
	        try { solveState.memoShareSelected?.clear?.(); } catch { }
	        renderSolveMemoSharePicker();
	        try { maybeRenderMemoShareManager(); } catch { }
	
	        // refresh current memo view (if current problem is affected)
	        if (curQid) {
	          const curSpan = $('#solveMemoLinkCurrent');
	          if (curSpan) curSpan.textContent = getMemoOwnerKey(curQid);
	          renderProblemMemoList(curQid, $('#solveMemoList'), $('#solveMemoArea'));
	        }
	        statusEl.textContent = `ë©”ëª¨ ê³µìœ  ê²°ì†ë¨ (ê¸°ì¤€: ${baseOwner})`;
	      });

	      // ---- Visual memo-share manager (solve-order list + group list) ----
		      function renderMemoShareManager() {
		        const win = document.getElementById('memoShareManagerWindow');
		        const listEl = document.getElementById('memoShareManagerProblemList');
		        const groupsEl = document.getElementById('memoShareManagerGroupList');
	        const countEl = document.getElementById('memoShareManagerSelCount');
	        if (!win || !listEl || !groupsEl) return;

	        const sess = solveState.session;
	        const selected = solveState.memoShareSelected || new Set();
	        if (countEl) countEl.textContent = `ì„ íƒ ${selected.size}`;

	        if (!sess) {
	          listEl.innerHTML = '<div class="muted">ë¨¼ì € í’€ì´ ì„¸ì…˜ì„ ì‹œì‘í•˜ì„¸ìš”.</div>';
	          groupsEl.innerHTML = '';
	          return;
	        }

		        const queue = Array.isArray(sess.queue) ? sess.queue.map(x => String(x || '')).filter(Boolean) : [];
		        if (!queue.length) {
		          listEl.innerHTML = '<div class="muted">ì„¸ì…˜ íê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.</div>';
		          groupsEl.innerHTML = '';
		          return;
		        }
		
		        const curSolveQid = (() => {
		          try {
		            const q = activeSolveQueue();
		            if (!q || !q.length) return '';
		            let idx = (sess && typeof sess.current === 'number') ? sess.current : 0;
		            if (idx < 0) idx = 0;
		            if (idx >= q.length) idx = q.length - 1;
		            return String(q[idx] || '').trim();
		          } catch { return ''; }
		        })();
		        const curOwner = curSolveQid ? getMemoOwnerKey(curSolveQid) : '';

		        const orderIndex = new Map();
		        queue.forEach((qid, i) => orderIndex.set(qid, i));

	        const getProblem = (qid) => {
	          const q = String(qid || '').trim();
	          if (!q) return null;
	          const raw = (sess.problemMap && sess.problemMap[q]) ? sess.problemMap[q] : (problems.byQid ? problems.byQid[q] : null);
	          if (!raw) return { qid: q, question_text: '', answer_choices: '', official_answer: undefined, official_explanation: '' };
	          return applyProblemOverrides(raw);
	        };
	        const buildSnippet = (p) => {
	          if (!p) return '';
	          const q = stripAnswerEmphasis(p.question_text || '').replace(/\r\n/g, '\n').trim();
	          const c = stripAnswerEmphasis(p.answer_choices || '').replace(/\r\n/g, '\n').trim();
	          const qLines = q ? q.split('\n').filter(x => x.trim()).slice(0, 8).join('\n') : '';
	          const cLines = c ? c.split('\n').filter(x => x.trim()).slice(0, 10).join('\n') : '';
	          return (qLines + (cLines ? `\n${cLines}` : '')).trim();
	        };

	        // Build memo groups for current solve queue.
	        const groupMap = new Map(); // owner -> { owner, members: [] }
	        queue.forEach(qid => {
	          const owner = getMemoOwnerKey(qid);
	          if (!groupMap.has(owner)) groupMap.set(owner, { owner, members: [] });
	          groupMap.get(owner).members.push(qid);
	        });
	        const groups = Array.from(groupMap.values()).map(g => {
	          const members = Array.isArray(g.members) ? g.members.slice() : [];
	          members.sort((a, b) => (orderIndex.get(a) ?? 1e9) - (orderIndex.get(b) ?? 1e9));
	          const firstIdx = members.length ? (orderIndex.get(members[0]) ?? 1e9) : 1e9;
	          return { owner: g.owner, members, firstIdx };
	        }).sort((a, b) => a.firstIdx - b.firstIdx);

		        // Problems list (solve order)
		        listEl.innerHTML = queue.map(qid => {
		          const p = getProblem(qid);
		          const tag = getEffectiveTag(qid);
		          const owner = getMemoOwnerKey(qid);
		          const isSelected = selected.has(qid);
		          const isCurrent = curSolveQid && String(qid) === String(curSolveQid);
		          const snippet = buildSnippet(p);
		          const ownerPill = (owner && owner !== qid)
		            ? `<span class="pill" title="ë©”ëª¨ ê³µìœ  ê¸°ì¤€">${escapeHtml(owner)}</span>`
		            : `<span class="pill" title="ë‹¨ë… ë©”ëª¨">ë‹¨ë…</span>`;
		          return `<div class="share-card ${isSelected ? 'selected' : ''} ${isCurrent ? 'current' : ''}" data-qid="${escapeHtml(qid)}" ${isCurrent ? 'aria-current="true"' : ''}>
		            <div style="display:flex; justify-content:space-between; gap:8px; align-items:flex-start; flex-wrap:wrap;">
		              <label style="display:flex; gap:6px; align-items:center; cursor:pointer; min-width:0;">
		                <input type="checkbox" data-act="shareSel" data-qid="${escapeHtml(qid)}" ${isSelected ? 'checked' : ''}>
		                <span class="tag-badge">${tag}</span>
	                <span style="overflow-wrap:anywhere;">${escapeHtml(qid)}</span>
	              </label>
	              <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
	                ${ownerPill}
	                <button class="btn" data-act="shareGoto" data-qid="${escapeHtml(qid)}">ì´ë™</button>
	              </div>
	            </div>
	            ${snippet ? `<div class="share-snippet">${escapeHtml(snippet)}</div>` : ''}
	          </div>`;
	        }).join('');

		        // Groups list
		        groupsEl.innerHTML = groups.map(g => {
		          const owner = String(g.owner || '').trim();
		          const repQid = owner || (g.members && g.members[0]) || '';
		          const rep = repQid ? getProblem(repQid) : null;
		          const repSnippet = buildSnippet(rep);
		          const membersShort = (g.members || []).slice(0, 10).join(', ') + (((g.members || []).length > 10) ? ` â€¦(+${(g.members || []).length - 10})` : '');
		          const isCurrentGroup = curOwner && owner && String(owner) === String(curOwner);
		          return `<div class="share-card ${isCurrentGroup ? 'current' : ''}" data-owner="${escapeHtml(owner)}" ${isCurrentGroup ? 'aria-current="true"' : ''}>
		            <div style="display:flex; justify-content:space-between; gap:8px; align-items:flex-start; flex-wrap:wrap;">
		              <div style="min-width:0;">
		                <div><strong>${escapeHtml(owner || '(ê¸°ì¤€ ì—†ìŒ)')}</strong> <span class="pill">${(g.members || []).length}ë¬¸í•­</span></div>
		                <div class="share-mini">ë©¤ë²„: ${escapeHtml(membersShort)}</div>
	              </div>
	              <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
	                <button class="btn" data-act="shareApplyGroup" data-owner="${escapeHtml(owner)}">ì„ íƒâ†’ì´ ê·¸ë£¹</button>
	                <button class="btn" data-act="shareGotoGroup" data-owner="${escapeHtml(owner)}">ì´ë™</button>
	              </div>
	            </div>
	            ${repSnippet ? `<div class="share-snippet">${escapeHtml(repSnippet)}</div>` : ''}
	          </div>`;
	        }).join('') || '<div class="muted">ê³µìœ  ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤.</div>';

	        if (countEl) countEl.textContent = `ì„ íƒ ${selected.size}`;
	      }

	      function maybeRenderMemoShareManager() {
	        try {
	          const win = document.getElementById('memoShareManagerWindow');
	          if (win && win.classList.contains('active')) renderMemoShareManager();
	        } catch { }
	      }

	      // Solve window â†’ open/close manager
	      $('#solveMemoShareManagerToggle')?.addEventListener('click', () => {
	        const win = document.getElementById('memoShareManagerWindow');
	        if (!win) return;
	        const showing = win.classList.contains('active');
	        win.classList.toggle('active', !showing);
	        win.style.display = showing ? 'none' : '';
	        if (!showing) {
	          try { restoreSavedBox(win, 'fmm_ui_memoShareManagerWindow'); } catch { }
	          renderMemoShareManager();
	        }
	      });
	      $('#memoShareManagerRefresh')?.addEventListener('click', renderMemoShareManager);
	      $('#memoShareManagerSelectAll')?.addEventListener('click', () => {
	        const sess = solveState.session;
	        if (!sess) return;
	        const queue = Array.isArray(sess.queue) ? sess.queue.map(x => String(x || '')).filter(Boolean) : [];
	        const sel = solveState.memoShareSelected || new Set();
	        sel.clear();
	        queue.forEach(qid => sel.add(qid));
	        solveState.memoShareSelected = sel;
	        renderMemoShareManager();
	        try { if ($('#solveMemoSharePicker')?.style.display !== 'none') renderSolveMemoSharePicker(); } catch { }
	      });
	      $('#memoShareManagerSelectNone')?.addEventListener('click', () => {
	        try { solveState.memoShareSelected?.clear?.(); } catch { }
	        renderMemoShareManager();
	        try { if ($('#solveMemoSharePicker')?.style.display !== 'none') renderSolveMemoSharePicker(); } catch { }
	      });
	      $('#memoShareManagerMakeGroup')?.addEventListener('click', () => {
	        const sess = solveState.session;
	        if (!sess) return;
	        const queue = Array.isArray(sess.queue) ? sess.queue.map(x => String(x || '')).filter(Boolean) : [];
	        const picked = queue.filter(qid => solveState.memoShareSelected && solveState.memoShareSelected.has(qid));
	        if (picked.length < 2) {
	          alert('2ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”.');
	          return;
	        }
	        const baseCandidate = picked[0];
	        const baseOwner = getMemoOwnerKey(baseCandidate);
	        picked.forEach(qid => {
	          if (!qid || qid === baseOwner) return;
	          if (getMemoOwnerKey(qid) === baseOwner) return;
	          linkProblemMemos(qid, baseOwner);
	        });
	        try { solveState.memoShareSelected?.clear?.(); } catch { }
	        renderMemoShareManager();
	        try { if ($('#solveMemoSharePicker')?.style.display !== 'none') renderSolveMemoSharePicker(); } catch { }
	        statusEl.textContent = `ë©”ëª¨ ê³µìœ  ê²°ì†ë¨ (ê¸°ì¤€: ${baseOwner})`;
	      });
	      $('#memoShareManagerUnlinkSelected')?.addEventListener('click', () => {
	        const sess = solveState.session;
	        if (!sess) return;
	        const queue = Array.isArray(sess.queue) ? sess.queue.map(x => String(x || '')).filter(Boolean) : [];
	        const picked = queue.filter(qid => solveState.memoShareSelected && solveState.memoShareSelected.has(qid));
	        if (!picked.length) {
	          alert('ê³µìœ  í•´ì œí•  ë¬¸ì œë¥¼ ì„ íƒí•˜ì„¸ìš”.');
	          return;
	        }
	        picked.forEach(qid => unlinkProblemMemos(qid));
	        try { solveState.memoShareSelected?.clear?.(); } catch { }
	        renderMemoShareManager();
	        try { if ($('#solveMemoSharePicker')?.style.display !== 'none') renderSolveMemoSharePicker(); } catch { }
	        statusEl.textContent = 'ë©”ëª¨ ê³µìœ ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.';
	      });

	      // Delegate clicks (select / goto / apply group) inside the manager window.
	      (function mountMemoShareManagerDelegation() {
	        const win = document.getElementById('memoShareManagerWindow');
	        if (!win || win.dataset.mounted === '1') return;
	        win.dataset.mounted = '1';
	        win.addEventListener('click', (ev) => {
	          const btn = ev.target.closest('button[data-act]');
	          const act = btn ? String(btn.dataset.act || '') : '';
	          if (btn && act === 'shareGoto') {
	            const qid = btn.dataset.qid || '';
	            const sess = solveState.session;
	            if (!qid || !sess) return;
	            const idx = (sess.queue || []).findIndex(x => String(x) === String(qid));
	            if (idx >= 0) {
	              sess.current = idx;
	              try { persistActiveSolveSession(sess); } catch { }
	              renderSolveQuestion();
	            }
	            return;
	          }
	          if (btn && act === 'shareGotoGroup') {
	            const owner = btn.dataset.owner || '';
	            const sess = solveState.session;
	            if (!sess) return;
	            const qid = owner && (sess.queue || []).some(x => String(x) === owner) ? owner : '';
	            const target = qid || (sess.queue || [])[0] || '';
	            const idx = (sess.queue || []).findIndex(x => String(x) === String(target));
	            if (idx >= 0) {
	              sess.current = idx;
	              try { persistActiveSolveSession(sess); } catch { }
	              renderSolveQuestion();
	            }
	            return;
	          }
	          if (btn && act === 'shareApplyGroup') {
	            const owner = String(btn.dataset.owner || '').trim();
	            if (!owner) return;
	            const picked = Array.from(solveState.memoShareSelected || []).map(x => String(x || '').trim()).filter(Boolean);
	            if (!picked.length) {
	              alert('ë¨¼ì € ë¬¸ì œë¥¼ ì„ íƒí•˜ì„¸ìš”.');
	              return;
	            }
	            const baseOwner = getMemoOwnerKey(owner);
	            picked.forEach(qid => {
	              if (!qid || qid === baseOwner) return;
	              if (getMemoOwnerKey(qid) === baseOwner) return;
	              linkProblemMemos(qid, baseOwner);
	            });
	            try { solveState.memoShareSelected?.clear?.(); } catch { }
	            renderMemoShareManager();
	            try { if ($('#solveMemoSharePicker')?.style.display !== 'none') renderSolveMemoSharePicker(); } catch { }
	            statusEl.textContent = `ë©”ëª¨ ê³µìœ  ê²°ì†ë¨ (ê¸°ì¤€: ${baseOwner})`;
	            return;
	          }

	          const cb = ev.target.closest('input[type="checkbox"][data-act="shareSel"]');
	          if (cb) {
	            const qid = String(cb.dataset.qid || '');
	            if (!qid) return;
	            if (!solveState.memoShareSelected) solveState.memoShareSelected = new Set();
	            if (cb.checked) solveState.memoShareSelected.add(qid);
	            else solveState.memoShareSelected.delete(qid);
	            renderMemoShareManager();
	            try { if ($('#solveMemoSharePicker')?.style.display !== 'none') renderSolveMemoSharePicker(); } catch { }
	          }
	        });
	      })();

	      function promptMissingOfficial(missing) {
	        const dlg = document.getElementById('gradeMissingDialog');
	        const textEl = document.getElementById('gradeMissingText');
        if (!dlg) return Promise.resolve('cancel');
        const list = Array.isArray(missing) ? missing : [];
        const qids = list.map(p => p?.qid).filter(Boolean);
        const preview = qids.slice(0, 6).join(', ');
        if (textEl) {
          textEl.textContent = `ê³µì‹ ì •ë‹µì´ ì—†ëŠ” ë¬¸ì œ ${qids.length}ê°œê°€ ìˆìŠµë‹ˆë‹¤.\n` +
            `- LLMìœ¼ë¡œ ì±„ìš°ê¸°: ì±„ìš´ ë’¤ ìë™ì±„ì \n` +
            `- ìŠ¤í‚µí•˜ê³  ì±„ì : ê³µì‹ ì •ë‹µ ì—†ëŠ” ë¬¸ì œëŠ” ë¯¸ì±„ì (ìŠ¤í‚µ) ì²˜ë¦¬\n` +
            (preview ? `\n(ì˜ˆ: ${preview}${qids.length > 6 ? ' â€¦' : ''})` : '');
        }
        return new Promise((resolve) => {
          const btnCancel = document.getElementById('gradeMissingCancel');
          const btnSkip = document.getElementById('gradeMissingSkip');
          const btnFill = document.getElementById('gradeMissingFill');
          const cleanup = () => {
            btnCancel?.removeEventListener('click', onCancel);
            btnSkip?.removeEventListener('click', onSkip);
            btnFill?.removeEventListener('click', onFill);
          };
          const onCancel = () => { cleanup(); try { dlg.close(); } catch { } resolve('cancel'); };
          const onSkip = () => { cleanup(); try { dlg.close(); } catch { } resolve('skip'); };
          const onFill = () => { cleanup(); try { dlg.close(); } catch { } resolve('fill'); };
          btnCancel?.addEventListener('click', onCancel);
          btnSkip?.addEventListener('click', onSkip);
          btnFill?.addEventListener('click', onFill);
          try { dlg.showModal(); } catch { dlg.style.display = ''; }
        });
      }

	      async function gradeSession(opts) {
	        if (!solveState.session) return;
	        opts = opts || {};
	        const skipMissingOfficial = !!opts.skipMissingOfficial;
	        let session = solveState.session;
	        let now = Date.now();
	        if (!session.id) session.id = 'S' + now;
	        if (!session.startedAt) session.startedAt = now;
	        let isReviewRegrade = session.reviewOnly || !!session.graded;

	        function reviewAnswersChanged(sess) {
	          if (!sess || !sess.reviewOnly) return false;
	          const base = sess.reviewBaseChoices;
	          if (!base || typeof base !== 'object') return false;
	          const q = Array.isArray(sess.queue) ? sess.queue : [];
	          for (const qid of q) {
	            const baseChoice = base[qid] ?? null;
	            const curChoice = sess.answers?.[qid]?.choice ?? null;
	            if (baseChoice !== curChoice) return true;
	          }
	          return false;
	        }

	        // Review session: if answers were modified, offer to fork into a new graded session.
	        // If answers are unchanged, simply re-grade in-place (no new history entry).
	        if (session.reviewOnly && session.result && !opts.forceRegrade) {
	          if (reviewAnswersChanged(session)) {
	            const ok = confirm('ê²€í†  ê¸°ë¡ì€ ìœ ì§€ë©ë‹ˆë‹¤. ì„ íƒí•œ ë‹µì„ ìœ ì§€í•œ ì±„ë¡œ ìƒˆ í’€ì´ ì„¸ì…˜ì„ ì‹œì‘í• ê¹Œìš”?');
	            if (!ok) {
	              renderSolveReview(solveState.reviewMode || 'wrong');
	              return;
	            }
	            const selected = (session.queue || []).map(qid => session.problemMap[qid] || getProblemForQid(qid)).filter(Boolean);
	            if (!selected.length) {
	              alert('ë¬¸ì œ ëª©ë¡ì„ ë³µì›í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
	              return;
	            }
	            const prevAnswers = {};
	            Object.entries(session.answers || {}).forEach(([qid, a]) => {
	              if (!a) return;
	              prevAnswers[qid] = {
	                choice: a.choice || null,
	                correct: (typeof a.result === 'boolean') ? a.result : null
	              };
	            });
	            startSolveSession(selected, {
	              typeTitle: session.typeTitle,
	              sheetId: session.sheetId || null,
	              sheetName: session.sheetName || null,
	              reviewOnly: false,
	              answers: prevAnswers
	            });
	            session = solveState.session;
	            now = Date.now();
	            if (!session.id) session.id = 'S' + now;
	            if (!session.startedAt) session.startedAt = now;
	            isReviewRegrade = session.reviewOnly || !!session.graded;
	          }
	        }

        // Ensure we have an original snapshot for revert (reviewOnly sessions).
        if (session.reviewOnly && !session.reviewOriginal) {
          session.reviewOriginal = {
            result: session.result ? JSON.parse(JSON.stringify(session.result)) : null,
            answers: null,
            baseChoices: JSON.parse(JSON.stringify(session.reviewBaseChoices || {}))
          };
        }

        // 1) ì±„ì  ì „ì— ê³µì‹ ì •ë‹µì´ ë¹„ì–´ ìˆëŠ” ë¬¸ì œ í™•ì¸
        //    í•­ìƒ applyProblemOverrides ë¥¼ ë‹¤ì‹œ ì ìš©í•´ ìµœì‹  ê³µì‹ ì •ë‹µ/í•´ì„¤ì„ ë°˜ì˜í•œë‹¤.
        const missingProblems = [];
        session.queue.forEach(qid => {
          const base = session.problemMap[qid];
          if (!base) return;
          const merged = applyProblemOverrides(base);
          const official = getOfficialAnswerText(merged.official_answer);
          if (!official) missingProblems.push(merged);
          session.problemMap[qid] = merged;
        });
        if (missingProblems.length && !skipMissingOfficial) {
          const action = await promptMissingOfficial(missingProblems);
          if (action === 'fill') {
            toggleAnswerPanel(true);
            llmFillState.mode = 'solve';
            llmFillState.pendingQids = missingProblems.map(p => String(p.qid || '')).filter(Boolean);
            llmFillRefresh();
            if (answerAPI.settings.endpoint) {
              $('#ansStatus').textContent = `ê³µì‹ ì •ë‹µì´ ì—†ëŠ” ë¬¸ì œ ${missingProblems.length}ê°œê°€ ìˆìŠµë‹ˆë‹¤. ìƒë‹¨ ì„¤ì •ì„ í™•ì¸í•œ ë’¤, "ì´ ì„¤ì •ìœ¼ë¡œ ì±„ìš°ê¸°" ë²„íŠ¼ì„ ëˆŒëŸ¬ ì±„ìš´ ë‹¤ìŒ ìë™ì±„ì ë©ë‹ˆë‹¤.`;
            } else {
              $('#ansStatus').textContent = `ê³µì‹ ì •ë‹µì´ ì—†ëŠ” ë¬¸ì œ ${missingProblems.length}ê°œê°€ ìˆìŠµë‹ˆë‹¤. ë¨¼ì € LLM Endpoint ì„¤ì •ì„ ì…ë ¥í•˜ì„¸ìš”.`;
            }
            return;
          }
          if (action === 'skip') {
            await gradeSession({ skipMissingOfficial: true });
          }
          return; // cancel or after skip
        }

        // 2) ì‹¤ì œ ì±„ì  ìˆ˜í–‰
        const result = { correct: [], wrong: [], skipped: [] };
        session.queue.forEach(qid => {
          const problem = session.problemMap[qid];
          if (!problem) return;
          const slot = ensureAnswerSlot(qid);
          const official = getOfficialAnswerText(problem.official_answer);
          let verdict = null;
          if (!official) {
            // ê³µì‹ ì •ë‹µì´ ì—†ìœ¼ë©´ ì •ì˜¤ë¥¼ íŒë‹¨í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ í†µê³„ì— ë°˜ì˜í•˜ì§€ ì•ŠìŒ
            result.skipped.push(qid);
            slot.result = null;
          } else if (!slot.choice) {
            // ë¬´ì‘ë‹µ(ìŠ¤í‚µ)ì€ "í‹€ë¦° ê²ƒ"ìœ¼ë¡œ ê°„ì£¼í•˜ë˜, ìš”ì•½ì—ì„œëŠ” ìŠ¤í‚µìœ¼ë¡œë„ í‘œì‹œ
            result.skipped.push(qid);
            result.wrong.push(qid);
            slot.result = false;
            verdict = false;
          } else {
            const ok = isAnswerCorrect(slot.choice, official, parseChoices(problem.answer_choices || ''));
            slot.result = ok;
            verdict = ok;
            if (ok) result.correct.push(qid); else result.wrong.push(qid);
          }
          if (!isReviewRegrade) {
            recordProblemAttempt(qid, {
              sessionId: session.id,
              choice: slot.choice || null,
              official: official || null,
              correct: verdict
            });
          }
        });
	        session.result = result;
	        if (session.reviewOnly && isReviewRegrade) {
	          session.reviewRegraded = true;
	        }
	        if (!session.reviewOnly && isReviewRegrade && session.gradeOriginal?.result) {
	          session.gradeRegraded = true;
	        }
	        // ê° ë¬¸í•­ë³„ ì„ íƒ ë³´ê¸°/ì •ë‹µ ì—¬ë¶€ ìŠ¤ëƒ…ìƒ· ì €ì¥ (ì‹œí—˜ ê¸°ë¡ì—ì„œ ì¬êµ¬ì„±ìš©)
	        const answersSnapshot = {};
	        session.queue.forEach(qid => {
	          const slot = ensureAnswerSlot(qid);
	          const problem = session.problemMap[qid];
          const official = problem ? getOfficialAnswerText(problem.official_answer) : '';
          answersSnapshot[qid] = {
            choice: slot.choice || null,
            correct: typeof slot.result === 'boolean' ? slot.result : null,
	            official: official || null
	          };
	        });
	        const markedSnapshot = (session.marked && typeof session.marked === 'object')
	          ? Object.keys(session.marked).filter(qid => session.marked[qid] === true)
	          : [];
	        if (!isReviewRegrade) {
	          if (!session.reviewOnly && !session.gradeOriginal) {
	            const baseChoices = {};
	            session.queue.forEach(qid => { baseChoices[qid] = answersSnapshot[qid]?.choice ?? null; });
	            session.gradeOriginal = {
	              result: JSON.parse(JSON.stringify(result)),
	              answers: JSON.parse(JSON.stringify(answersSnapshot)),
	              baseChoices: JSON.parse(JSON.stringify(baseChoices))
	            };
	            session.gradeRegraded = false;
	          }
	          appendSolveHistory({
	            id: session.id,
	            typeTitle: session.typeTitle || currentTypeTitle(),
	            sheetId: session.sheetId || null,
	            sheetName: session.sheetName || null,
            startedAt: session.startedAt || now,
            gradedAt: now,
            total: session.queue.length,
            queue: Array.isArray(session.queue) ? session.queue.slice() : [],
	            correct: result.correct.slice(),
	            wrong: result.wrong.slice(),
	            skipped: result.skipped.slice(),
	            answers: answersSnapshot,
	            marked: markedSnapshot
	          });
	          session.graded = true;
	          if (typeof statsRenderSheetDetail === 'function') statsRenderSheetDetail();
	        }
        if (typeof solveWindow !== 'undefined' && solveWindow) {
          solveWindow.classList.add('active');
          solveWindow.style.display = '';
          restoreSavedBox(solveWindow, 'fmm_ui_solveWindow');
        }
        renderSolveReview(solveState.reviewMode || 'wrong');
      }
      $('#solveGrade').addEventListener('click', () => { gradeSession(); });

	      function renderSolveReview(mode) {
	        if (!solveState.session || !solveState.session.result) return;
	        solveState.reviewMode = mode;
	        solveState.reviewFilter = (mode === 'wrong' || mode === 'correct') ? mode : 'all';
	        $('#solveReview').classList.add('active');
	        $('#solvePlay').classList.remove('active');
	        $('#solveSetup').classList.remove('active');
	        const { correct, wrong, skipped } = solveState.session.result;
	        const skipInfo = skipped.length ? ` (ì´ ì¤‘ ìŠ¤í‚µ ${skipped.length})` : '';
	        const regradedNote = (solveState.session.reviewOnly ? solveState.session.reviewRegraded : solveState.session.gradeRegraded) ? ' Â· (ì¬ì±„ì ë¨)' : '';
	        $('#solveReviewSummary').textContent = `ë§ìŒ ${correct.length} Â· í‹€ë¦¼ ${wrong.length}${skipInfo}${regradedNote}`;
	        const restoreBtn = $('#solveReviewRestore');
	        if (restoreBtn) {
	          const canRestoreReview = solveState.session.reviewOnly && !!solveState.session.reviewOriginal?.result && solveState.session.reviewRegraded;
	          const canRestoreSolve = !solveState.session.reviewOnly && !!solveState.session.gradeOriginal?.result && solveState.session.gradeRegraded;
	          restoreBtn.style.display = (canRestoreReview || canRestoreSolve) ? '' : 'none';
	        }
        let baseList = [];
        const base = Array.isArray(solveState.session.queue) ? solveState.session.queue.slice() : [];
        const wrongSet = new Set(Array.isArray(wrong) ? wrong : []);
        const correctSet = new Set(Array.isArray(correct) ? correct : []);
        if (mode === 'correct') baseList = base.filter(qid => correctSet.has(qid));
        else if (mode === 'all') baseList = base;
        else baseList = base.filter(qid => wrongSet.has(qid));
	        const exMasteredEl = $('#solveReviewExcludeMastered');
	        if (exMasteredEl) {
	          exMasteredEl.checked = !!solveState.reviewExcludeMastered;
	          exMasteredEl.style.display = (mode === 'correct') ? '' : 'none';
	        }
	        if (mode === 'correct' && solveState.reviewExcludeMastered) {
	          baseList = baseList.filter(qid => getEffectiveTag(qid) !== 'âœ…');
	        }
	        const tagFilterEl = $('#solveReviewTagFilter');
	        if (tagFilterEl) {
	          // ìƒíƒœ ê°ì²´ì™€ ì…€ë ‰íŠ¸ ê°’ì„ ë™ê¸°í™”
	          if (typeof solveState.reviewTag === 'string') tagFilterEl.value = solveState.reviewTag || '';
	        }
	        const tagFilter = solveState.reviewTag || (tagFilterEl ? (tagFilterEl.value || '') : '');
	        const list = tagFilter
	          ? baseList.filter(qid => getEffectiveTag(qid) === tagFilter)
	          : baseList;
	        const markedOnlyEl = $('#solveReviewMarkedOnly');
	        if (markedOnlyEl) markedOnlyEl.checked = !!solveState.reviewMarkedOnly;
		        const marked = solveState.session.marked || {};
		        const filtered = solveState.reviewMarkedOnly ? list.filter(qid => marked[String(qid)] === true) : list;
		        const box = $('#solveReviewList');
		        const sel = solveState.reviewSelected || new Set();
		        box.innerHTML = filtered.length ? filtered.map(qid => {
		          const st = getProblemState(qid);
		          const tag = getEffectiveTag(qid);
		          const wrongCount = st.wrongCount || 0;
		          const attempts = st.attempts || 0;
		          const correctCount = st.correctCount || 0;
		          const accuracy = attempts > 0 ? Math.round((correctCount / attempts) * 100) : 0;
		          const pinned = marked[String(qid)] === true ? ' Â· ğŸ“' : '';
		          const checked = sel.has(qid) ? 'checked' : '';
		          const safeQid = escapeHtml(qid);
		          return `<div class="item" data-qid="${safeQid}">
		            <input type="checkbox" class="review-sel" data-qid="${safeQid}" ${checked}>
		            <div class="review-line"><strong>${safeQid}</strong>${pinned} Â· íƒœê·¸ ${escapeHtml(tag)} Â· ì˜¤ë‹µ ${wrongCount} / í’€ì´ ${attempts} Â· ì •ë‹µë¥  ${accuracy}%</div>
		          </div>`;
		        }).join('') : '<div class="muted">ì—†ìŒ</div>';
		        const selPill = $('#solveReviewSelCount');
		        const updateSelPill = () => {
		          if (!selPill) return;
		          const n = box.querySelectorAll('input.review-sel:checked').length;
		          selPill.textContent = `ì„ íƒ ${n}`;
		        };
		        updateSelPill();
		        box.querySelectorAll('input.review-sel').forEach(cb => {
		          cb.addEventListener('change', () => {
		            const qid = cb.dataset.qid;
		            if (!qid) return;
		            if (cb.checked) sel.add(qid); else sel.delete(qid);
		            updateSelPill();
		          });
		        });
		        box.querySelectorAll('.item').forEach(el => {
		          el.addEventListener('click', (ev) => {
		            if (ev.target && ev.target.closest && ev.target.closest('input.review-sel')) return;
		            const qid = el.dataset.qid;
		            if (!qid) return;
		            const active = activeSolveQueue();
		            const idx = active.indexOf(qid);
		            if (idx >= 0) {
		              solveState.session.current = idx;
		              renderSolveQuestion();
		              revealForCurrent();
		            }
		          });
		        });
		      }
      $('#solveReviewWrong').addEventListener('click', () => renderSolveReview('wrong'));
      $('#solveReviewCorrect').addEventListener('click', () => renderSolveReview('correct'));
      $('#solveReviewAll').addEventListener('click', () => renderSolveReview('all'));
      $('#solveReviewSimilarBtn')?.addEventListener('click', () => {
        const sess = solveState.session;
        if (!sess) return;
        const q = activeSolveQueue();
        if (!q.length) return;
        let idx = sess.current || 0;
        if (idx < 0) idx = 0;
        if (idx >= q.length) idx = q.length - 1;
        const qid = q[idx];
        if (qid && typeof window.openSimilarWindowForQid === 'function') window.openSimilarWindowForQid(qid);
      });
      $('#solveReviewRestore')?.addEventListener('click', () => {
        const sess = solveState.session;
        if (!sess) return;
        const isReview = !!sess.reviewOnly;
        const snap = isReview ? sess.reviewOriginal : sess.gradeOriginal;
        const canRestore = isReview ? !!sess.reviewRegraded : !!sess.gradeRegraded;
        if (!canRestore || !snap?.result) return;
        const ok = confirm('ì²˜ìŒ ì±„ì  ìƒíƒœë¡œ ë˜ëŒë¦´ê¹Œìš”?\n(ì¬ì±„ì  ê²°ê³¼ëŠ” ì·¨ì†Œë©ë‹ˆë‹¤.)');
        if (!ok) return;
        try {
          sess.result = JSON.parse(JSON.stringify(snap.result));
          const baseChoices = snap.baseChoices || (isReview ? (sess.reviewBaseChoices || {}) : {});
          if (isReview) sess.reviewBaseChoices = JSON.parse(JSON.stringify(baseChoices || {}));
          const q = Array.isArray(sess.queue) ? sess.queue : [];
          const ansSnap = snap.answers;
          const nextAnswers = {};
          q.forEach(qid => {
            const a = ansSnap && ansSnap[qid] ? ansSnap[qid] : null;
            const choice = a ? (a.choice || null) : (baseChoices[qid] ?? null);
            nextAnswers[qid] = {
              choice,
              revealed: false,
              result: a && typeof a.correct === 'boolean' ? a.correct : null
            };
          });
          sess.answers = nextAnswers;
          if (isReview) sess.reviewRegraded = false;
          else sess.gradeRegraded = false;
        } catch { }
        renderSolveReview(solveState.reviewMode || 'wrong');
      });
      $('#solveRetakeWrong').addEventListener('click', () => {
        if (!solveState.session?.result) return;
        const wrong = solveState.session.result.wrong;
        if (!wrong.length) { alert('ì˜¤ë‹µì´ ì—†ìŠµë‹ˆë‹¤.'); return; }
        const selected = wrong.map(qid => solveState.session.problemMap[qid]).filter(Boolean);
        startSolveSession(selected);
      });
      $('#solveReviewMarkedOnly')?.addEventListener('change', (e) => {
        solveState.reviewMarkedOnly = !!e.target.checked;
        renderSolveReview(solveState.reviewMode || 'wrong');
      });
      $('#solveReviewExcludeMastered')?.addEventListener('change', (e) => {
        solveState.reviewExcludeMastered = !!e.target.checked;
        renderSolveReview(solveState.reviewMode || 'wrong');
      });
      $('#solveReviewTagFilter')?.addEventListener('change', (e) => {
        solveState.reviewTag = e.target.value || '';
        const mode = solveState.reviewMode || 'wrong';
        renderSolveReview(mode);
      });
      $('#solveBulkTagWrong').addEventListener('change', (e) => {
        if (!solveState.session?.result) return;
        const val = e.target.value; if (!val) return;
        solveState.session.result.wrong.forEach(qid => setProblemTag(qid, val));
        renderProblemsForCurrentType();
        renderSolveReview(solveState.reviewMode);
        e.target.value = '';
      });
	      $('#solveBulkTagCorrect').addEventListener('change', (e) => {
	        if (!solveState.session?.result) return;
	        const val = e.target.value; if (!val) return;
	        solveState.session.result.correct.forEach(qid => setProblemTag(qid, val));
	        renderProblemsForCurrentType();
	        renderSolveReview(solveState.reviewMode);
	        e.target.value = '';
	      });
	
	      function solveReviewSelectedQidsFromDom() {
	        const box = $('#solveReviewList');
	        if (!box) return [];
	        return Array.from(box.querySelectorAll('input.review-sel:checked'))
	          .map(cb => cb?.dataset?.qid || '')
	          .map(v => String(v || '').trim())
	          .filter(Boolean);
	      }
	      function solveReviewUpdateSelPillFromDom() {
	        const pill = $('#solveReviewSelCount');
	        const box = $('#solveReviewList');
	        if (!pill || !box) return;
	        const n = box.querySelectorAll('input.review-sel:checked').length;
	        pill.textContent = `ì„ íƒ ${n}`;
	      }
	      function solveHistoryIdForCurrentSession() {
	        const sess = solveState.session;
	        if (!sess) return null;
	        return sess.reviewOnly ? (sess.historyId || sess.id || null) : (sess.id || null);
	      }
	      function updateSolveHistoryVerdict(sessionId, qid, nextCorrect) {
	        const sid = String(sessionId || '').trim();
	        const q = String(qid || '').trim();
	        if (!sid || !q) return false;
	        const all = LS.get(SOLVE_HISTORY_KEY, []);
	        const idx = all.findIndex(h => h && String(h.id || '') === sid);
	        if (idx < 0) return false;
	        const entry = all[idx] || {};
	        const queue = Array.isArray(entry.queue) ? entry.queue.slice() : [];
	        const correct = new Set(Array.isArray(entry.correct) ? entry.correct : []);
	        const wrong = new Set(Array.isArray(entry.wrong) ? entry.wrong : []);
	        const skipped = new Set(Array.isArray(entry.skipped) ? entry.skipped : []);
	
	        correct.delete(q); wrong.delete(q); skipped.delete(q);
	        if (nextCorrect === true) correct.add(q);
	        else if (nextCorrect === false) wrong.add(q);
	
	        entry.correct = queue.length ? queue.filter(x => correct.has(x)) : Array.from(correct);
	        entry.wrong = queue.length ? queue.filter(x => wrong.has(x)) : Array.from(wrong);
	        entry.skipped = queue.length ? queue.filter(x => skipped.has(x)) : Array.from(skipped);
	
	        if (!entry.answers || typeof entry.answers !== 'object') entry.answers = {};
	        const prevA = entry.answers[q] || {};
	        entry.answers[q] = { ...prevA, correct: nextCorrect };
	
	        all[idx] = entry;
	        LS.set(SOLVE_HISTORY_KEY, all);
	        return true;
	      }
	      function updateProblemAttemptVerdict(qid, sessionId, nextCorrect) {
	        const q = String(qid || '').trim();
	        const sid = String(sessionId || '').trim();
	        if (!q || !sid) return false;
	        const st = getProblemState(q);
	        const history = Array.isArray(st.history) ? st.history.slice() : [];
	        let hit = -1;
	        for (let i = history.length - 1; i >= 0; i--) {
	          const h = history[i];
	          if (h && String(h.sessionId || '') === sid) { hit = i; break; }
	        }
	        if (hit < 0) {
	          // fallback: adjust counters only (imported data ë“±ìœ¼ë¡œ historyê°€ ëˆ„ë½ëœ ê²½ìš°)
	          let correctCount = st.correctCount || 0;
	          let wrongCount = st.wrongCount || 0;
	          if (nextCorrect === true && wrongCount > 0) {
	            wrongCount = Math.max(0, wrongCount - 1);
	            correctCount += 1;
	            updateProblemState(q, { correctCount, wrongCount, lastResult: 'correct' });
	            return true;
	          }
	          return false;
	        }
	        const prev = history[hit] || {};
	        const prevCorrect = prev.correct;
	        if (prevCorrect === nextCorrect) return true;
	        history[hit] = { ...prev, correct: nextCorrect };
	
	        let correctCount = st.correctCount || 0;
	        let wrongCount = st.wrongCount || 0;
	        if (prevCorrect === true) correctCount = Math.max(0, correctCount - 1);
	        if (prevCorrect === false) wrongCount = Math.max(0, wrongCount - 1);
	        if (nextCorrect === true) correctCount += 1;
	        if (nextCorrect === false) wrongCount += 1;
	
	        let last = null;
	        history.forEach(h => {
	          if (!h || typeof h.ts !== 'number') return;
	          if (!last || h.ts > last.ts) last = h;
	        });
	        const lastResult = last ? (last.correct === null ? 'skipped' : (last.correct ? 'correct' : 'wrong')) : (st.lastResult || '');
	        const lastAnswer = last ? (last.choice ?? null) : (st.lastAnswer ?? null);
	        const lastOfficial = last ? (last.official ?? null) : (st.lastOfficial ?? null);
	        const lastAttemptAt = last ? last.ts : (st.lastAttemptAt || null);
	
	        updateProblemState(q, {
	          correctCount,
	          wrongCount,
	          history,
	          lastResult,
	          lastAnswer,
	          lastOfficial,
	          lastAttemptAt
	        });
	        return true;
	      }
	      function updateSessionVerdictInMemory(qid, nextCorrect) {
	        const sess = solveState.session;
	        if (!sess || !sess.result) return;
	        const q = String(qid || '').trim();
	        if (!q) return;
	        const res = sess.result;
	        const queue = Array.isArray(sess.queue) ? sess.queue : [];
	        const correct = new Set(Array.isArray(res.correct) ? res.correct : []);
	        const wrong = new Set(Array.isArray(res.wrong) ? res.wrong : []);
	        const skipped = new Set(Array.isArray(res.skipped) ? res.skipped : []);
	
	        correct.delete(q); wrong.delete(q); skipped.delete(q);
	        if (nextCorrect === true) correct.add(q);
	        else if (nextCorrect === false) wrong.add(q);
	
	        res.correct = queue.filter(x => correct.has(x));
	        res.wrong = queue.filter(x => wrong.has(x));
	        res.skipped = queue.filter(x => skipped.has(x));
	
	        const slot = ensureAnswerSlot(q);
	        slot.result = nextCorrect;
	        sess.answers[q] = slot;
	      }
	
	      $('#solveReviewSelectAll')?.addEventListener('click', () => {
	        const box = $('#solveReviewList'); if (!box) return;
	        const sel = solveState.reviewSelected || new Set();
	        box.querySelectorAll('input.review-sel').forEach(cb => {
	          cb.checked = true;
	          const qid = cb.dataset.qid;
	          if (qid) sel.add(qid);
	        });
	        solveReviewUpdateSelPillFromDom();
	      });
	      $('#solveReviewSelectNone')?.addEventListener('click', () => {
	        const box = $('#solveReviewList'); if (!box) return;
	        box.querySelectorAll('input.review-sel').forEach(cb => { cb.checked = false; });
	        try { solveState.reviewSelected?.clear?.(); } catch { }
	        solveReviewUpdateSelPillFromDom();
	      });
	      $('#solveReviewBulkTagSelected')?.addEventListener('change', (e) => {
	        if (!solveState.session?.result) return;
	        const val = e.target.value; if (!val) return;
	        const targets = solveReviewSelectedQidsFromDom();
	        if (!targets.length) { alert('ì„ íƒëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.'); e.target.value = ''; return; }
	        targets.forEach(qid => setProblemTag(qid, val));
	        renderProblemsForCurrentType();
	        renderSolveReview(solveState.reviewMode);
	        e.target.value = '';
	      });
	      $('#solveReviewFixWrongToCorrect')?.addEventListener('click', () => {
	        const sess = solveState.session;
	        if (!sess?.result) return;
	        const targets = solveReviewSelectedQidsFromDom();
	        if (!targets.length) { alert('ì„ íƒëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.'); return; }
	        const sid = solveHistoryIdForCurrentSession();
	        if (!sid) { alert('ì„¸ì…˜ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
	        if (!confirm(`ì„ íƒí•œ ${targets.length}ë¬¸í•­ì„ 'ì •ë‹µ'ìœ¼ë¡œ ìˆ˜ì •í• ê¹Œìš”?\n(ëˆ„ì  ì˜¤ë‹µ ì§‘ê³„ì—ì„œ ì œì™¸ë©ë‹ˆë‹¤.)`)) return;
	
	        let changed = 0;
	        targets.forEach(qid => {
	          updateSessionVerdictInMemory(qid, true);
	          updateSolveHistoryVerdict(sid, qid, true);
	          if (updateProblemAttemptVerdict(qid, sid, true)) changed++;
	        });
	        try { solveState.reviewSelected?.clear?.(); } catch { }
	        renderProblemsForCurrentType();
	        renderSolveReview(solveState.reviewMode || 'wrong');
	        statusEl.textContent = `ì±„ì  ê¸°ë¡ ìˆ˜ì •ë¨ Â· ${changed}ë¬¸í•­`;
	      });

	      // === NEW: LLM fill for missing official answers ===============================
		      const DEFAULT_ANSWER_SETTINGS = {
		        endpoint: '',
		        proxyUrl: '',
		        apiKey: '',
		        model: '',
		        batchSize: 3,
		        includeTypeGuide: true,
		        includeProblemMemos: false,
		        memoEval: false,
		        memoEvalMode: 'repOrLatest',
		        overwriteExplanation: false,
		        bypassSystemRole: false
		      };
      const answerAPI = {
        settings: { ...DEFAULT_ANSWER_SETTINGS, ...(LS.get(ANSWER_API_KEY, {}) || {}) },
        save() { LS.set(ANSWER_API_KEY, this.settings); }
      };
		      let ansRunning = false;
		      let ansAbort = false;
			      function populateAnswerUI() {
			        $('#ansEndpoint').value = answerAPI.settings.endpoint || '';
			        $('#ansProxyUrl').value = answerAPI.settings.proxyUrl || '';
			        $('#ansApiKey').value = answerAPI.settings.apiKey || '';
			        $('#ansModel').value = answerAPI.settings.model || '';
			        $('#ansBatch').value = String(answerAPI.settings.batchSize || 3);
		        const useGuide = $('#ansUseTypeGuide');
		        if (useGuide) useGuide.checked = !!answerAPI.settings.includeTypeGuide;
		        const useMemos = $('#ansUseProblemMemos');
		        if (useMemos) useMemos.checked = !!answerAPI.settings.includeProblemMemos;
		        const memoEval = $('#ansMemoEval');
		        if (memoEval) memoEval.checked = !!answerAPI.settings.memoEval;
		        const bypass = $('#ansBypassSystemRole');
		        if (bypass) bypass.checked = !!answerAPI.settings.bypassSystemRole;
		        const memoEvalMode = $('#ansMemoEvalMode');
		        if (memoEvalMode) memoEvalMode.value = String(answerAPI.settings.memoEvalMode || 'repOrLatest');
		        const overwriteExplain = $('#ansOverwriteExplanation');
		        if (overwriteExplain) overwriteExplain.checked = !!answerAPI.settings.overwriteExplanation;
		      }
      function resetAnswerLog() {
        const box = $('#ansLogBox');
        if (box) box.innerHTML = '';
        const prog = $('#ansProgress');
        if (prog) prog.textContent = '';
      }
      function appendAnswerLog(msg) {
        const box = $('#ansLogBox'); if (!box) return;
        const row = document.createElement('div');
        row.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        box.appendChild(row);
        box.scrollTop = box.scrollHeight;
      }
      function toggleAnswerPanel(show) {
        const win = $('#llmFillWindow');
        if (!win) return;
        win.classList.toggle('active', !!show);
        win.style.display = show ? '' : 'none';
        if (show) {
          restoreSavedBox(win, 'fmm_ui_llmFillWindow');
          scrubProblemStatePlaceholderAnswers();
          scrubProblemsJsonPlaceholderAnswers();
          populateAnswerUI();
          $('#ansStatus').textContent = '';
          resetAnswerLog();
          llmFillRefresh();
        } else {
          ansRunning = false;
          ansAbort = false;
        }
      }
      function guideExplanationForTypeTitle(typeTitle) {
        const target = normalizeTitle(typeTitle || '');
        if (!target) return '';
        const guide = Array.isArray(window.fmm_types) ? window.fmm_types : [];
        let found = guide.find(t => t && normalizeTitle(t.title) === target);
        if (!found && hasIndexSuffix(typeTitle)) {
          const base = normalizeTitle(stripIndexSuffix(typeTitle));
          found = guide.find(t => t && normalizeTitle(t.title) === base);
        }
        return found?.explanationMarkdown || '';
      }

      function typeTitleForProblem(p) {
        const qid = String(p?.qid || '');
        if (p && p.__typeTitle) return String(p.__typeTitle);
        if (typeof problems !== 'undefined' && problems && problems.qidType && qid && problems.qidType[qid]) {
          return String(problems.qidType[qid]);
        }
        return currentTypeTitle();
      }

		      function memoSelectionForProblemPrompt(qid, mode, sessionId) {
		        const list = getProblemMemos(qid);
		        if (!Array.isArray(list) || list.length === 0) return [];
		        const ownerKey = getMemoOwnerKey(qid);
		        const repSt = getProblemState(ownerKey);
		        const repId = repSt.representativeMemoId == null ? null : String(repSt.representativeMemoId);
		        const rep = repId ? list.find(m => String(m.id) === repId) : null;
		        // "ìµœê·¼"ì€ í˜„ì¬ í‘œì‹œ ìˆœì„œ(ì‚¬ìš©ì ì¬ì •ë ¬)ì™€ ë¬´ê´€í•˜ê²Œ ìƒì„± ì‹œê° ê¸°ì¤€ìœ¼ë¡œ ê²°ì •
		        let latest = null;
		        let latestTs = -Infinity;
		        list.forEach(m => {
		          const ts = Number(m?.createdAt ?? m?.id ?? 0);
		          if (!Number.isFinite(ts)) return;
		          if (ts > latestTs) { latestTs = ts; latest = m; }
		        });
		        const sid = sessionId == null ? null : String(sessionId);
		        const m = String(mode || 'repOrLatest');
		        if (m === 'rep') return rep ? [rep] : [];
		        if (m === 'latest') return latest ? [latest] : [];
		        if (m === 'all') return list.slice();
	        if (m === 'session') {
	          if (!sid) return [];
	          return list.filter(x => String(x.sessionId || '') === sid);
	        }
	        // default/back-compat: representative first, else latest
	        return (rep || latest) ? [rep || latest] : [];
	      }

	      function parseMemoEvalById(memoEvalText) {
	        const out = {};
	        const s = String(memoEvalText || '');
	        if (!s.trim()) return out;
	        const re = /memo_id\s*:\s*([0-9]+)/ig;
	        const hits = [];
	        let m;
	        while ((m = re.exec(s))) {
	          hits.push({ id: String(m[1] || ''), idx: m.index, len: m[0].length });
	        }
	        if (!hits.length) return out;
	        for (let i = 0; i < hits.length; i++) {
	          const cur = hits[i];
	          const next = hits[i + 1];
	          const start = cur.idx + cur.len;
	          const end = next ? next.idx : s.length;
	          let body = s.slice(start, end).trim();
	          body = body.replace(/^[=\s-]+/g, '').trim();
	          body = body.replace(/^ë©”ëª¨í•´ì„¤\s*:\s*/i, '').trim();
	          if (cur.id && body) out[cur.id] = body;
	        }
	        return out;
	      }

	      function applyMemoEvaluationToProblem(qid, memoEvalText, opts) {
	        const text = String(memoEvalText || '').trim();
	        if (!text) return;
	        opts = opts || {};
	        const mode = String(opts.mode || answerAPI.settings.memoEvalMode || 'repOrLatest');
	        const sessionId = (typeof opts.sessionId !== 'undefined') ? opts.sessionId : (solveState?.session?.id || null);

	        const list = getProblemMemos(qid);
	        if (!Array.isArray(list) || !list.length) return;
	        const picked = memoSelectionForProblemPrompt(qid, mode, sessionId);
	        if (!picked.length) return;

	        const byId = parseMemoEvalById(text);
	        const now = Date.now();
	        const appendBlock = (memoText, evalText) => {
	          const body = String(evalText || '').trim();
	          if (!body) return memoText;
	          return String(memoText || '') + `\n\n=================\në©”ëª¨í•´ì„¤:\n${body}\n`;
	        };

	        if (Object.keys(byId).length) {
	          const allowed = new Set(picked.map(m => String(m.id)));
	          Object.entries(byId).forEach(([id, evText]) => {
	            if (!allowed.has(String(id))) return;
	            const idx = list.findIndex(m => String(m.id) === String(id));
	            if (idx < 0) return;
	            list[idx] = { ...list[idx], text: appendBlock(list[idx].text, evText), updatedAt: now };
	          });
	          saveProblemMemos(qid, list);
	          return;
	        }

	        // Single-eval fallback: attach to the single selected memo (or rep/latest policy).
	        if (picked.length === 1) {
	          const id = String(picked[0].id);
	          const idx = list.findIndex(m => String(m.id) === id);
	          if (idx < 0) return;
	          list[idx] = { ...list[idx], text: appendBlock(list[idx].text, text), updatedAt: now };
	          saveProblemMemos(qid, list);
	        }
	      }

		      async function callAnswerBatch(batch, opts) {
		        opts = opts || {};
		        const includeGuide = ('includeTypeGuide' in opts) ? !!opts.includeTypeGuide : !!answerAPI.settings.includeTypeGuide;
		        const includeMemos = ('includeProblemMemos' in opts) ? !!opts.includeProblemMemos : !!answerAPI.settings.includeProblemMemos;
		        const memoEvalEnabled = ('memoEval' in opts) ? !!opts.memoEval : !!answerAPI.settings.memoEval;
	        const memoEvalMode = ('memoEvalMode' in opts) ? String(opts.memoEvalMode || 'repOrLatest') : String(answerAPI.settings.memoEvalMode || 'repOrLatest');
	        const memoEvalSessionId = ('memoEvalSessionId' in opts) ? opts.memoEvalSessionId : (solveState?.session?.id || null);

        const typeTitles = Array.from(new Set(batch.map(p => typeTitleForProblem(p)).filter(Boolean)));
        const guideBlock = includeGuide
          ? typeTitles.map(tt => {
            const g = guideExplanationForTypeTitle(tt);
            return g ? `[# ìœ í˜• ê°€ì´ë“œ: ${tt}]\n${stripAnswerEmphasis(g)}` : `[# ìœ í˜• ê°€ì´ë“œ: ${tt}]\n(ê°€ì´ë“œ ì—†ìŒ)`;
          }).join('\n\n---\n\n')
          : '';

        const system = [
          `ë‹¹ì‹ ì€ ì „ê¸°ê¸°ëŠ¥ì‚¬ ë¬¸ì œë¥¼ ê°€ë¥´ì¹˜ëŠ” êµì‚¬ì…ë‹ˆë‹¤.`,
          ``,
          `1. ëª¨ë“  ê¸°í˜¸/ë¬¼ë¦¬ëŸ‰/ë‹¨ìœ„ëŠ” ì²˜ìŒ ë“±ì¥í•  ë•Œë§ˆë‹¤ ëœ»ê³¼ ë‹¨ìœ„ë¥¼ í•¨ê»˜ ì ìœ¼ì„¸ìš”.`,
          `   ì˜ˆ) P(ì „ë ¥, [W]), E(ì „ì••, [V]), I(ì „ë¥˜, [A]), Î¦(ìì†, [Wb]), t(ì‹œê°„, [s]) ë“±`,
          `   - ì „ë ¥ì˜ ë‹¨ìœ„ W([W])ì™€ ì—ë„ˆì§€(ì¼)ì˜ ë‹¨ìœ„ J([J])ëŠ” ì ˆëŒ€ ì„ì§€ ë§ˆì„¸ìš”.`,
          `   - W(ì „ë ¥, [W])ì™€ ê°™ì€ í‘œê¸°ëŠ” "ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ì§€ + ë‹¨ìœ„" ë¥¼ í•­ìƒ ê°™ì´ ì”ë‹ˆë‹¤.`,
          `2. ëª¨ë“  ìˆ˜ì‹ì€ LaTeX ë¡œ í‘œê¸°í•˜ê³ , ë°˜ë“œì‹œ $...$ ë˜ëŠ” $$...$$ ë¡œ ê°ì‹¸ì„œ ì‘ì„±í•©ë‹ˆë‹¤.`,
          `   - ì‹¬ì§€ì–´ ë³€ìˆ˜ í•˜ë‚˜ë§Œ ì ì„ ë•Œë„ $P$, $E$, $I$ ì²˜ëŸ¼ LaTeX ë¡œ ì ìŠµë‹ˆë‹¤.`,
          `   - ì˜ˆ) ì‹: $P(\\\\text{ì „ë ¥}, [W]) = E(\\\\text{ì „ì••}, [V]) \\\\times I(\\\\text{ì „ë¥˜}, [A])$`,
          `3. í•´ì„¤ êµ¬ì¡°ëŠ” í•­ìƒ ë‹¤ìŒ ë‘ ë‹¨ê³„ë¥¼ ë”°ë¦…ë‹ˆë‹¤.`,
          `   (1) ê¸°ë°˜ ì„¤ëª…: ì‚¬ìš©ìê°€ ê¸°ì´ˆ ê°œë…ì„ ì „í˜€ ëª¨ë¥¸ë‹¤ê³  ê°€ì •í•˜ê³ , ë²•ì¹™/ì •ì˜/ë‹¨ìœ„ë¥¼ ë¨¼ì € ì°¨ê·¼ì°¨ê·¼ ì„¤ëª…í•©ë‹ˆë‹¤.`,
          `       - ì™œ ì´ëŸ° ì‹ì´ ë‚˜ì˜¤ëŠ”ì§€, ê° í•­ì´ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ì§€, ë‹¨ìœ„ê°€ ì–´ë–»ê²Œ ë˜ëŠ”ì§€ê¹Œì§€ ì—°ê²°í•´ì„œ ì„¤ëª…í•©ë‹ˆë‹¤.`,
          `       - ê°‘ìê¸° ìƒˆë¡œìš´ ê°œë…ì´ 'íˆ­' í•˜ê³  ë–¨ì–´ì§€ì§€ ì•Šê²Œ, ì• ë‹¨ê³„ì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ì´ì–´ì§€ë„ë¡ ì”ë‹ˆë‹¤.`,
          `   (2) ì ìš© í’€ì´: ìœ„ì—ì„œ ì„¤ëª…í•œ ê°œë…/ê³µì‹ì„ ì‹¤ì œ ìˆ«ìì— ëŒ€ì…í•˜ì—¬ ë§¤ìš° ì§‘ì•½ì Â·ëª…ë£Œí•˜ê²Œ ê³„ì‚° ê³¼ì •ì„ ë³´ì…ë‹ˆë‹¤.`,
          `       - ë‹¨ê³„ë³„ í’€ì´ ê³¼ì •ì„ ì ˆëŒ€ ìƒëµí•˜ì§€ ë§ˆì„¸ìš”.`,
          `       - "ê°„ë‹¨íˆ"ëŠ” "ëª…í™•í•˜ê²Œ"ë¥¼ ì˜ë¯¸í•˜ë©°, ë‚´ìš©ì„ ë¹„ìš°ë¼ëŠ” ëœ»ì´ ì•„ë‹™ë‹ˆë‹¤.`,
          `4. í’€ì´ ì¤‘ì— ë‚˜ì˜¤ëŠ” ìš”ì•½(ì¨ë¨¸ë¦¬)ì€`,
          `   - ì§§ê³  ì§‘ì•½ì ì´ì–´ì•¼ í•˜ì§€ë§Œ`,
          `   - ì•ì—ì„œ ì„¤ëª…í•œ ê¸°ë°˜ ê°œë…ê³¼ ë‹¨ì ˆë˜ì§€ ì•Šê²Œ, ì–´ë””ì„œ ë‚˜ì˜¨ ë§ì¸ì§€ ë°”ë¡œ ì¶”ì  ê°€ëŠ¥í•´ì•¼ í•©ë‹ˆë‹¤.`,
          `5. ì¼ë¶€ ë¬¸ì œ í…ìŠ¤íŠ¸ì— ì´ë¯¸ í¬í•¨ëœ ì‹/ìˆ˜ì‹ì´ LaTeX ê°€ ì•„ë‹ˆë”ë¼ë„, ë‹¹ì‹ ì˜ í•´ì„¤ê³¼ ì¨ë¨¸ë¦¬ëŠ” ë°˜ë“œì‹œ ìœ„ ê·œì¹™ì„ ì§€í‚µë‹ˆë‹¤.`,
          includeGuide && guideBlock.trim()
            ? `\n[ì°¸ê³ ] ì•„ë˜ ìœ í˜• ê°€ì´ë“œë¥¼ ì°¸ê³ í•´ ìš©ì–´ë¥¼ í†µì¼í•˜ì„¸ìš”:\n${guideBlock}`
            : ''
        ].join('\n');

		        const rows = batch.map((p, i) => {
		          const tt = typeTitleForProblem(p) || '';
		          const pickedMemos = includeMemos ? memoSelectionForProblemPrompt(p.qid, memoEvalMode, memoEvalSessionId) : [];
		          const memoBlock = includeMemos
		            ? (pickedMemos.length === 0
	              ? `\nì‚¬ìš©ìë©”ëª¨: ì—†ìŒ`
	              : (pickedMemos.length === 1
	                ? `\nì‚¬ìš©ìë©”ëª¨(id=${pickedMemos[0].id}):\n${stripAnswerEmphasis(pickedMemos[0].text || '')}`
	                : `\nì‚¬ìš©ìë©”ëª¨(${pickedMemos.length}ê°œ):\n` +
	                  pickedMemos.map(m => `[MEMO id="${m.id}"]\n${stripAnswerEmphasis(m.text || '')}`).join('\n\n=================\n\n')
		          ))
		            : '';
		          const official = getOfficialAnswerText(p.official_answer) || 'ì—†ìŒ';
		          const rawChoices = stripAnswerEmphasis(p.answer_choices || 'ì—†ìŒ').trim();
		          const isChoice = !!(rawChoices && rawChoices !== 'ì—†ìŒ' && rawChoices !== '(ì—†ìŒ)');
		          const choices = isChoice ? parseChoices(rawChoices) : [];
		          const answerFmt = isChoice
		            ? `\në‹µì•ˆí˜•ì‹: <answer>ì—ëŠ” ì„ ì§€ ë²ˆí˜¸/ë§ˆí¬ë§Œ ë‹¨ë…ìœ¼ë¡œ (ê°€ëŠ¥í•˜ë©´ 1~${choices.length || 4})`
		            : `\në‹µì•ˆí˜•ì‹: <answer>ëŠ” ë‹¨ë‹µ/í…ìŠ¤íŠ¸`;
		          return `[ë¬¸ì œ ${i + 1} id="${p.qid}"${tt ? ` type="${tt}"` : ''}]\nìœ í˜•: ${tt || 'ì•Œ ìˆ˜ ì—†ìŒ'}\nì§ˆë¬¸: ${stripAnswerEmphasis(p.question_text || '')}\nì„ ì§€: ${rawChoices || 'ì—†ìŒ'}${answerFmt}\nê³µì‹ì •ë‹µ: ${official}${memoBlock}`;
		        }).join('\n\n');

	        const xmlGuide = `<data>${batch.map(p => `<item id="${p.qid}"><answer>ì—¬ê¸°ì— ì •ë‹µ(ì„ ì§€ ìˆìœ¼ë©´ ë²ˆí˜¸/ë§ˆí¬ë§Œ)</answer><í•´ì„¤>ì—¬ê¸°ì— ìƒì„¸í•œ í•´ì„¤</í•´ì„¤>${memoEvalEnabled ? '<memo_eval>ì—¬ê¸°ì— ë©”ëª¨ í‰ê°€</memo_eval>' : ''}</item>`).join('')}</data>`;
		        const user = `${rows}\n\nìš”ì²­:\n- ìœ„ ë¬¸ì œë“¤ì„ ëª¨ë‘ í’€ê³ , ë§ˆì§€ë§‰ì— ${xmlGuide} í˜•ì‹ìœ¼ë¡œ ì¶œë ¥í•˜ì„¸ìš”.\n- idëŠ” qid ê·¸ëŒ€ë¡œ.\n- ê³µì‹ì •ë‹µì´ ì œê³µëœ ë¬¸ì œëŠ” ê·¸ ì •ë‹µì„ ìµœì¢… ì •ë‹µìœ¼ë¡œ ìœ ì§€í•˜ê³ , í•´ì„¤ì€ ê·¸ ì •ë‹µì´ ë§ëŠ” ì´ìœ ë¥¼ ì„¤ëª…í•˜ì„¸ìš”.\n- [ì¤‘ìš”] ì„ ì§€ê°€ ìˆëŠ” ë¬¸ì œ(ì„ ì§€ê°€ \"ì—†ìŒ\"ì´ ì•„ë‹Œ ë¬¸ì œ)ëŠ” <answer>ì— ì„ ì§€ ë²ˆí˜¸/ë§ˆí¬ë§Œ ì ìœ¼ì„¸ìš”. ì˜ˆ: â‘  ë˜ëŠ” 1 ë˜ëŠ” A\n  - ì„ ì§€ ë‚´ìš©(ì˜ˆ: 60)ì´ë‚˜ ë‹¨ìœ„/ì„¤ëª… í…ìŠ¤íŠ¸ë¥¼ <answer>ì— ë„£ì§€ ë§ˆì„¸ìš”.\n  - <answer>ì—ëŠ” ë‹¤ë¥¸ ê¸€ì„ ì„ì§€ ë§ê³  ë²ˆí˜¸/ë§ˆí¬ë§Œ ë‹¨ë…ìœ¼ë¡œ ì“°ì„¸ìš”.\n- <answer>ëŠ” ë¹ˆ ê°’ ê¸ˆì§€.\n- <í•´ì„¤>ì€ ì ˆëŒ€ ë¹„ìš°ì§€ ë§ˆì„¸ìš”(ê³µë°±/ë¹ˆ ë¬¸ìì—´ ê¸ˆì§€). í™•ì‹ ì´ ì—†ë”ë¼ë„, ì™œ ê·¸ë ‡ê²Œ íŒë‹¨í–ˆëŠ”ì§€ì™€ ì •ë¦¬ëœ ê·¼ê±°ë¥¼ ë°˜ë“œì‹œ ì ìœ¼ì„¸ìš”.\n${memoEvalEnabled ? `- <memo_eval> ê·œì¹™:\n  - ì‚¬ìš©ìë©”ëª¨ê°€ ì—†ìœ¼ë©´ \"ì—†ìŒ\"\n  - ì‚¬ìš©ìë©”ëª¨ê°€ 1ê°œë©´: ê·¸ ë©”ëª¨ì— ëŒ€í•œ í‰ê°€ë§Œ ì¶œë ¥\n  - ì‚¬ìš©ìë©”ëª¨ê°€ 2ê°œ ì´ìƒì´ë©´: ì•„ë˜ í˜•ì‹ìœ¼ë¡œ ê° ë©”ëª¨ë¥¼ ëª¨ë‘ í‰ê°€í•˜ì„¸ìš”.\n    =================\n    memo_id: 123\n    ë©”ëª¨í•´ì„¤: ...\n` : ''}- XMLì´ ë¹„ë©´ ì•ˆ ë©ë‹ˆë‹¤.`;

		        const parseAndValidate = (content) => {
		          const xmlMatch = String(content || '').match(/<data[\s\S]*<\/data>/i);
		          if (!xmlMatch) throw new Error('XML ë¯¸ê²€ì¶œ');
		          const parser = new DOMParser();
		          const doc = parser.parseFromString(xmlMatch[0], 'text/xml');
		          const items = [...doc.querySelectorAll('item')];
		          if (!items.length) throw new Error('XML íŒŒì‹± ì‹¤íŒ¨');

		          const out = {};
		          items.forEach(it => {
		            const idAttr = it.getAttribute('id');
		            let id = idAttr;
		            if (!id && it.tagName.includes(':')) id = it.tagName.split(':')[1];
		            const ans = it.querySelector('answer')?.textContent?.trim()
		              || it.querySelector('ì •ë‹µ')?.textContent?.trim();
		            const exp = it.querySelector('í•´ì„¤')?.textContent?.trim()
		              || it.querySelector('explanation')?.textContent?.trim()
		              || it.querySelector('commentary')?.textContent?.trim();
		            const memoEval = it.querySelector('memo_eval')?.textContent?.trim()
		              || it.querySelector('memoEval')?.textContent?.trim()
		              || it.querySelector('memo')?.textContent?.trim();
		            if (id) out[id] = { answer: ans, explanation: exp, memo_eval: memoEval };
		          });
		          if (Object.keys(out).length === 0) throw new Error('ì •ë‹µ ì—†ìŒ');

		          // Enforce: every requested item must have non-empty answer+explanation.
		          const missingAns = [];
		          const missingExp = [];
		          const missingMemoEval = [];
		          batch.forEach(p => {
		            const id = String(p.qid || '');
		            const rec = out[id];
		            const ansOk = !!(rec && coerceText(rec.answer || '').trim());
		            const expOk = !!(rec && coerceText(rec.explanation || '').trim());
		            if (!ansOk) missingAns.push(id);
		            if (!expOk) missingExp.push(id);
			            if (memoEvalEnabled && !(rec && coerceText(rec.memo_eval || '').trim())) missingMemoEval.push(id);
		          });
		          if (missingAns.length || missingExp.length || missingMemoEval.length) {
		            const parts = [];
		            if (missingAns.length) parts.push(`ì •ë‹µ ë¹„ì–´ìˆìŒ: ${missingAns.join(', ')}`);
		            if (missingExp.length) parts.push(`í•´ì„¤ ë¹„ì–´ìˆìŒ: ${missingExp.join(', ')}`);
		            if (missingMemoEval.length) parts.push(`ë©”ëª¨í‰ê°€ ë¹„ì–´ìˆìŒ: ${missingMemoEval.join(', ')}`);
		            throw new Error(parts.join(' / '));
		          }

		          // Enforce: multiple-choice problems must answer by option number/mark (not the value).
		          const invalidChoiceAnswers = [];
		          batch.forEach(p => {
		            const id = String(p?.qid || '');
		            if (!id) return;
		            if (getOfficialAnswerText(p?.official_answer)) return; // not used anyway
		            const rec = out[id];
		            if (!rec) return;
		            const rawChoices = stripAnswerEmphasis(String(p?.answer_choices || '')).trim();
		            if (!rawChoices || rawChoices === 'ì—†ìŒ' || rawChoices === '(ì—†ìŒ)') return;
		            const choices = parseChoices(rawChoices);
		            if (!Array.isArray(choices) || choices.length < 2) return; // treat as non-choice
		            const token = normalizeAnswerToken(rec.answer);
		            const idx = token && Number.isFinite(token.index) ? token.index : null;
		            if (idx == null || idx < 0 || idx >= choices.length) {
			              invalidChoiceAnswers.push(`${id}="${coerceText(rec.answer || '').trim()}"`);
		              return;
		            }
		            rec.answer = String(idx + 1); // normalize to choice number
		          });
		          if (invalidChoiceAnswers.length) {
		            throw new Error(`ì„ ì§€í˜• ë¬¸ì œ <answer> í˜•ì‹ ì˜¤ë¥˜: ${invalidChoiceAnswers.join(', ')} (ì„ ì§€ ë²ˆí˜¸/ë§ˆí¬ë§Œ í—ˆìš©)`);
		          }
		          return out;
		        };

		        const baseMessages = [{ role: 'system', content: system }, { role: 'user', content: user }];
		        const MAX_TRIES = 8;
		        let lastOutput = '';
		        let lastReason = '';
		        for (let tryIdx = 1; tryIdx <= MAX_TRIES; tryIdx++) {
		          if (ansAbort) throw new Error('ì‚¬ìš©ì ì¤‘ë‹¨');
		          const messages = (tryIdx === 1 || !lastOutput)
		            ? baseMessages
		            : [
		              { role: 'system', content: system },
		              { role: 'user', content: user },
		              { role: 'assistant', content: lastOutput },
		              {
		                role: 'user',
		                content:
		                  `ìœ„ ì‘ë‹µì€ ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${lastReason || '(ì‚¬ìœ  ì—†ìŒ)'}\n` +
		                  `ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ë„ë¡ <data>...</data> XMLë§Œ ë‹¤ì‹œ ì¶œë ¥í•˜ì„¸ìš”.\n` +
		                  `- ë‹¤ë¥¸ í…ìŠ¤íŠ¸/ì„¤ëª…/ì½”ë“œë¸”ë¡ ê¸ˆì§€\n` +
		                  `- item idëŠ” qid ê·¸ëŒ€ë¡œ\n` +
		                  `- <answer>/<í•´ì„¤>${memoEvalEnabled ? '/<memo_eval>' : ''} ë¹„ìš°ê¸° ê¸ˆì§€\n` +
		                  `- ì„ ì§€í˜• ë¬¸ì œëŠ” <answer>ì— ì„ ì§€ ë²ˆí˜¸/ë§ˆí¬ë§Œ(ì˜ˆ: â‘  ë˜ëŠ” 1 ë˜ëŠ” A)\n`
		              }
		            ];
		          let content = '';
		          try {
			            const result = await callLlmApiWithKeyRoll({
			              endpoint: answerAPI.settings.endpoint,
			              proxyUrl: answerAPI.settings.proxyUrl,
			              apiKeysRaw: answerAPI.settings.apiKey,
			              model: answerAPI.settings.model || 'gpt-4o-mini',
			              messages,
			              bypassSystemRole: !!answerAPI.settings.bypassSystemRole,
			              cursorKey: 'fmm_ans_key_cursor',
			              cooldownKey: 'fmm_ans_key_cooldowns',
			              timeoutMs: 5 * 60 * 1000,
			              temperature: 0.2,
		              shouldAbort: () => ansAbort
		            });
		            content = result.contentText || '';
		            return parseAndValidate(content);
		          } catch (err) {
		            const msg = (err && err.message) ? err.message : String(err);
		            if (msg === 'ì‚¬ìš©ì ì¤‘ë‹¨') throw err;
		            if (content) lastOutput = content.slice(0, 20000);
		            lastReason = msg;
		            if (tryIdx >= MAX_TRIES) throw err;
		            try { await sleepInterruptible(1000, () => ansAbort); } catch (e) { throw e; }
		          }
		        }
		        throw new Error('ì •ë‹µ ìƒì„± ì‹¤íŒ¨');
		      }

		      async function fillMissingOfficialAnswers(pool) {
	        const rawTargets = (Array.isArray(pool) && pool.length)
	          ? pool.slice()
	          : currentTypeProblems();
	        const overwriteExplain = !!answerAPI.settings.overwriteExplanation;
	        const targets = rawTargets
	          .map(applyProblemOverrides)
	          .filter(p => overwriteExplain ? true : !hasOfficialAnswer(p.official_answer));
	        if (!targets.length) {
	          alert(overwriteExplain ? 'ì„ íƒëœ ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤.' : 'ê³µì‹ ì •ë‹µì´ ë¹„ì–´ìˆëŠ” ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
	          return;
	        }
        const total = targets.length;
        const batchSize = Math.max(1, parseInt(answerAPI.settings.batchSize || 3, 10));
        const progEl = $('#ansProgress');
	        ansAbort = false;
	        ansRunning = true;
	        if (progEl) progEl.textContent = `0 / ${total} ì™„ë£Œ`;
	        try {
	          for (let i = 0; i < targets.length; i += batchSize) {
	            if (ansAbort) break;
	            const batch = targets.slice(i, i + batchSize).map(applyProblemOverrides);
	            const index = Math.floor(i / batchSize) + 1;
	            appendAnswerLog(`ë°°ì¹˜ ${index} ì‹¤í–‰ (ë¬¸ì œ: ${batch.map(p => p.qid).join(', ')})`);
	            let parsed = null;
	            try {
	              parsed = await callAnswerBatch(batch);
	              appendAnswerLog(`ë°°ì¹˜ ${index} ì„±ê³µ (ì •ë‹µ ${Object.keys(parsed).length}ê°œ)`);
	            } catch (err) {
	              const msg = (err && err.message) ? err.message : String(err);
	              if (msg === 'ì‚¬ìš©ì ì¤‘ë‹¨' || ansAbort) break;
	              appendAnswerLog(`ë°°ì¹˜ ${index} ìµœì¢… ì‹¤íŒ¨: ${msg}`);
	              throw err;
	            }
	            if (!parsed) break;
	            Object.entries(parsed || {}).forEach(([qid, data]) => {
	              const base = batch.find(p => String(p.qid) === String(qid));
	              const existingAnswer = base ? getOfficialAnswerText(base.official_answer) : '';
			              const existingExp = base ? coerceText(base.official_explanation || '').trim() : '';
	              const patch = {};
	              if (!existingAnswer) patch.official_answer = data.answer;
	              if (overwriteExplain || !existingExp) patch.official_explanation = data.explanation;
	              if (Object.keys(patch).length) updateProblemState(qid, patch);
	              if (answerAPI.settings.memoEval && data && data.memo_eval) {
	                applyMemoEvaluationToProblem(qid, data.memo_eval, { mode: answerAPI.settings.memoEvalMode, sessionId: solveState?.session?.id || null });
	              }
	            });
	            if (progEl) {
	              const done = Math.min(i + batch.length, total);
	              progEl.textContent = `${done} / ${total} ì™„ë£Œ`;
	            }
	          }
	          renderProblemsForCurrentType();
	        } finally {
	          ansRunning = false;
	        }
	        if (typeof llmFillWin !== 'undefined' && llmFillWin && llmFillWin.classList.contains('active')) {
	          llmFillRefresh();
	        }

        // FIX: Auto-grade if in solve session after filling answers
        // ideology: ì •ë‹µ ì±„ìš°ê¸° í›„ ìë™ ì±„ì ìœ¼ë¡œ ì›í´ë¦­ ì›Œí¬í”Œë¡œìš° ë‹¬ì„±
        if (solveState.session && !ansAbort) {
          // Refresh problem data in session with new official answers
          solveState.session.queue.forEach(qid => {
            const fresh = getProblemForQid(qid);
            if (fresh) solveState.session.problemMap[qid] = applyProblemOverrides(fresh);
          });
          setTimeout(() => {
            gradeSession();
          }, 100);
        }
      }

      function openAnswerSettingsIfNeeded() {
        if (answerAPI.settings.endpoint) return true;
        toggleAnswerPanel(true);
        alert('ë¨¼ì € LLM Endpoint ì„¤ì •ì„ ì…ë ¥í•˜ì„¸ìš”.');
        return false;
      }

      function getProblemForQid(qid) {
        const id = String(qid || '');
        if (!id) return null;
        // 1) solve session cache
        const fromSolve = solveState?.session?.problemMap?.[id];
        if (fromSolve) return { ...applyProblemOverrides(fromSolve), __typeTitle: fromSolve.__typeTitle };

        // 2) current type
        try {
          const cur = currentTypeProblems().find(p => String(p.qid) === id);
          if (cur) return { ...applyProblemOverrides(cur), __typeTitle: currentTypeTitle() };
        } catch { }

        // 3) global map (if built)
        if (typeof problems !== 'undefined' && problems && problems.byQid && problems.byQid[id]) {
          const base = problems.byQid[id];
          const typeTitle = base.__typeTitle || problems.qidType?.[id] || null;
          return { ...applyProblemOverrides(base), __typeTitle: typeTitle };
        }

        // 4) brute scan (fallback)
        const src = problems?.json?.types || {};
        for (const title of Object.keys(src)) {
          const found = (src[title] || []).find(p => String(p?.qid) === id);
          if (found) return { ...applyProblemOverrides(found), __typeTitle: title };
        }
        return null;
      }

      async function llmFillOfficialExplanationForQid(qid) {
        if (!qid) return;
        if (ansRunning) { alert('LLM ì±„ìš°ê¸° ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.'); return; }
        if (!openAnswerSettingsIfNeeded()) return;

        const base = getProblemForQid(qid);
        if (!base) { alert('ë¬¸ì œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
        const merged = applyProblemOverrides(base);
        const typeTitle = base.__typeTitle || typeTitleForProblem(base) || currentTypeTitle();
        const p = { ...merged, __typeTitle: typeTitle };

        // Prefer unsaved UI value (manual corrections) for official answer when generating explanation
        if (solveState?.session) {
          const queue = activeSolveQueue();
          const idx = solveState.session.current || 0;
          const curQid = queue[idx];
          if (curQid === qid) {
            const ansInput = $('#solveOfficialAnswer');
            const v = ansInput ? String(ansInput.value || '').trim() : '';
            const normalized = normalizeOfficialAnswerValue(v);
            if (normalized) p.official_answer = normalized;

            // Use unsaved edits from inline problem editor (solve window) if open
            const editBox = $('#solveProblemEditBox');
            const qEl = editBox?.querySelector('textarea[data-role="q"]');
            const cEl = editBox?.querySelector('textarea[data-role="c"]');
            const qv = qEl ? String(qEl.value || '').trim() : '';
            const cv = cEl ? String(cEl.value || '').trim() : '';
            if (qv) p.question_text = qv;
            if (cv) p.answer_choices = cv;
          }
        }
        const detailEl = $('#problemDetail');
        if (detailEl?.dataset?.qid === String(qid)) {
          const ansInput = $('#detailOfficialAnswer');
          const v = ansInput ? String(ansInput.value || '').trim() : '';
          const normalized = normalizeOfficialAnswerValue(v);
          if (normalized) p.official_answer = normalized;

          // Use unsaved question/choice edits if user is editing in-place
          const qArea = $('#detailQuestionEdit');
          const cArea = $('#detailChoicesEdit');
          const newQ = qArea ? String(qArea.value || '').trim() : '';
          const newC = cArea ? String(cArea.value || '').trim() : '';
          if (newQ) p.question_text = newQ;
          if (newC) p.answer_choices = newC;
        }

        const existingExp = stripAnswerEmphasis(p.official_explanation || '').trim();
        if (existingExp) {
          if (!confirm('ê¸°ì¡´ ê³µì‹ í•´ì„¤ì„ LLM ê²°ê³¼ë¡œ ë®ì–´ì”ë‹ˆë‹¤. ê³„ì†í• ê¹Œìš”?')) return;
        }

        ansRunning = true;
        ansAbort = false;
        try {
          appendAnswerLog(`ë‹¨ì¼ ì‹¤í–‰ (ë¬¸ì œ: ${qid})`);
          const parsed = await callAnswerBatch([p]);
          const rec = parsed[String(qid)] || {};
          const keepAnswer = getOfficialAnswerText(p.official_answer);
	          const nextAnswer = keepAnswer || coerceText(rec.answer || '').trim();
	          const nextExp = coerceText(rec.explanation || '').trim();
          if (!nextExp) throw new Error('í•´ì„¤ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');

          updateProblemState(qid, {
            official_answer: nextAnswer || undefined,
            official_explanation: nextExp || undefined
          });
          if (answerAPI.settings.memoEval && rec && rec.memo_eval) {
            applyMemoEvaluationToProblem(qid, rec.memo_eval);
          }

          renderProblemsForCurrentType();

          // Sync solve session view if needed
          if (solveState?.session?.problemMap?.[qid]) {
            solveState.session.problemMap[qid] = applyProblemOverrides({
              ...solveState.session.problemMap[qid],
              official_answer: nextAnswer,
              official_explanation: nextExp
            });
          }
          if (solveState?.session) {
            const queue = activeSolveQueue();
            const idx = solveState.session.current || 0;
            if (queue[idx] === qid) {
              $('#solveOfficialAnswer').value = displayOfficialAnswerValue(nextAnswer);
              const expEl = $('#solveOfficialExplanation');
              if (expEl) expEl.value = maskDataImages(nextExp || '', expEl);
              $('#solveOfficialWrap').style.display = '';
              if ($('#solveRevealPanel')?.style.display !== 'none') {
                try { revealForCurrent(); } catch { }
              }
            }
          }

          statusEl.textContent = 'LLM í•´ì„¤ ì €ì¥ë¨';
        } catch (err) {
          appendAnswerLog(`ë‹¨ì¼ ì‹¤í–‰ ì‹¤íŒ¨: ${err.message}`);
          alert('LLM í˜¸ì¶œ ì‹¤íŒ¨: ' + err.message);
        } finally {
          ansRunning = false;
          ansAbort = false;
        }
      }

	      $('#solveLlmFillOne')?.addEventListener('click', async () => {
	        if (!solveState.session) return;
	        const queue = activeSolveQueue();
	        if (!queue.length) return;
	        const idx = solveState.session.current || 0;
	        const qid = queue[idx];
	        if (!qid) return;
	        llmFillState.mode = 'solve';
	        llmFillState.pendingQids = [qid];
	        toggleAnswerPanel(true);
	        try {
	          const base = getProblemForQid(qid);
	          const existing = base ? stripAnswerEmphasis(base.official_explanation || '').trim() : '';
	          const st = $('#ansStatus');
	          if (st) st.textContent = existing
	            ? 'í˜„ì¬ ë¬¸ì œë§Œ ì„ íƒë¨. ì´ë¯¸ í•´ì„¤ì´ ìˆìœ¼ë©´ "ê¸°ì¡´ í•´ì„¤ ë®ì–´ì“°ê¸°"ë¥¼ ì¼  ë’¤ ì‹¤í–‰í•˜ì„¸ìš”.'
	            : 'í˜„ì¬ ë¬¸ì œë§Œ ì„ íƒë¨. "ì´ ì„¤ì •ìœ¼ë¡œ ì±„ìš°ê¸°"ë¥¼ ëˆŒëŸ¬ ì‹¤í–‰í•˜ì„¸ìš”.';
	        } catch { }
	      });
      $('#solveFillBtn').addEventListener('click', () => {
        toggleAnswerPanel(true);
      });
      $('#ansClose').addEventListener('click', () => toggleAnswerPanel(false));
      $('#llmFillCloseBtn')?.addEventListener('click', () => toggleAnswerPanel(false));
			      $('#ansSave').addEventListener('click', () => {
			        answerAPI.settings.endpoint = $('#ansEndpoint').value.trim();
			        answerAPI.settings.proxyUrl = $('#ansProxyUrl').value.trim();
			        answerAPI.settings.apiKey = $('#ansApiKey').value.trim();
			        answerAPI.settings.model = $('#ansModel').value.trim();
			        answerAPI.settings.batchSize = parseInt($('#ansBatch').value || '3', 10) || 3;
		        answerAPI.settings.includeTypeGuide = !!$('#ansUseTypeGuide')?.checked;
		        answerAPI.settings.includeProblemMemos = !!$('#ansUseProblemMemos')?.checked;
		        answerAPI.settings.memoEval = !!$('#ansMemoEval')?.checked;
		        answerAPI.settings.memoEvalMode = String($('#ansMemoEvalMode')?.value || 'repOrLatest');
		        answerAPI.settings.overwriteExplanation = !!$('#ansOverwriteExplanation')?.checked;
		        answerAPI.settings.bypassSystemRole = !!$('#ansBypassSystemRole')?.checked;
		        answerAPI.save();
		        $('#ansStatus').textContent = 'ì„¤ì • ì €ì¥ë¨';
		      });
			      $('#ansRun').addEventListener('click', async () => {
			        if (ansRunning) return;
			        $('#ansStatus').textContent = 'ì‹¤í–‰ ì¤‘...';
			        answerAPI.settings.endpoint = $('#ansEndpoint').value.trim();
			        answerAPI.settings.proxyUrl = $('#ansProxyUrl').value.trim();
			        answerAPI.settings.apiKey = $('#ansApiKey').value.trim();
			        answerAPI.settings.model = $('#ansModel').value.trim();
			        answerAPI.settings.batchSize = parseInt($('#ansBatch').value || '3', 10) || 3;
		        answerAPI.settings.includeTypeGuide = !!$('#ansUseTypeGuide')?.checked;
		        answerAPI.settings.includeProblemMemos = !!$('#ansUseProblemMemos')?.checked;
		        answerAPI.settings.memoEval = !!$('#ansMemoEval')?.checked;
		        answerAPI.settings.memoEvalMode = String($('#ansMemoEvalMode')?.value || 'repOrLatest');
		        answerAPI.settings.overwriteExplanation = !!$('#ansOverwriteExplanation')?.checked;
		        answerAPI.settings.bypassSystemRole = !!$('#ansBypassSystemRole')?.checked;
		        answerAPI.save();
		        try {
		          const selectedKeys = Array.from(llmFillState.selectedKeys || []);
          if (!selectedKeys.length) {
            alert('ì„ íƒëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
            $('#ansStatus').textContent = 'ëŒ€ìƒ ì„ íƒ í•„ìš”';
            return;
          }
          const map = llmFillState.problemMap || {};
          const pool = selectedKeys.map(k => map[k]).filter(Boolean).map(applyProblemOverrides);
          if (!pool.length) {
            alert('ì„ íƒëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
            $('#ansStatus').textContent = 'ëŒ€ìƒ ì„ íƒ í•„ìš”';
            return;
          }
          await fillMissingOfficialAnswers(pool);
          $('#ansStatus').textContent = ansAbort ? 'ì‚¬ìš©ì ì¤‘ë‹¨ë¨' : 'ì™„ë£Œ';
        } catch (err) {
          $('#ansStatus').textContent = 'ì‹¤íŒ¨: ' + err.message;
          appendAnswerLog(`ì „ì²´ ì‹¤íŒ¨: ${err.message}`);
        }
      });
      $('#ansStop').addEventListener('click', () => {
        if (!ansRunning) return;
        ansAbort = true;
        $('#ansStatus').textContent = 'ì¤‘ë‹¨ ìš”ì²­ë¨â€¦ í˜„ì¬ í˜¸ì¶œì´ ëë‚˜ë©´ ë©ˆì¶¥ë‹ˆë‹¤.';
        appendAnswerLog('ì‚¬ìš©ìê°€ ì¤‘ë‹¨ì„ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.');
      });

      // === NEW: Stats window (type overview & LLM ëŒ€ìƒ ì„ íƒ) =======================
      const statsWin = $('#statsWindow');
      const statsToggleBtn = $('#statsToggleBtn');
      const llmFillWin = $('#llmFillWindow');
      const llmFillToggleBtn = $('#llmFillToggleBtn');
	      const sheetState = {
	        list: LS.get(SHEETS_KEY, []),
	        selectedId: null,
	        wrongOnly: false,
	        focusQid: null
	      };
		      const statsState = {
		        selectedKeys: new Set(),
		        filterMissingOnly: false,
		        problemMap: {},
		        lastItems: [],
		        filteredProblems: [],
		        typeSort: 'guide'
		      };
	      const llmFillState = {
	        mode: 'solve',
	        selectedKeys: new Set(),
	        filterMissingOnly: true,
	        problemMap: {},
	        lastItems: [],
	        pendingQids: null
	      };

		      function parseTagSetFromOrInput(raw) {
		        const s = String(raw || '');
		        const out = new Set();
		        if (!s) return out;
		        (TAG_DEFS || []).forEach(d => {
		          const tag = d?.tag;
		          if (tag && s.includes(tag)) out.add(tag);
		        });
		        return out;
		      }
	
		      function ensureStatsTagCheckboxes() {
		        const build = (id) => {
		          const el = document.getElementById(id);
		          if (!el || el._tagChecksBuilt) return;
		          el._tagChecksBuilt = true;
		          el.innerHTML = (TAG_DEFS || []).map(d => {
		            const tag = String(d?.tag || '');
		            const label = String(d?.label || '');
		            const safeTag = tag.replace(/\"/g, '&quot;');
		            const safeLabel = label.replace(/\"/g, '&quot;');
		            return `<label class="tag-check" title="${safeLabel}">
		              <input type="checkbox" data-tag="${safeTag}">
		              <span class="tag-check-chip">${safeTag}</span>
		            </label>`;
		          }).join('');
		        };
		        build('statsTagChecks');
		      }
		      function getCheckedTagSetFromContainer(id) {
		        const out = new Set();
		        const el = typeof id === 'string' ? document.getElementById(id) : id;
		        if (!el) return out;
		        el.querySelectorAll('input[type="checkbox"][data-tag]').forEach(cb => {
		          if (cb.checked) out.add(String(cb.getAttribute('data-tag') || ''));
		        });
		        out.delete('');
		        return out;
		      }
		      function clearCheckedTagSetInContainer(id) {
		        const el = typeof id === 'string' ? document.getElementById(id) : id;
		        if (!el) return;
		        el.querySelectorAll('input[type="checkbox"][data-tag]').forEach(cb => { cb.checked = false; });
		      }

	      // Guide ìƒì˜ ìœ í˜• ìˆœë²ˆì„ titleì— ë§¤í•‘
	      function guideIndexForTitle(title) {
        const guide = Array.isArray(window.fmm_types) ? window.fmm_types : [];
        const target = normalizeTitle(title || '');
        if (!target) return null;
        for (let i = 0; i < guide.length; i++) {
          const t = guide[i];
          if (!t || !t.title) continue;
          if (normalizeTitle(t.title) === target) return i + 1; // 1-based
        }
        return null;
      }
      function formatTypeLabel(title) {
        const idx = guideIndexForTitle(title);
        return idx ? `${idx}. ${title}` : title;
      }

      function statsAllTypes() {
        const src = problems.json?.types || {};
        const titles = Object.keys(src);
        if (!titles.length) return [];
        const guide = Array.isArray(window.fmm_types) ? window.fmm_types : [];
        const guideTitles = guide.map(t => t.title).filter(Boolean);
        const seen = new Set();
        const ordered = [];
        guideTitles.forEach(title => {
          if (Object.prototype.hasOwnProperty.call(src, title) && !seen.has(title)) {
            seen.add(title);
            ordered.push(title);
          }
        });
        titles.forEach(title => {
          if (!seen.has(title)) {
            seen.add(title);
            ordered.push(title);
          }
        });
        return ordered;
      }

      function llmFillPopulateTypeSelect() {
        const sel = $('#llmFillTypeSelect');
        if (!sel) return;
        sel.innerHTML = '';
        const optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = 'ì „ì²´ ìœ í˜•';
        sel.appendChild(optAll);
        statsAllTypes().forEach(title => {
          const opt = document.createElement('option');
          opt.value = title;
          opt.textContent = formatTypeLabel(title);
          sel.appendChild(opt);
        });
      }

		      function llmFillPopulatePaperSelect() {
		        const sel = $('#llmFillPaperSelect');
		        if (!sel) return;
		        const reg = ensurePaperRegistry();
		        const map = llmFillState.problemMap || {};
		        const names = new Set();
		        Object.values(map).forEach(p => {
		          if (!p) return;
		          const pid = paperKeyForProblem(p) || '';
		          if (pid) names.add(pid);
		        });
		        const sorted = Array.from(names).sort((a, b) => {
		          const an = reg.papers?.[a]?.name || a;
		          const bn = reg.papers?.[b]?.name || b;
		          return an.localeCompare(bn, 'ko');
		        });
		        sel.innerHTML = '';
		        const optAll = document.createElement('option');
		        optAll.value = '';
		        optAll.textContent = 'ì „ì²´ ì‹œí—˜ì§€';
		        sel.appendChild(optAll);
			        sorted.forEach(pid => {
			          const paperName = reg.papers?.[pid]?.name || '';
			          const opt = document.createElement('option');
			          opt.value = pid;
			          opt.textContent = formatPaperNameDisplay(paperName, '') || paperName || pid;
			          sel.appendChild(opt);
			        });
			      }

	      // ----- Paper manager (merge/split/rename original papers) -----
	      const paperManagerWin = $('#paperManagerWindow');
	      const paperManagerBtn = $('#paperManagerBtn');
	      const paperManagerState = {
	        selectedPaperIds: new Set(),
	        activePaperId: null,
	        selectedAliasKeys: new Set()
	      };

	      function rebuildProblemIndexesFromJson() {
	        const src = problems.json?.types || {};
	        problems.norm = {};
	        problems.byQid = {};
	        problems.qidType = {};
	        Object.keys(src).forEach(typeTitle => {
	          const list = src[typeTitle] || [];
	          problems.norm[normalizeTitle(typeTitle)] = list;
	          list.forEach(p => {
	            const qid = String(p?.qid || '');
	            if (!qid) return;
	            problems.qidType[qid] = typeTitle;
	            problems.byQid[qid] = { ...p, __typeTitle: typeTitle };
	          });
	        });
	      }
	      function persistProblemsJson() {
	        try { LS.set('fmm_problems_json', problems.json); } catch { }
	      }
	      function refreshAfterPaperChange() {
	        if (problems.json) {
	          let changed = false;
	          try { if (normalizeProblemsPaperNamesInPlace(problems.json)) changed = true; } catch { }
	          try { if (migratePartSuffixQids()) changed = true; } catch { }
	          if (changed) persistProblemsJson();
	        }
	        rebuildProblemIndexesFromJson();
	        renderProblemsForCurrentType();
	        statsRefresh();
	        if (llmFillWin && llmFillWin.classList.contains('active')) llmFillRefresh();
	      }
	      function countProblemsByPaperId() {
	        const counts = {};
	        const src = problems.json?.types || {};
	        Object.keys(src).forEach(typeTitle => {
	          (src[typeTitle] || []).forEach(p => {
	            const pid = String(p?.paperId || '').trim();
	            if (!pid) return;
	            counts[pid] = (counts[pid] || 0) + 1;
	          });
	        });
	        return counts;
	      }
	      function paperNameForId(reg, pid) {
	        const name = reg.papers?.[pid]?.name || '';
	        return formatPaperNameDisplay(name, '') || name || pid;
	      }
	      function paperManagerRenderAliasList(reg) {
	        const el = $('#paperManagerAliasList');
	        if (!el) return;
	        const pid = paperManagerState.activePaperId;
	        if (!pid || !reg.papers?.[pid]) {
	          el.innerHTML = '<div class="muted">ì‹œí—˜ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.</div>';
	          return;
	        }
	        const paper = reg.papers[pid];
	        const keys = Array.isArray(paper.aliasKeys) ? paper.aliasKeys.slice() : [];
	        if (!keys.length) {
	          el.innerHTML = '<div class="muted">ë³„ì¹­ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
	          return;
	        }
	        keys.sort((a, b) => {
	          const an = (paper.aliasNames && paper.aliasNames[a]) ? paper.aliasNames[a] : a;
	          const bn = (paper.aliasNames && paper.aliasNames[b]) ? paper.aliasNames[b] : b;
	          return String(an).localeCompare(String(bn), 'ko');
	        });
	        el.innerHTML = keys.map(k => {
	          const label = (paper.aliasNames && paper.aliasNames[k]) ? paper.aliasNames[k] : k;
	          const checked = paperManagerState.selectedAliasKeys.has(k) ? 'checked' : '';
	          const safeKey = String(k).replace(/\"/g, '&quot;');
	          return `<label class="problems-item" style="gap:8px;">
	            <input type="checkbox" data-paper-alias="${safeKey}" ${checked}>
	            <span class="pill">${sanitize(label)}</span>
	            <span class="muted">${sanitize(k)}</span>
	          </label>`;
	        }).join('');
	        el.querySelectorAll('input[type=\"checkbox\"][data-paper-alias]').forEach(cb => {
	          cb.addEventListener('change', () => {
	            const k = cb.getAttribute('data-paper-alias');
	            if (!k) return;
	            if (cb.checked) paperManagerState.selectedAliasKeys.add(k);
	            else paperManagerState.selectedAliasKeys.delete(k);
	          });
	        });
	      }
	      function paperManagerRender() {
	        const listEl = $('#paperManagerList');
	        if (!listEl) return;
	        const reg = ensurePaperRegistry();
	        const counts = countProblemsByPaperId();
	        const papers = Object.values(reg.papers || {}).filter(p => p && p.id).sort((a, b) => {
	          const an = paperNameForId(reg, a.id);
	          const bn = paperNameForId(reg, b.id);
	          return an.localeCompare(bn, 'ko');
	        });
	        if (!papers.length) {
	          listEl.innerHTML = '<div class="muted">ì›ë³¸ ì‹œí—˜ì§€ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
	          paperManagerRenderAliasList(reg);
	          return;
	        }
	        listEl.innerHTML = papers.map(p => {
	          const pid = p.id;
	          const checked = paperManagerState.selectedPaperIds.has(pid) ? 'checked' : '';
	          const active = paperManagerState.activePaperId === pid ? 'style="outline:1px dashed var(--border);"' : '';
	          const total = counts[pid] || 0;
	          const aliasCount = Array.isArray(p.aliasKeys) ? p.aliasKeys.length : 0;
	          return `<label class="problems-item" data-paper-row="${pid.replace(/\"/g, '&quot;')}" ${active}>
	            <input type="checkbox" data-paper-id="${pid.replace(/\"/g, '&quot;')}" ${checked}>
	            <strong>${sanitize(paperNameForId(reg, pid))}</strong>
	            <span class="pill">${total}ë¬¸í•­</span>
	            <span class="pill">ë³„ì¹­ ${aliasCount}</span>
	          </label>`;
	        }).join('');
	        listEl.querySelectorAll('input[type=\"checkbox\"][data-paper-id]').forEach(cb => {
	          cb.addEventListener('change', () => {
	            const pid = cb.getAttribute('data-paper-id');
	            if (!pid) return;
	            if (cb.checked) {
	              paperManagerState.selectedPaperIds.add(pid);
	              paperManagerState.activePaperId = pid;
	            } else {
	              paperManagerState.selectedPaperIds.delete(pid);
	              if (paperManagerState.activePaperId === pid) paperManagerState.activePaperId = null;
	            }
	            paperManagerState.selectedAliasKeys = new Set();
	            paperManagerRender();
	          });
	        });
	        listEl.querySelectorAll('[data-paper-row]').forEach(row => {
	          row.addEventListener('click', (e) => {
	            const cb = e.target.closest('input[type=\"checkbox\"]');
	            if (cb) return;
	            const pid = row.getAttribute('data-paper-row');
	            if (!pid) return;
	            paperManagerState.activePaperId = pid;
	            paperManagerState.selectedAliasKeys = new Set();
	            paperManagerRender();
	          });
	        });
	        paperManagerRenderAliasList(reg);
	      }
	      function togglePaperManager(show) {
	        if (!paperManagerWin) return;
	        paperManagerWin.classList.toggle('active', !!show);
	        paperManagerWin.style.display = show ? '' : 'none';
	        if (show) {
	          restoreSavedBox(paperManagerWin, 'fmm_ui_paperManagerWindow');
	          paperManagerRender();
	        }
	      }
	      function updateProblemsForPaperName(paperId, name) {
	        const src = problems.json?.types || {};
	        Object.keys(src).forEach(title => {
	          (src[title] || []).forEach(p => {
	            if (!p || typeof p !== 'object') return;
	            if (String(p.paperId || '') !== String(paperId || '')) return;
	            p.paperName = name;
	          });
	        });
	      }
	      function updateProblemsPaperId(fromId, toId, toName) {
	        const src = problems.json?.types || {};
	        Object.keys(src).forEach(title => {
	          (src[title] || []).forEach(p => {
	            if (!p || typeof p !== 'object') return;
	            if (String(p.paperId || '') !== String(fromId || '')) return;
	            p.paperId = toId;
	            p.paperName = toName;
	          });
	        });
	      }
	      function splitProblemsByAlias(oldId, newId, newName, aliasKeys) {
	        const set = new Set((aliasKeys || []).map(k => String(k || '').trim()).filter(Boolean));
	        if (!set.size) return;
	        const src = problems.json?.types || {};
	        Object.keys(src).forEach(title => {
	          (src[title] || []).forEach(p => {
	            if (!p || typeof p !== 'object') return;
	            if (String(p.paperId || '') !== String(oldId || '')) return;
	            const k = String(p.paperSourceKey || '').trim();
	            if (!k || !set.has(k)) return;
	            p.paperId = newId;
	            p.paperName = newName;
	          });
	        });
	      }

	      $('#paperManagerCloseBtn')?.addEventListener('click', () => togglePaperManager(false));
	      $('#paperManagerRefreshBtn')?.addEventListener('click', () => { refreshAfterPaperChange(); paperManagerRender(); });
	      $('#paperManagerRenameBtn')?.addEventListener('click', () => {
	        const ids = Array.from(paperManagerState.selectedPaperIds || []);
	        if (ids.length !== 1) { alert('ì´ë¦„ì„ ë°”ê¿€ ì‹œí—˜ì§€ë¥¼ 1ê°œë§Œ ì„ íƒí•˜ì„¸ìš”.'); return; }
	        const pid = ids[0];
	        const reg = ensurePaperRegistry();
	        const paper = reg.papers?.[pid];
	        if (!paper) { alert('ì‹œí—˜ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
	        const next = prompt('ìƒˆ ì›ë³¸ ì‹œí—˜ì§€ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: xxx.pdf)', paper.name || '');
	        if (next == null) return;
	        const newName = normalizePaperNameDisplay(next);
	        if (!newName) { alert('ì´ë¦„ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.'); return; }
	        paper.name = newName;
	        paper.nameLocked = true;
	        paper.updatedAt = Date.now();
	        savePaperRegistry(reg);
	        updateProblemsForPaperName(pid, newName);
	        persistProblemsJson();
	        refreshAfterPaperChange();
	        paperManagerRender();
	      });
	      $('#paperManagerMergeBtn')?.addEventListener('click', () => {
	        const ids = Array.from(paperManagerState.selectedPaperIds || []);
	        if (ids.length < 2) { alert('ë³‘í•©í•  ì‹œí—˜ì§€ë¥¼ 2ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”.'); return; }
	        const reg = ensurePaperRegistry();
	        const targetId = paperManagerState.activePaperId && ids.includes(paperManagerState.activePaperId)
	          ? paperManagerState.activePaperId
	          : ids[0];
	        const target = reg.papers?.[targetId];
	        if (!target) { alert('ëŒ€ìƒ ì‹œí—˜ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
	        const next = prompt('ë³‘í•© í›„ ëŒ€í‘œ ì›ë³¸ ì‹œí—˜ì§€ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.', target.name || '');
	        if (next == null) return;
	        const mergedName = normalizePaperNameDisplay(next);
	        if (!mergedName) { alert('ì´ë¦„ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.'); return; }
	        target.name = mergedName;
	        target.nameLocked = true;
	        target.updatedAt = Date.now();
	        if (!Array.isArray(target.aliasKeys)) target.aliasKeys = [];
	        if (!target.aliasNames || typeof target.aliasNames !== 'object') target.aliasNames = {};

	        ids.forEach(id => {
	          if (id === targetId) return;
	          const p = reg.papers?.[id];
	          if (!p) return;
	          (p.aliasKeys || []).forEach(k => {
	            if (!target.aliasKeys.includes(k)) target.aliasKeys.push(k);
	            const prev = target.aliasNames[k] || '';
	            const cand = (p.aliasNames && p.aliasNames[k]) ? p.aliasNames[k] : '';
	            target.aliasNames[k] = preferBetterPaperName(prev, cand);
	            reg.aliasToId[k] = targetId;
	          });
	          delete reg.papers[id];
	          updateProblemsPaperId(id, targetId, mergedName);
	        });
	        updateProblemsForPaperName(targetId, mergedName);
	        savePaperRegistry(reg);
	        persistProblemsJson();
	        paperManagerState.selectedPaperIds = new Set([targetId]);
	        paperManagerState.activePaperId = targetId;
	        paperManagerState.selectedAliasKeys = new Set();
	        refreshAfterPaperChange();
	        paperManagerRender();
	      });
	      $('#paperManagerSplitBtn')?.addEventListener('click', () => {
	        const ids = Array.from(paperManagerState.selectedPaperIds || []);
	        if (ids.length !== 1) { alert('ë¶„ë¦¬í•  ì‹œí—˜ì§€ë¥¼ 1ê°œë§Œ ì„ íƒí•˜ì„¸ìš”.'); return; }
	        const oldId = ids[0];
	        const reg = ensurePaperRegistry();
	        const paper = reg.papers?.[oldId];
	        if (!paper) { alert('ì‹œí—˜ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
	        const selectedAliases = Array.from(paperManagerState.selectedAliasKeys || []).filter(k => (paper.aliasKeys || []).includes(k));
	        if (!selectedAliases.length) { alert('ë¶„ë¦¬í•  ë³„ì¹­(ì›ë³¸)ì„ ì„ íƒí•˜ì„¸ìš”.'); return; }
	        if ((paper.aliasKeys || []).length <= selectedAliases.length) {
	          alert('ëª¨ë“  ë³„ì¹­ì„ ë¶„ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ìµœì†Œ 1ê°œëŠ” ì›ë³¸ ì‹œí—˜ì§€ì— ë‚¨ì•„ì•¼ í•©ë‹ˆë‹¤)');
	          return;
	        }
	        const defaultName = (paper.aliasNames && paper.aliasNames[selectedAliases[0]]) ? paper.aliasNames[selectedAliases[0]] : paper.name || '';
	        const next = prompt('ë¶„ë¦¬ëœ ìƒˆ ì›ë³¸ ì‹œí—˜ì§€ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.', defaultName);
	        if (next == null) return;
	        const newName = normalizePaperNameDisplay(next);
	        if (!newName) { alert('ì´ë¦„ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.'); return; }
	        const newId = makePaperId();
	        const now = Date.now();
	        const newPaper = { id: newId, name: newName, nameLocked: true, aliasKeys: [], aliasNames: {}, createdAt: now, updatedAt: now };
	        selectedAliases.forEach(k => {
	          newPaper.aliasKeys.push(k);
	          if (paper.aliasNames && paper.aliasNames[k]) newPaper.aliasNames[k] = paper.aliasNames[k];
	          reg.aliasToId[k] = newId;
	        });
	        paper.aliasKeys = (paper.aliasKeys || []).filter(k => !selectedAliases.includes(k));
	        if (paper.aliasNames && typeof paper.aliasNames === 'object') {
	          selectedAliases.forEach(k => { delete paper.aliasNames[k]; });
	        }
	        reg.papers[newId] = newPaper;
	        paper.updatedAt = now;
	        savePaperRegistry(reg);
	        splitProblemsByAlias(oldId, newId, newName, selectedAliases);
	        persistProblemsJson();
	        paperManagerState.selectedPaperIds = new Set([oldId, newId]);
	        paperManagerState.activePaperId = newId;
	        paperManagerState.selectedAliasKeys = new Set();
	        refreshAfterPaperChange();
	        paperManagerRender();
	      });

	      if (paperManagerBtn && paperManagerWin) {
	        paperManagerBtn.addEventListener('click', () => {
	          const showing = paperManagerWin.classList.contains('active');
	          togglePaperManager(!showing);
	        });
	      }

      function llmFillPopulateSheetSelect() {
        const sel = $('#llmFillSheetSelect');
        if (!sel) return;
        sel.innerHTML = '';
        if (!sheetState.list.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'ì‹œí—˜ì§€ ì—†ìŒ';
          sel.appendChild(opt);
          return;
        }
        sheetState.list.forEach(sheet => {
          const opt = document.createElement('option');
          opt.value = sheet.id;
          opt.textContent = sheet.name || '(ì œëª© ì—†ìŒ)';
          if (sheet.id === sheetState.selectedId) opt.selected = true;
          sel.appendChild(opt);
        });
      }

      function llmFillBuildProblemMap() {
        llmFillState.problemMap = {};
        const mode = llmFillState.mode || 'solve';
        if (mode === 'solve') {
          const queue = solveState?.session?.queue || [];
          queue.forEach(qid => {
            const p = getProblemForQid(qid);
            if (!p) return;
            const merged = applyProblemOverrides(p);
            const withType = { ...merged, __typeTitle: p.__typeTitle || merged.__typeTitle || typeTitleForProblem(p) };
            const key = `${withType.__typeTitle || ''}::${withType.qid}`;
            llmFillState.problemMap[key] = withType;
          });
          return;
        }
        if (mode === 'sheet') {
          const sheetId = $('#llmFillSheetSelect')?.value || sheetState.selectedId;
          const sheet = sheetState.list.find(s => s && s.id === sheetId);
          const qids = Array.isArray(sheet?.qids) ? sheet.qids : [];
          qids.forEach(qid => {
            const p = getProblemForQid(qid);
            if (!p) return;
            const merged = applyProblemOverrides(p);
            const withType = { ...merged, __typeTitle: p.__typeTitle || merged.__typeTitle || typeTitleForProblem(p) };
            const key = `${withType.__typeTitle || ''}::${withType.qid}`;
            llmFillState.problemMap[key] = withType;
          });
          return;
        }
        statsCollectProblems().forEach(p => {
          const key = `${p.__typeTitle}::${p.qid}`;
          llmFillState.problemMap[key] = p;
        });
      }

      function llmFillApplyPendingSelection() {
        const pending = Array.isArray(llmFillState.pendingQids) ? llmFillState.pendingQids.slice() : [];
        if (!pending.length) return;
        const map = llmFillState.problemMap || {};
        const keys = [];
        pending.forEach(qid => {
          const hit = Object.entries(map).find(([_, p]) => String(p?.qid || '') === String(qid));
          if (hit) keys.push(hit[0]);
        });
        if (keys.length) llmFillState.selectedKeys = new Set(keys);
        llmFillState.pendingQids = null;
      }

      function llmFillApplyModeVisibility() {
        const mode = llmFillState.mode || 'solve';
        const isAll = mode === 'all';
        const isSheet = mode === 'sheet';
        const sheetWrap = $('#llmFillSheetWrap');
        const typeWrap = $('#llmFillTypeWrap');
        const tagWrap = $('#llmFillTagWrap');
        const yearWrap = $('#llmFillYearWrap');
        const paperWrap = $('#llmFillPaperWrap');
        if (sheetWrap) sheetWrap.style.display = isSheet ? '' : 'none';
        if (typeWrap) typeWrap.style.display = isAll ? '' : 'none';
        if (tagWrap) tagWrap.style.display = isAll ? '' : 'none';
        if (yearWrap) yearWrap.style.display = isAll ? '' : 'none';
        if (paperWrap) paperWrap.style.display = isAll ? '' : 'none';
      }

      function llmFillRenderList() {
        const listEl = $('#llmFillList');
        if (!listEl) return;
        const entries = Object.entries(llmFillState.problemMap || {});
        if (!entries.length) {
          listEl.innerHTML = '<div class="muted">ë¬¸ì œ JSON ë˜ëŠ” í’€ì´ ì„¸ì…˜ì„ ë¨¼ì € ì¤€ë¹„í•˜ì„¸ìš”.</div>';
          return;
        }
        const mode = llmFillState.mode || 'solve';
        const typeTitle = $('#llmFillTypeSelect')?.value || '';
        const tagTarget = ($('#llmFillTagFilter')?.value || '').trim();
        const yearOp = ($('#llmFillYearOp')?.value || '>=').trim();
        const yearRaw = ($('#llmFillYearFilter')?.value || '').trim();
        const yearFilter = yearRaw ? (parseInt(yearRaw, 10) || 0) : 0;
        const paperTarget = $('#llmFillPaperSelect')?.value || '';
        const onlyMissing = llmFillState.filterMissingOnly;
        const items = [];
        llmFillState.lastItems = [];
        entries.forEach(([key, p]) => {
	          if (mode === 'all') {
	            if (typeTitle && p.__typeTitle !== typeTitle) return;
	            if (tagTarget) {
	              const qid = String(p.qid || '');
	              const tag = getEffectiveTag(qid);
	              if (tag !== tagTarget) return;
	            }
            const year = extractYearForStatsProblem(p);
            if (yearFilter && year) {
              if (yearOp === '>=') {
                if (year < yearFilter) return;
              } else if (yearOp === '<=') {
                if (year > yearFilter) return;
              } else if (yearOp === '==') {
                if (year !== yearFilter) return;
              } else {
                if (year < yearFilter) return;
              }
            }
		            const pid = paperKeyForProblem(p) || '';
		            if (paperTarget && pid !== paperTarget) return;
		          }
          const missing = !hasOfficialAnswer(p.official_answer);
          if (onlyMissing && !missing) return;
          const year = extractYearFromQid(p.qid);
          llmFillState.lastItems.push(key);
          items.push({ key, p, year, missing });
        });
        const visible = new Set(llmFillState.lastItems || []);
        if (llmFillState.selectedKeys && llmFillState.selectedKeys.size) {
          llmFillState.selectedKeys = new Set(Array.from(llmFillState.selectedKeys).filter(k => visible.has(k)));
        }
        if (!items.length) {
          listEl.innerHTML = '<div class="muted">ì¡°ê±´ì— ë§ëŠ” ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
          return;
        }
        listEl.innerHTML = items.map(item => {
          const st = getProblemState(item.p.qid);
          const tag = getEffectiveTag(item.p.qid);
          const checked = llmFillState.selectedKeys.has(item.key) ? 'checked' : '';
          return `<label class="problems-item">
            <input type="checkbox" data-llm-key="${item.key}" ${checked}>
            <span class="tag-badge">${tag}</span>
            <strong>${sanitize(item.p.qid)}</strong>
            ${item.year ? `<span class="pill">${item.year}</span>` : ''}
            <span class="pill">${sanitize(item.p.__typeTitle ? formatTypeLabel(item.p.__typeTitle) : '')}</span>
            ${item.missing ? '<span class="pill">ê³µì‹ì •ë‹µ ì—†ìŒ</span>' : ''}
          </label>`;
        }).join('');
        listEl.querySelectorAll('input[type="checkbox"][data-llm-key]').forEach(cb => {
          cb.addEventListener('change', () => {
            const key = cb.getAttribute('data-llm-key');
            if (!key) return;
            if (cb.checked) llmFillState.selectedKeys.add(key);
            else llmFillState.selectedKeys.delete(key);
          });
        });
      }

      function llmFillRefresh() {
        const modeSel = $('#llmFillMode');
        if (modeSel && modeSel.value !== llmFillState.mode) modeSel.value = llmFillState.mode || 'solve';
        llmFillApplyModeVisibility();
        llmFillBuildProblemMap();
        llmFillApplyPendingSelection();
        llmFillPopulateTypeSelect();
        llmFillPopulatePaperSelect();
        llmFillPopulateSheetSelect();
        llmFillRenderList();
        const filterBtn = $('#llmFillFilterMissing');
        if (filterBtn) {
          filterBtn.textContent = llmFillState.filterMissingOnly ? 'ë¯¸ì •ë‹µë§Œ' : 'ì „ì²´ ë³´ê¸°';
        }
      }

      function statsCollectProblems() {
        const src = problems.json?.types || {};
        const out = [];
        Object.keys(src).forEach(title => {
          (src[title] || []).forEach(p => {
            const applied = applyProblemOverrides(p);
            out.push({ ...applied, __typeTitle: title });
          });
        });
        return out;
      }

      // ì‹œí—˜ì§€ì—ì„œ í’€ ë•Œ ë¬¸ì œ ìœ ì‚¬ë„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¹„ìŠ·í•œ ë¬¸ì œë¥¼ ì¸ì ‘í•˜ê²Œ ë°°ì¹˜
      function clusterSimilarProblems(list) {
        const arr = Array.isArray(list) ? list.slice() : [];
        const n = arr.length;
        if (n <= 2) return arr;
        const texts = arr.map(p => {
          let raw = stripAnswerEmphasis(p.question_text || '');
          // remove obvious markdown noise but keep core tokens
          raw = raw.replace(/!\[[^\]]*?\]\([^)]+?\)/g, ' ');
          raw = raw.replace(/`[^`]*`/g, ' ');
          raw = raw.replace(/\s+/g, ' ').trim().toLowerCase();
          // keep alnum + hangul for stable similarity
          raw = raw.replace(/[^0-9a-zA-Zê°€-í£ ]+/g, ' ');
          raw = raw.replace(/\s+/g, ' ').trim();
          return raw.slice(0, 800);
        });

        function shingles(s, k) {
          const out = new Set();
          const str = String(s || '');
          if (str.length <= k) { if (str) out.add(str); return out; }
          for (let i = 0; i <= str.length - k; i++) out.add(str.slice(i, i + k));
          return out;
        }
        const sh = texts.map(t => shingles(t.replace(/\s+/g, ''), 3));
        function jaccard(a, b) {
          if (!a.size || !b.size) return 0;
          // iterate smaller set
          const [small, big] = a.size <= b.size ? [a, b] : [b, a];
          let inter = 0;
          small.forEach(x => { if (big.has(x)) inter++; });
          const union = a.size + b.size - inter;
          return union ? (inter / union) : 0;
        }

        const THRESH = 0.78;
        const used = new Array(n).fill(false);
        const out = [];
        for (let i = 0; i < n; i++) {
          if (used[i]) continue;
          used[i] = true;
          out.push(arr[i]);
          for (let j = i + 1; j < n; j++) {
            if (used[j]) continue;
            const sim = jaccard(sh[i], sh[j]);
            if (sim >= THRESH) {
              used[j] = true;
              out.push(arr[j]);
            }
          }
        }
        return out;
      }

      // Stats/Reviewì—ì„œ "ìœ ì‚¬ë„ ë¬¶ê¸°"ë¥¼ ìœ„í•´ ê·¸ë£¹ ë‹¨ìœ„ë¡œ ë°˜í™˜
      function clusterSimilarProblemGroups(list) {
        const arr = Array.isArray(list) ? list.slice() : [];
        const n = arr.length;
        if (n <= 1) return [{ items: arr }];

        const texts = arr.map(p => {
          let raw = stripAnswerEmphasis(p.question_text || '');
          raw = raw.replace(/!\[[^\]]*?\]\([^)]+?\)/g, ' ');
          raw = raw.replace(/`[^`]*`/g, ' ');
          raw = raw.replace(/\s+/g, ' ').trim().toLowerCase();
          raw = raw.replace(/[^0-9a-zA-Zê°€-í£ ]+/g, ' ');
          raw = raw.replace(/\s+/g, ' ').trim();
          return raw.slice(0, 800);
        });

        function shingles(s, k) {
          const out = new Set();
          const str = String(s || '');
          if (str.length <= k) { if (str) out.add(str); return out; }
          for (let i = 0; i <= str.length - k; i++) out.add(str.slice(i, i + k));
          return out;
        }
        const sh = texts.map(t => shingles(t.replace(/\s+/g, ''), 3));
        function jaccard(a, b) {
          if (!a.size || !b.size) return 0;
          const [small, big] = a.size <= b.size ? [a, b] : [b, a];
          let inter = 0;
          small.forEach(x => { if (big.has(x)) inter++; });
          const union = a.size + b.size - inter;
          return union ? (inter / union) : 0;
        }

        const THRESH = 0.78;
        const used = new Array(n).fill(false);
        const groups = [];
        for (let i = 0; i < n; i++) {
          if (used[i]) continue;
          used[i] = true;
          const items = [arr[i]];
          for (let j = i + 1; j < n; j++) {
            if (used[j]) continue;
            const sim = jaccard(sh[i], sh[j]);
            if (sim >= THRESH) {
              used[j] = true;
              items.push(arr[j]);
            }
          }
          groups.push({ items });
        }
        return groups;
      }

      // === Similarity index + auto sharing (memo/tag) ============================
      const similarityState = {
        groups: [],
        byQid: {}, // qid -> { groupId, ownerQid }
        cache: null // qid -> { sh:Set, text:string }
      };

      function normalizeTextForSimilarity(problem) {
        const p = problem || {};
        let raw = stripAnswerEmphasis(p.question_text || '');
        raw = raw.replace(/!\[[^\]]*?\]\([^)]+?\)/g, ' ');
        raw = raw.replace(/`[^`]*`/g, ' ');
        raw = raw.replace(/\s+/g, ' ').trim().toLowerCase();
        raw = raw.replace(/[^0-9a-zA-Zê°€-í£ ]+/g, ' ');
        raw = raw.replace(/\s+/g, ' ').trim();
        return raw.slice(0, 900);
      }
      function buildShinglesSet(text, k) {
        const out = new Set();
        const str = String(text || '').replace(/\s+/g, '');
        const kk = Number(k || 3) || 3;
        if (!str) return out;
        if (str.length <= kk) { out.add(str); return out; }
        for (let i = 0; i <= str.length - kk; i++) out.add(str.slice(i, i + kk));
        return out;
      }
      function jaccardSet(a, b) {
        if (!a || !b || !a.size || !b.size) return 0;
        const [small, big] = a.size <= b.size ? [a, b] : [b, a];
        let inter = 0;
        small.forEach(x => { if (big.has(x)) inter++; });
        const union = a.size + b.size - inter;
        return union ? (inter / union) : 0;
      }
      function yearKeyForQid(qid) {
        const y = extractYearFromQid(String(qid || ''));
        return (typeof y === 'number' && Number.isFinite(y)) ? y : Infinity;
      }
      function canonicalCompareQid(a, b) {
        const ya = yearKeyForQid(a);
        const yb = yearKeyForQid(b);
        if (ya !== yb) return ya - yb;
        return String(a || '').localeCompare(String(b || ''), 'ko');
      }

      function ensureSimilarityCache() {
        if (similarityState.cache) return similarityState.cache;
        const map = {};
        const all = (typeof statsCollectProblems === 'function') ? statsCollectProblems().map(applyProblemOverrides) : [];
        all.forEach(p => {
          const qid = String(p?.qid || '').trim();
          if (!qid || map[qid]) return;
          const t = normalizeTextForSimilarity(p);
          map[qid] = { text: t, sh: buildShinglesSet(t, 3) };
        });
        similarityState.cache = map;
        return map;
      }

      function findSimilarProblems(qid, threshold, limit) {
        const q = String(qid || '').trim();
        if (!q) return [];
        const TH = Number(threshold || 0.78);
        const LIM = Number(limit || 80) || 80;
        const cache = ensureSimilarityCache();
        const base = cache[q];
        if (!base || !base.sh || !base.sh.size) return [];
        const out = [];
        Object.keys(cache).forEach(other => {
          if (other === q) return;
          const sim = jaccardSet(base.sh, cache[other]?.sh);
          if (sim >= TH) out.push({ qid: other, score: sim });
        });
        out.sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          const ya = yearKeyForQid(a.qid);
          const yb = yearKeyForQid(b.qid);
          if (ya !== yb) return ya - yb;
          return String(a.qid).localeCompare(String(b.qid), 'ko');
        });
        return out.slice(0, Math.max(1, LIM));
      }

      function rebuildSimilarityGroupsAndApplyAutoSharing() {
        similarityState.groups = [];
        similarityState.byQid = {};
        similarityState.cache = null; // force refresh (question overrides may change)
        const all = (typeof statsCollectProblems === 'function') ? statsCollectProblems().map(applyProblemOverrides) : [];
        if (!all.length) return;

        // Prefer imported grouping when available:
        // - subgroup_tag: manually assigned subgroup for near-identical problems
        // - keep grouping within the same type to avoid cross-type memo leaks
        const normalizeSubgroup = (s) => String(s || '')
          .trim()
          .toLowerCase()
          .replace(/\s+/g, '');
        const subgroupMap = new Map(); // key -> items[]
        all.forEach(p => {
          const raw = String(p?.subgroup_tag || p?.subgroupTag || '').trim();
          if (!raw) return;
          const tag = normalizeSubgroup(raw);
          if (!tag) return;
          const typeTitle = String(p?.__typeTitle || '').trim();
          const key = `${typeTitle}::subgroup::${tag}`;
          if (!subgroupMap.has(key)) subgroupMap.set(key, []);
          subgroupMap.get(key).push(p);
        });

        let groups = [];
        subgroupMap.forEach(items => {
          if (Array.isArray(items) && items.length >= 2) groups.push({ items });
        });
        if (!groups.length) {
          groups = clusterSimilarProblemGroups(all);
        }

        const gOut = [];
        (groups || []).forEach((g, idx) => {
          const items = (g && Array.isArray(g.items)) ? g.items.slice() : [];
          const qids = items.map(p => String(p?.qid || '').trim()).filter(Boolean);
          const uniq = Array.from(new Set(qids));
          if (uniq.length <= 1) return;
          uniq.sort(canonicalCompareQid);
          const owner = uniq[0];
          const gid = 'G' + (idx + 1);
          gOut.push({ id: gid, ownerQid: owner, qids: uniq });
          uniq.forEach(qid => { similarityState.byQid[qid] = { groupId: gid, ownerQid: owner }; });
        });
        similarityState.groups = gOut;

        // Apply auto memo/tag sharing for grouped problems unless the user opted out or is in manual mode.
        gOut.forEach(g => {
          const owner = g.ownerQid;
          (g.qids || []).forEach(qid => {
            const st = getProblemState(qid);
            // Memo auto share
            if (!st.memoAutoOff && st.memoLinkMode !== 'manual') {
              if (qid === owner) {
                if (st.memoLink !== owner || st.memoLinkMode !== 'auto') {
                  updateProblemState(qid, { memoLink: owner, memoLinkMode: 'auto' });
                }
              } else {
                if (st.memoLink !== owner || st.memoLinkMode !== 'auto') {
                  updateProblemState(qid, { memoLink: owner, memoLinkMode: 'auto' });
                }
              }
            }
            // Tag auto share
            if (!st.tagAutoOff && st.tagLinkMode !== 'manual') {
              if (qid === owner) {
                if (st.tagLink !== owner || st.tagLinkMode !== 'auto') {
                  updateProblemState(qid, { tagLink: owner, tagLinkMode: 'auto' });
                }
              } else {
                if (st.tagLink !== owner || st.tagLinkMode !== 'auto') {
                  updateProblemState(qid, { tagLink: owner, tagLinkMode: 'auto' });
                }
              }
            }
          });
        });
      }
      window.rebuildSimilarityGroupsAndApplyAutoSharing = rebuildSimilarityGroupsAndApplyAutoSharing;

      function statsBuildOverview() {
        const box = $('#statsOverview');
        if (!box) return;
        const types = statsAllTypes();
        if (!types.length) {
          box.innerHTML = '<div class="muted">ë¬¸ì œ JSONì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”.</div>';
          return;
        }
        const rows = [];
        const orderIndex = new Map();
        types.forEach((t, idx) => orderIndex.set(t, idx));
        types.forEach(title => {
          const list = problemsForType(title).map(applyProblemOverrides);
          const total = list.length;
          let missing = 0, attempted = 0, correctEver = 0, wrongEver = 0;
          list.forEach(p => {
            const st = getProblemState(p.qid);
            if (!hasOfficialAnswer(p.official_answer)) missing++;
            if (st.attempts > 0) attempted++;
            if (st.correctCount > 0) correctEver++;
            if (st.wrongCount > 0) wrongEver++;
          });
          rows.push({ title, total, missing, attempted, correctEver, wrongEver });
        });
        if (statsState.typeSort === 'wrongDesc') {
          rows.sort((a, b) => {
            if (b.wrongEver !== a.wrongEver) return b.wrongEver - a.wrongEver;
            const ia = orderIndex.get(a.title) ?? 0;
            const ib = orderIndex.get(b.title) ?? 0;
            return ia - ib;
          });
        }
        const totalAll = rows.reduce((a, r) => a + r.total, 0);
        const missingAll = rows.reduce((a, r) => a + r.missing, 0);
        box.innerHTML = `
          <p class="muted">ì „ì²´ ${totalAll}ë¬¸í•­ Â· ê³µì‹ ì •ë‹µ ì—†ìŒ ${missingAll}ë¬¸í•­</p>
          <table>
            <thead><tr>
              <th>ìœ í˜•</th><th>ì „ì²´</th><th>ì‹œë„</th><th>ì •ë‹µ ê²½í—˜</th><th>ì˜¤ë‹µ ê²½í—˜</th><th>ê³µì‹ ì •ë‹µ ì—†ìŒ</th>
            </tr></thead>
            <tbody>
              ${rows.map(r => `
                <tr data-stats-type="${r.title.replace(/"/g, '&quot;')}">
                  <td>${sanitize(formatTypeLabel(r.title))}</td>
                  <td>${r.total}</td>
                  <td>${r.attempted}</td>
                  <td>${r.correctEver}</td>
                  <td>${r.wrongEver}</td>
                  <td>${r.missing}</td>
                </tr>`).join('')}
            </tbody>
          </table>`;
        box.querySelectorAll('tbody tr').forEach(tr => {
          tr.addEventListener('click', () => {
            const title = tr.getAttribute('data-stats-type') || '';
            const sel = $('#statsTypeSelect');
            if (sel) {
              Array.from(sel.options).forEach(opt => { opt.selected = (opt.value === title); });
            }
            statsRenderMissingList();
          });
        });
      }

      function statsPopulateTypeSelect() {
        const sel = $('#statsTypeSelect');
        if (!sel) return;
        sel.innerHTML = '';
        const optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = 'ì „ì²´ ìœ í˜•';
        sel.appendChild(optAll);
        statsAllTypes().forEach(title => {
          const opt = document.createElement('option');
          opt.value = title;
          opt.textContent = formatTypeLabel(title);
          sel.appendChild(opt);
        });
      }

      function extractYearForStatsProblem(p) {
        if (!p) return null;
		        // 1) qid ì—ì„œ ì—°ë„ ì¶”ì¶œ
		        let y = extractYearFromQid(p.qid);
		        // 2) ì‹œí—˜ì§€ ì´ë¦„(ë˜ëŠ” qid prefix)ì—ì„œ ì¶”ì¶œ
		        if (!y) {
		          const paperSrc = String(p.paperName || p.paperSourceName || extractPaperFromQid(p.qid) || '').trim();
		          y = extractYearFromQid(paperSrc);
		        }
		        // 3) ë¬¸ì œ í…ìŠ¤íŠ¸ ì•ˆì— ë‚ ì§œ/ì—°ë„ë§Œ ìˆëŠ” ê²½ìš° (ì˜ˆ: 20100328í•´ì„¤)
		        if (!y && p.question_text) {
          y = extractYearFromQid(p.question_text);
        }
        return y;
      }

      function compareNumericOp(val, op, thr) {
        const v = Number(val || 0);
        const t = Number(thr || 0);
        const o = String(op || '>=');
        if (o === '==') return v === t;
        if (o === '<=') return v <= t;
        return v >= t;
      }

      function statsComputeMarkedCounts() {
        const out = {};
        const hist = LS.get(SOLVE_HISTORY_KEY, []);
        (hist || []).forEach(h => {
          const arr = Array.isArray(h?.marked) ? h.marked : [];
          arr.forEach(qid => {
            const k = String(qid || '').trim();
            if (!k) return;
            out[k] = (out[k] || 0) + 1;
          });
        });
        return out;
      }

      function statsReadFilterCfgFromUi() {
        try { ensureStatsTagCheckboxes(); } catch { }
        const joinMode = ($('#statsJoinMode')?.value || 'and').trim();
        const typeTitle = ($('#statsTypeSelect')?.value || '').trim();
        const tagMode = ($('#statsTagMode')?.value || 'include').trim();
        const tagSet = getCheckedTagSetFromContainer('statsTagChecks');
        const attemptedMode = ($('#statsAttemptedMode')?.value || '').trim();
        const correctMode = ($('#statsCorrectMode')?.value || '').trim();
        const yearOp = ($('#statsYearOp')?.value || '>=').trim();
        const yearRaw = ($('#statsYearFilter')?.value || '').trim();
        const yearFilter = yearRaw ? (parseInt(yearRaw, 10) || 0) : 0;
        const wrongOp = ($('#statsWrongOp')?.value || '>=').trim();
        const wrongRaw = ($('#statsWrongCount')?.value || '').trim();
        const wrongFilter = wrongRaw ? (parseInt(wrongRaw, 10) || 0) : 0;
        const markedOp = ($('#statsMarkedOp')?.value || '>=').trim();
        const markedRaw = ($('#statsMarkedCount')?.value || '').trim();
        const markedFilter = markedRaw ? (parseInt(markedRaw, 10) || 0) : 0;
        const paperTarget = ($('#statsPaperSelect')?.value || '').trim();
        const onlyMissing = !!statsState.filterMissingOnly;
        return { joinMode, typeTitle, tagMode, tagSet, attemptedMode, correctMode, yearOp, yearFilter, wrongOp, wrongFilter, markedOp, markedFilter, paperTarget, onlyMissing };
      }

      function statsPassesFilters(cfg, p, st, tag, markedCount, year, missing, pid) {
        const joinMode = (cfg?.joinMode === 'or') ? 'or' : 'and';
        const checks = [];

        const typeTitle = String(cfg?.typeTitle || '').trim();
        if (typeTitle) checks.push(() => p.__typeTitle === typeTitle);

        const tagMode = (String(cfg?.tagMode || 'include').trim() === 'exclude') ? 'exclude' : 'include';
        const tagSet = cfg?.tagSet;
        if (tagMode === 'include' && tagSet && tagSet.size) checks.push(() => tagSet.has(tag));

        const attemptedMode = String(cfg?.attemptedMode || '').trim();
        const attempts = st?.attempts || 0;
        if (attemptedMode === 'has') checks.push(() => attempts > 0);
        else if (attemptedMode === 'none') checks.push(() => attempts <= 0);

        const correctMode = String(cfg?.correctMode || '').trim();
        const correctCount = st?.correctCount || 0;
        if (correctMode === 'has') checks.push(() => correctCount > 0);
        else if (correctMode === 'none') checks.push(() => correctCount <= 0);

        const wrongFilter = Number(cfg?.wrongFilter || 0) || 0;
        if (wrongFilter > 0) checks.push(() => compareNumericOp(st?.wrongCount || 0, cfg?.wrongOp, wrongFilter));

        const markedFilter = Number(cfg?.markedFilter || 0) || 0;
        if (markedFilter > 0) checks.push(() => compareNumericOp(markedCount || 0, cfg?.markedOp, markedFilter));

        const yearFilter = Number(cfg?.yearFilter || 0) || 0;
        if (yearFilter > 0) {
          // Keep original behavior: only constrain when year is known; unknown years remain included.
          checks.push(() => !year || compareNumericOp(year, cfg?.yearOp, yearFilter));
        }

        const onlyMissing = !!cfg?.onlyMissing;
        if (onlyMissing) checks.push(() => !!missing);

        const paperTarget = String(cfg?.paperTarget || '').trim();
        if (paperTarget) checks.push(() => String(pid || '') === paperTarget);

        const includePass = checks.length
          ? (joinMode === 'or' ? checks.some(fn => fn()) : checks.every(fn => fn()))
          : true;

        if (!includePass) return false;

        if (tagMode === 'exclude' && tagSet && tagSet.size) {
          if (tagSet.has(tag)) return false;
        }

        return true;
      }

      function statsRenderMissingList() {
        const listEl = $('#statsMissingList');
        if (!listEl) return;
	        try { ensureStatsTagCheckboxes(); } catch { }
			        const entries = Object.entries(statsState.problemMap || {});
			        if (!entries.length) {
			          statsState.filteredProblems = [];
			          listEl.innerHTML = '<div class="muted">ë¬¸ì œ JSONì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”.</div>';
			          return;
			        }
			        const cfg = statsReadFilterCfgFromUi();
			        const clusterOn = !!$('#statsClusterSimilar')?.checked;
			        const items = [];
		        const markedCounts = statsComputeMarkedCounts();
		        statsState.lastItems = [];
		        entries.forEach(([key, p]) => {
	          if (!p) return;
	          const qid = String(p.qid || '');
	          if (!qid) return;
	          const st = getProblemState(qid);
	          const markedCount = markedCounts[qid] || 0;
	          const tag = getEffectiveTag(qid);
	          const year = extractYearForStatsProblem(p);
	          const missing = !hasOfficialAnswer(p.official_answer);
	          const pid = paperKeyForProblem(p) || '';
	          if (!statsPassesFilters(cfg, p, st, tag, markedCount, year, missing, pid)) return;
			          statsState.lastItems.push(key);
			          items.push({ key, p, year, missing, _st: st, _markedCount: markedCount });
			        });
        // When filters change, auto-clear selections that are no longer visible.
        // ideology: selection should reflect what the user can currently see.
        const visible = new Set(statsState.lastItems || []);
        if (statsState.selectedKeys && statsState.selectedKeys.size) {
          statsState.selectedKeys = new Set(Array.from(statsState.selectedKeys).filter(k => visible.has(k)));
        }
	        if (!items.length) {
	          statsState.filteredProblems = [];
	          listEl.innerHTML = '<div class="muted">ì¡°ê±´ì— ë§ëŠ” ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
	          return;
	        }
        // Optional: cluster similar problems into adjacent groups (render-only).
        let orderedItems = items.slice();
        let groups = null;
	        if (clusterOn && items.length > 2) {
	          const byQid = new Map(items.map(it => [String(it.p.qid || ''), it]));
	          groups = clusterSimilarProblemGroups(items.map(it => it.p));
	          orderedItems = [];
          groups.forEach((g, gi) => {
            (g.items || []).forEach(p => {
              const qid = String(p?.qid || '');
              const it = byQid.get(qid);
              if (it) orderedItems.push({ ...it, _group: gi + 1, _groupSize: (g.items || []).length });
            });
	          });
	        }
	        statsState.filteredProblems = orderedItems.map(it => it.p).filter(Boolean);

	        let htmlOut = '';
	        let lastGroup = null;
	        orderedItems.forEach(item => {
          const st = item._st || getProblemState(item.p.qid);
          const tag = getEffectiveTag(item.p.qid);
          const wrongCount = st.wrongCount || 0;
          const markedCount = item._markedCount || 0;
          const attempts = st.attempts || 0;
          const correctCount = st.correctCount || 0;
          const accuracy = attempts > 0 ? Math.round((correctCount / attempts) * 100) : 0;
          const checked = statsState.selectedKeys.has(item.key) ? 'checked' : '';
          if (clusterOn && item._group && item._group !== lastGroup) {
            htmlOut += `<div class="muted" style="margin:8px 0 4px;">ìœ ì‚¬ ê·¸ë£¹ ${item._group} Â· ${item._groupSize}ë¬¸í•­</div>`;
            lastGroup = item._group;
          }
          htmlOut += `<label class="problems-item">
            <input type="checkbox" data-stats-key="${item.key}" ${checked}>
            <span class="tag-badge">${tag}</span>
            <strong>${sanitize(item.p.qid)}</strong>
            ${item.year ? `<span class="pill">${item.year}</span>` : ''}
            <span class="pill">${sanitize(item.p.__typeTitle ? formatTypeLabel(item.p.__typeTitle) : '')}</span>
            ${item.missing ? '<span class="pill">ê³µì‹ì •ë‹µ ì—†ìŒ</span>' : ''}
            ${markedCount > 0 ? `<span class="pill">ì°ìŒ ${markedCount}</span>` : ''}
            ${attempts > 0 ? `<span class="pill">ì˜¤ë‹µ ${wrongCount} / í’€ì´ ${attempts} Â· ì •ë‹µë¥  ${accuracy}%</span>` : ''}
          </label>`;
        });
        listEl.innerHTML = htmlOut;
        listEl.querySelectorAll('input[type="checkbox"][data-stats-key]').forEach(cb => {
          cb.addEventListener('change', () => {
            const key = cb.getAttribute('data-stats-key');
            if (!key) return;
            if (cb.checked) statsState.selectedKeys.add(key);
            else statsState.selectedKeys.delete(key);
          });
        });
      }

		      function statsPopulatePaperSelect() {
		        const sel = $('#statsPaperSelect');
		        if (!sel) return;
		        const reg = ensurePaperRegistry();
		        const map = statsState.problemMap || {};
		        const names = new Set();
		        Object.values(map).forEach(p => {
		          if (!p) return;
		          const pid = paperKeyForProblem(p) || '';
		          if (pid) names.add(pid);
		        });
		        const sorted = Array.from(names).sort((a, b) => {
		          const an = reg.papers?.[a]?.name || a;
		          const bn = reg.papers?.[b]?.name || b;
		          return an.localeCompare(bn, 'ko');
		        });
		        sel.innerHTML = '';
	        const optAll = document.createElement('option');
	        optAll.value = '';
	        optAll.textContent = 'ì „ì²´ ì‹œí—˜ì§€';
	        sel.appendChild(optAll);
		        sorted.forEach(pid => {
		          const paperName = reg.papers?.[pid]?.name || '';
		          const opt = document.createElement('option');
		          opt.value = pid;
		          opt.textContent = formatPaperNameDisplay(paperName, '') || paperName || pid;
		          sel.appendChild(opt);
		        });
		      }

      function saveSheets() {
        LS.set(SHEETS_KEY, sheetState.list);
      }
      function ensureSheetSelected() {
        if (sheetState.selectedId && sheetState.list.some(s => s.id === sheetState.selectedId)) return;
        sheetState.selectedId = sheetState.list.length ? sheetState.list[0].id : null;
      }
      function findSheet(id) {
        return sheetState.list.find(s => s.id === id) || null;
      }

      function statsRenderSheetSelect() {
        const sel = $('#sheetSelect');
        if (!sel) return;
        sel.innerHTML = '';
        if (!sheetState.list.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'ì‹œí—˜ì§€ ì—†ìŒ';
          sel.appendChild(opt);
          return;
        }
        ensureSheetSelected();
        sheetState.list.forEach(sheet => {
          const opt = document.createElement('option');
          opt.value = sheet.id;
          opt.textContent = sheet.name || '(ì œëª© ì—†ìŒ)';
          if (sheet.id === sheetState.selectedId) opt.selected = true;
          sel.appendChild(opt);
        });
      }

	      function statsRenderSheetDetail() {
	        const infoEl = $('#sheetInfo');
	        const listEl = $('#sheetProblemList');
        const historyPanel = $('#sheetHistoryPanel');
        const historyList = $('#sheetHistoryList');
        const historyEmpty = $('#sheetHistoryEmpty');
        const probHistPanel = $('#sheetProblemHistoryPanel');
        const probHistTitle = $('#sheetProblemHistoryTitle');
        const probHistList = $('#sheetProblemHistoryList');
        if (!infoEl || !listEl) return;
        const sheet = findSheet(sheetState.selectedId);
        if (!sheet) {
          infoEl.textContent = 'ì‹œí—˜ì§€ë¥¼ ë¨¼ì € ìƒì„±í•˜ì„¸ìš”.';
          listEl.innerHTML = '';
          sheetState.focusQid = null;
          if (probHistPanel && probHistList) { probHistPanel.style.display = 'none'; probHistList.innerHTML = ''; }
          if (historyPanel && historyList && historyEmpty) {
            historyPanel.style.display = 'none';
            historyList.innerHTML = '';
            historyEmpty.style.display = '';
          }
          return;
        }
        const orderSel = $('#sheetSolveOrder');
        if (orderSel) orderSel.value = sheet.solveOrder || 'similar';
	        const qids = Array.isArray(sheet.qids) ? sheet.qids : [];
	        const allProblems = Object.values(statsState.problemMap || {});
	        const problems = qids.map(qid => allProblems.find(p => p && p.qid === qid)).filter(Boolean);
        const total = qids.length;
        const historyAll = LS.get(SOLVE_HISTORY_KEY, []);
        const hist = historyAll.filter(h => h && h.sheetId === sheet.id);
        const attempts = hist.length;
        let summary = `ë¬¸í•­ ${total}ê°œ Â· í’€ì´ ${attempts}íšŒ`;
        if (attempts) {
          const last = hist[hist.length - 1];
          const lastTotal = last.total ?? problems.length;
          const lastCorrect = (last.correct || []).length;
          const lastWrong = (last.wrong || []).length;
          summary += ` Â· ìµœê·¼: ë§ìŒ ${lastCorrect} Â· í‹€ë¦¼ ${lastWrong} / ${lastTotal}`;
        }
	        infoEl.textContent = summary;
	
		        // Apply the same filters as stats list to sheet problems (so filters are composable).
		        const cfg = statsReadFilterCfgFromUi();
		        const markedCounts = statsComputeMarkedCounts();

	        function renderSheetProblemHistory(qid) {
	          const q = String(qid || '').trim();
          if (!probHistPanel || !probHistTitle || !probHistList) return;
          if (!q) { probHistPanel.style.display = 'none'; probHistList.innerHTML = ''; return; }
          probHistPanel.style.display = '';
          probHistTitle.textContent = `ë¬¸ì œ í’€ì´ ê¸°ë¡ Â· ${q}`;
          const rel = (hist || []).filter(h => {
            const queue = Array.isArray(h?.queue) ? h.queue : [];
            if (queue.includes(q)) return true;
            return !!(h?.answers && typeof h.answers === 'object' && Object.prototype.hasOwnProperty.call(h.answers, q));
          }).slice().sort((a, b) => {
            const ta = b?.gradedAt ?? b?.startedAt ?? 0;
            const tb = a?.gradedAt ?? a?.startedAt ?? 0;
            return ta - tb;
          });
          if (!rel.length) {
            probHistList.innerHTML = '<div class="muted">ì´ ì‹œí—˜ì§€ë¡œ í‘¼ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
            return;
          }
          probHistList.innerHTML = rel.map(h => {
            const ts = new Date(h.gradedAt || h.startedAt || Date.now()).toLocaleString();
            const qCorrect = (h.correct || []).includes(q);
            const qWrong = (h.wrong || []).includes(q);
            const qSkipped = (h.skipped || []).includes(q);
            const verdict = qCorrect ? 'ë§ìŒ' : (qWrong ? 'í‹€ë¦¼' : (qSkipped ? 'ìŠ¤í‚µ' : 'ë¯¸ìƒ'));
            const ans = (h.answers && h.answers[q]) ? (h.answers[q].choice || '') : '';
            const hid = String(h.id || '').replace(/\"/g, '&quot;');
            return `<div class="problems-item" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
              <strong>${sanitize(ts)}</strong>
              <span class="pill">${sanitize(verdict)}</span>
              ${ans ? `<span class="pill">ì„ íƒ ${sanitize(ans)}</span>` : ''}
              <div style="display:flex;gap:6px;flex-wrap:wrap;margin-left:auto;">
                <button class="btn" data-act="set" data-hid="${hid}" data-qid="${String(q).replace(/\"/g, '&quot;')}" data-val="true">ì •ë‹µ</button>
                <button class="btn" data-act="set" data-hid="${hid}" data-qid="${String(q).replace(/\"/g, '&quot;')}" data-val="false">ì˜¤ë‹µ</button>
              </div>
            </div>`;
          }).join('');
          probHistList.querySelectorAll('button[data-act="set"][data-hid][data-qid][data-val]').forEach(btn => {
            btn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              const hid = btn.getAttribute('data-hid') || '';
              const qid2 = btn.getAttribute('data-qid') || '';
              const val = btn.getAttribute('data-val');
              if (!hid || !qid2 || (val !== 'true' && val !== 'false')) return;
              const nextCorrect = val === 'true';
              updateSolveHistoryVerdict(hid, qid2, nextCorrect);
              updateProblemAttemptVerdict(qid2, hid, nextCorrect);
              statusEl.textContent = `í’€ì´ ê¸°ë¡ ìˆ˜ì •ë¨ Â· ${qid2} â†’ ${nextCorrect ? 'ì •ë‹µ' : 'ì˜¤ë‹µ'}`;
              sheetState.focusQid = qid2;
              statsRenderSheetDetail();
            });
          });
        }

        if (historyPanel && historyList && historyEmpty) {
          historyList.innerHTML = '';
          if (!hist.length) {
            historyPanel.style.display = 'none';
            historyEmpty.style.display = '';
          } else {
            historyPanel.style.display = '';
            historyEmpty.style.display = 'none';
            const sorted = hist.slice().sort((a, b) => {
              const ta = b.gradedAt ?? b.startedAt ?? 0;
              const tb = a.gradedAt ?? a.startedAt ?? 0;
              return ta - tb;
            });
            historyList.innerHTML = sorted.map(h => {
              const ts = new Date(h.gradedAt || h.startedAt || Date.now()).toLocaleString();
              const totalRow = h.total ?? (Array.isArray(h.queue) ? h.queue.length : 0);
              const c = (h.correct || []).length;
              const w = (h.wrong || []).length;
              const s = (h.skipped || []).length;
              return `<div class="problems-item" data-history-id="${h.id || ''}" style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
                <strong>${ts}</strong>
                <span class="pill">ì ìˆ˜ ${c} / ${totalRow}</span>
                <span class="pill">í‹€ë¦¼ ${w}</span>
                ${s ? `<span class="pill">ìŠ¤í‚µ ${s}</span>` : ''}
                <button class="btn" data-history-del="${h.id || ''}" style="margin-left:auto;">ì‚­ì œ</button>
              </div>`;
            }).join('');
            historyList.querySelectorAll('[data-history-del]').forEach(btn => {
              btn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const hid = btn.getAttribute('data-history-del');
                if (!hid) return;
                if (!confirm('ì´ í…ŒìŠ¤íŠ¸ ê¸°ë¡ì„ ì‚­ì œí• ê¹Œìš”?')) return;
                const all = LS.get(SOLVE_HISTORY_KEY, []);
                const next = all.filter(h => h && h.id !== hid);
                LS.set(SOLVE_HISTORY_KEY, next);
                statsRenderSheetDetail();
              });
            });
            historyList.querySelectorAll('.problems-item[data-history-id]').forEach(row => {
              row.addEventListener('click', () => {
                const hid = row.getAttribute('data-history-id');
                if (!hid) return;
                const all = LS.get(SOLVE_HISTORY_KEY, []);
                const entry = all.find(h => h && h.id === hid);
                if (!entry) return;
                const baseQueue = Array.isArray(entry.queue) && entry.queue.length
                  ? entry.queue
                  : (Array.isArray(sheet.qids) ? sheet.qids.slice() : []);
                const selected = baseQueue.map(qid => allProblems.find(p => p && p.qid === qid)).filter(Boolean);
                if (!selected.length) {
                  alert('ì´ ê¸°ë¡ì— í•´ë‹¹í•˜ëŠ” ë¬¸ì œë¥¼ ë¬¸ì œ JSONì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                  return;
                }
                if (typeof solveWindow !== 'undefined') {
                  solveWindow.classList.add('active');
                  solveWindow.style.display = '';
                  restoreSavedBox(solveWindow, 'fmm_ui_solveWindow');
                }
                if (typeof startSolveSession === 'function') {
	                  startSolveSession(selected, {
	                    typeTitle: entry.typeTitle || `[ì‹œí—˜ì§€] ${sheet.name || ''}`,
	                    sheetId: sheet.id,
	                    sheetName: sheet.name || '',
	                    reviewOnly: true,
	                    historyId: entry.id,
	                    result: {
	                      correct: Array.isArray(entry.correct) ? entry.correct.slice() : [],
	                      wrong: Array.isArray(entry.wrong) ? entry.wrong.slice() : [],
	                      skipped: Array.isArray(entry.skipped) ? entry.skipped.slice() : []
	                    },
	                    answers: entry.answers || null,
	                    marked: entry.marked || null
	                  });
	                }
              });
            });
          }
        }

        listEl.innerHTML = '';
        if (!problems.length) {
          listEl.innerHTML = '<div class="muted">ì‹œí—˜ì§€ì— í¬í•¨ëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
          sheetState.focusQid = null;
          if (probHistPanel && probHistList) { probHistPanel.style.display = 'none'; probHistList.innerHTML = ''; }
          return;
        }
		        const qidSet = new Set(qids.map(x => String(x || '')));
		        problems.forEach(p => {
		          if (!p) return;
		          const qid = String(p.qid || '');
		          if (!qid) return;
		          const st = getProblemState(qid);
		          const tag = getEffectiveTag(qid);
		          const wrongCount = st.wrongCount || 0;
		          const correctCount = st.correctCount || 0;
		          const attempts = st.attempts || 0;
		          const accuracy = attempts > 0 ? Math.round((correctCount / attempts) * 100) : 0;
		          const markedCount = markedCounts[qid] || 0;
		          const year = extractYearForStatsProblem(p);
		          const missing = !hasOfficialAnswer(p.official_answer);
		          const pid = paperKeyForProblem(p) || '';
		          if (!statsPassesFilters(cfg, p, st, tag, markedCount, year, missing, pid)) return;
		          if (sheetState.wrongOnly && wrongCount === 0) return;
		          const paper = formatPaperNameDisplay(p.paperName, p.qid);
		          const div = document.createElement('div');
	          div.className = 'problems-item';
	          div.dataset.qid = String(p.qid || '');
	          if (sheetState.focusQid === p.qid) div.style.outline = '1px dashed var(--border)';
	          div.innerHTML = `
	            <strong>${sanitize(p.qid)}</strong>
	            <span class="tag-badge">${tag}</span>
	            ${year ? `<span class="pill">${year}</span>` : ''}
	            ${paper ? `<span class="pill">${sanitize(paper)}</span>` : ''}
	            ${missing ? '<span class="pill">ê³µì‹ì •ë‹µ ì—†ìŒ</span>' : ''}
	            ${markedCount > 0 ? `<span class="pill">ì°ìŒ ${markedCount}</span>` : ''}
	            <span class="pill">ë§ìŒ ${correctCount} Â· í‹€ë¦¼ ${wrongCount} / í’€ì´ ${attempts} Â· ì •ë‹µë¥  ${accuracy}%</span>
	          `;
          div.addEventListener('click', () => {
            sheetState.focusQid = String(p.qid || '');
            listEl.querySelectorAll('.problems-item[data-qid]').forEach(el => { el.style.outline = ''; });
            div.style.outline = '1px dashed var(--border)';
            renderSheetProblemHistory(sheetState.focusQid);
          });
          listEl.appendChild(div);
        });
        if (!listEl.innerHTML.trim()) {
          listEl.innerHTML = '<div class="muted">ì¡°ê±´ì— ë§ëŠ” ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
        }
        const focus = String(sheetState.focusQid || '').trim();
        if (focus && qidSet.has(focus)) {
          renderSheetProblemHistory(focus);
        } else {
          sheetState.focusQid = null;
          if (probHistPanel && probHistList) { probHistPanel.style.display = 'none'; probHistList.innerHTML = ''; }
        }
      }

      function statsRefresh() {
        // rebuild global problem map with latest overrides
        statsState.problemMap = {};
        statsCollectProblems().forEach(p => {
          const key = `${p.__typeTitle}::${p.qid}`;
          statsState.problemMap[key] = p;
        });
        statsPopulateTypeSelect();
        statsPopulatePaperSelect();
        statsBuildOverview();
        statsRenderMissingList();
        statsRenderSheetSelect();
        statsRenderSheetDetail();
        const filterBtn = $('#statsFilterMissing');
        if (filterBtn) {
          filterBtn.textContent = statsState.filterMissingOnly ? 'ë¯¸ì •ë‹µë§Œ' : 'ì „ì²´ ë³´ê¸°';
        }
      }

      if (statsToggleBtn && statsWin) {
        statsToggleBtn.addEventListener('click', () => {
          const showing = statsWin.classList.contains('active');
          statsWin.classList.toggle('active', !showing);
          statsWin.style.display = showing ? 'none' : '';
			          if (!showing) {
			            try { ensureStatsTagCheckboxes(); } catch { }
			            const tagModeSel = $('#statsTagMode');
			            if (tagModeSel) tagModeSel.value = 'include';
			            const joinSel = $('#statsJoinMode');
			            if (joinSel) joinSel.value = 'and'; // ê¸°ë³¸ê°’: AND
			            try { clearCheckedTagSetInContainer('statsTagChecks'); } catch { }
			            const attemptedMode = $('#statsAttemptedMode');
			            if (attemptedMode) attemptedMode.value = '';
			            const correctMode = $('#statsCorrectMode');
			            if (correctMode) correctMode.value = '';
		            const yearOp = $('#statsYearOp');
		            if (yearOp) yearOp.value = '>='; // ê¸°ë³¸ê°’: ì´ìƒ(â‰¥)
		            const yearInput = $('#statsYearFilter');
		            if (yearInput) {
              yearInput.value = ''; // ê¸°ë³¸ê°’: ì—°ë„ í•„í„° ì—†ìŒ (0ë…„)
            }
            restoreSavedBox(statsWin, 'fmm_ui_statsWindow');
            statsRefresh();
          }
        });
      }
      if (llmFillToggleBtn && llmFillWin) {
        llmFillToggleBtn.addEventListener('click', () => {
          const showing = llmFillWin.classList.contains('active');
          toggleAnswerPanel(!showing);
        });
      }
	      $('#statsRefreshBtn')?.addEventListener('click', statsRefresh);
	      const statsOnFiltersChanged = () => {
	        statsRenderMissingList();
	        statsRenderSheetDetail();
	      };
	      $('#statsFilterMissing')?.addEventListener('click', () => {
	        statsState.filterMissingOnly = !statsState.filterMissingOnly;
	        const btn = $('#statsFilterMissing');
	        if (btn) btn.textContent = statsState.filterMissingOnly ? 'ë¯¸ì •ë‹µë§Œ' : 'ì „ì²´ ë³´ê¸°';
	        statsOnFiltersChanged();
	      });
      $('#statsSelectAllMissing')?.addEventListener('click', () => {
        statsState.selectedKeys = new Set(statsState.lastItems || []);
        statsRenderMissingList();
      });
	      $('#statsClearSelection')?.addEventListener('click', () => {
	        statsState.selectedKeys = new Set();
	        statsRenderMissingList();
	      });
			      $('#statsTypeSelect')?.addEventListener('change', statsOnFiltersChanged);
			      $('#statsJoinMode')?.addEventListener('change', statsOnFiltersChanged);
			      $('#statsTagMode')?.addEventListener('change', statsOnFiltersChanged);
			      $('#statsTagChecks')?.addEventListener('change', statsOnFiltersChanged);
			      $('#statsAttemptedMode')?.addEventListener('change', statsOnFiltersChanged);
			      $('#statsCorrectMode')?.addEventListener('change', statsOnFiltersChanged);
		      $('#statsYearOp')?.addEventListener('change', statsOnFiltersChanged);
		      $('#statsYearFilter')?.addEventListener('change', statsOnFiltersChanged);
		      $('#statsWrongOp')?.addEventListener('change', statsOnFiltersChanged);
		      $('#statsWrongCount')?.addEventListener('input', statsOnFiltersChanged);
	      $('#statsMarkedOp')?.addEventListener('change', statsOnFiltersChanged);
	      $('#statsMarkedCount')?.addEventListener('input', statsOnFiltersChanged);
	      $('#statsClusterSimilar')?.addEventListener('change', statsOnFiltersChanged);
	      $('#statsPaperSelect')?.addEventListener('change', statsOnFiltersChanged);
	      $('#statsTypeOrder')?.addEventListener('change', (e) => {
	        const val = e.target.value || 'guide';
	        statsState.typeSort = val;
	        statsBuildOverview();
	      });
	      $('#statsLlmSettings')?.addEventListener('click', () => toggleAnswerPanel(true));
	      $('#statsCollectFiltered')?.addEventListener('click', () => {
	        const items = Array.isArray(statsState.filteredProblems) ? statsState.filteredProblems.slice() : [];
	        if (!items.length) {
	          alert('ì¡°ê±´ì— ë§ëŠ” ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
	          return;
	        }
			        const parts = [];
			        const cfg = statsReadFilterCfgFromUi();
			        if (cfg.joinMode === 'or') parts.push('OR ê²°í•©');
			        if (cfg.typeTitle) parts.push(formatTypeLabel(cfg.typeTitle));
			        if (cfg.tagSet && cfg.tagSet.size) {
			          const tagRaw = Array.from(cfg.tagSet).join('');
			          parts.push(`${cfg.tagMode === 'exclude' ? 'íƒœê·¸ ì œì™¸(OR)' : 'íƒœê·¸ í¬í•¨(OR)'}:${tagRaw}`);
			        }
			        if (cfg.attemptedMode === 'has') parts.push('í’€ì´ê²½í—˜ ìˆìŒ');
			        else if (cfg.attemptedMode === 'none') parts.push('í’€ì´ê²½í—˜ ì—†ìŒ');
			        if (cfg.correctMode === 'has') parts.push('ì •ë‹µê²½í—˜ ìˆìŒ');
			        else if (cfg.correctMode === 'none') parts.push('ì •ë‹µê²½í—˜ ì—†ìŒ');
			        if ((cfg.yearFilter || 0) > 0) parts.push(`ì—°ë„${cfg.yearOp || '>='}${cfg.yearFilter}`);
			        if ((cfg.wrongFilter || 0) > 0) parts.push(`ì˜¤ë‹µ${cfg.wrongOp || '>='}${cfg.wrongFilter}`);
			        if ((cfg.markedFilter || 0) > 0) parts.push(`ì°ìŒ${cfg.markedOp || '>='}${cfg.markedFilter}`);
			        if (cfg.paperTarget) parts.push(`ì‹œí—˜ì§€:${cfg.paperTarget}`);
			        if (cfg.onlyMissing) parts.push('ë¯¸ì •ë‹µë§Œ');
	        const label = parts.length ? parts.join(' Â· ') : 'í†µê³„ í•„í„°';
	        if (typeof window.openCollectionInSolve === 'function') window.openCollectionInSolve(items, label);
	        else if (typeof openProblemCollectionInSolve === 'function') openProblemCollectionInSolve(items, label);
	      });

	      // ì‹œí—˜ì§€ ê´€ë¦¬ ì´ë²¤íŠ¸
	      $('#sheetSelect')?.addEventListener('change', (e) => {
	        sheetState.selectedId = e.target.value || null;
        statsRenderSheetDetail();
      });
      $('#sheetWrongOnly')?.addEventListener('change', (e) => {
        sheetState.wrongOnly = !!e.target.checked;
        statsRenderSheetDetail();
      });
      $('#sheetSolveOrder')?.addEventListener('change', (e) => {
        const sheet = findSheet(sheetState.selectedId);
        if (!sheet) return;
        sheet.solveOrder = e.target.value || 'similar';
        saveSheets();
      });
      $('#sheetRenameBtn')?.addEventListener('click', () => {
        const sheet = findSheet(sheetState.selectedId);
        if (!sheet) {
          alert('ë¨¼ì € ì‹œí—˜ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
          return;
        }
        const name = prompt('ìƒˆ ì‹œí—˜ì§€ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.', sheet.name || '');
        if (!name) return;
        sheet.name = name.trim();
        saveSheets();
        statsRenderSheetSelect();
        statsRenderSheetDetail();
      });
      $('#sheetDeleteBtn')?.addEventListener('click', () => {
        const sheet = findSheet(sheetState.selectedId);
        if (!sheet) {
          alert('ë¨¼ì € ì‹œí—˜ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
          return;
        }
        if (!confirm('ì´ ì‹œí—˜ì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ë¬¸ì œ/í’€ì´ ê¸°ë¡ì€ ìœ ì§€ë©ë‹ˆë‹¤.)')) return;
        sheetState.list = sheetState.list.filter(s => s.id !== sheet.id);
        sheetState.selectedId = null;
        saveSheets();
        statsRenderSheetSelect();
        statsRenderSheetDetail();
      });
      $('#sheetNewBtn')?.addEventListener('click', () => {
        const name = prompt('ìƒˆ ì‹œí—˜ì§€ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.');
        if (!name) return;
        const sheet = {
          id: 'sheet_' + Date.now(),
          name: name.trim(),
          qids: []
        };
        sheetState.list.push(sheet);
        sheetState.selectedId = sheet.id;
        saveSheets();
        statsRenderSheetSelect();
        statsRenderSheetDetail();
      });
      function computeSheetOrderedQids(sheet, order) {
        const qids = Array.isArray(sheet?.qids) ? sheet.qids.slice() : [];
        if (qids.length <= 1) return qids;
        const o = String(order || sheet?.solveOrder || 'similar');
        if (o === 'sheet') return qids;
        if (o === 'uid') {
          return qids.slice().sort((a, b) => {
            const na = extractQuestionNumberFromQid(a);
            const nb = extractQuestionNumberFromQid(b);
            if (na != null && nb != null && na !== nb) return na - nb;
            if (na != null && nb == null) return -1;
            if (na == null && nb != null) return 1;
            return String(a || '').localeCompare(String(b || ''), 'ko');
          });
        }
        // similar: order by similarity adjacency (based on question text)
        const allProblems = Object.values(statsState.problemMap || {});
        const found = qids.map(qid => allProblems.find(p => p && p.qid === qid)).filter(Boolean);
        const ordered = (typeof clusterSimilarProblems === 'function') ? clusterSimilarProblems(found) : found;
        const orderedQids = ordered.map(p => String(p?.qid || '')).filter(Boolean);
        // keep qids that couldn't be resolved (append at end)
        const set = new Set(orderedQids);
        qids.forEach(qid => { if (qid && !set.has(qid)) orderedQids.push(qid); });
        return orderedQids;
      }
      $('#sheetApplyOrderBtn')?.addEventListener('click', () => {
        const sheet = findSheet(sheetState.selectedId);
        if (!sheet || !Array.isArray(sheet.qids) || sheet.qids.length < 2) {
          alert('ë¨¼ì € ë¬¸ì œë¥¼ í¬í•¨í•œ ì‹œí—˜ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
          return;
        }
        const order = String($('#sheetSolveOrder')?.value || sheet.solveOrder || 'similar');
        if (order === 'sheet') {
          alert('ì‹œí—˜ì§€ ì €ì¥ ìˆœì€ ì •ë ¬ ì ìš©ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.');
          return;
        }
        const ok = confirm(`ì´ ì‹œí—˜ì§€ì˜ ë¬¸ì œ ìˆœì„œë¥¼ '${order}' ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•´ ì €ì¥í• ê¹Œìš”?`);
        if (!ok) return;
        sheet.qids = computeSheetOrderedQids(sheet, order);
        sheet.solveOrder = order;
        saveSheets();
        statsRenderSheetDetail();
      });
      $('#sheetAddSelected')?.addEventListener('click', () => {
        const sheet = findSheet(sheetState.selectedId);
        if (!sheet) {
          alert('ë¨¼ì € ì‹œí—˜ì§€ë¥¼ ì„ íƒí•˜ê±°ë‚˜ ìƒˆë¡œ ë§Œë“œì„¸ìš”.');
          return;
        }
        const map = statsState.problemMap || {};
        const keys = Array.from(statsState.selectedKeys || []);
        const qids = keys.map(k => map[k]?.qid).filter(Boolean);
        if (!qids.length) {
          alert('ì„ íƒëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }
        const set = new Set(sheet.qids || []);
        qids.forEach(qid => set.add(qid));
        sheet.qids = Array.from(set);
        saveSheets();
        statsRenderSheetDetail();
        alert(`${qids.length}ë¬¸ì œë¥¼ ì‹œí—˜ì§€ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`);
      });
      $('#sheetRemoveSelected')?.addEventListener('click', () => {
        const sheet = findSheet(sheetState.selectedId);
        if (!sheet || !Array.isArray(sheet.qids)) {
          alert('ë¨¼ì € ì‹œí—˜ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
          return;
        }
        const map = statsState.problemMap || {};
        const keys = Array.from(statsState.selectedKeys || []);
        const removeSet = new Set(keys.map(k => map[k]?.qid).filter(Boolean));
        if (!removeSet.size) {
          alert('ì„ íƒëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }
        sheet.qids = sheet.qids.filter(qid => !removeSet.has(qid));
        saveSheets();
        statsRenderSheetDetail();
      });
      $('#sheetStartSolve')?.addEventListener('click', () => {
        const sheet = findSheet(sheetState.selectedId);
        if (!sheet || !Array.isArray(sheet.qids) || !sheet.qids.length) {
          alert('ë¨¼ì € ë¬¸ì œë¥¼ í¬í•¨í•œ ì‹œí—˜ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
          return;
        }
        const allProblems = Object.values(statsState.problemMap || {});
        let selected = sheet.qids.map(qid => allProblems.find(p => p && p.qid === qid)).filter(Boolean);
        if (!selected.length) {
          alert('ì‹œí—˜ì§€ì— í•´ë‹¹í•˜ëŠ” ë¬¸ì œë¥¼ ë¬¸ì œ JSONì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }
        // Apply Stats filters (same as the Sheet list UI).
        try {
          const cfg = statsReadFilterCfgFromUi();
          const markedCounts = statsComputeMarkedCounts();
          selected = selected.filter(p => {
            const qid = String(p?.qid || '');
            if (!qid) return false;
            const st = getProblemState(qid);
            const tag = getEffectiveTag(qid);
            const markedCount = markedCounts[qid] || 0;
            const year = extractYearForStatsProblem(p);
            const missing = !hasOfficialAnswer(p?.official_answer);
            const pid = paperKeyForProblem(p) || '';
            return statsPassesFilters(cfg, p, st, tag, markedCount, year, missing, pid);
          });
        } catch { }
        if (!selected.length) {
          alert('ì¡°ê±´ì— ë§ëŠ” ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }
        // "í‹€ë¦° ë¬¸ì œë§Œ" ì˜µì…˜ì´ ì¼œì ¸ ìˆìœ¼ë©´ í•œ ë²ˆì´ë¼ë„ ì˜¤ë‹µì´ì—ˆë˜ ë¬¸ì œë§Œ ëŒ€ìƒìœ¼ë¡œ ì‚¼ëŠ”ë‹¤.
        if (sheetState.wrongOnly) {
          selected = selected.filter(p => (getProblemState(p.qid).wrongCount || 0) > 0);
          if (!selected.length) {
            alert('ì´ ì‹œí—˜ì§€ì—ì„œ í‹€ë ¸ë˜ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
            return;
          }
        }
        // ì‹œí—˜ì§€ë§Œ ëŒ€ìƒìœ¼ë¡œ í’€ì´ ì„¸ì…˜ ì‹œì‘ (ì˜µì…˜: ìœ ì‚¬ë„ ë¬¶ê¸° / UID ìˆœ / ì €ì¥ ìˆœ)
        if (typeof solveWindow !== 'undefined') {
          solveWindow.classList.add('active');
          solveWindow.style.display = '';
          restoreSavedBox(solveWindow, 'fmm_ui_solveWindow');
        }
        if (typeof startSolveSession === 'function') {
          const order = String($('#sheetSolveOrder')?.value || 'similar');
          let ordered = selected;
          if (order === 'uid') {
            ordered = selected.slice().sort((a, b) => {
              const na = extractQuestionNumberFromQid(a?.qid);
              const nb = extractQuestionNumberFromQid(b?.qid);
              if (na != null && nb != null && na !== nb) return na - nb;
              if (na != null && nb == null) return -1;
              if (na == null && nb != null) return 1;
              return String(a?.qid || '').localeCompare(String(b?.qid || ''), 'ko');
            });
          } else if (order === 'similar') {
            ordered = clusterSimilarProblems(selected);
          } // else 'sheet': keep sheet order

          // startSolveSession uses currentTypeTitle; override typeTitle on session afterwards
          startSolveSession(ordered);
          if (solveState && solveState.session) {
            solveState.session.typeTitle = `[ì‹œí—˜ì§€] ${sheet.name || ''}`;
            solveState.session.sheetId = sheet.id;
            solveState.session.sheetName = sheet.name || '';
          }
        }
      });
      $('#sheetStartSolveRandom')?.addEventListener('click', () => {
        const sheet = findSheet(sheetState.selectedId);
        if (!sheet || !Array.isArray(sheet.qids) || !sheet.qids.length) {
          alert('ë¨¼ì € ë¬¸ì œë¥¼ í¬í•¨í•œ ì‹œí—˜ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
          return;
        }
        const nRaw = ($('#sheetRandomCount')?.value || '').trim();
        const n = nRaw ? (parseInt(nRaw, 10) || 0) : 0;
        if (n <= 0) {
          alert('ëœë¤ìœ¼ë¡œ í’€ ë¬¸ì œ ìˆ˜ Nì„ ì…ë ¥í•˜ì„¸ìš”.');
          return;
        }
        const allProblems = Object.values(statsState.problemMap || {});
        let selected = sheet.qids.map(qid => allProblems.find(p => p && p.qid === qid)).filter(Boolean);
        if (!selected.length) {
          alert('ì‹œí—˜ì§€ì— í•´ë‹¹í•˜ëŠ” ë¬¸ì œë¥¼ ë¬¸ì œ JSONì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }
        // Apply Stats filters (same as the Sheet list UI).
        try {
          const cfg = statsReadFilterCfgFromUi();
          const markedCounts = statsComputeMarkedCounts();
          selected = selected.filter(p => {
            const qid = String(p?.qid || '');
            if (!qid) return false;
            const st = getProblemState(qid);
            const tag = getEffectiveTag(qid);
            const markedCount = markedCounts[qid] || 0;
            const year = extractYearForStatsProblem(p);
            const missing = !hasOfficialAnswer(p?.official_answer);
            const pid = paperKeyForProblem(p) || '';
            return statsPassesFilters(cfg, p, st, tag, markedCount, year, missing, pid);
          });
        } catch { }
        if (!selected.length) {
          alert('ì¡°ê±´ì— ë§ëŠ” ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }
        if (sheetState.wrongOnly) {
          selected = selected.filter(p => (getProblemState(p.qid).wrongCount || 0) > 0);
          if (!selected.length) {
            alert('ì´ ì‹œí—˜ì§€ì—ì„œ í‹€ë ¸ë˜ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
            return;
          }
        }
        const picked = shuffle(selected.slice()).slice(0, Math.min(n, selected.length));
        if (!picked.length) {
          alert('ëœë¤ìœ¼ë¡œ ì„ íƒëœ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }
        if (typeof solveWindow !== 'undefined') {
          solveWindow.classList.add('active');
          solveWindow.style.display = '';
          restoreSavedBox(solveWindow, 'fmm_ui_solveWindow');
        }
        if (typeof startSolveSession === 'function') {
          const order = String($('#sheetSolveOrder')?.value || 'similar');
          let ordered = picked;
          if (order === 'uid') {
            ordered = picked.slice().sort((a, b) => {
              const na = extractQuestionNumberFromQid(a?.qid);
              const nb = extractQuestionNumberFromQid(b?.qid);
              if (na != null && nb != null && na !== nb) return na - nb;
              if (na != null && nb == null) return -1;
              if (na == null && nb != null) return 1;
              return String(a?.qid || '').localeCompare(String(b?.qid || ''), 'ko');
            });
          } else if (order === 'similar') {
            ordered = clusterSimilarProblems(picked);
          } // else 'sheet': keep random order

          startSolveSession(ordered);
          if (solveState && solveState.session) {
            solveState.session.typeTitle = `[ì‹œí—˜ì§€ ëœë¤ ${Math.min(n, selected.length)}] ${sheet.name || ''}`;
            solveState.session.sheetId = sheet.id;
            solveState.session.sheetName = sheet.name || '';
          }
        }
      });
      $('#statsFillSelected')?.addEventListener('click', async () => {
        const map = statsState.problemMap || {};
        const keys = Array.from(statsState.selectedKeys || []);
        const selected = keys.map(k => map[k]).filter(Boolean).filter(p => !hasOfficialAnswer(p.official_answer));
        if (!selected.length) {
          alert('ì„ íƒëœ LLM ëŒ€ìƒ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤. (ê³µì‹ ì •ë‹µì´ ë¹„ì–´ ìˆëŠ” ë¬¸ì œë§Œ ì „ì†¡í•©ë‹ˆë‹¤.)');
          return;
        }
        toggleAnswerPanel(true);
        if (!answerAPI.settings.endpoint) {
          alert('ë¨¼ì € LLM Endpoint ì„¤ì •ì„ ì…ë ¥í•˜ì„¸ìš”.');
          return;
        }
        $('#ansStatus').textContent = 'ì„ íƒëœ ë¬¸ì œì— ëŒ€í•´ ì‹¤í–‰ ì¤‘...';
        try {
          await fillMissingOfficialAnswers(selected);
          $('#ansStatus').textContent = ansAbort ? 'ì„ íƒ ëŒ€ìƒ ì¼ë¶€ê¹Œì§€ë§Œ ì±„ì›Œì¡ŒìŠµë‹ˆë‹¤.' : 'ì„ íƒëœ ë¬¸ì œ ì±„ìš°ê¸° ì™„ë£Œ';
          statsRefresh();
        } catch (err) {
          $('#ansStatus').textContent = 'ì‹¤íŒ¨: ' + err.message;
          appendAnswerLog(`ì„ íƒ ì‹¤í–‰ ì‹¤íŒ¨: ${err.message}`);
        }
      });

      // === NEW: LLM Fill selection window =========================================
      $('#llmFillMode')?.addEventListener('change', (e) => {
        llmFillState.mode = e.target.value || 'solve';
        llmFillState.selectedKeys = new Set();
        llmFillRefresh();
      });
      $('#llmFillSheetSelect')?.addEventListener('change', () => {
        llmFillState.selectedKeys = new Set();
        llmFillRefresh();
      });
      $('#llmFillTypeSelect')?.addEventListener('change', llmFillRenderList);
      $('#llmFillTagFilter')?.addEventListener('change', llmFillRenderList);
      $('#llmFillYearOp')?.addEventListener('change', llmFillRenderList);
      $('#llmFillYearFilter')?.addEventListener('change', llmFillRenderList);
      $('#llmFillPaperSelect')?.addEventListener('change', llmFillRenderList);
      $('#llmFillFilterMissing')?.addEventListener('click', () => {
        llmFillState.filterMissingOnly = !llmFillState.filterMissingOnly;
        const btn = $('#llmFillFilterMissing');
        if (btn) btn.textContent = llmFillState.filterMissingOnly ? 'ë¯¸ì •ë‹µë§Œ' : 'ì „ì²´ ë³´ê¸°';
        llmFillRenderList();
      });
      $('#llmFillSelectAll')?.addEventListener('click', () => {
        llmFillState.selectedKeys = new Set(llmFillState.lastItems || []);
        llmFillRenderList();
      });
      $('#llmFillClearSelection')?.addEventListener('click', () => {
        llmFillState.selectedKeys = new Set();
        llmFillRenderList();
      });

      // === ensure memos allow paste for new areas ====================================
      enableImagePaste($('#globalMemo'));
      enableImagePaste($('#typeMemo'));
      // FIX: Enable image paste in guide body textarea (Bug #10)
      enableImagePaste($('#source'));

      // === FIX: Header auto-hide with mouse hover reveal ============================
      // ideology: maximize reading space, but header reachable on hover
      (function initHeaderHover() {
        const header = document.querySelector('header');
        if (!header) return;
        const root = document.documentElement;
        let mouseY = 9999;
        let suppressed = false;   // if auto-hidden while still in zone, don't re-open until mouse leaves the zone
        let lastNearTop = false;
        let hideTimer = null;

        // Dynamic reveal zone: 15% of viewport or min 100px
        const revealZone = () => Math.max(Math.round(window.innerHeight * 0.15), 100);

        function clearTimer() {
          if (hideTimer) clearTimeout(hideTimer);
          hideTimer = null;
        }
        function scheduleAutoHide() {
          clearTimer();
          hideTimer = setTimeout(() => {
            const nearTop = mouseY <= revealZone();
            if (!nearTop) return;
            header.classList.add('hidden');
            suppressed = true;
          }, 2000);
        }

        function update() {
          // At the very top of the page, keep header always visible (no auto-hide).
          const atTop = (window.scrollY || 0) <= 8;
          if (atTop) {
            clearTimer();
            suppressed = false;
            header.classList.remove('hidden');
            const h = Math.ceil(header.getBoundingClientRect().height);
            root.style.setProperty('--header-visible-h', `${h}px`);
            return;
          }
          const nearTop = mouseY <= revealZone();
          if (nearTop !== lastNearTop) {
            lastNearTop = nearTop;
            if (!nearTop) suppressed = false; // leaving zone re-enables hover trigger
          }
          if (!nearTop) {
            clearTimer();
            header.classList.add('hidden');
            root.style.setProperty('--header-visible-h', '0px');
            return;
          }
          if (suppressed) {
            if (header.classList.contains('hidden')) {
              root.style.setProperty('--header-visible-h', '0px');
            }
            return;
          }
          header.classList.remove('hidden');
          const h = Math.ceil(header.getBoundingClientRect().height);
          root.style.setProperty('--header-visible-h', `${h}px`);
          scheduleAutoHide();
        }

        document.addEventListener('mousemove', (e) => {
          mouseY = e.clientY;
          update();
        }, { passive: true });
        document.addEventListener('mouseleave', () => {
          mouseY = 9999;
          update();
        });
        window.addEventListener('resize', update, { passive: true });
        document.addEventListener('scroll', update, { passive: true });

        // Any click inside header counts as "interaction": keep it open a bit longer.
        header.addEventListener('click', () => {
          suppressed = false;
          scheduleAutoHide();
        });

        // Initial check
        update();
      })();

      // === EXPOSE INTERNAL STATE FOR RESCUE ===
      window.problemState = problemState;
      window.solveState = solveState; // FIX: Expose for Rescue script
      window.saveSheets = saveSheets;
      window.fmmDumpAll = fmmDumpAll;
      window.fmmSaveAll = () => {
        // Flush all known state managers to localStorage
        if (typeof saveSheets === 'function') saveSheets();
        if (problemState) {
          problemState.save();
          problemState.saveMemos();
        }
        if (typeof llm !== 'undefined' && llm.save) llm.save();
        if (typeof chats !== 'undefined' && chats.sync) chats.sync();
        if (typeof answerAPI !== 'undefined' && answerAPI.save) answerAPI.save();
      };

      // === Memo-only recovery (additive) =======================================
      // Load an old Export/Rescue JSON and merge only problem memos into current state.
      function parseMaybeJson(value) {
        if (value == null) return null;
        if (typeof value === 'object') return value;
        if (typeof value !== 'string') return null;
        const s = value.trim();
        if (!s) return null;
        try { return JSON.parse(s); } catch { return null; }
      }
      function extractProblemMemosFromBundle(bundle) {
        if (!bundle || typeof bundle !== 'object') return null;
        const key = PROBLEM_MEMO_KEY;
        const items = bundle.items && typeof bundle.items === 'object' ? bundle.items : null;
        if (items && Object.prototype.hasOwnProperty.call(items, key)) {
          const item = items[key];
          if (item && typeof item === 'object' && Object.prototype.hasOwnProperty.call(item, 'kind')) {
            if (item.kind === 'json') return parseMaybeJson(item.value) || (item.value && typeof item.value === 'object' ? item.value : null);
            return parseMaybeJson(item.value);
          }
          return parseMaybeJson(item);
        }
        const data = bundle.data && typeof bundle.data === 'object' ? bundle.data : null;
        if (data && Object.prototype.hasOwnProperty.call(data, key)) {
          return parseMaybeJson(data[key]);
        }
        if (Object.prototype.hasOwnProperty.call(bundle, key)) {
          return parseMaybeJson(bundle[key]);
        }
        return null;
      }
      function coerceMemoList(value) {
        if (Array.isArray(value)) return value;
        const parsed = parseMaybeJson(value);
        if (Array.isArray(parsed)) return parsed;
        if (parsed && typeof parsed === 'object') {
          if (Array.isArray(parsed.list)) return parsed.list;
          if (Array.isArray(parsed.items)) return parsed.items;
          if (Array.isArray(parsed.memos)) return parsed.memos;
        }
        return [];
      }
      function normalizeRecoveredMemo(raw, allocId) {
        if (raw == null) return null;
        if (typeof raw === 'string') {
          const id = allocId();
          return { id, text: raw, createdAt: id };
        }
        if (typeof raw !== 'object') return null;
        const text = (raw.text != null) ? String(raw.text) : (raw.content != null ? String(raw.content) : '');
        if (!text.trim()) return null;
        let id = raw.id;
        if (typeof id === 'string' && /^[0-9]+$/.test(id)) id = Number(id);
        if (typeof id !== 'number' || !Number.isFinite(id)) id = allocId();
        let createdAt = raw.createdAt ?? raw.ts ?? raw.created_at ?? null;
        if (typeof createdAt === 'string' && /^[0-9]+$/.test(createdAt)) createdAt = Number(createdAt);
        if (typeof createdAt !== 'number' || !Number.isFinite(createdAt)) createdAt = id;
        return { id, text, createdAt };
      }
      window.fmmRecoverProblemMemosFromBundle = (bundle) => {
        const incoming = extractProblemMemosFromBundle(bundle);
        if (!incoming || typeof incoming !== 'object') {
          throw new Error('ì´ íŒŒì¼ì—ì„œ ë¬¸ì œë©”ëª¨(fmm_problem_memos)ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
        }

        const memoMap = problemState.memos || (problemState.memos = {});
        let added = 0;
        let skipped = 0;
        let conflicts = 0;
        let touchedQids = 0;

        Object.keys(incoming).forEach((qidKey) => {
          const qid = String(qidKey || '').trim();
          if (!qid) return;
          const incomingListRaw = coerceMemoList(incoming[qidKey]);
          if (!incomingListRaw.length) return;

          const ownerKey = getMemoOwnerKey(qid);
          const existingList = Array.isArray(memoMap[ownerKey])
            ? memoMap[ownerKey]
            : (Array.isArray(memoMap[qid]) ? memoMap[qid] : []);

          // Ensure both canonical + legacy keys point to the same list object.
          memoMap[ownerKey] = existingList;
          memoMap[qid] = existingList;

          const byId = new Map();
          existingList.forEach(m => {
            if (!m) return;
            const idv = m.id;
            if (typeof idv === 'number' || typeof idv === 'string') {
              byId.set(String(idv), String(m.text || ''));
            }
          });
          const allocId = () => {
            let id = Date.now();
            while (byId.has(String(id))) id += 1;
            return id;
          };

          let localTouched = false;
          incomingListRaw.forEach(raw => {
            const memo = normalizeRecoveredMemo(raw, allocId);
            if (!memo) return;
            let idKey = String(memo.id);
            if (byId.has(idKey)) {
              if (byId.get(idKey) === String(memo.text || '')) {
                skipped += 1;
                return;
              }
              // ID collision with different content â†’ keep both by re-keying the recovered one.
              memo.id = allocId();
              idKey = String(memo.id);
              conflicts += 1;
            }
            byId.set(idKey, String(memo.text || ''));
            existingList.push(memo);
            added += 1;
            localTouched = true;
          });
          if (localTouched) touchedQids += 1;
        });

        if (added || skipped || conflicts) {
          problemState.saveMemos();
          try { if (typeof renderProblemsForCurrentType === 'function') renderProblemsForCurrentType(); } catch { }
          try { if (solveState?.session && typeof renderSolveQuestion === 'function') renderSolveQuestion(); } catch { }
        }
        statusEl.textContent = `ë¬¸ì œë©”ëª¨ ë³µêµ¬ ì™„ë£Œ Â· ì¶”ê°€ ${added}ê°œ (ì¤‘ë³µ ${skipped}ê°œ, ì¶©ëŒ ${conflicts}ê°œ)`;
        return { added, skipped, conflicts, touchedQids };
      };

      // === Problem editor (Type view + Solve view) ===============================
      // Uses the same override keys as other editors: question_text / answer_choices.
      window.mountProblemEditor = function mountProblemEditor(container, qid) {
        if (!container || !qid) return;
        const base = currentTypeProblems().find(x => x.qid === qid) || (solveState.session?.problemMap[qid]);
        if (!base) return;
        const st = getProblemState(qid);
        const curQ = (st.question_text ?? base.question_text ?? '');
        const curC = (st.answer_choices ?? base.answer_choices ?? '');
        const curA = displayOfficialAnswerValue(st.official_answer ?? base.official_answer ?? '');
        const curE = (st.official_explanation ?? base.official_explanation ?? '');

        // NOTE: qid can contain characters (e.g. "::") that break CSS selectors.
        // Use data-* selectors scoped to this container, not dynamic IDs.
        container.innerHTML = `
          <div class="panel" style="margin-top:8px; border:1px solid var(--accent); padding:10px;">
            <div style="font-weight:bold; margin-bottom:6px;">ë¬¸ì œ ìˆ˜ì • (QID: <span data-role="qid"></span>)</div>
            <div class="muted">ì§ˆë¬¸ (Markdown/LaTeX ì§€ì›)</div>
            <textarea class="memo-textarea" data-role="q" style="min-height:80px;"></textarea>
            <div class="muted" style="margin-top:6px;">ì„ ì§€ (ì¤„ë°”ê¿ˆì´ë‚˜ ë²ˆí˜¸ë¡œ êµ¬ë¶„)</div>
            <textarea class="memo-textarea" data-role="c" style="min-height:80px;"></textarea>
            <div style="display:flex; gap:8px; margin-top:6px;">
              <div style="flex:1">
                <div class="muted">ê³µì‹ ì •ë‹µ</div>
                <input class="memo-textarea" data-role="a">
              </div>
            </div>
            <div class="muted" style="margin-top:6px;">ê³µì‹ í•´ì„¤</div>
            <textarea class="memo-textarea" data-role="e" style="min-height:80px;"></textarea>
            <div class="chat-actions" style="margin-top:8px; display:flex; gap:6px; justify-content:flex-end;">
              <button class="btn" data-act="cancel">ì·¨ì†Œ</button>
              <button class="btn" data-act="reset">ì´ˆê¸°í™”(ì›ë˜ëŒ€ë¡œ)</button>
              <button class="btn-primary" data-act="save">ì €ì¥</button>
            </div>
          </div>
        `;

        const qidEl = container.querySelector('[data-role="qid"]');
        if (qidEl) qidEl.textContent = String(qid);
        const qEl = container.querySelector('textarea[data-role="q"]');
        const cEl = container.querySelector('textarea[data-role="c"]');
        const aEl = container.querySelector('input[data-role="a"]');
        const eEl = container.querySelector('textarea[data-role="e"]');
        if (qEl) qEl.value = maskDataImages(curQ, qEl);
        if (cEl) cEl.value = maskDataImages(typeof curC === 'string' ? curC : JSON.stringify(curC), cEl);
        if (aEl) aEl.value = curA;
        if (eEl) eEl.value = maskDataImages(curE, eEl);

        enableImagePaste(qEl);
        enableImagePaste(cEl);
        enableImagePaste(eEl);

        container.querySelector('[data-act="cancel"]')?.addEventListener('click', () => { container.innerHTML = ''; });
        container.querySelector('[data-act="reset"]')?.addEventListener('click', () => {
          if (!confirm('ì´ ë¬¸ì œì˜ ëª¨ë“  ìˆ˜ì •ì‚¬í•­ì„ ì œê±°í•˜ê³  ì›ë³¸ìœ¼ë¡œ ë˜ëŒë¦¬ê² ìŠµë‹ˆê¹Œ?')) return;
          updateProblemState(qid, {
            question_text: undefined,
            answer_choices: undefined,
            official_answer: undefined,
            official_explanation: undefined
          });
          renderProblemsForCurrentType();
          if (solveState.session) renderSolveQuestion();
          container.innerHTML = '';
        });
        container.querySelector('[data-act="save"]')?.addEventListener('click', () => {
          const newQ = unmaskDataImages(qEl?.value || '', qEl);
          const newC = unmaskDataImages(cEl?.value || '', cEl);
          const newA = aEl?.value || '';
          const newE = unmaskDataImages(eEl?.value || '', eEl);
          updateProblemState(qid, {
            question_text: newQ.trim() || undefined,
            answer_choices: newC.trim() || undefined,
            official_answer: normalizeOfficialAnswerValue(newA),
            official_explanation: newE.trim() || undefined
          });
          // Sync current session map if active
          if (solveState.session && solveState.session.problemMap[qid]) {
            solveState.session.problemMap[qid] = applyProblemOverrides({
              ...solveState.session.problemMap[qid],
              question_text: newQ,
              answer_choices: newC,
              official_answer: normalizeOfficialAnswerValue(newA),
              official_explanation: newE
            });
          }
          renderProblemsForCurrentType();
          if (solveState.session) renderSolveQuestion();
          statusEl.textContent = 'ë¬¸ì œ ìˆ˜ì • ì €ì¥ë¨';
          container.innerHTML = '';
        });
      };

    })();

    // Hydrate from IndexedDB/localStorage snapshot after all hooks are in place
	    snapshotDB.init().then(() => {
	      try { maybeLoadExampleGuide(); } catch { }
	    });
    window.addEventListener('pagehide', () => {
      try { snapshotDB.saveNow(); } catch { }
    });
    window.addEventListener('beforeunload', () => {
      try { snapshotDB.saveNow(); } catch { }
    });
  </script>

  <dialog id="txtExportDialog">
    <h3>ğŸ“„ TXT ë‹¤ìš´ë¡œë“œ</h3>
    <p class="muted">ë¬¸ì œ ë³¸ë¬¸ + ê³µì‹ì •ë‹µ + (ì˜µì…˜) ê³µì‹í•´ì„¤/ë¬¸ì œë©”ëª¨ë¥¼ í•œ ë¬¸ì œì”© ë¬¶ì–´ì„œ ì¶œë ¥í•©ë‹ˆë‹¤.</p>
    <div style="display:grid;gap:10px;">
      <label>ìœ í˜•
        <select class="memo-textarea" id="txtExportType" style="min-height:36px; max-width:420px;"></select>
      </label>
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
        <label>íƒœê·¸
          <select class="memo-textarea" id="txtExportTag" style="min-height:36px; max-width:140px;">
            <option value="">ì „ì²´</option>
            <option value="ğŸ”’">ğŸ”’</option>
            <option value="âŒ">âŒ</option>
            <option value="â€¼ï¸">â€¼ï¸</option>
            <option value="â“">â“</option>
            <option value="â—">â—</option>
            <option value="â—">â—</option>
            <option value="âœ…">âœ…</option>
          </select>
        </label>
        <label>ì—°ë„ â‰¥
          <input class="memo-textarea" id="txtExportYear" placeholder="ì˜ˆ: 2020" style="min-height:36px; max-width:120px;">
        </label>
      </div>
      <div style="display:flex;gap:14px;flex-wrap:wrap;align-items:center;">
        <label style="display:flex;gap:6px;align-items:center;"><input type="checkbox" id="txtExportIncludeExplanation" checked>ê³µì‹í•´ì„¤ í¬í•¨</label>
        <label style="display:flex;gap:6px;align-items:center;"><input type="checkbox" id="txtExportIncludeMemo">ë¬¸ì œë©”ëª¨ í¬í•¨</label>
      </div>
      <div style="display:flex;justify-content:flex-end;gap:10px;flex-wrap:wrap;">
        <button class="btn" id="txtExportClose">ë‹«ê¸°</button>
        <button class="btn-primary" id="txtExportRun">ë‹¤ìš´ë¡œë“œ</button>
      </div>
    </div>
  </dialog>

  <dialog id="rescueDialog">
    <h2>ğŸš‘ Data Rescue Center</h2>
    <p class="muted">Recover your data into a clean, portable file.</p>

    <div class="rescue-row">
      <label>1. Clean Guide File (.txt)</label>
      <input type="file" id="rescueGuideFile" accept=".txt">
    </div>

    <div class="rescue-row">
      <label>2. Clean Problems File (.json)</label>
      <input type="file" id="rescueProbFile" accept=".json">
    </div>

    <div class="rescue-row">
      <p class="muted" style="font-size: 0.9em">
        * This will combine the clean files above with your current
        <strong>Exam Sheets</strong> and <strong>Memos</strong> from this browser.
      </p>
    </div>

    <div class="hr"></div>
    <h3 style="margin:10px 0 6px;">ë¬¸ì œë©”ëª¨ ë³µêµ¬(ì¶”ê°€)</h3>
    <p class="muted" style="font-size:0.9em; margin-top:0;">
      ì˜ˆì „ Export/Rescue JSONì—ì„œ <strong>ë¬¸ì œë©”ëª¨</strong>ë§Œ ì½ì–´ì„œ í˜„ì¬ ë°ì´í„°ì— <strong>ë”í•©ë‹ˆë‹¤</strong>(ê¸°ì¡´ ë©”ëª¨ ìœ ì§€). ë¬¸ì œíŒŒì¼ ë¶ˆí•„ìš”(QIDë¡œ ë§¤ì¹­).
    </p>
    <div class="rescue-row">
      <label>Old Export/Rescue File (.json)</label>
      <input type="file" id="rescueMemoFile" accept=".json,application/json">
    </div>
    <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:6px;">
      <button class="btn" id="rescueMemoRunBtn">ë¬¸ì œë©”ëª¨ë§Œ ë³µêµ¬(ì¶”ê°€)</button>
    </div>

    <div style="display:flex; justify-content:flex-end; gap:10px;">
      <button class="btn btn-ghost" onclick="document.getElementById('rescueDialog').close()">Cancel</button>
      <button class="btn btn-primary" id="rescueRunBtn">RESCUE & EXPORT</button>
    </div>
  </dialog>

  <dialog id="gradeMissingDialog">
    <h3>ê³µì‹ ì •ë‹µì´ ì—†ëŠ” ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤</h3>
    <p class="muted" id="gradeMissingText"></p>
    <div style="display:flex; justify-content:flex-end; gap:10px; flex-wrap:wrap; margin-top:10px;">
      <button class="btn" id="gradeMissingCancel">ì·¨ì†Œ</button>
      <button class="btn" id="gradeMissingSkip">ìŠ¤í‚µí•˜ê³  ì±„ì </button>
      <button class="btn-primary" id="gradeMissingFill">LLMìœ¼ë¡œ ì±„ìš°ê¸°</button>
    </div>
  </dialog>

  <script>
    // === RESCUE CENTER LOGIC (JSON EXPORT) ===
    (function () {
      const dlg = document.getElementById('rescueDialog');
      const btn = document.getElementById('rescueRunBtn');
      const guideIn = document.getElementById('rescueGuideFile');
      const probIn = document.getElementById('rescueProbFile');
      const memoIn = document.getElementById('rescueMemoFile');
      const memoBtn = document.getElementById('rescueMemoRunBtn');

      // Expose open function for the header button
      window.openRescueCenter = () => dlg.showModal();

      memoBtn?.addEventListener('click', async () => {
        if (!memoIn?.files?.[0]) {
          alert('ì˜ˆì „ Export/Rescue JSON íŒŒì¼(.json)ì„ ì„ íƒí•˜ì„¸ìš”.');
          return;
        }
        if (!confirm('ì„ íƒí•œ íŒŒì¼ì˜ ë¬¸ì œë©”ëª¨ë¥¼ í˜„ì¬ ë°ì´í„°ì— "ì¶”ê°€"í• ê¹Œìš”?\n(ê¸°ì¡´ ë©”ëª¨ëŠ” ì‚­ì œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤)')) return;
        try {
          memoBtn.textContent = 'ë³µêµ¬ ì¤‘...';
          memoBtn.disabled = true;
          if (window.fmmSaveAll) window.fmmSaveAll();

          const raw = await readFile(memoIn.files[0], 'text');
          let payload;
          try { payload = JSON.parse(raw); } catch { throw new Error('Invalid JSON file.'); }

          if (typeof window.fmmRecoverProblemMemosFromBundle !== 'function') {
            throw new Error('ë³µêµ¬ í•¨ìˆ˜ê°€ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (fmmRecoverProblemMemosFromBundle ì—†ìŒ)');
          }
          const result = window.fmmRecoverProblemMemosFromBundle(payload);
          alert(`ë¬¸ì œë©”ëª¨ ë³µêµ¬ ì™„ë£Œ\n\nì¶”ê°€: ${result.added}\nì¤‘ë³µ(ìŠ¤í‚µ): ${result.skipped}\nì¶©ëŒ(ìƒˆ ID): ${result.conflicts}`);
        } catch (err) {
          console.error(err);
          alert('ë¬¸ì œë©”ëª¨ ë³µêµ¬ ì‹¤íŒ¨: ' + (err?.message || err));
        } finally {
          memoBtn.textContent = 'ë¬¸ì œë©”ëª¨ë§Œ ë³µêµ¬(ì¶”ê°€)';
          memoBtn.disabled = false;
          try { memoIn.value = ''; } catch { }
        }
      });

      btn.addEventListener('click', async () => {
        if (!guideIn.files[0] || !probIn.files[0]) {
          alert("Please select BOTH the Clean Guide and Clean Problems files.");
          return;
        }

        try {
          btn.textContent = "Processing...";
          btn.disabled = true;

          // 1. Read Files
          const guideText = await readFile(guideIn.files[0], 'text');
          const probText = await readFile(probIn.files[0], 'text');

          // Validate JSON
          let probObj;
          try {
            probObj = JSON.parse(probText);
          } catch (e) { throw new Error("Invalid Problem JSON file."); }

          // 2. Gather State
          // FIX: Use the app's internal dump function to ensure we get everything (in-memory + storage)
          // and flush pending changes first.
          if (window.fmmSaveAll) window.fmmSaveAll();

          let bundle;
          if (window.fmmDumpAll) {
            bundle = window.fmmDumpAll();
          } else {
            // Fallback if something is wrong, though fmmDumpAll should be there
            bundle = { __fmm_bundle__: 1, items: {} };
            Object.keys(localStorage).forEach(k => {
              if (k.startsWith('fmm_')) bundle.items[k] = { kind: 'raw', value: localStorage.getItem(k) };
            });
          }

          // 3. Inject Clean Data (Overwrite)
          // We want to force the clean guide and problems into this bundle.
          // fmmDumpAll returns { items: { key: { kind, value } } }

          // Inject clean problems
          bundle.items['fmm_problems_json'] = { kind: 'raw', value: probText };

          // Inject clean guide
          bundle.items['fmm_source'] = { kind: 'raw', value: guideText };

          // Update timestamp
          bundle.savedAt = new Date().toISOString();
          bundle.rescued = true; // marker

          // 4. Download JSON
          const jsonStr = JSON.stringify(bundle, null, 2);
          const blob = new Blob([jsonStr], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'fmm_rescue_export_' + new Date().toISOString().slice(0, 10) + '.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          btn.textContent = "Success!";

          // Provide instruction
          alert("Rescue Export Complete!\n\n1. A new JSON file has been downloaded.\n2. Click 'Import' in the header.\n3. Select this new JSON file to restore your clean environment.");

          setTimeout(() => { dlg.close(); btn.textContent = "RESCUE & EXPORT"; btn.disabled = false; }, 2000);

        } catch (err) {
          console.error(err);
          alert("Rescue Failed: " + err.message);
          btn.textContent = "Failed";
          btn.disabled = false;
        }
      });

      function readFile(file, type) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = e => resolve(e.target.result);
          reader.onerror = reject;
          if (type === 'text') reader.readAsText(file);
          else reader.readAsArrayBuffer(file);
        });
      }
    })();
  </script>
</body>

</html>
